USE [master]
GO
/****** Object:  Database [QuanLySinhVien]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE DATABASE [QuanLySinhVien]
 CONTAINMENT = NONE
 ON  PRIMARY 
 WITH CATALOG_COLLATION = DATABASE_DEFAULT
GO
ALTER DATABASE [QuanLySinhVien] SET COMPATIBILITY_LEVEL = 110
GO
IF (1 = FULLTEXTSERVICEPROPERTY('IsFullTextInstalled'))
begin
EXEC [QuanLySinhVien].[dbo].[sp_fulltext_database] @action = 'enable'
end
GO
ALTER DATABASE [QuanLySinhVien] SET ANSI_NULL_DEFAULT ON 
GO
ALTER DATABASE [QuanLySinhVien] SET ANSI_NULLS ON 
GO
ALTER DATABASE [QuanLySinhVien] SET ANSI_PADDING ON 
GO
ALTER DATABASE [QuanLySinhVien] SET ANSI_WARNINGS ON 
GO
ALTER DATABASE [QuanLySinhVien] SET ARITHABORT ON 
GO
ALTER DATABASE [QuanLySinhVien] SET AUTO_CLOSE OFF 
GO
ALTER DATABASE [QuanLySinhVien] SET AUTO_SHRINK OFF 
GO
ALTER DATABASE [QuanLySinhVien] SET AUTO_UPDATE_STATISTICS ON 
GO
ALTER DATABASE [QuanLySinhVien] SET CURSOR_CLOSE_ON_COMMIT OFF 
GO
ALTER DATABASE [QuanLySinhVien] SET CURSOR_DEFAULT  LOCAL 
GO
ALTER DATABASE [QuanLySinhVien] SET CONCAT_NULL_YIELDS_NULL ON 
GO
ALTER DATABASE [QuanLySinhVien] SET NUMERIC_ROUNDABORT OFF 
GO
ALTER DATABASE [QuanLySinhVien] SET QUOTED_IDENTIFIER ON 
GO
ALTER DATABASE [QuanLySinhVien] SET RECURSIVE_TRIGGERS OFF 
GO
ALTER DATABASE [QuanLySinhVien] SET  ENABLE_BROKER 
GO
ALTER DATABASE [QuanLySinhVien] SET AUTO_UPDATE_STATISTICS_ASYNC OFF 
GO
ALTER DATABASE [QuanLySinhVien] SET DATE_CORRELATION_OPTIMIZATION OFF 
GO
ALTER DATABASE [QuanLySinhVien] SET TRUSTWORTHY ON 
GO
ALTER DATABASE [QuanLySinhVien] SET ALLOW_SNAPSHOT_ISOLATION OFF 
GO
ALTER DATABASE [QuanLySinhVien] SET PARAMETERIZATION FORCED 
GO
ALTER DATABASE [QuanLySinhVien] SET READ_COMMITTED_SNAPSHOT ON 
GO
ALTER DATABASE [QuanLySinhVien] SET HONOR_BROKER_PRIORITY OFF 
GO
ALTER DATABASE [QuanLySinhVien] SET RECOVERY FULL 
GO
ALTER DATABASE [QuanLySinhVien] SET  MULTI_USER 
GO
ALTER DATABASE [QuanLySinhVien] SET PAGE_VERIFY TORN_PAGE_DETECTION  
GO
ALTER DATABASE [QuanLySinhVien] SET DB_CHAINING OFF 
GO
ALTER DATABASE [QuanLySinhVien] SET FILESTREAM( NON_TRANSACTED_ACCESS = OFF ) 
GO
ALTER DATABASE [QuanLySinhVien] SET TARGET_RECOVERY_TIME = 0 SECONDS 
GO
ALTER DATABASE [QuanLySinhVien] SET DELAYED_DURABILITY = DISABLED 
GO
EXEC sys.sp_db_vardecimal_storage_format N'QuanLySinhVien', N'ON'
GO
ALTER DATABASE [QuanLySinhVien] SET QUERY_STORE = OFF
GO
USE [QuanLySinhVien]
GO
/****** Object:  User [mds_ssb_user]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE USER [mds_ssb_user] WITHOUT LOGIN WITH DEFAULT_SCHEMA=[mdm]
GO
/****** Object:  User [mds_schema_user]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE USER [mds_schema_user] WITHOUT LOGIN WITH DEFAULT_SCHEMA=[mdm]
GO
/****** Object:  User [mds_email_user]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE USER [mds_email_user] FOR LOGIN [mds_email_login] WITH DEFAULT_SCHEMA=[mdm]
GO
/****** Object:  User [mds_br_user]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE USER [mds_br_user] WITHOUT LOGIN WITH DEFAULT_SCHEMA=[dbo]
GO
/****** Object:  DatabaseRole [mds_exec]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE ROLE [mds_exec]
GO
/****** Object:  SqlAssembly [Microsoft.MasterDataServices.DataQuality]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE ASSEMBLY [Microsoft.MasterDataServices.DataQuality]
FROM 0x4D5A90000300000004000000FFFF0000B800000000000000400000000000000000000000000000000000000000000000000000000000000000000000800000000E1FBA0E00B409CD21B8014CCD21546869732070726F6772616D2063616E6E6F742062652072756E20696E20444F53206D6F64652E0D0D0A2400000000000000504500004C0103008721F65C0000000000000000E00022200B013000005C000000060000000000009A7B000000200000008000000000001000200000000200000400000000000000060000000000000000C000000002000097200100030060850000100000100000000010000010000000000000100000000000000000000000487B00004F00000000800000280300000000000000000000000000000000000000A000000C000000107A00001C0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000080000000000000000000000082000004800000000000000000000002E74657874000000B05B000000200000005C000000020000000000000000000000000000200000602E72737263000000280300000080000000040000005E0000000000000000000000000000400000402E72656C6F6300000C00000000A00000000200000062000000000000000000000000000040000042000000000000000000000000000000007C7B0000000000004800000002000500C83E0000C83A000009000000000000000000000000000000907900008000000000000000000000000000000000000000000000000000000000000000000000001B3005006B00000001000011026F0700000A2D08036F0700000A2C06280800000A2A730900000A0A06036F0A00000A6F0B00000A280C00000A730D00000A0B077E01000004280E00000A0C06026F0A00000A1408146F0F00000ADE0A082C06086F1000000ADC076F1100000A281200000A731300000A2A000110000002003F001150000A0000000013300400F4000000020000110F00281400000A2D240F01281400000A2D1B0F02281500000A2D120F03281600000A2D090F04281600000A2C067E1700000A2A0F02281800000A0A0645040000000500000027000000500000007200000038980000000F00281900000A0F01281900000A0F04281A00000A28040000060B07731B00000A2A0F00281900000A0F01281900000A0F03281A00000A0F04281A00000A28050000060C08731B00000A2A0F00281900000A0F01281900000A0F04281A00000A28060000060D09731B00000A2A0F00281900000A0F01281900000A0F03281A00000A0F04281A00000A280700000613041104731B00000A2A7E1700000A2A1330020047000000030000110F00281C00000A2D090F01281C00000A2C067E1700000A2A0F00281D00000A0D1203281E00000A0A0F01281D00000A0D1203281E00000A0B060728080000060C08731B00000A2A0013300500820200000400001102281F00000A2D08026F2000000A2B01160A062D0A2300000000000000002A03281F00000A2D08036F2000000A2B01160B072D0A2300000000000000002A0423000000000000F03F372E06072E0A2300000000000000002A02031B282100000A0D092C0A2300000000000000002A23000000000000F03F2A06073112031304071305021001060B1104100011050A04230000000000000000350F2300000000000000001002070C2B20076C23000000000000F03F04595A690C060858072F0A2300000000000000002A026F2200000A1000036F2200000A1001161306171307181308198D0100001B25160617588D2C000001A225170617588D2C000001A225180617588D2C000001A213091613102B10110911079A111011109E11101758131011100631EB070659130E1713113804010000110911089A1611119E17131338D5000000110911089A1113175994175825130D130A110911079A1113941758130B110B110A2F04110B130A110911079A1113175994130C02111317596F2300000A03111117596F2300000A2E54110C1758130C1113173149111117314402111317596F2300000A03111118596F2300000A332E02111318596F2300000A03111117596F2300000A3318110911069A11131859941758130D110D110A2F04110D130A110911089A1113110C110A3204110A2B02110C9E1113110E5811113315110911089A11139408310A2300000000000000002A1113175813131113063E23FFFFFF110613121107130611081307111213081111175813111111073EF4FEFFFF110911079A06946C130F110F230000000000000000330A23000000000000F03F2A23000000000000F03F110F076C5B59130F110F043703110F2A2300000000000000002A0000133003009F010000050000117E17000004252D17267E16000004FE0630000006732400000A2580170000040A02281F00000A2D08026F2000000A2B01160B072D0A2300000000000000002A03281F00000A2D08036F2000000A2B01160C082D0A2300000000000000002A0523000000000000F03F372E07082E0A2300000000000000002A02031B282100000A0D092C0A2300000000000000002A23000000000000F03F2A026F2200000A1000036F2200000A100106026F2500000A130706036F2500000A130811072C0E11078E2C0911082C0511088E2D0A2300000000000000002A1107280100002B13091108280100002B130A110A280200002B1109280200002B2F0C1109130D110A1309110D130A1109280200002B6C13041104110A280200002B6C58130B1109110A280300002B130C110C280200002B6C1305110B110559130611052300000000000000003651042300000000000000003509110511065B130E2B340423000000000000F03F3709110511045B130E2B1F110523000000000000F03F04595A11065B130E110E1105045A11045B58130E110E053703110E2A2300000000000000002A00133006007F0200000600001102281F00000A2D08026F2000000A2B01160A062D0A2300000000000000002A03281F00000A2D08036F2000000A2B01160B072D0A2300000000000000002A0423000000000000F03F372E06072E0A2300000000000000002A02031B282100000A0C082C0A2300000000000000002A23000000000000F03F2A06073110030D071304021001060B09100011040A026F2200000A1000036F2200000A100106130507185B175913061106162F03161306026F2900000A1307036F2900000A1308068D2E0000011309078D2E000001130A230000000000000000130B16130F2B73110F110659162F03162B05110F1106591310110F11065807175931050717592B05110F1106581311111013122B39110A1112912D2C1107110F93110811129333201109110F110A1112172513139C11139C110B23000000000000F03F58130B2B0C1112175813121112111131C1110F1758130F110F063288110B230000000000000000330A2300000000000000002A16130C230000000000000000130D1613142B4711091114912C3A110C13152B15110A1115912C0811151758130C2B0B11151758131511150732E6110711149311081115932E0E110D23000000000000F03F58130D11141758131411140632B4110D69185B6C130D110B066C5B110B076C5B58110B110D59110B5B582300000000000008405B130E110E23666666666666E63F366C110E23000000000000F03F345F11051A2F0411052B011A13161613172B06111717581317111711162F1E11071117931108111793331211071117931F3032DF11071117931F3930D6111716311F110E11176C239A9999999999B93F5A23000000000000F03F110E595A58130E110E043703110E2A2300000000000000002A00133005009C0200000700001102281F00000A2D08026F2000000A2B01160A062D0A2300000000000000002A03281F00000A2D08036F2000000A2B01160B072D0A2300000000000000002A0523000000000000F03F372E06072E0A2300000000000000002A02031B282100000A0C082C0A2300000000000000002A23000000000000F03F2A06073110030D071304021001060B09100011040A05230000000000000000350D23000000000000000010032B12066C05076C5A340A2300000000000000002A026F2200000A1000036F2200000A100123000000000000000013051613060617591309071759130A2B14110617581306110523000000000000F03F581305110611092F341106110A2F2E0211066F2300000A0311066F2300000A2ECE2B1A110917591309110A1759130A110523000000000000F03F581305110911063218110A110632120211096F2300000A03110A6F2300000A2EC8110911065917581307110A110659175813081107163ED10000001108163EC900000016130B17130C188D0100001B2516110717588D2C000001A22517110717588D2C000001A2130D17130E3884000000110D110C9A16169E1713102B5F16131102110611105817596F2300000A031106110E5817596F2300000A3310110D110B9A1110175994175813112B20110D110B9A1110941312110D110C9A11101759941311111111122F0411121311110D110C9A111011119E11101758131011101107319B110B130F110C130B110F130C110E1758130E110E11083E73FFFFFF1105110D110B9A1107946C5813051105230000000000000000364D0423000000000000000035091105066C5B13052B300423000000000000F03F37091105076C5B13052B1B110523000000000000F03F04595A066C5B1105045A076C5B581305110505370311052A2300000000000000002A1330020045000000080000110F00281E00000A10000F01281E00000A10010203282A00000A2C0A23000000000000F03F2A0203281F0000060A020328240000060B0607582300000000000008405B0C082A000000133009000C020000090000110F00281400000A2D2A0F00281900000A281F00000A2D1C0F01281500000A2D130F01281800000A1732090F02282B00000A2C02142A0F00281900000A6F2C00000A0A066F2000000A2D02142A0F02282D00000A0B0F01281800000A0C066F2000000A085817598D060000020D0817594503000000050000003F000000AE00000038220100001613042B260911041104178D2F00000125160611046F2300000A9D7329000006A4060000021104175813041104066F2000000A32D0384B010000072D127201000070067205000070282E00000A2B107209000070067209000070282E00000A0A1613052B330911051105188D2F00000125160611056F2300000A9D251706110517586F2300000A9D7329000006A4060000021105175813051105066F2000000A175932C138DC000000072D12720D000070067213000070282E00000A2B107219000070067219000070282E00000A0A1613062B400911061106198D2F00000125160611066F2300000A9D251706110617586F2300000A9D251806110618586F2300000A9D7329000006A4060000021106175813061106066F2000000A185932B42B6306066F2000000A08581759072D03182B021F206F2F00000A0A06066F2000000A08581759072D03192B021F206F3000000A0A1613072B1E0911071107061107086F3100000A732A000006A4060000021107175813071107066F2000000A0817595932D4092A13300300280000000A00001102A5060000020A03067B0C0000041758733200000A811900000104067B0D000004733300000A512A133007003E0000000B0000110F00282D00000A0F01282D00000A0F02282D00000A0F03282D00000A0F04282D00000A0F05282D00000A0F06282D00000A28150000060A06733400000A2A000013300300660000000C0000110F00281400000A2D090F01281400000A2C067E3500000A2A0F00281900000A0A0F01281900000A0B0F02281500000A2D090F02281800000A2B01160C081728140000060D283600000A1F0A2F071F0A283700000A060709283800000A13041104733900000A2A000013300100230000000D0000110F00281400000A2C067E3500000A2A0F00281900000A28160000060A06733900000A2A00133003009D0000000E0000110F00281400000A2D120F01281400000A2D090F02281400000A2C067E3A00000A2A0F00281900000A0A0F01281900000A0B0F02281900000A0C0F03281500000A2D090F03281800000A2B01160D091728140000061304283600000A1F0A2F071F0A283700000A06071104283B00000A130511056F3C00000A2D077E3A00000A2B1711056F3D00000A086F3E00000A6F3F00000A734000000A130611062A000000133004007A0000000F0000110F00281400000A2D120F01281400000A2D090F02281400000A2C067E3A00000A2A0F00281900000A0A0F01281900000A0B0F02281900000A0C0F03281500000A2D090F03281800000A2B01160D091728140000061304283600000A1F0A2F071F0A283700000A0607081104284100000A13051105734000000A2A000013300500A1000000100000110F00281400000A2D090F01281400000A2C02142A0F00281900000A0A0F01281900000A0B0F02281500000A2D090F02281800000A2B01160C081728140000060D283600000A1F0A2F071F0A283700000A060709284200000A130411046F4300000A8D0700000213051613062B261105110611061758110411066F4400000A6F3F00000A732B000006A407000002110617581306110611046F4300000A32CF11052A000000133002002A0000001100001102A5070000020A03067B0E000004733200000A811900000104067B0F000004734000000A81110000012A000013300500E7000000120000110F00281400000A2D090F01281400000A2C02142A0F00281900000A0A0F01281900000A0B0F03281500000A2D090F03281800000A2B01160C081728140000060D283600000A1F0A2F071F0A283700000A060709284500000A130411048E698D0800000213050F02281400000A2C2D1613062B1E1105110611061758110411069A17732C000006A408000002110617581306110611048E6932DA2B490F02281900000A09734600000A13071613082B2D1107110411089A6F4700000A13091105110811081758110411089A1109732C000006A408000002110817581308110811048E6932CB11052A00133002003B0000001300001102A5080000020A03067B10000004733200000A811900000104067B11000004734000000A811100000105067B12000004733900000A81180000012A00133002005E00000014000011032D03162B011E0A0216315002175F163108062000020000600A02185F163104061A600A021A5F1631040617600A021E5F163105061F20600A021F105F1631040618600A021F205F163105061F40600A021F405F163105061F10600A062A000013300200420000000B000011160A022C05061758D20A032C05061858D20A042C05061A58D20A052C05061E58D20A0E042C06061F1058D20A0E052C06061F2058D20A0E062C06061F4058D20A062A00001B30020022000000150000110216734600000A0A066F4800000A1760163104170BDE09DE0526160BDE02172A072A00000110000000000000191900051E00000113300500FE000000160000110F00281400000A2D200F01281400000A2D170F01281900000A281F00000A2D090F02282B00000A2C02142A0F00281900000A0A0F01281900000A6F2900000A0B0F02282D00000A2D03162B01170C0607086F4900000A0D098E698D0900000213040F03281400000A2C2B1613052B1D11041105110517580911059A17732D000006A4090000021105175813051105098E6932DC2B660F04281500000A2D090F04281800000A2B01161306110617281400000613070F03281900000A1107734600000A13081613092B2B11080911099A6F4700000A130A11041109110917580911099A110A732D000006A4090000021109175813091109098E6932CE11042A0000133002003B0000001700001102A5090000020A03067B13000004733200000A811900000104067B14000004734000000A811100000105067B15000004733900000A81180000012A0013300600B8000000180000117E4A00000A0A0214281200000A284B00000A13041104284C00000A2D1511040F00281400000A284D00000A284E00000A2B0211040D09284C00000A2D1C090F00281900000A6F2000000A16FE01284D00000A284E00000A2B01090C08284C00000A2D45080F00281900000A280C00000A161201284F00000A2C210F00281900000A178D2F00000125161F2E9D6F5000000A8E6918FE0116FE012B0116284D00000A284E00000A2B0108284C00000A2C067E5100000A0A062A1330050094000000190000117E4A00000A0A0214281200000A284B00000A13041104284C00000A2D1511040F00281400000A284D00000A284E00000A2B0211040D09284C00000A2D1C090F00281900000A6F2000000A16FE01284D00000A284E00000A2B01090C08284C00000A2D21080F00281900000A1D280C00000A1201285200000A284D00000A284E00000A2B0108284C00000A2C067E5100000A0A062A13300500590000001A0000117E4A00000A0A0214281200000A284B00000A0C08284C00000A2D2E08028C11000001280C00000A285300000A20A7000000280C00000A1201285400000A284D00000A284E00000A2B0108284C00000A2C067E5100000A0A062A000000133003004E0000001B0000117E4A00000A0A0214281200000A284B00000A0B07284C00000A2D2307028C11000001280C00000A285300000A17285500000A284D00000A284E00000A2B0107284C00000A2C067E5100000A0A062A000013300200600000001C000011027E5600000A285700000A284C00000A2C067E3A00000A2A037E3A00000A284B00000A284C00000A2C1A0F00281D00000A0A1200280C00000A285800000A734000000A2A0F00281D00000A0A12000F01281900000A285900000A734000000A2A76735A00000A25166F5B00000A25285C00000A6F5D00000A80010000042A0000133003008F0000001D0000117E0800000417952D0528220000067E080000040F00285E00000A950A7E080000040F00285F00000A950B7E080000040F01285E00000A950C7E080000040F01285F00000A950D0608282000000607092820000006581304110423000000000000004034280609282000000608072820000006581305110523AE47E17A14AEEF3F5A130511051104360311052A11042A0013300200180000001E00001102035F28210000066C0A02036028210000066C0B06075B2A13300200220000001F000011022C0402173302022A160A2B0F02175F1733040617580A0217641000021635ED062A000013300500E001000020000011170A38D001000017061F1F5F620B198D2C00000125D007000004286000000A0C160D2B62080994130406110430540717110406581759185911045D17581F1F5F62600B0717110406581759175911045D17581F1F5F62600B0717110406581759175811045D17581F1F5F62600B0717110406581759185811045D17581F1F5F62600B0917580D09088E693298061F0930570619300C0717061F0A5A1F1F5F62600B0617330A072080000000600B2B08061D33040718600B0617330A072000082080600B2B160717061F0A581F1F5F6217061F14581F1F5F6260600B0720FE030000600B38E2000000061F0A5B1305061F0A5D1306110617330F07171F0A1105581F1F5F62600B2B2B110618330F07171F141105581F1F5F62600B2B171105173312110619330D07171F1E1105581F1F5F62600B061F1F2F2A1106173311071711051F0A5A1D581F1F5F62600B2B1411061D330F071711051F0A5A17581F1F5F62600B11062D0A072000041040600B2B2F110617330A072002082080600B2B20071711061F1F5F62171F0A1106581F1F5F6260171F141106581F1F5F6260600B110517330A072000FC0F00600B2B1C110518330A07200000F03F600B2B0D11051933080720000000C0600B7E0800000406079E061758D20A061F1F3E28FEFFFF2A361F208D3F00000180080000042A0000133003006E000000210000110228250000060A0328250000060B067B0A000004736100000A077B0A000004286200000A067B0B000004077B0B000004286300000A28260000066C0C067B0A000004736100000A077B0A000004286400000A067B0B000004077B0B000004286300000A28260000066C0D08095B2A000013300500ED000000220000117E09000004168F050000027B0A0000042D052827000006198D2C00000125160F00286500000A1F645B9E25170F00286500000A1F0A5B1F645D9E25180F00286500000A1F645D9E0A7E090000040616948F050000027B0A000004736100000A0B077E090000040617948F050000027B0A0000046F6400000A7E090000040618948F050000027B0A0000046F6400000A0B7E090000040616948F050000027B0B0000047E090000040617948F050000027B0B000004286300000A0C087E090000040618948F050000027B0B000004286300000A0C1203FE15050000021203077D0A0000041203087D0B000004092A000000133002001D00000023000011160A160B2B1102076F6600000A2C040617580A0717580B070331EB062A000000133004008B01000024000011160A387B0100001F64736700000A0B0706176F6800000A071F64065817591F645D176F6800000A071F64065818591F645D176F6800000A071F64065817581F645D176F6800000A071F64065818581F645D176F6800000A061F09304C07061F0A5A176F6800000A0617330A071D176F6800000A2B0C061D33080717176F6800000A160D2B1907091F0A5A0658176F6800000A0709176F6800000A0917580D091F0A32E23896000000061F0A5B1304061F0A5D13050711051F0A5A110458176F6800000A110417330E071F46110558176F6800000A2B1111041D330C071F0A110558176F6800000A11051733100711041F0A5A1D58176F6800000A2B1311051D330E0711041F0A5A1758176F6800000A1613062B240711061F0A5A110558176F6800000A0711041F0A5A110658176F6800000A11061758130611061F0A32D6076F6900000A1759D20C2B05081759D20C07086F6600000A2CF27E09000004061207FE15050000021207077D0A0000041207087D0B0000041107A405000002061758D20A061F643F7DFEFFFF2A361F648D0500000280090000042A3E02037D0C00000402047D0D0000042A3A0203046F2900000A28290000062A3E02037D0E00000402047D0F0000042A5A02037D1000000402047D1100000402057D120000042A5A02037D1300000402047D1400000402057D150000042A2E732F00000680160000042A1E02286A00000A2A0000133005008A00000025000011160A03281F00000A2D14036F2C00000A6F2200000A1001036F2000000A0A062D02142A720D000070037213000070282E00000A1001036F2000000A18598D2A0000010B198D2F0000010C160D2B2F081603096F2300000A9D0817030917586F2300000A9D0818030918586F2300000A9D070908736B00000AA20917580D09036F2000000A185932C6072A000042534A4201000100000000000C00000076342E302E33303331390000000005006C000000B80C0000237E0000240D00006C0B000023537472696E677300000000901800002000000023555300B0180000100000002347554944000000C01800000822000023426C6F620000000000000002000001579D0228090A000000FA01330016000001000000400000000B0000001700000030000000700000006B0000000500000020000000020000002500000002000000010000000100000005000000080000000300000000006E050100000000000600040406080600240406080600DB03F3070F00260800000600C203940806008909E8050A007308AF050E00EF03B4070E00DC01B4070E00D601B4070E002E095E080E00BA055E080A000306C50506008607ED000A009307AF050E00B0025E080E00BB045E080E0042045E080E00CD025E080600D002E80506006F00E80506002400660106009202DA080E0025065E080E0066005E0812000C09BB081200E304BB0812006106BB081200CE0ABB0806008106E8050600F908E80506000303E8050600060BDA080600A70306080A005607AF050600F7064C0606006007E80506009D07ED000A00620AC5050A00A807AF0506009E02E8050600CB04E80506009306E80506006900E805160093020F0706002806E80506003B07E80512000307BB0812007106BB0812004E03BB08060042084C0606009200E805060051084C0606005A0AE8050600B302E80512000305E8051200CE01E8050A005D05AF0506009C04790A0600370906080600090BE8050600BA02E80506005F00E8050600E904E80500000000C500000000000100010081011000CF070F0B19000100010000010000CE000000190007001F000B011000DC0A0000810008001F000B011000310700008100090024000B011000D405000081000C0029000B011000BD09000081000E002B000B011000A3090000810010002C000B011000A8090000810013002D000321100062010000190016002E00130100004200000081001800310031008508810551801B01850551808904880551802E0185055180FA0085055180FF008505330198008B053100AA028F053100AA0293050100FD0598050100C50A9D0506006C0288050600DA05A00506006C02880506003006850506006C0288050600300685050600A301A40506006C0288050600300685050600A301A4053600C100A70516000100AB0550200000000096001806B4050100D820000000009600440BBD050300D8210000000096008C03CC0508002C220000000091003606D5050A00BC24000000009100F201DC050D0068260000000091007007D5051100F4280000000091005202DC0514009C2B000000009100A406E4051800F02B000000009600B408EC051A00082E000000009600A00AF7051D003C2E0000000096004A0502062000882E000000009600DC0415062700FC2E000000009600960120062A002C2F0000000096007C0927062B00D82F000000009600040227062F0060300000000096003508340633001031000000009600AD0A3F063600483100000000960007054A0639003C32000000009600850A57063D008432000000009100220565064100F03200000000910037056C0643004033000000009100DB06AC004A0080330000000096000C0577064B008C340000000096008A0A57065000D4340000000096007900200654009835000000009600140A200655003836000000009600400720065600A0360000000096001B0520065700FC36000000009600C504860658006837000000009118DC078F065A008837000000009600FC01E4055A002438000000009100FC0193065C0048380000000091005D0999065E00783800000000910088028F065F00643A000000009118DC078F065F00743A000000009600FC01E4055F00F03A000000009100F4059E066100EC3B0000000091005D09A5066200183C00000000910088028F066400AF3D000000009118DC078F066400BD3D000000008618D607AD066400CD3D000000008618D607B4066600DC3D000000008618D607B4066800EC3D000000008618D607BA066A00033E000000008618D607BA066D001A3E000000009118DC078F067000263E000000008618D60706007000303E0000000083000A00C106700000000100C105000002000F0A000001003B00000002008B0000000300EB0100000400E30700000500AB01000001003B00000002008B00000001003B00000002008B0000000300AB01000001003B00000002008B0000000300E30700000400AB01000001003B00000002008B0000000300AB01000001003B00000002008B0000000300BA0100000400AB0100000100350000000200850000000100730A00000200F506000003001902000001005401020002006C0202000300DA05000001002E0A00000200460300000300610300000400220200000500F90200000600E80900000700D90200000100730A00000200EF0600000300540500000100EF0600000100730A00000200EF0600000300090700000400540500000100730A00000200EF0600000300110200000400540500000100730A00000200EF06000003005405000001005401020002006C0202000300300600000100730A00000200CE0600000300C106000004005405000001005401020002006C0202000300300602000400A301000001005405000002008601000001001D0A000002003603000003005603000004003A0200000500EF0200000600DC0900000700E40200000100EF0600000100730A000002004609000003004F0B00000400C106000005005405000001005401020002006C0202000300300602000400A30100000100730A00000100730A00000100730A00000100730A00000100730A00000200710900000100350000000200850000000100320000000200760000000100FD05000001003500000002008500000001009B0300000100540400000200C50A000001006C0200000200F700000001006C02000002006809000001006C02000002003006000001006C0200000200300600000300A301000001006C0200000200300600000300A30100000100730A0900D60701001100D60706001900D6070A002900D60710004100D60706001101D60706006100A4051F0059009B0523006900D6070600610049072800690081012E002101210335007100D6073B007900A003420069001B064C004901720306003100C9045B008900FD095F005900D60765008900A4051F009100A4051F008100A4051F008100AA05730091004A04770089004A045B0081004A047B008100D6077F009900A4051F0099004A048E00A10083038E0051015B0BAC005101EE04B10051010D03B50051013F0A5B0051012409C1001400D607F80014008102FE0069019A0905016901540A19016901900924015101FA0A5901A100380B7C01C100A4051F005101EF055B00C10062041F0051016A0991015101D40998015101F40998015101D2049E01C900D60701005900D607A9019100D607B301C100AA05C101E9006D04C501E9007B04C901E900E104CE01C100D607D6018900AA05EC01E900E304F001810151091F00D9001909F9018901DF05FF0191014A045B008900D6070602E90009021502E9003A082C02E100500AB100E100DF053502E900090A5202E900D6075B02E900E1046202E900ED0877025101090A9102C1006C03C1018900380BAC02C1005A04B502C100FD09BB02C1001B07C102A1007A03CA025101090AD802C1006804C101A1017A03EB02B101C9040003B9017A030803C101A5041C039900AA0529039900380B2D03A100C9043603A100C9043D033900D6070600390059054203D90175024903390098044F03A100D40AB100A100F904B100E101EA0A73030901D60786030901CA018D030102C10A9603090125078D03A1002807B1000901DF05AC030901D60701000901D009BF030901500AB1003100D60706005101D607A9010E000800790408000C00C4040E001000C9040E00140016050E001800160520002B0052082E000B00C7062E001300D0062E001B00EF062E002300F8062E00230049072E002300DA0740002B00AE0960002B00080B630033000222C0002300660C20012300A50C20012300F40C20012B00480D40012300F70E43013300022260012B00270F80012B008010A0012B00DC11C0012B003813E0012B00941400022B00F01520022300F70E40022B00AD1760022300F70EE0022B007E1900032300F70E20032B00451B40032B00A01C60032B00F81D80032B00501FA0032B00A620000001000000040001000C0000000B0016006B0084009300C6003A015E0176018401A401AF01B801DB01DF010B021E023B02400267026C0271027C029A029F02DF02F8021503240356035F03640368037D039C03A703B103C503BE00F000A07B0000070004800000000000000000000001000000D7030F0B0000040000000000000000000000CE03590100000000040000000000000000000000CE03AF0500000000040000000000000000000000CE03480100000000040000000000000000000000CE03E80500000000040000000000000000000000CE031503000000000400020005000200060002000700020008000200090002000A0002000B0003004D0015014F0015015100150100000000003C3E395F5F355F30003C53696D696C61726974794A6163636172643E625F5F355F300049456E756D657261626C65603100623100646174653100696E70757431005F5F5374617469634172726179496E69745479706553697A653D31320055496E7433320053716C496E7433320046756E6360320062320049734461746554696D653200646174653200696E7075743200496E7436340041343944434130443944363437323543334142383332393830334237423545413336434330373636003C3E39003C4D6F64756C653E003C50726976617465496D706C656D656E746174696F6E44657461696C733E0053797374656D2E494F00636100526567657853706C697457697468436865636B46696C6C526F77536368656D61004E4772616D46696C6C526F77536368656D610052656765784D61746368657346696C6C526F77536368656D610053797374656D2E446174610064617461006D73636F726C6962003C3E630053797374656D2E436F6C6C656374696F6E732E47656E65726963004C6F616400696E636C756465436F6D70696C6564005265676578497356616C696400697356616C69640073636F72655468726573686F6C64006C656E6774685468726573686F6C6400416E64005572694B696E640053797374656D446174614163636573734B696E64006D6574686F640053696D696C61726974794A6163636172640052656765785265706C616365007265706C6163650070616453706163650069676E6F72655061747465726E576869746553706163650049676E6F72655061747465726E576869746573706163650053696D696C61726974794C6F6E67657374436F6D6D6F6E53756273657175656E6365006765745F556E69636F646500496E766F6B65004C6F61645461626C650049456E756D657261626C650049446973706F7361626C65007461626C650053716C446F75626C650052756E74696D654669656C6448616E646C650053716C4461746554696D650073696E676C654C696E650053696E676C656C696E65004D756C74696C696E65006D756C74696C696E650056616C75655479706500436F6D706172650053797374656D2E436F7265006765745F496E76617269616E7443756C74757265004578706C6963697443617074757265006578706C69636974436170747572650049676E6F7265436173650069676E6F7265436173650046616C736500446973706F7365005472795061727365006765745F446174650053696D696C61726974794461746500646174650043726561746500436F6D70696C657247656E6572617465644174747269627574650053757070726573734D6573736167654174747269627574650044656275676761626C654174747269627574650053716C46756E6374696F6E41747472696275746500436F6D70696C6174696F6E52656C61786174696F6E734174747269627574650052756E74696D65436F6D7061746962696C6974794174747269627574650053716C42797465006765745F56616C75650076616C7565006F705F54727565006765745F497354727565006765745F436163686553697A65007365745F436163686553697A65007265676578436163686553697A65007365745F456E636F64696E6700497357656C6C466F726D6564557269537472696E670053716C537472696E670044617465546F537472696E6700537562737472696E6700526567657849734D61746368004D617468006765745F4C656E677468006765745F4D6F6E74680055726900526567657853706C697457697468436865636B0049734C696E6B0052656765784F7074696F6E7346726F6D4D61736B0052656765784F7074696F6E73546F4D61736B0052656765784D61736B006D61736B007365745F436F6E666F726D616E63654C6576656C004D6963726F736F66742E4D61737465724461746153657276696365732E446174615175616C6974792E646C6C006765745F4E756C6C006765745F49734E756C6C0053797374656D2E586D6C0053716C586D6C00786D6C0053797374656D2E586D6C2E58736C004E4772616D006772616D006765745F4974656D0053797374656D005472696D00476574426C6F6F6D00626C6F6F6D0058736C436F6D70696C65645472616E73666F726D00586D6C5472616E73666F726D0053716C426F6F6C65616E00746F6B656E0053696D696C61726974794C6576656E73687465696E0053797374656D2E476C6F62616C697A6174696F6E004D61746368436F6C6C656374696F6E0047726F7570436F6C6C656374696F6E00417267756D656E74457863657074696F6E00537472696E67436F6D70617269736F6E0053696D696C6172697479446174654772616E744469636B696E736F6E00746F6B656E5061747465726E0073706C69745061747465726E00497356616C696452656765785061747465726E007061747465726E0043756C74757265496E666F0047726F75700067726F75700053797374656D2E4C696E71006F705F426974776973654F72006765745F5965617200426C6F6F6D5965617200436861720049734E756D6265720043726561746552656164657200586D6C5265616465720049466F726D617450726F76696465720053696D696C61726974794A61726F57696E6B6C657200537472696E6757726974657200586D6C577269746572005465787457726974657200586D6C5265736F6C766572004D6963726F736F66742E53716C5365727665722E5365727665720053716C436C72002E63746F72002E6363746F7200636F6E7461696E6D656E74426961730053797374656D2E446961676E6F73746963730053797374656D2E52756E74696D652E436F6D70696C6572536572766963657300446562756767696E674D6F6465730052656765784D617463686573004461746554696D655374796C6573004E756D6265725374796C65730053797374656D2E446174612E53716C547970657300586D6C57726974657253657474696E6773006F757470757453657474696E67730053797374656D2E446961676E6F73746963732E436F6465416E616C79736973004E4772616D730053797374656D2E546578742E526567756C617245787072657373696F6E730053797374656D2E436F6C6C656374696F6E73006765745F4F7074696F6E7300537472696E6753706C69744F7074696F6E730052656765784F7074696F6E73006765745F47726F757073006765745F43686172730053716C43686172730052756E74696D6548656C7065727300736570617261746F7273006765745F5375636365737300436F756E745365744269747300436F6E6361740064617465466F726D617400526567657845787472616374004F626A65637400496E746572736563740044697374696E637400526567657853706C697457697468436865636B5374727563740052656765784D61746368657353747275637400536574005061644C656674005269676874546F4C656674007269676874546F4C656674005061645269676874006F705F496D706C696369740053706C69740078736C74004973426967496E740043756C74757265496E76617269616E740063756C74757265496E76617269616E7400546F5570706572496E76617269616E74006765745F436F756E7400436F6E766572740058736C74417267756D656E744C69737400696E7075740053797374656D2E5465787400526567657853706C697457697468436865636B46696C6C526F77004E4772616D46696C6C526F770052656765784D61746368657346696C6C526F77004D6178006D6178496E646578005265676578006765745F44617900426C6F6F6D4D6F6E746844617900496E697469616C697A65417272617900546F436861724172726179004269744172726179004D6963726F736F66742E4D61737465724461746153657276696365732E446174615175616C697479006F705F457175616C6974790053696D696C61726974790072656D6F7665456D7074790049734E756C6C4F72456D7074790000000000030200010303000103200000050200020001050300030001052000200000008F0D18672DF8E4449886A55C054B682100042001010803200001052001011111052002010E0E08070312351239123D03200002040000122D05200012808D0620010112808D05000012809106200101128095090002123D128099121D0E20040112808D12809D123D1280A10320000E05000111450E052001011145070705050D0D0D0D03061141032000050320000D042001010D090704115111510D11510420001151180714080808080E080808081D1D0808080808080D08080808040001020E03200008080003080E0E1180AD021D08042001030829070F151255020E1D0E0808080D0D0D1D0E1D0E151259010E151259010E0D151259010E151259010E0D07151255020E1D0E052002011C18062001130113000F100101151259011E00151259011E00030A010E0A10010108151259011E0015100102151259011E00151259011E00151259011E001E07180808080E0808081D031D031D021D020D080D0D0808080802080808080420001D031707130808080E080D080808080808081D1D0808080808080507030D0D0D07000202115111510C07080E02051D1118080808080600030E0E0E0E0520020E08030520020E08080407011118052001011D030307010504200101050807050E0E0511690203061161030000080400010108070003020E0E11690420010102030701020C07070E0E0E051169126D114503061145080003126D0E0E11690520001280C50620011280C10E042001010E0907060E0E0E0511690E0800040E0E0E0E11690D07070E0E05116912711D111C0808000312710E0E1169052001126D08040701111C11070A0E0E0511691D0E1D112008127508020800031D0E0E0E1169062002010E1169042001020E04070111200407011169050702127502042000116914070B0E1D03117D1D0E1D112408051169127508020820021D0E1D03117D04070111240C0705116111511161116111610800021161114511450500010211610500011161020800021161116111610D0004020E1280951180CD1011510620011D0E1D030B070511610A1161116111610C0004020E1180D5128095100A07070311610D11610700020E1C1280950C0004020E1180D5128095100D06070211611161070002020E1180E504070111510306114D0800021161114D114D0620010E1280950420010E0E062001011180E90500001280ED062001011280ED080706090909090D0D0407020D0D030701080A070705081D0808080808090002011280F51180F9080704111411140D0D062001011280850820011280851280850500020505050A07041D08128085051114040702080804200102080D07080512808505080808081114052002010802080704081D0E1D030808B77A5C561934E08980A000240000048000009400000006020000002400005253413100040000010001009F0761CC1669C6C9958A11D738C26215B042A02D893975DEEC2DEBE291AD177ADB1407EC72C07E00E504EB0066F495D5BEB989B4B05783C358960C360150D4BCD6A1685531ED50FD4F1DEBAD1C0BEC21948FD39D770BF39AA5DBFC284106AFEFD5077BEF58C033D6DDA53C6E6C9E3116DC035DD166BA5FB43C0F81470DB90ABE4A5B00530065007100750065006E00630065005D00200049004E0054002C0020005B0054006F006B0065006E005D0020004E00560041005200430048004100520028003200350035002900040A0000004C5B00530065007100750065006E00630065005D00200049004E0054002C0020005B0054006F006B0065006E005D0020004E0056004100520043004800410052002800340030003000300029006A5B00530065007100750065006E00630065005D00200049004E0054002C0020005B0054006F006B0065006E005D0020004E0056004100520043004800410052002800340030003000300029002C0020005B0049007300560061006C00690064005D0020004200490054000306121D02060E0206080306112C03061D0904061D1114040612808502060503061D03020602030612280806151255020E1D0E080002122D123112310E00051141114511451149114111410800021141114D114D0600030D0E0E0D0700040D0E0E0D0D0700020D115111510A0003125D1145114911610A0003011C10116510122D120007114911611161116111611161116111610A00031161114511451149060001116111450C0004114511451145114511490A0003125D1145114511490A0003011C1011651011450C0004125D11451145114511490D0004011C101165101145101161060002116905020A000705020202020202020E0005125D114511451161114511490800021145114D1145030000010500020D0909040001080906000111141151070002081280850806200201081D0305200201080E06200301080E020520011D0E0E0801000800000000001E01000100540216577261704E6F6E457863657074696F6E5468726F777301080100020000000000500100104D6963726F736F66742E4E616D696E672A4341313730343A4964656E7469666965727353686F756C6442655370656C6C6564436F72726563746C790100540E094D6573736167654964034D646D808F0100104D6963726F736F66742E4E616D696E672A4341313730343A4964656E7469666965727353686F756C6442655370656C6C6564436F72726563746C790300540E094D6573736167654964034D646D540E0553636F7065096E616D657370616365540E06546172676574234D6963726F736F66742E4D61737465724461746153657276696365732E53716C436C72770100104D6963726F736F66742E44657369676E224341313032303A41766F69644E616D657370616365735769746846657754797065730200540E0553636F7065096E616D657370616365540E06546172676574234D6963726F736F66742E4D61737465724461746153657276696365732E53716C436C72815A0100050054020F497344657465726D696E697374696301540E044E616D650C586D6C5472616E73666F726D5455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054557F4D6963726F736F66742E53716C5365727665722E5365727665722E53797374656D446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038391053797374656D44617461416363657373000000005402094973507265636973650181580100050054020F497344657465726D696E697374696301540E044E616D650A53696D696C61726974795455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054557F4D6963726F736F66742E53716C5365727665722E5365727665722E53797374656D446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038391053797374656D446174614163636573730000000054020949735072656369736500815C0100050054020F497344657465726D696E697374696301540E044E616D650E53696D696C6172697479446174655455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054557F4D6963726F736F66742E53716C5365727665722E5365727665722E53797374656D446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038391053797374656D4461746141636365737300000000540209497350726563697365003E0100194D6963726F736F66742E4D61696E7461696E6162696C6974791F4341313530323A41766F6964457863657373697665436F6D706C657869747900004E0100104D6963726F736F66742E4E616D696E672A4341313730343A4964656E7469666965727353686F756C6442655370656C6C6564436F72726563746C790100540E094D6573736167654964016E530100104D6963726F736F66742E4E616D696E672A4341313730343A4964656E7469666965727353686F756C6442655370656C6C6564436F72726563746C790100540E094D6573736167654964064E4772616D7381AD0100070054020F497344657465726D696E697374696301540E044E616D65064E4772616D73540E1146696C6C526F774D6574686F644E616D650C4E4772616D46696C6C526F77540E0F5461626C65446566696E6974696F6E255B53657175656E63655D20494E542C205B546F6B656E5D204E5641524348415228323535295455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054557F4D6963726F736F66742E53716C5365727665722E5365727665722E53797374656D446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038391053797374656D4461746141636365737300000000540209497350726563697365012F0100104D6963726F736F66742E44657369676E194341313032313A41766F69644F7574506172616D6574657273000081570100050054020F497344657465726D696E697374696301540E044E616D650952656765784D61736B5455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054557F4D6963726F736F66742E53716C5365727665722E5365727665722E53797374656D446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038391053797374656D446174614163636573730000000054020949735072656369736501815A0100050054020F497344657465726D696E697374696301540E044E616D650C526567657849734D617463685455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054557F4D6963726F736F66742E53716C5365727665722E5365727665722E53797374656D446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038391053797374656D446174614163636573730000000054020949735072656369736501815A0100050054020F497344657465726D696E697374696301540E044E616D650C5265676578497356616C69645455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054557F4D6963726F736F66742E53716C5365727665722E5365727665722E53797374656D446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038391053797374656D446174614163636573730000000054020949735072656369736501815A0100050054020F497344657465726D696E697374696301540E044E616D650C5265676578457874726163745455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054557F4D6963726F736F66742E53716C5365727665722E5365727665722E53797374656D446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038391053797374656D446174614163636573730000000054020949735072656369736501815A0100050054020F497344657465726D696E697374696301540E044E616D650C52656765785265706C6163655455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054557F4D6963726F736F66742E53716C5365727665722E5365727665722E53797374656D446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038391053797374656D44617461416363657373000000005402094973507265636973650181BB0100070054020F497344657465726D696E697374696301540E044E616D650C52656765784D617463686573540E1146696C6C526F774D6574686F644E616D651352656765784D61746368657346696C6C526F77540E0F5461626C65446566696E6974696F6E265B53657175656E63655D20494E542C205B546F6B656E5D204E564152434841522834303030295455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054557F4D6963726F736F66742E53716C5365727665722E5365727665722E53797374656D446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038391053797374656D44617461416363657373000000005402094973507265636973650181CF0100070054020F497344657465726D696E697374696301540E044E616D650A526567657853706C6974540E1146696C6C526F774D6574686F644E616D651A526567657853706C697457697468436865636B46696C6C526F77540E0F5461626C65446566696E6974696F6E355B53657175656E63655D20494E542C205B546F6B656E5D204E564152434841522834303030292C205B497356616C69645D204249545455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054557F4D6963726F736F66742E53716C5365727665722E5365727665722E53797374656D446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038391053797374656D44617461416363657373000000005402094973507265636973650181C50100070054020F497344657465726D696E697374696301540E044E616D650553706C6974540E1146696C6C526F774D6574686F644E616D651553706C697457697468436865636B46696C6C526F77540E0F5461626C65446566696E6974696F6E355B53657175656E63655D20494E542C205B546F6B656E5D204E564152434841522834303030292C205B497356616C69645D204249545455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054557F4D6963726F736F66742E53716C5365727665722E5365727665722E53797374656D446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038391053797374656D44617461416363657373000000005402094973507265636973650181590100050054020F497344657465726D696E697374696301540E044E616D650B49734461746554696D65325455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054557F4D6963726F736F66742E53716C5365727665722E5365727665722E53797374656D446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038391053797374656D44617461416363657373000000005402094973507265636973650181560100050054020F497344657465726D696E697374696301540E044E616D65084973426967496E745455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054557F4D6963726F736F66742E53716C5365727665722E5365727665722E53797374656D446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038391053797374656D44617461416363657373000000005402094973507265636973650181560100050054020F497344657465726D696E697374696301540E044E616D650849734E756D6265725455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054557F4D6963726F736F66742E53716C5365727665722E5365727665722E53797374656D446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038391053797374656D44617461416363657373000000005402094973507265636973650181540100050054020F497344657465726D696E697374696301540E044E616D650649734C696E6B5455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054557F4D6963726F736F66742E53716C5365727665722E5365727665722E53797374656D446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038391053797374656D446174614163636573730000000054020949735072656369736501815A0100050054020F497344657465726D696E697374696301540E044E616D650C44617465546F537472696E675455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054557F4D6963726F736F66742E53716C5365727665722E5365727665722E53797374656D446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038391053797374656D446174614163636573730000000054020949735072656369736501040100000000BCF1D60B106D6D41B7BD843747C245CD94A977D5AEAFD65EEF9C46C0707DCF5EC686E9E83E9909E840759290C42ED358F629A1732A66DD494189E43DA3626510A2F8059C932CCFE0FC66E71CAB9AA23E2B6170DF804315203D1FB133B4696E1FFC5ACE3A82C6BE1BAA0AAD4E06E6FE3F966DCB4413C67F1A30C61EEC9D515C28000000008521F65C00000000020000001C0100002C7A00002C5C00005253445353BFD72F4C0A4D4A976DF401D45B72FD01000000443A5C4D44535F4D61696E5C6F626A5C78363464656275675C73716C5C6D64735C6465765C64625C7372635C73716C636C725C6D6963726F736F66742E6D61737465726461746173657276696365732E646174617175616C6974792E73716C70726F6A5C4D6963726F736F66742E4D61737465724461746153657276696365732E446174615175616C6974792E7064620000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000707B000000000000000000008A7B00000020000000000000000000000000000000000000000000007C7B0000000000000000000000005F436F72446C6C4D61696E006D73636F7265652E646C6C0000000000FF25002000100C0000001E0000001F00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100100000001800008000000000000000000000000000000100010000003000008000000000000000000000000000000100000000004800000058800000CC0200000000000000000000CC0234000000560053005F00560045005200530049004F004E005F0049004E0046004F0000000000BD04EFFE00000100000000000000000000000000000000003F000000000000000400000002000000000000000000000000000000440000000100560061007200460069006C00650049006E0066006F00000000002400040000005400720061006E0073006C006100740069006F006E00000000000000B0042C020000010053007400720069006E006700460069006C00650049006E0066006F0000000802000001003000300030003000300034006200300000002C0002000100460069006C0065004400650073006300720069007000740069006F006E000000000020000000300008000100460069006C006500560065007200730069006F006E000000000030002E0030002E0030002E00300000007A002D00010049006E007400650072006E0061006C004E0061006D00650000004D006900630072006F0073006F00660074002E004D00610073007400650072004400610074006100530065007200760069006300650073002E0044006100740061005100750061006C006900740079002E0064006C006C00000000002800020001004C006500670061006C0043006F00700079007200690067006800740000002000000082002D0001004F0072006900670069006E0061006C00460069006C0065006E0061006D00650000004D006900630072006F0073006F00660074002E004D00610073007400650072004400610074006100530065007200760069006300650073002E0044006100740061005100750061006C006900740079002E0064006C006C0000000000340008000100500072006F006400750063007400560065007200730069006F006E00000030002E0030002E0030002E003000000038000800010041007300730065006D0062006C0079002000560065007200730069006F006E00000030002E0030002E0030002E003000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007000000C0000009C3B00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
WITH PERMISSION_SET = SAFE
GO
ALTER ASSEMBLY [Microsoft.MasterDataServices.DataQuality]
ADD FILE FROM 0x4D6963726F736F667420432F432B2B204D534620372E30300D0A1A4453000000000200000200000057000000A00100000000000055000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000C0FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF38000000000000000000C0FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0BCA3101380000000010000000100000000000001800FFFF04000000FFFF03000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000BCA3101380000000010000000100000000000001900FFFF04000000FFFF0300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000942E31018521F65C0100000053BFD72F4C0A4D4A976DF401D45B72FD00000000000000000100000001000000000000000000000000000000DC51330100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000BCA310138000000001000000010000000000000FFFFFFFF04000000FFFF030000000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000BCA310138000000001000000010000000000000FFFFFFFF04000000FFFF030000000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000F862513FC607D311905300C04FA302A1C4454B99E9E6D211903F00C04FA302A10B9D865A1166D311BD2A0000F80849BDEC1618FF5EAA104D87F76F49638334601400000000000000808560640C20A8000381BE19FF75315A9E120397000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000F862513FC607D311905300C04FA302A1C4454B99E9E6D211903F00C04FA302A10B9D865A1166D311BD2A0000F80849BDEC1618FF5EAA104D87F76F496383346014000000000000001E648E79576015901DF68193D43D529B12D5573B000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000F862513FC607D311905300C04FA302A1C4454B99E9E6D211903F00C04FA302A10B9D865A1166D311BD2A0000F80849BDEC1618FF5EAA104D87F76F496383346014000000000000002EBC5D7D41059C2D4678131BDAAE3F524A85F867000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000F862513FC607D311905300C04FA302A1C4454B99E9E6D211903F00C04FA302A10B9D865A1166D311BD2A0000F80849BDEC1618FF5EAA104D87F76F496383346014000000000000006EFAA28FE82959325A89ADCE84151B1AB445D7F00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000391C000000000000391C0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FEEFFEEF010000009401000000443A5C4D44535F4D61696E5C53716C5C6D64735C6465765C44425C7372635C53716C436C725C537472696E672E63730000643A5C6D64735F6D61696E5C73716C5C6D64735C6465765C64625C7372635C73716C636C725C737472696E672E637300443A5C4D44535F4D61696E5C53716C5C6D64735C6465765C44425C7372635C53716C436C725C52656765782E637300643A5C6D64735F6D61696E5C73716C5C6D64735C6465765C64625C7372635C73716C636C725C72656765782E637300443A5C4D44535F4D61696E5C53716C5C6D64735C6465765C44425C7372635C53716C436C725C53696D696C61726974792E637300643A5C6D64735F6D61696E5C73716C5C6D64735C6465765C64625C7372635C73716C636C725C73696D696C61726974792E637300443A5C4D44535F4D61696E5C53716C5C6D64735C6465765C44425C7372635C53716C436C725C4D647353716C436C72586D6C2E637300643A5C6D64735F6D61696E5C73716C5C6D64735C6465765C64625C7372635C73716C636C725C6D647373716C636C72786D6C2E63730011000000000000000000000000000000000000003100000000000000000000000000000000000000C00000000100000032000000F4000000280100005E01000062000000910000000900000000000000000000000000000000000000000000001BE2300104010000931A5770A91AD5010100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000400000006000000010000001E0000000000000091000000280000001BE230016E9E18DB5C00000062000000310000009100000065000000000000000000000032000000280000001BE23001C517070A5C0000000100000031000000320000006500000000000000000000005E010000280000001BE23001ADDB1BE65C00000028010000310000005E010000650000000000000000000000F4000000280000001BE23001B41529845C000000C000000031000000F40000006500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000400000036002A1100000000C4010000000000006B000000000000000000000001000006000000000100000000586D6C5472616E73666F726D0000001600031104000000880100006B00000000000000010000001E0024115553797374656D2E436F6C6C656374696F6E732E47656E65726963001A0024115553797374656D2E446174612E53716C54797065730000000E0024115553797374656D2E494F0000120024115553797374656D2E54657874000000000E0024115553797374656D2E586D6C00120024115553797374656D2E586D6C2E58736C001E002411554D6963726F736F66742E53716C5365727665722E536572766572001A0024115553797374656D2E476C6F62616C697A6174696F6E000000160020110000000001000011000000000000000078736C001A00201101000000010000110000000000000000726573756C740000160003113C0000008401000027000000330000000100000022002011020000000100001100000000000000006F757470757457726974657200000000020006000200060036000404C93FEAC6B359D649BC250902BBABB460000000004D004400320000000401000004000000140000000400000000000000080000000200060032002A1100000000F803000000000000F40000000000000000000000020000066B000000010000000053696D696C61726974790016000311C8010000BC030000F40000006B000000010000000A0024115553797374656D00160024115553797374656D2E436F6C6C656374696F6E73001E0024115553797374656D2E436F6C6C656374696F6E732E47656E65726963001A0024115553797374656D2E446174612E53716C5479706573000000120024115553797374656D2E4C696E71000000001E002411554D6963726F736F66742E53716C5365727665722E53657276657200160024115553797374656D2E446961676E6F7374696373001A0024115553797374656D2E476C6F62616C697A6174696F6E00000016000311FC0100001003000022000000C1000000010000001A0020110100000002000011000000000000000073636F72650000000200060016000311FC0100004803000029000000E3000000010000001A0020110200000002000011000000000000000073636F72650000000200060016000311FC01000080030000220000000C010000010000001A0020110300000002000011000000000000000073636F72650000000200060016000311FC010000B80300002B0000002E010000010000001A0020110400000002000011000000000000000073636F7265000000020006000200060036000404C93FEAC6B359D649BC250902BBABB460000000004D004400320000000401000004000000140000000400000000000000080000000200060036002A1100000000D404000000000000470000000000000000000000030000065F010000010000000053696D696C6172697479446174650016000311FC030000A0040000470000005F010000010000001A0020110000000003000011000000000000000064617465310000001A0020110100000003000011000000000000000064617465320000001A0020110200000003000011000000000000000073636F7265000000020006002E000404C93FEAC6B359D649BC250902BBABB460000000004D0044003200000004010000040100000C00000002000006020006003E002A11000000002C0800000000000082020000000000000000000004000006A6010000010000000053696D696C61726974794C6576656E73687465696E000016000311D8040000F807000082020000A6010000010000001A002011000000000400001100000000000000006C656E67746831001A002011010000000400001100000000000000006C656E67746832001E002011020000000400001100000000000000006D61784564697473000000001600031118050000B80500002E000000F0010000010000001600201103000000040000110000000000000000630000000200060016000311180500000406000012000000220200000100000016002011040000000400001100000000000000007400000016002011050000000400001100000000000000006E000000020006001600031118050000F4070000AF0100006F020000010000001A00201106000000040000110000000000000000726F7730000000001A00201107000000040000110000000000000000726F7731000000001A00201108000000040000110000000000000000726F773200000000160020110900000004000011000000000000000065640000160020110A0000000400001100000000000000006D696E00160020110B00000004000011000000000000000064656C00160020110C00000004000011000000000000000073756200160020110D00000004000011000000000000000074726E00160020110E000000040000110000000000000000646966001A0020110F00000004000011000000000000000064697374000000001600031108060000500700001A000000B102000001000000160020111000000004000011000000000000000078000000020006001600031108060000F007000014010000D0020000010000001600201111000000040000110000000000000000790000001600031154070000EC070000FE000000D8020000010000001A00201112000000040000110000000000000000726F7774000000001600031184070000E8070000E5000000E10200000100000016002011130000000400001100000000000000007800000002000600020006000200060002000600020006002E000404C93FEAC6B359D649BC250902BBABB460000000004D0044003200000004010000040100000C00000002000006020006003A002A1100000000040B0000000000009F01000000000000000000000500000628040000010000000053696D696C61726974794A61636361726400001600031130080000D00A00009F010000280400000100000022002011000000000500001100000000000000005F67656E65726174654E6772616D73001A002011010000000500001100000000000000006C656E67746831001A002011020000000500001100000000000000006C656E6774683200160003116C080000100900002E000000920400000100000016002011030000000500001100000000000000006300000002000600160003116C080000CC0A0000FD000000C0040000010000001E00201104000000050000110000000000000000736D616C6C436F756E7400002200201105000000050000110000000000000000696E74657273656374436F756E7400001E00201106000000050000110000000000000000756E696F6E436F756E7400001600031114090000900A00008F000000D0040000010000001A002011070000000500001100000000000000006E6772616D7331001A002011080000000500001100000000000000006E6772616D7332001A0020110900000005000011000000000000000073657431000000001A0020110A0000000500001100000000000000007365743200000000220020110B000000050000110000000000000000756E696F6E416C6C436F756E740000001E0020110C000000050000110000000000000000696E7465727365637400000016000311900900008C0A00000C0000002005000001000000160020110D0000000500001100000000000000007400000002000600020006001600031114090000C80A0000510000006C050000010000001A0020110E00000005000011000000000000000073636F72650000000200060002000600020006002E000404C93FEAC6B359D649BC250902BBABB460000000004D0044003200000004010000040100000C00000002000006020006003E002A1100000000EC0E0000000000007F020000000000000000000006000006C7050000010000000053696D696C61726974794A61726F57696E6B6C6572000016000311080B0000B80E00007F020000C7050000010000001A002011000000000600001100000000000000006C656E67746831001A002011010000000600001100000000000000006C656E677468320016000311480B0000C80B00002E00000011060000010000001600201102000000060000110000000000000000630000000200060016000311480B0000140C000010000000430600000100000016002011030000000600001100000000000000007400000016002011040000000600001100000000000000006E0000000200060016000311480B0000B40E0000E901000053060000010000001A002011050000000600001100000000000000006D696E4C656E00001A0020110600000006000011000000000000000072616E67650000001A00201107000000060000110000000000000000686F6C64310000001A00201108000000060000110000000000000000686F6C64320000001A00201109000000060000110000000000000000666C6167310000001A0020110A000000060000110000000000000000666C6167320000001A0020110B0000000600001100000000000000006D61746368656400160020110C0000000600001100000000000000006B0000001E0020110D0000000600001100000000000000007472616E73706F73656400001A0020110E00000006000011000000000000000073636F726500000016000311180C0000FC0D00007D000000A006000001000000160020110F0000000600001100000000000000006900000016000311480D0000F80D00006D000000A5060000010000001A0020111000000006000011000000000000000066726F6D000000001600201111000000060000110000000000000000746F000016000311780D0000F40D000045000000CD0600000100000016002011120000000600001100000000000000006A00000002000600020006000200060016000311180C0000640E000051000000420700000100000016002011140000000600001100000000000000006900000016000311000E0000600E00003A0000004E0700000100000016002011150000000600001100000000000000006A000000020006000200060016000311180C0000B00E00005F000000D50700000100000016002011160000000600001100000000000000006A0000001600201117000000060000110000000000000000690000000200060002000600020006002E000404C93FEAC6B359D649BC250902BBABB460000000004D0044003200000004010000040100000C00000002000006020006004A002A110000000094120000000000009C02000000000000000000000700000646080000010000000053696D696C61726974794C6F6E67657374436F6D6D6F6E53756273657175656E63650016000311F00E0000601200009C02000046080000010000001A002011000000000700001100000000000000006C656E67746831001A002011010000000700001100000000000000006C656E6774683200160003113C0F0000BC0F00002E000000900800000100000016002011020000000700001100000000000000006300000002000600160003113C0F00000810000010000000C20800000100000016002011030000000700001100000000000000007400000016002011040000000700001100000000000000006E00000002000600160003113C0F00005C120000DB010000FD080000010000001E002011050000000700001100000000000000006C63734C656E67746800000016002011060000000700001100000000000000006C6674001A002011070000000700001100000000000000006C656E31000000001A002011080000000700001100000000000000006C656E3200000000160003110C100000E41000008A0000001B090000010000001A0020110900000007000011000000000000000072677431000000001A0020110A000000070000110000000000000000726774320000000002000600160003110C10000058120000C9000000B5090000010000001A0020110B000000070000110000000000000000726F7730000000001A0020110C000000070000110000000000000000726F773100000000160020110D0000000700001100000000000000006564000016000311E81000005412000095000000DB09000001000000160020110E000000070000110000000000000000790000001600031150110000501200007E000000E3090000010000001A0020110F000000070000110000000000000000726F77740000000016000311801100004C1200006A000000EB0900000100000016002011100000000700001100000000000000007800000016000311B41100004812000059000000F00900000100000016002011110000000700001100000000000000006C63730016000311E411000044120000200000001F0A00000100000016002011120000000700001100000000000000007600000002000600020006000200060002000600020006000200060002000600020006002E000404C93FEAC6B359D649BC250902BBABB460000000004D0044003200000004010000040100000C000000020000060200060046002A11000000008C1300000000000045000000000000000000000008000006E20A0000010000000053696D696C6172697479446174654772616E744469636B696E736F6E00000016000311981200005813000045000000E20A000001000000220020110000000008000011000000000000000073636F72654461794D6F6E74680000001E0020110100000008000011000000000000000073636F7265596561720000001A0020110200000008000011000000000000000073636F7265000000020006002E000404C93FEAC6B359D649BC250902BBABB460000000004D0044003200000004010000040100000C00000002000006020006002E002A110000000048150000000000000C020000000000000000000009000006270B000001000000004E4772616D73001600031190130000141500000C020000270B0000010000001600201100000000090000110000000000000000737472001E002011010000000900001100000000000000007573655370616365000000001600201102000000090000110000000000000000710000001A002011030000000900001100000000000000006772616D7300000016000311C01300007414000035000000AC0B0000010000001600201104000000090000110000000000000000690000000200060016000311C0130000A8140000440000000C0C0000010000001600201105000000090000110000000000000000690000000200060016000311C0130000DC140000510000007B0C0000010000001600201106000000090000110000000000000000690000000200060016000311C01300001015000031000000000D00000100000016002011070000000900001100000000000000006900000002000600020006002E000404C93FEAC6B359D649BC250902BBABB460000000004D0044003200000004010000040100000C000000020000060200060036002A1100000000E8150000000000002800000000000000000000000A000006330D000001000000004E4772616D46696C6C526F77000000160003114C150000B415000028000000330D00000100000016002011000000000A000011000000000000000067000000020006002E000404C93FEAC6B359D649BC250902BBABB460000000004D0044003200000004010000040100000C000000020000060200060032002A110000000010170000000000003E00000000000000000000000B0000065B0D0000010000000052656765784D61736B000016000311EC150000D41600003E0000005B0D0000010000000A0024115553797374656D00160024115553797374656D2E436F6C6C656374696F6E73001A0024115553797374656D2E446174612E53716C5479706573000000220024115553797374656D2E546578742E526567756C617245787072657373696F6E73001E002411554D6963726F736F66742E53716C5365727665722E5365727665720016002011000000000B0000110000000000000000620000000200060036000404C93FEAC6B359D649BC250902BBABB460000000004D004400320000000401000004000000140000000400000000000000050000000200060036002A110000000014180000000000006600000000000000000000000C000006990D00000100000000526567657849734D617463680000001600031114170000E017000066000000990D00000100000016002011000000000C0000110000000000000000696E700016002011010000000C00001100000000000000007061740016002011020000000C00001100000000000000006D736B0016002011030000000C00001100000000000000006F7074001A002011040000000C0000110000000000000000726573756C740000020006002E000404C93FEAC6B359D649BC250902BBABB460000000004D0044003200000004010000040100000C0000000B0000060200060036002A1100000000B8180000000000002300000000000000000000000D000006FF0D000001000000005265676578497356616C696400000016000311181800008418000023000000FF0D0000010000001A002011000000000D0000110000000000000000726573756C740000020006002E000404C93FEAC6B359D649BC250902BBABB460000000004D0044003200000004010000040100000C0000000B0000060200060036002A1100000000EC190000000000009D00000000000000000000000E000006220E0000010000000052656765784578747261637400000016000311BC180000B81900009D000000220E00000100000016002011000000000E0000110000000000000000696E700016002011010000000E00001100000000000000007061740016002011020000000E00001100000000000000006772700016002011030000000E00001100000000000000006D736B0016002011040000000E00001100000000000000006F70740016002011050000000E00001100000000000000006D6174001A002011060000000E0000110000000000000000726573756C740000020006002E000404C93FEAC6B359D649BC250902BBABB460000000004D0044003200000004010000040100000C0000000B0000060200060036002A1100000000081B0000000000007A00000000000000000000000F000006BF0E0000010000000052656765785265706C61636500000016000311F0190000D41A00007A000000BF0E00000100000016002011000000000F0000110000000000000000696E700016002011010000000F00001100000000000000007061740016002011020000000F00001100000000000000007265700016002011030000000F00001100000000000000006D736B0016002011040000000F00001100000000000000006F7074001A002011050000000F0000110000000000000000726573756C740000020006002E000404C93FEAC6B359D649BC250902BBABB460000000004D0044003200000004010000040100000C0000000B0000060200060036002A11000000005C1C000000000000A1000000000000000000000010000006390F0000010000000052656765784D617463686573000000160003110C1B0000281C0000A1000000390F0000010000001600201100000000100000110000000000000000696E700016002011010000001000001100000000000000007061740016002011020000001000001100000000000000006D736B0016002011030000001000001100000000000000006F7074001A002011040000001000001100000000000000006D617463686573001A00201105000000100000110000000000000000726573756C74000016000311441B0000241C000036000000A10F00000100000016002011060000001000001100000000000000006900000002000600020006002E000404C93FEAC6B359D649BC250902BBABB460000000004D0044003200000004010000040100000C0000000B000006020006003E002A1100000000081D0000000000002A000000000000000000000011000006DA0F0000010000000052656765784D61746368657346696C6C526F770000000016000311601C0000D41C00002A000000DA0F0000010000001A002011000000001100001100000000000000006974656D00000000020006002E000404C93FEAC6B359D649BC250902BBABB460000000004D0044003200000004010000040100000C0000000B000006020006003E002A1100000000001F000000000000E7000000000000000000000012000006041000000100000000526567657853706C697457697468436865636B00000000160003110C1D0000CC1E0000E700000004100000010000001600201100000000120000110000000000000000696E700016002011010000001200001100000000000000007061740016002011020000001200001100000000000000006D736B0016002011030000001200001100000000000000006F7074001A00201104000000120000110000000000000000746F6B656E7300001A00201105000000120000110000000000000000726573756C740000160003114C1D00002C1E00002B000000721000000100000016002011060000001200001100000000000000006900000002000600160003114C1D0000C81E0000490000009F1000000100000016002011070000001200001100000000000000007267780016000311301E0000C41E00003A000000AE1000000100000016002011080000001200001100000000000000006900000016000311601E0000C01E000027000000B310000001000000160020110900000012000011000000000000000076000000020006000200060002000600020006002E000404C93FEAC6B359D649BC250902BBABB460000000004D0044003200000004010000040100000C0000000B0000060200060042002A1100000000B01F0000000000003B000000000000000000000013000006EB1000000100000000526567657853706C697457697468436865636B46696C6C526F770016000311041F00007C1F00003B000000EB100000010000001A002011000000001300001100000000000000006974656D00000000020006002E000404C93FEAC6B359D649BC250902BBABB460000000004D0044003200000004010000040100000C0000000B000006020006003E002A110000000058200000000000005E00000000000000000000001400000626110000010000000052656765784F7074696F6E7346726F6D4D61736B00000016000311B41F0000242000005E000000261100000100000016002011000000001400001100000000000000006F707400020006002E000404C93FEAC6B359D649BC250902BBABB460000000004D0044003200000004010000040100000C0000000B000006020006003A002A110000000000210000000000004200000000000000000000001500000684110000010000000052656765784F7074696F6E73546F4D61736B00160003115C200000CC2000004200000084110000010000001A002011000000000B00001100000000000000006D61736B00000000020006002E000404C93FEAC6B359D649BC250902BBABB460000000004D0044003200000004010000040100000C0000000B000006020006003E002A1100000000C42100000000000022000000000000000000000016000006C61100000100000000497356616C696452656765785061747465726E0000000016000311042100009021000022000000C61100000100000016000311442100008C21000017000000C61100000100000016002011000000001500001100000000000000007267780002000600020006002E000404C93FEAC6B359D649BC250902BBABB460000000004D0044003200000004010000040100000C0000000B0000060200060036002A11000000007424000000000000FE000000000000000000000017000006E8110000010000000053706C697457697468436865636B0016000311C821000038240000FE000000E8110000010000000A0024115553797374656D00160024115553797374656D2E436F6C6C656374696F6E73001A0024115553797374656D2E446174612E53716C54797065730000001A0024115553797374656D2E476C6F62616C697A6174696F6E000000220024115553797374656D2E546578742E526567756C617245787072657373696F6E73001E002411554D6963726F736F66742E53716C5365727665722E536572766572001600201100000000160000110000000000000000696E7000160020110100000016000011000000000000000073657000160020110200000016000011000000000000000073736F001A00201103000000160000110000000000000000746F6B656E7300001A00201104000000160000110000000000000000726573756C74000016000311002200006823000029000000521200000100000016002011050000001600001100000000000000006900000002000600160003110022000034240000660000007D1200000100000016002011060000001600001100000000000000006D736B0016002011070000001600001100000000000000006F707400160020110800000016000011000000000000000072677800160003116C2300003024000037000000AC1200000100000016002011090000001600001100000000000000006900000016000311CC2300002C24000025000000B112000001000000160020110A000000160000110000000000000000760000000200060002000600020006000200060036000404C93FEAC6B359D649BC250902BBABB460000000004D00440032000000040100000400000014000000040000000000000006000000020006003E002A110000000020250000000000003B000000000000000000000018000006E6120000010000000053706C697457697468436865636B46696C6C526F7700001600031178240000EC2400003B000000E6120000010000001A002011000000001700001100000000000000006974656D00000000020006002E000404C93FEAC6B359D649BC250902BBABB460000000004D0044003200000004010000040100000C000000170000060200060036002A1100000000E825000000000000B800000000000000000000001900000621130000010000000049734461746554696D6532000000001600031124250000B4250000B800000021130000010000001A002011000000001800001100000000000000007375636365737300220020110100000018000011000000000000000074656D704461746554696D6500000000020006002E000404C93FEAC6B359D649BC250902BBABB460000000004D0044003200000004010000040100000C000000170000060200060032002A1100000000A8260000000000009400000000000000000000001A000006D913000001000000004973426967496E7400000016000311EC2500007426000094000000D9130000010000001A0020110000000019000011000000000000000073756363657373001E0020110100000019000011000000000000000074656D704C6F6E6700000000020006002E000404C93FEAC6B359D649BC250902BBABB460000000004D0044003200000004010000040100000C000000170000060200060032002A110000000068270000000000005900000000000000000000001B0000066D140000010000000049734E756D62657200000016000311AC26000034270000590000006D140000010000001A002011000000001A000011000000000000000073756363657373001E002011010000001A000011000000000000000074656D7056616C7565000000020006002E000404C93FEAC6B359D649BC250902BBABB460000000004D0044003200000004010000040100000C00000017000006020006002E002A110000000004280000000000004E00000000000000000000001C000006C6140000010000000049734C696E6B00160003116C270000D02700004E000000C6140000010000001A002011000000001B00001100000000000000007375636365737300020006002E000404C93FEAC6B359D649BC250902BBABB460000000004D0044003200000004010000040100000C000000170000060200060036002A110000000070280000000000006000000000000000000000001D00000614150000010000000044617465546F537472696E670000002E000404C93FEAC6B359D649BC250902BBABB460000000004D0044003200000004010000040100000C00000017000006020006002E002A1100000000B8290000000000001D00000000000000000000001E0000067415000001000000002E6363746F720016000311742800007C2900001D00000074150000010000001E0024115553797374656D2E436F6C6C656374696F6E732E47656E65726963001A0024115553797374656D2E446174612E53716C54797065730000000E0024115553797374656D2E494F0000120024115553797374656D2E54657874000000000E0024115553797374656D2E586D6C00120024115553797374656D2E586D6C2E58736C001E002411554D6963726F736F66742E53716C5365727665722E536572766572001A0024115553797374656D2E476C6F62616C697A6174696F6E0000000200060036000404C93FEAC6B359D649BC250902BBABB460000000004D0044003200000004010000040000001400000004000000000000000800000002000600F20000009C00000000000000010001006B000000000000000B000000900000000000000028000080100000002A00008016000000300000801C00000034000080280000003700008033000000380000803F0000003B0000804E0000003C00008050000000EEEFFE8059000000EEEFFE805A0000003E0000800D002B00110026000D0043000D002B000D0052001400550011004D000D000E0000000000000000000D003400F2000000A80000006B00000001000100F4000000080000000C0000009C000000000000001E0000802D0000001F000080330000002200008056000000260000807100000027000080780000002B0000809A0000002C000080A100000030000080BC00000031000080C300000035000080E600000036000080EE0000003B0000800D007400110027000D002200190077001900350019008A0019003500190077001900350019009B00190035000D002300F2000000600000005F01000001000100470000000800000006000000540000000000000043000080120000004400008018000000470000802800000048000080380000004B000080400000004E0000800D003000110027000D0030000D0030000D004E000D002900F200000078030000A6010000010001008202000008000000480000006C030000000000005D000080120000005E000080150000005F0000801F00000062000080310000006300008034000000640000803E000000670000804A000000690000804E00000069000080580000006B000080610000006C00008078000000700000807C000000720000807F000000720000808200000073000080850000007300008087000000740000808B000000740000808E000000790000809A0000007B000080A50000007C000080A70000007D000080A900000081000080B900000084000080BF00000085000080C90000008B000080D10000008C000080D900000090000080DC00000090000080DF00000090000080E2000000910000800B010000950000800E010000EEEFFE8010010000960000801A010000950000802001000095000080250100009A0000802A0100009B0000802D010000EEEFFE80320100009D0000803B010000A00000803E010000EEEFFE8043010000A200008054010000A300008060010000A400008066010000A40000806A010000A500008076010000A80000808C010000AA00008092010000AD000080C8010000AF000080D6010000B0000080DC010000B0000080E0010000B5000080F4010000B8000080FD010000B900008008020000BA00008012020000A000008018020000A000008020020000BE00008024020000BF00008028020000C00000802C020000C1000080300200009B000080360200009B0000803E020000C500008048020000C800008055020000CB0000805F020000D000008070020000D300008075020000D400008078020000D90000800D004C000D001E0011001C000D004C000D001E0011001C000D002700110028002900340011005C0011002D000D0023001100230024003400110021002200340011001C001D0029000D00270011002600110024000D000E00110044001100320015002000110034001100340011001D001F002700290031001100700016001F0000000000150025002F00320021002D0011002D0016001F0000000000150025001A002300000000001900390019002F00190027002800320019002F0019003C001D0023001D00740021003B0021002F0030003A0019003D0019002A001D00380021002C003300360025003100150025001500210015002100150021002F00320021002D001100310011002100150020001500330015003000190025000D001800F2000000EC01000028040000010001009F0100000800000027000000E001000000000000E40000A3200000000C010080320000000D010080350000000E0100803F00000011010080510000001201008054000000130100805E000000160100806A000000180100806E00000018010080780000001A010080810000001B0100809800000021010080A000000022010080A800000028010080B100000029010080BA0000002C010080CC0000002D010080D600000030010080DF00000031010080E800000034010080F800000036010080FC000000370100800001000038010080040100003C0100800E0100003E0100801B01000040010080260100004101008030010000430100803701000047010080440100004B010080500100004C010080590100004D010080650100004E0100806E0100005201008081010000530100808D010000570100809201000058010080950100005D0100800D000F000D004C000D001E0011001C000D004C000D001E0011001C000D002700110028002900340011005C0011002D001100340011003400150040001500400015006A001900240015004300150043001500350019003600190025001900220015002F001500460015004A00150038001500410011002A001500300019003D001A00350019003D00190059001900520015003100190026000D001800F200000090030000C7050000010001007F020000080000004A0000008403000000000000680100801200000069010080150000006A0100801F0000006D010080310000006E010080340000006F0100803E000000720100804A000000740100804E0000007401008058000000760100806100000077010080780000007B0100807C0000007D0100807E0000007D010080810000007E010080840000007E010080860000007F010080890000007F0100808C0000008501008094000000860100809C000000890100809F0000008A010080A60000008B010080AB0000008B010080AE0000008E010080B60000008F010080BE00000092010080C600000093010080CE00000096010080D900000097010080DC000000EEEFFE80DE00000099010080F00000009A010080060100009B0100800A010000EEEFFE800C0100009D0100801F0100009F0100802F010000A00100803D010000A10100803F0100009B010080450100009B0100804B01000097010080510100009701008056010000A701008063010000A80100806D010000AB01008070010000AC0100807B010000AD0100807E010000EEEFFE8080010000AF01008087010000B20100808B010000EEEFFE808D010000B401008094010000B60100809A010000B70100809C010000B2010080A2010000B2010080A7010000BA010080B3010000BB010080C1010000AD010080C7010000AD010080CC010000BF010080D4010000C2010080F4010000C50100800E020000C80100801A020000CB0100801D020000EEEFFE801F020000CB01008025020000CB01008049020000CD0100804E020000CE0100806D020000D201008072020000D301008075020000D70100800D004C000D001E0011001C000D004C000D001E0011001C000D002700110028002900340011005C0011002D000D0023001100230024003400110021002200340011001C001D00290011003400110034001100260011002F0011001F0020002A00110035001100350011003200110032001100260016001F000000000015004300150055001A0026000000000019003F001D0038001D0027001D0023003100340028002F002E00310021002C00110024001500200011001B001100290016001F0000000000150022001E002300000000001D002A0021002B00210027003200350025003000190032001D002A002E00310021002C00110037001100770011003000150036001A001F0000000000740077002100720015001F0019003A0011002D00150022000D001800F20000009003000046080000010001009C020000080000004A0000008403000000000000E101008012000000E201008015000000E30100801F000000E601008031000000E701008034000000E80100803E000000EB0100804A000000ED0100804E000000ED01008058000000EF01008061000000F001008078000000F40100807C000000F60100807E000000F601008081000000F701008084000000F701008086000000F801008089000000F80100808C000000FC01008098000000FD010080A500000001020080AD00000002020080B700000008020080BF00000009020080C70000000C020080D200000010020080D500000012020080DA00000012020080DF000000EEEFFE80E100000014020080E700000014020080F50000001402008013010000EEEFFE8015010000160200801B0100001602008021010000160200802F010000160200804D01000019020080560100001A0200805F0100001E0200806F0100002202008072010000220200807501000023020080950100002602008098010000EEEFFE809D01000028020080A50100002B020080A8010000EEEFFE80AA0100002D020080AD01000030020080C901000032020080D701000033020080D901000037020080E301000038020080EF01000039020080F501000039020080F90100003D020080030200002B020080090200002B0200800F02000041020080130200004202008017020000430200801B0200002602008021020000260200802A02000047020080380200004B020080450200004E020080510200004F0200805A0200005002008066020000510200806F020000560200808A0200005A0200808F0200005B02008092020000600200800D004C000D001E0011001C000D004C000D001E0011001C000D002700110028002900340011005C0011002D000D0023001100230024003400110021002200340011001C001D0029000D00270011002600110038001500200011003400110034001100280011001C0015002C002D0044000000000056005C005D00690015005300000000005A006100620069006A0076001500570015002B0015002B0011002A001500210023002B00150058001A00230000000000190029001E002700000000001D0029001D004C0021003B001D001E00210035002100370021002D002E0036001D002F0034003700290032001900290019002500190025003000330025002E00150031001100250015003000190039001A0035001900390019007F001500350019002A000D001800F200000078000000E20A0000010001004500000008000000080000006C0000000000000069020080090000006A020080120000006D0200801B0000006E02008025000000710200802D000000740200803500000078020080430000007B0200800D0020000D0020000D00200011001C000D0048000D0040000D003E000D001A00F2000000D4010000270B0000010001000C0200000800000025000000C801000000000000B003008033000000B103008035000000B503008042000000B60300804A000000B70300804C000000BC03008054000000C00300805C000000C10300806C000000C403008085000000C903008088000000EEEFFE808A000000CA030080AA000000C9030080B0000000C9030080BA000000CC030080BF000000D1030080E5000000D4030080E8000000EEEFFE80EA000000D503008017010000D40300801D010000D403008029010000D70300802E010000DC03008054010000DF03008057010000EEEFFE8059010000E003008093010000DF03008099010000DF030080A5010000E2030080A7010000E7030080C0010000E8030080D9010000EB030080DC010000EEEFFE80DE010000EC030080F6010000EB030080FC010000EB0300800A020000F30300800D00710011001D000D002D000D00210011001D000D002D000D001E000D003B000D0017001E002700000000001D004D003D00400029003B0019001F0019005A001E002700000000001D0059003D00400029003B0019001F00190068001E002700000000001D0065003D00400029003B0019001F0019005A0019005B001E002700000000001D004A0043004600290041000D001A00F200000048000000330D0000010001002800000008000000040000003C000000000000000B040080070000000C0400801A0000000D040080270000000E0400800D0023000D0035000D00290009000A00F2000000300000005B0D0000010001003E000000100000000200000024000000000000002400008037000000270000800D00C6000D002300F200000090000000990D00000100010066000000100000000A000000840000000000000034000080120000003500008018000000380000802000000039000080280000003C0000803C0000003D00008044000000400000804D0000004100008054000000440000805E000000470000800D003000110028000D0026000D0028000D003B000D0040000D003200110032000D0038000D002B00F200000048000000FF0D0000010001002300000010000000040000003C000000000000005200008009000000530000800F000000550000801C000000580000800D002000110028000D003E000D002B00F2000000A8000000220E0000010001009D000000100000000C0000009C00000000000000660000801B00000067000080210000006A000080290000006B000080310000006C000080390000006F0000804D0000007000008056000000730000805F00000074000080660000007700008071000000780000809A0000007B0000800D004000110027000D0026000D0028000D0026000D003B000D0040000D003200110032000D0034000D0064000D001B00F20000009C000000BF0E0000010001007A000000100000000B0000009000000000000000890000801B0000008A000080210000008D000080290000008E000080310000008F00008039000000920000804D0000009300008056000000960000805F00000097000080660000009A000080720000009D0000800D004200110027000D0026000D0028000D0028000D003B000D0040000D003200110032000D003F000D002A00F2000000D8000000390F000001000100A10000001000000010000000CC00000000000000B000008012000000B100008014000000B40000801C000000B500008024000000B800008038000000B900008040000000BC00008049000000BD00008050000000C00000805A000000C100008068000000C20000806B000000EEEFFE806D000000C40000808D000000C200008093000000C20000809E000000C80000800D00300011001D000D0026000D0028000D003B000D0040000D003200110032000D0044000D00510012001B000000000011004D00300033001D002E000D001B00F200000048000000DA0F0000010001002A00000010000000040000003C00000000000000D000008007000000D100008018000000D200008029000000D30000800D0040000D0034000D002F0009000A00F2000000440100000410000001000100E700000010000000190000003801000000000000F100008012000000F200008014000000F50000801C000000F600008024000000F900008038000000FA00008040000000FD00008049000000FE00008050000000010100805A0000000401008065000000050100806E0000000701008071000000EEEFFE8073000000090100808B000000070100809100000007010080990000000B0100809B0000000F010080AA00000012010080AD000000EEEFFE80AF00000014010080BD00000015010080D600000012010080DC00000012010080E40000001A0100800D00350011001D000D0026000D002D000D003B000D0040000D003200110032000D003A000D005F000D00250016001F00000000001500570034003700210032000D000E001100400016001F0000000000150035001500540034003700210032000D001B00F200000054000000EB100000010001003B00000010000000050000004800000000000000300100800700000031010080180000003201008029000000330100803A000000340100800D004E000D0034000D002F000D00340009000A00F2000000E400000026110000010001005E0000001000000011000000D8000000000000003E010080080000003F0100800C0000004101008012000000410100801A00000042010080200000004201008024000000430100802A000000430100802E0000004401008034000000440100803900000045010080400000004501008044000000460100804B00000046010080500000004701008057000000470100805C0000004A0100800D005C000D001A001100240025004A001100240025004900110024002500440011002400250051001100250026004400110025002600460011002500260045000D001800F2000000D80000008411000001000100420000001000000010000000CC000000000000004F010080020000005001008005000000500100800A000000510100800D00000051010080120000005201008015000000520100801A000000530100801D00000053010080220000005401008026000000540100802C00000055010080300000005501008036000000560100803A0000005601008040000000580100800D001B000D00220023002D000D00210022002C000D001C001D0027000D0029002A0034000D001B001C0027000D001D001E0029000D001C001D0028000D001900F200000078000000C6110000010001002200000010000000080000006C000000000000005F01008008000000610100801300000061010080170000006201008019000000630100801A000000630100801E000000640100802000000065010080110043001100410042004E000D000E000D002600290036000D00190009000A00F200000038010000E811000001000100FE00000018000000180000002C010000000000002500008029000000260000802B00000029000080330000002A000080400000002D0000804E0000002E000080570000003100008061000000320000806A000000340000806D000000EEEFFE806F0000003600008086000000340000808C000000340000809300000038000080950000003C000080AA0000003D000080B400000040000080C400000043000080C7000000EEEFFE80C900000045000080D600000046000080EE00000043000080F400000043000080FB0000004B0000800D00730011001D000D0026000D0039000D007B000D0033000D0055000D00250016001F00000000001500520034003700210032000D000E0011003F00110044001100400016001F00000000001500350015004F0034003700210032000D001B00F200000054000000E6120000010001003B00000018000000050000004800000000000000610000800700000062000080180000006300008029000000640000803A000000650000800D0044000D0034000D002F000D00340009000A00F2000000480000002113000001000100B800000018000000040000003C00000000000000820000800600000084000084B00000008A000080B60000008C0000800D002C000D00360011002B000D001C00F200000048000000D9130000010001009400000018000000040000003C000000000000009C000080060000009E0000838C000000A300008092000000A50000800D002C000D006E0011002B000D001C00F2000000480000006D140000010001005900000018000000040000003C00000000000000B000008006000000B200008151000000B500008057000000B70000800D002C000D00990011002B000D001C00F200000048000000C6140000010001004E00000018000000040000003C00000000000000C200008006000000C300008146000000C60000804C000000C80000800D002C000D00740011002B000D001C00F20000005400000014150000010001006000000018000000050000004800000000000000D300008012000000D500008018000000D80000802A000000DA00008044000000DE0000800D002B00110027000D002E0011005A0011004E00F20000002400000074150000010001001D000000000000000100000018000000000000001900008409000B00F4000000200000002801000000000000C00000000000000062000000000000000100000000000000F0000000000000001C00000034000000500000006800000088000000A0000000C4000000DC000000FC000000140100003801000050010000840100009C010000C8010000E0010000F8010000100200002C020000440200005C0200007402000090020000A8020000C4020000DC020000F8020000100300002C0300004403000060030000780300009C030000B4030000D8030000F00300001C04000034040000580400007004000094040000AC040000D0040000E80400000805000020050000440500005C0500007805000090050000A8050000C0050000D8050000F005000008060000200600003C060000540600006C060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000040000002E002A110000000064000000000000000F000000000000000000000029000006571B000001000000002E63746F7200002E000404C93FEAC6B359D649BC250902BBABB460000000004D0044003200000004010000040100000C0000001F000006020006002E002A1100000000C8000000000000000E00000000000000000000002A000006661B000001000000002E63746F7200002E000404C93FEAC6B359D649BC250902BBABB460000000004D0044003200000004010000040100000C0000001F00000602000600F20000003C000000571B0000010001000F00000000000000030000003000000000000000FD03008007000000FE0300800E000000FF03008011002A00110020000D000E00F200000030000000661B0000010001000E00000000000000020000002400000000000000020400800D00000003040080130032000F001000F400000008000000C000000000000000100000008406000098060000B0060000C406000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000040000002E002A110000000064000000000000001600000000000000000000002C000006831B000001000000002E63746F7200002E000404C93FEAC6B359D649BC250902BBABB460000000004D0044003200000004010000040100000C0000002B00000602000600F200000048000000831B0000010001001600000000000000040000003C000000000000002501008007000000260100800E00000027010080150000002801008011002A0011002400110028000D000E00F400000008000000620000000000000008000000DC060000F0060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000040000002E002A110000000028010000000000001600000000000000000000002D000006991B000001000000002E63746F7200001600031104000000EC00000016000000991B0000010000000A0024115553797374656D00160024115553797374656D2E436F6C6C656374696F6E73001A0024115553797374656D2E446174612E53716C54797065730000001A0024115553797374656D2E476C6F62616C697A6174696F6E000000220024115553797374656D2E546578742E526567756C617245787072657373696F6E73001E002411554D6963726F736F66742E53716C5365727665722E536572766572000200060036000404C93FEAC6B359D649BC250902BBABB460000000004D0044003200000004010000040000001400000004000000000000000600000002000600F200000048000000991B0000010001001600000000000000040000003C000000000000005600008007000000570000800E00000058000080150000005900008011002A0011002400110028000D000E00F400000008000000010000000000000008000000080700001C07000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000400000042002A1100000000E4010000000000008A000000000000000000000030000006AF1B000001000000003C53696D696C61726974794A6163636172643E625F5F355F3000001600031104000000A80100008A000000AF1B0000010000000A0024115553797374656D00160024115553797374656D2E436F6C6C656374696F6E73001E0024115553797374656D2E436F6C6C656374696F6E732E47656E65726963001A0024115553797374656D2E446174612E53716C5479706573000000120024115553797374656D2E4C696E71000000001E002411554D6963726F736F66742E53716C5365727665722E53657276657200160024115553797374656D2E446961676E6F7374696373001A0024115553797374656D2E476C6F62616C697A6174696F6E00000016002011000000002500001100000000000000006C656E001A002011010000002500001100000000000000006E6772616D7300001600201102000000250000110000000000000000636100001600031148000000A40100003E000000F91B000001000000160020110300000025000011000000000000000069000000020006000200060036000404C93FEAC6B359D649BC250902BBABB460000000004D0044003200000004010000040000001400000004000000000000000800000002000600F2000000F0000000AF1B0000010001008A0000000000000012000000E400000000000000E700008002000000E80000800A000000EA00008017000000EB0000801E000000EF00008021000000F000008023000000F300008035000000F700008043000000FA0000804A000000FB0000804C000000EEEFFE804E000000FD00008058000000FE00008064000000FF000080700000000201008079000000FB0000807D000000FB000080880000000601008011001D001100320015003D001500280011001E001500210011004100110040001100290016001F00000000001500260015002A0015002A001500300037003A002100350011001F00F400000008000000C00000000000000008000000340700005C07000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000400000032002A110000000020020000000000008F00000000000000000000001F0000069115000001000000004A616363617264000000001600031104000000E40100008F00000091150000010000000A0024115553797374656D00160024115553797374656D2E436F6C6C656374696F6E73001E0024115553797374656D2E436F6C6C656374696F6E732E47656E65726963001A0024115553797374656D2E446174612E53716C5479706573000000120024115553797374656D2E4C696E71000000001E002411554D6963726F736F66742E53716C5365727665722E53657276657200160024115553797374656D2E446961676E6F7374696373001A0024115553797374656D2E476C6F62616C697A6174696F6E00000016002011000000001D00001100000000000000006431000016002011010000001D00001100000000000000006D31000016002011020000001D00001100000000000000006432000016002011030000001D00001100000000000000006D32000026002011040000001D000011000000000000000073636F7265436F6D7061726553616D65000000001600031138000000E001000028000000F51500000100000026002011050000001D000011000000000000000073636F7265537761704461794D6F6E7468000000020006000200060036000404C93FEAC6B359D649BC250902BBABB460000000004D004400320000000401000004000000140000000400000000000000080000000200060032002A1100000000DC02000000000000180000000000000000000000200000062016000001000000004A616363617264000000001600031124020000A80200001800000020160000010000001A002011000000001E0000110000000000000000696E7465720000001A002011010000001E0000110000000000000000756E696F6E000000020006002E000404C93FEAC6B359D649BC250902BBABB460000000004D0044003200000004010000040100000C0000001F0000060200060036002A1100000000800300000000000022000000000000000000000021000006381600000100000000436F756E745365744269747300000016000311E00200004C0300002200000038160000010000001A002011000000001F0000110000000000000000636F756E74000000020006002E000404C93FEAC6B359D649BC250902BBABB460000000004D0044003200000004010000040100000C0000001F0000060200060032002A1100000000F804000000000000E00100000000000000000000220000065A16000001000000004C6F61645461626C6500001600031184030000C4040000E00100005A1600000100000016000311B8030000C0040000DF0100005A1600000100000016002011000000002000001100000000000000006900000016000311D0030000BC040000CB01000061160000010000001A00201101000000200000110000000000000000626C6F6F6D0000001600031100040000640400005E0000007E1600000100000016002011040000002000001100000000000000006D000000020006001600031100040000B8040000E200000042170000010000001A0020110500000020000011000000000000000069446976313000001A00201106000000200000110000000000000000694D6F6431300000020006000200060002000600020006002E000404C93FEAC6B359D649BC250902BBABB460000000004D0044003200000004010000040100000C0000001F000006020006002E002A11000000005C050000000000000D0000000000000000000000230000063A18000001000000002E6363746F72002E000404C93FEAC6B359D649BC250902BBABB460000000004D0044003200000004010000040100000C0000001F00000602000600F2000000B400000091150000010001008F000000000000000D000000A8000000000000009E020080090000009F0200800E000000A20200801C000000A30200802A000000A602008038000000A702008046000000AA02008057000000AD02008064000000B002008075000000B302008083000000B602008089000000B70200808C000000BA020080110025001500210011002C0011002E0011002C0011002E0011006B0011002C001500700015002F0015003E001900320011002900F20000003C00000020160000010001001800000000000000030000003000000000000000C00200800A000000C102008014000000C3020080110036001100360011002600F20000008400000038160000010001002200000000000000090000007800000000000000C802008007000000C902008009000000CB0200800B000000EEEFFE800D000000CE02008013000000CE02008017000000CF0200801C000000CC02008020000000D202008011002E001500270011001F000000000015002E002F003700150021001100220011001E00F2000000940200005A16000001000100E001000000000000350000008802000000000000DB02008002000000EEEFFE8007000000DE0200800E000000E102008022000000EEEFFE8024000000E102008029000000E30200802E000000E502008043000000E602008058000000E70200806D000000E802008082000000EEEFFE8086000000E10200808C000000ED02008091000000F002008095000000F0020080A1000000F3020080A5000000F3020080AF000000F4020080B3000000F4020080B7000000F8020080BB000000F8020080C5000000F9020080DB000000FC020080E3000000FD020080E800000002030080EE00000003030080F400000006030080F90000000603008008010000070300800D010000070300801C010000080300802601000008030080330100000B030080380100000D0300803D0100000D0300804E0100000E030080530100000E03008062010000120300806601000012030080700100001303008075010000130300807F010000140300809F01000017030080A401000017030080AE01000018030080B301000018030080BD01000019030080C201000019030080CA0100001D030080D2010000DB020080D7010000DB020080DF0100001F030080160020000000000015002C0027003F00000000001E002300190024001D0049001D0049001D0049001D004900000000002400260015002000190024002500400019002400250039001E0029002A003E0019002400250056001E004D00190028001500160019002D0019002D00190029002A004A001E002E002F004F001E003D003E005E00190024001D002D002E0052002200320033005700190029002A005B001E002E002F006D001E006900190029002A0041001E002E002F0046001E002E002F005200150037002B002E00220029000D000E00F2000000240000003A180000010001000D00000000000000010000001800000000000000D60200800D004100F400000008000000C00000000000000028000000740700008C070000A4070000BC070000D4070000F00700000808000020080000380800005008000000000000000000000000000000000000040000002E002A11000000000C010000000000000F00000000000000000000002B000006741B000001000000002E63746F7200001600031104000000D00000000F000000741B0000010000000A0024115553797374656D00160024115553797374656D2E436F6C6C656374696F6E73001A0024115553797374656D2E446174612E53716C5479706573000000220024115553797374656D2E546578742E526567756C617245787072657373696F6E73001E002411554D6963726F736F66742E53716C5365727665722E536572766572000200060036000404C93FEAC6B359D649BC250902BBABB460000000004D0044003200000004010000040000001400000004000000000000000500000002000600F20000003C000000741B0000010001000F00000000000000030000003000000000000000DC00008007000000DD0000800E000000DE00008011002A00110024000D000E00F400000008000000620000000000000008000000680800007C0800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000400000032002A1100000000EC000000000000006E0000000000000000000000240000064718000001000000004A616363617264000000001600031104000000B80000006E00000047180000010000001600201100000000210000110000000000000000623100001600201101000000210000110000000000000000623200001A00201102000000210000110000000000000000696E7465720000001A00201103000000210000110000000000000000756E696F6E000000020006002E000404C93FEAC6B359D649BC250902BBABB460000000004D0044003200000004010000040100000C0000001F0000060200060032002A1100000000C001000000000000ED000000000000000000000025000006B51800000100000000476574426C6F6F6D00000016000311F00000008C010000ED000000B5180000010000001A0020110000000022000011000000000000000079656172730000001A00201101000000220000110000000000000000626C6F6F6D00000016002011020000002200001100000000000000006D617800020006002E000404C93FEAC6B359D649BC250902BBABB460000000004D0044003200000004010000040100000C0000001F0000060200060036002A110000000098020000000000001D000000000000000000000026000006A21900000100000000436F756E745365744269747300000016000311C4010000640200001D000000A2190000010000001A00201100000000230000110000000000000000636F756E7400000016000311FC0100006002000019000000A41900000100000016002011010000002300001100000000000000006900000002000600020006002E000404C93FEAC6B359D649BC250902BBABB460000000004D0044003200000004010000040100000C0000001F0000060200060032002A110000000064040000000000008B010000000000000000000027000006BF19000001000000004C6F61645461626C650000160003119C020000300400008B010000BF1900000100000016000311D00200002C0400008A010000BF1900000100000016002011000000002400001100000000000000006900000016000311E80200002804000076010000C6190000010000001A00201101000000240000110000000000000000626C6F6F6D0000001E002011020000002400001100000000000000006D6178496E6465780000000016000311180300009C03000022000000401A00000100000016002011030000002400001100000000000000006A0000000200060016000311180300002404000096000000671A0000010000001A0020110400000024000011000000000000000069446976313000001A00201105000000240000110000000000000000694D6F643130000016000311A0030000200400002F000000CE1A00000100000016002011060000002400001100000000000000006A00000002000600020006000200060002000600020006002E000404C93FEAC6B359D649BC250902BBABB460000000004D0044003200000004010000040100000C0000001F000006020006002E002A1100000000C8040000000000000D0000000000000000000000280000064A1B000001000000002E6363746F72002E000404C93FEAC6B359D649BC250902BBABB460000000004D0044003200000004010000040100000C0000001F00000602000600F20000005400000047180000010001006E000000000000000500000048000000000000002F03008007000000300300800E000000320300803C000000330300806A0000003403008011003A0011003A00110079001100780011002600F200000078000000B518000001000100ED00000000000000080000006C0000000000000042030080120000004303008017000000460300804800000049030080600000004A030080900000004B030080BA0000004C030080D30000004F03008011002C00150021001100670011004600110053001100590011003F0011004800F200000078000000A2190000010001001D00000000000000080000006C0000000000000054030080020000005503008004000000EEEFFE8006000000560300800F00000057030080130000005503008017000000550300801B0000005903008011001F0016001F000000000015002200190021003000330021002E0011001E00F200000040020000BF190000010001008B010000000000002E00000034020000000000005F03008002000000EEEFFE8007000000610300800F0000006403008017000000670300802700000068030080370000006B030080470000006C030080570000006F0300805C0000007203008067000000750300806B0000007503008075000000760300807900000076030080810000007903008083000000EEEFFE80850000007B030080920000007C0300809A000000790300809E00000079030080A30000007E030080A800000083030080AE00000084030080B400000087030080C30000008A030080C80000008A030080D60000008B030080DB0000008B030080E70000008D030080EC0000008D030080FC0000008E030080010100008E0300800F0100009103008012010000EEEFFE8014010000930300802301000094030080320100009103008038010000910300803E0100009903008048010000EEEFFE804A0100009A0300804F0100009A030080580100009D0300807D0100005F030080820100005F0300808A0100009F0300801600200000000000150038001500280015003A0015003A0015003A0015003A00150020001900310019002400250038001E0029002A003D001E002700000000001D0039001D0030003100340029002F001500160019002D0019002D0019003F00190029002A0047001E002E002F004C00190029002A004B001E002E002F0050001E002700000000001D003E001D003E003100340029002F0015003D00000000002E00390015002D00150055002B002E00220029000D000E00F2000000240000004A1B0000010001000D00000000000000010000001800000000000000380300800D004C00F400000008000000C0000000000000002800000094080000AC080000C4080000DC080000F408000010090000280900004009000058090000700900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFFFFFFF1A092FF1E00200004403000051000000010000005D02000001000000D903000001000000D905000001000000A10000000100000021080000010000007D08000001000000F508000001000000D507000001000000890000000100000091020000010000001D0400000100000009060000010000005108000001000000F106000001000000610300000100000029090000010000000908000001000000BD070000010000005D070000010000002105000001000000C508000001000000910500000100000069080000010000000907000001000000DD06000001000000B10600000100000085060000010000001D000000010000002D020000010000009D03000001000000A905000001000000F107000001000000C506000001000000C10500000100000039010000010000002D03000001000000D1040000010000008D0700000100000011090000010000007104000001000000850100000100000009050000010000004109000001000000AD04000001000000B50300000100000051010000010000001501000001000000C500000001000000C50200000100000059040000010000003D06000001000000AD080000010000001D0700000100000035000000010000007502000001000000FD00000001000000F902000001000000010000000100000095040000010000006D06000001000000DD080000010000009D010000010000001102000001000000DD00000001000000A902000001000000590900000100000039080000010000005506000001000000C90100000100000045050000010000001103000001000000690000000100000071090000010000004502000001000000F103000001000000E904000001000000F901000001000000E10100000100000079050000010000009906000001000000DD0200000100000021060000010000009508000001000000A5070000010000007507000001000000F1050000010000005D050000010000003507000001000000790300000100000045030000010000003504000001000000010400000208000005010000000000000000040000000000000000000000000001040000020800000401000000000000000000000000000000000000000000000000000002000040040000000820010004020000000000000000000000000000010400000208000004010000002000000000000000000000000000000000000001040000020800000400000000000000000000000000000000000001000000000100000002000000040000000000040000010000000000000000000000000000010400000208000004010000000000000000000000000040000000000000008001040020020800000400000000000000000040040000000000000001000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000400000000000000000000000000000000000002000000814000000800000000000000100000000000000000000002000800000200000801000000080000000000000010000000000000000000000000000000000000000002000000000000400000000000000000000000020000000000000000000000000000000000000200000004000000000000000000000000001000000000000000000000000000000004000000000000008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000C0000001800000024000000300000003C00000048000000540000006C0000007800000084000000900000009C000000A8000000B4000000C0000000D8000000E4000000F0000000FC0000000801000014010000500100005C0100006801000074010000800100008C01000098010000A4010000B0010000BC010000C8010000D4010000E0010000EC010000F8010000040200001002000034020000400200004C0200005802000064020000700200007C0200008802000094020000A0020000AC020000B8020000C4020000D0020000DC020000E8020000F4020000000300000C030000180300003C0300004803000054030000600300006C0300007803000084030000900300009C030000A8030000B4030000C0030000CC030000D8030000E40300000804000014040000200400002C0400003804000044040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001A00251100000000040000000100586D6C5472616E73666F726D00001600291100000000040000000100303630303030303100001A00251100000000C8010000010053696D696C6172697479000000001600291100000000C80100000100303630303030303200001E00251100000000FC030000010053696D696C617269747944617465000000001600291100000000FC0300000100303630303030303300002200251100000000D8040000010053696D696C61726974794C6576656E73687465696E001600291100000000D80400000100303630303030303400001E0025110000000030080000010053696D696C61726974794A616363617264001600291100000000300800000100303630303030303500002200251100000000080B0000010053696D696C61726974794A61726F57696E6B6C6572001600291100000000080B00000100303630303030303600003200251100000000F00E0000010053696D696C61726974794C6F6E67657374436F6D6D6F6E53756273657175656E6365000000001600291100000000F00E00000100303630303030303700002A0025110000000098120000010053696D696C6172697479446174654772616E744469636B696E736F6E000016002911000000009812000001003036303030303038000016002511000000009013000001004E4772616D7300000000160029110000000010000000000000000000000000000000000000000000000049000000FFFFFFFF1A092FF10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000901300000100303630303030303900001A002511000000004C15000001004E4772616D46696C6C526F77000016002911000000004C1500000100303630303030306100001600251100000000EC150000010052656765784D61736B001600291100000000EC1500000100303630303030306200001A00251100000000141700000100526567657849734D6174636800001600291100000000141700000100303630303030306300001A002511000000001818000001005265676578497356616C696400001600291100000000181800000100303630303030306400001A00251100000000BC180000010052656765784578747261637400001600291100000000BC1800000100303630303030306500001A00251100000000F0190000010052656765785265706C61636500001600291100000000F01900000100303630303030306600001A002511000000000C1B0000010052656765784D617463686573000016002911000000000C1B00000100303630303030313000002200251100000000601C0000010052656765784D61746368657346696C6C526F770000001600291100000000601C000001003036303030303131000022002511000000000C1D00000100526567657853706C697457697468436865636B00000016002911000000000C1D00000100303630303030313200002A00251100000000041F00000100526567657853706C697457697468436865636B46696C6C526F77000000001600291100000000041F00000100303630303030313300002200251100000000B41F0000010052656765784F7074696F6E7346726F6D4D61736B00001600291100000000B41F000001003036303030303134000022002511000000005C200000010052656765784F7074696F6E73546F4D61736B0000000016002911000000005C2000000100303630303030313500002200251100000000042100000100497356616C696452656765785061747465726E0000001600291100000000042100000100303630303030313600001E00251100000000C8210000010053706C697457697468436865636B000000001600291100000000C8210000010030363030303031370000220025110000000078240000010053706C697457697468436865636B46696C6C526F77001600291100000000782400000100303630303030313800001A0025110000000024250000010049734461746554696D65320000001600291100000000242500000100303630303030313900001600251100000000EC25000001004973426967496E7400001600291100000000EC2500000100303630303030316100001600251100000000AC260000010049734E756D62657200001600291100000000AC26000001003036303030303162000016002511000000006C270000010049734C696E6B0000000016002911000000006C2700000100303630303030316300001A0025110000000008280000010044617465546F537472696E67000016002911000000000828000001003036303030303164000016002511000000007428000001002E6363746F720000000016002911000000007428000001003036303030303165000012002511000000000400000004002E63746F720016002911000000000400000004003036303030303239000012002511000000006800000004002E63746F720016002911000000006800000004003036303030303261000012002511000000000400000006002E63746F720016002911000000000400000006003036303030303263000012002511000000000400000007002E63746F720016002911000000000400000007003036303030303264000026002511000000000400000008003C53696D696C61726974794A6163636172643E625F5F355F300016002911000000000400000008003036303030303330000016002511000000000400000002004A61636361726400000016002911000000000400000002003036303030303166000016002511000000002402000002004A6163636172640000001600291100000000240200000200303630303030323000001A00251100000000E00200000200436F756E745365744269747300001600291100000000E002000002003036303030303231000016002511000000008403000002004C6F61645461626C65001600291100000000840300000200303630303030323200001600251100000000FC04000002002E6363746F72000000001600291100000000FC04000002003036303030303233000012002511000000000400000005002E63746F720016002911000000000400000005003036303030303262000016002511000000000400000003004A6163636172640000001600291100000000040000000300303630303030323400001600251100000000F00000000300476574426C6F6F6D00001600291100000000F00000000300303630303030323500001A00251100000000C40100000300436F756E745365744269747300001600291100000000C401000003003036303030303236000016002511000000009C02000003004C6F61645461626C650016002911000000009C02000003003036303030303237000016002511000000006804000003002E6363746F7200000000160029110000000068040000030030363030303032380000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100A015BF0E00007A000000000000000000861800000000000000000100A015390F0000A1000000000000000000861800000000000000000100A015DA0F00002A000000000000000000861800000000000000000100A01504100000E7000000000000000000861800000000000000000100A015EB1000003B000000000000000000861800000000000000000100A015261100005E000000000000000000861800000000000000000100A0158411000042000000000000000000861800000000000000000100A015C611000022000000000000000000861800000000000000000100A015E8110000FE000000000000000000861800000000000000000100A015E61200003B000000000000000000861800000000000000000100A01521130000B8000000000000000000861800000000000000000100A015D913000094000000000000000000861800000000000000000100A0156D14000059000000000000000000861800000000000000000100A015C61400004E000000000000000000861800000000000000000100A0151415000060000000000000000000861800000000000000000100A015741500001D00000000000000000086180000000000000000010031B8911500008F00000000000000010031B80000000000000000010031B8201600001800000000000000010031B80000000000000000010031B800000000000000004D6963726F736F66742E4D61737465724461746153657276696365732E446174615175616C6974792E53716C436C722E4E4772616D003835374539303641000000000000FFFF000000000000FFFFFFFF00000000FFFF000000000000000000000000130010010000000000005400000001007B170000000000000000000000004D6963726F736F66742E4D61737465724461746153657276696365732E446174615175616C6974792E53716C436C722E52656765784D6174636865735374727563740030343342443946390000000000FFFF000000000000FFFFFFFF00000000FFFF0000000000000000000000000F0068000000000000006000000001007B170000000000000000000000004D6963726F736F66742E4D61737465724461746153657276696365732E446174615175616C6974792E53716C436C722E526567657853706C697457697468436865636B537472756374004344354543324136000000000000FFFF000000000000FFFFFFFF00000000FFFF00000000000000000000000010002C010000000000006000000001007B170000000000000000000000004D6963726F736F66742E4D61737465724461746153657276696365732E446174615175616C6974792E53716C436C722E53706C697457697468436865636B53747275637400463842423633423600000000000000FFFF000000000000FFFFFFFF00000000FFFF0000000000000000000000001100E8010000000000000801000001007B170000000000000000000000004D6963726F736F66742E4D61737465724461746153657276696365732E446174615175616C6974792E53716C436C722E3C3E63004235394237333937000000002DBA2EF10100A015000000006B000000000000000000861800000000000000000100A0156B000000F4000000000000000000861800000000000000000100A0155F01000047000000000000000000861800000000000000000100A015A601000082020000000000000000861800000000000000000100A015280400009F010000000000000000861800000000000000000100A015C70500007F020000000000000000861800000000000000000100A015460800009C020000000000000000861800000000000000000100A015E20A000045000000000000000000861800000000000000000100A015270B00000C020000000000000000861800000000000000000100A015330D000028000000000000000000861800000000000000000100A0155B0D00003E000000000000000000861800000000000000000100A015990D000066000000000000000000861800000000000000000100A015FF0D000023000000000000000000861800000000000000000100A015220E00009D000000000000000000861800000000FFFFFFFF770931010100000015000B8E1600B76317000000380400000C0500002C0000001C010000000000000000000016000000190000000000EEC00000000000000000FFFF000000000000FFFFFFFF00000000FFFF0000000000000000000000000D00BC29000000000000301C000004007B170000000000000000000000004D6963726F736F66742E4D61737465724461746153657276696365732E446174615175616C6974792E53716C436C720042453933463237390000000000000000FFFF000000000000FFFFFFFF00000000FFFF000000000000000000000000120060050000000000006404000001007B170000000000000000000000004D6963726F736F66742E4D61737465724461746153657276696365732E446174615175616C6974792E53716C436C722E426C6F6F6D4D6F6E7468446179003342303739434433000000000000FFFF000000000000FFFFFFFF00000000FFFF0000000000000000000000001400CC04000000000000E003000001007B170000000000000000000000004D6963726F736F66742E4D61737465724461746153657276696365732E446174615175616C6974792E53716C436C722E426C6F6F6D59656172003033364144324539000000000000FFFF000000000000FFFFFFFF00000000FFFF0000000000000000000000000E00CC000000000000008C00000001007B1700000000381600002200000000000000010031B80000000000000000010031B85A160000E001000000000000010031B80000000000000000010031B83A1800000D00000000000000010031B8000000000000000001000000471800006E0000000000000002000000000000000000000001000000B5180000ED0000000000000002000000000000000000000001000000A21900001D0000000000000002000000000000000000000001000000BF1900008B01000000000000020000000000000000000000010000004A1B00000D0000000000000002000000000000000000000001000006571B00000F0000000000000003007219000000000000000001000006661B00000E0000000000000003007219000000000000000001000000741B00000F0000000000000004000000000000000000000001000000831B0000160000000000000005000000000000000000000001000000991B0000160000000000000006000000000000000000000001000000AF1B00008A000000000000000700D1B80000000000000000020002000D01000000000100FFFFFFFF00000000391C00000802000000000000FFFFFFFF00000000FFFFFFFF08000B0000000400050006000700080009000A000400010001000100010001000100010000000000360000006A000000990000003600000036000000360000006A0000006A0000009900000036000000443A5C4D44535F4D61696E5C53716C5C6D64735C6465765C44425C7372635C53716C436C725C4D647353716C436C72586D6C2E637300443A5C4D44535F4D61696E5C53716C5C6D64735C6465765C44425C7372635C53716C436C725C53696D696C61726974792E637300443A5C4D44535F4D61696E5C53716C5C6D64735C6465765C44425C7372635C53716C436C725C52656765782E637300443A5C4D44535F4D61696E5C53716C5C6D64735C6465765C44425C7372635C53716C436C725C537472696E672E637300000000FEEFFEEF010000000100000000010000000000000000000000FFFFFFFFFFFFFFFFFFFF0C00FFFFFFFFFFFFFFFFFFFF000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000942E31018521F65C0100000053BFD72F4C0A4D4A976DF401D45B72FD170100002F4C696E6B496E666F002F6E616D6573002F7372632F686561646572626C6F636B002F7372632F66696C65732F643A5C6D64735F6D61696E5C73716C5C6D64735C6465765C64625C7372635C73716C636C725C737472696E672E6373002F7372632F66696C65732F643A5C6D64735F6D61696E5C73716C5C6D64735C6465765C64625C7372635C73716C636C725C72656765782E6373002F7372632F66696C65732F643A5C6D64735F6D61696E5C73716C5C6D64735C6465765C64625C7372635C73716C636C725C73696D696C61726974792E6373002F7372632F66696C65732F643A5C6D64735F6D61696E5C73716C5C6D64735C6465765C64625C7372635C73716C636C725C6D647373716C636C72786D6C2E637300070000000E00000001000000E033000000000000970000000A0000000A000000060000000000000005000000220000000800000011000000070000005D00000009000000D60000000B00000000000000DC51330100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000018000000200000008B01000038000000FB0A00003800000000000000EC010000040100005C0000005C0000005C0000005C00000028000000E04600006C010000D400000098010000FC020000F009000070010000D8080000340600002C00000088090000030000005300000006000000500000004E0000004F0000004D0000005100000052000000070000000D0000000E00000008000000090000000A0000000B0000000C0000000F000000100000001100000012000000130000001400000015000000160000001700000018000000190000001A0000001B0000001C0000001D0000001E0000001F000000200000002100000022000000230000002400000025000000260000002700000028000000290000002A0000002B0000002C0000002D0000002E0000002F000000300000003100000032000000330000003400000035000000360000003700000038000000390000003A0000003B0000003C0000003D0000003E0000003F000000400000004100000042000000430000004400000045000000460000004800000047000000490000004A0000004B0000004C00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000054000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
AS N'Microsoft.MasterDataServices.DataQuality.pdb'
GO
/****** Object:  Schema [dqs]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE SCHEMA [dqs]
GO
/****** Object:  Schema [mdm]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE SCHEMA [mdm]
GO
/****** Object:  Schema [mdq]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE SCHEMA [mdq]
GO
/****** Object:  Schema [stg]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE SCHEMA [stg]
GO
/****** Object:  Schema [usr]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE SCHEMA [usr]
GO
/****** Object:  UserDefinedTableType [mdm].[Attribute]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE TYPE [mdm].[Attribute] AS TABLE(
	[Row_ID] [int] NOT NULL,
	[Model_MUID] [uniqueidentifier] NULL,
	[ModelName] [nvarchar](50) NULL,
	[Entity_MUID] [uniqueidentifier] NULL,
	[EntityName] [nvarchar](50) NULL,
	[MemberType_ID] [tinyint] NOT NULL,
	[Attribute_MUID] [uniqueidentifier] NULL,
	[AttributeName] [nvarchar](100) NOT NULL,
	[AttributeType_ID] [tinyint] NULL,
	[Description] [nvarchar](500) NULL,
	[DisplayName] [nvarchar](250) NULL,
	[DisplayWidth] [int] NOT NULL,
	[DomainEntity_MUID] [uniqueidentifier] NULL,
	[DomainEntityName] [nvarchar](50) NULL,
	[DataType_ID] [tinyint] NULL,
	[DataTypeInformation] [int] NULL,
	[InputMask_Name] [nvarchar](250) NULL,
	[ChangeTrackingGroup] [int] NULL DEFAULT ((0)),
	[SortOrder] [int] NULL,
	PRIMARY KEY CLUSTERED 
(
	[Row_ID] ASC
)WITH (IGNORE_DUP_KEY = OFF)
)
GO
/****** Object:  UserDefinedTableType [mdm].[AttributeFilter]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE TYPE [mdm].[AttributeFilter] AS TABLE(
	[AttributeRow_ID] [int] NULL,
	[ParentAttribute_MUID] [uniqueidentifier] NULL,
	[ParentAttributeName] [nvarchar](100) NULL,
	[Hierarchy_MUID] [uniqueidentifier] NULL,
	[HierarchyName] [nvarchar](50) NULL,
	[HierarchyLevelNumber] [int] NULL
)
GO
/****** Object:  UserDefinedTableType [mdm].[AttributeGroup]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE TYPE [mdm].[AttributeGroup] AS TABLE(
	[Row_ID] [int] NOT NULL,
	[Model_MUID] [uniqueidentifier] NULL,
	[ModelName] [nvarchar](50) NULL,
	[Entity_MUID] [uniqueidentifier] NULL,
	[EntityName] [nvarchar](50) NULL,
	[MemberType_ID] [tinyint] NOT NULL,
	[MUID] [uniqueidentifier] NULL,
	[Name] [nvarchar](50) NOT NULL,
	[SortOrder] [int] NULL,
	[FreezeNameCode] [bit] NULL DEFAULT ((0)),
	[IsSystem] [bit] NULL DEFAULT ((0)),
	PRIMARY KEY CLUSTERED 
(
	[Row_ID] ASC
)WITH (IGNORE_DUP_KEY = OFF)
)
GO
/****** Object:  UserDefinedTableType [mdm].[AttributeGroupDetail]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE TYPE [mdm].[AttributeGroupDetail] AS TABLE(
	[AttributeGroupRow_ID] [int] NOT NULL,
	[MUID] [uniqueidentifier] NULL,
	[Name] [nvarchar](100) NULL
)
GO
/****** Object:  UserDefinedTableType [mdm].[CustomIndex]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE TYPE [mdm].[CustomIndex] AS TABLE(
	[Model_MUID] [uniqueidentifier] NULL,
	[ModelName] [nvarchar](50) NULL,
	[Entity_MUID] [uniqueidentifier] NULL,
	[EntityName] [nvarchar](50) NULL,
	[MUID] [uniqueidentifier] NULL,
	[Name] [nvarchar](50) NOT NULL,
	[IsUnique] [bit] NULL DEFAULT ((0))
)
GO
/****** Object:  UserDefinedTableType [mdm].[CustomIndexDetail]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE TYPE [mdm].[CustomIndexDetail] AS TABLE(
	[Model_MUID] [uniqueidentifier] NULL,
	[ModelName] [nvarchar](50) NULL,
	[Entity_MUID] [uniqueidentifier] NULL,
	[EntityName] [nvarchar](50) NULL,
	[CustomIndex_MUID] [uniqueidentifier] NULL,
	[CustomIndexName] [nvarchar](50) NULL,
	[MUID] [uniqueidentifier] NULL,
	[Name] [nvarchar](100) NULL
)
GO
/****** Object:  UserDefinedTableType [mdm].[DerivedHierarchy]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE TYPE [mdm].[DerivedHierarchy] AS TABLE(
	[Model_MUID] [uniqueidentifier] NULL,
	[ModelName] [nvarchar](50) NULL,
	[MUID] [uniqueidentifier] NULL,
	[Name] [nvarchar](50) NULL,
	[AnchorNullRecursions] [bit] NULL DEFAULT ((1))
)
GO
/****** Object:  UserDefinedTableType [mdm].[DerivedHierarchyLevel]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE TYPE [mdm].[DerivedHierarchyLevel] AS TABLE(
	[Model_MUID] [uniqueidentifier] NULL,
	[ModelName] [nvarchar](50) NULL,
	[DerivedHierarchy_MUID] [uniqueidentifier] NULL,
	[DerivedHierarchyName] [nvarchar](50) NULL,
	[MUID] [uniqueidentifier] NULL,
	[Name] [nvarchar](100) NOT NULL,
	[ForeignEntity_MUID] [uniqueidentifier] NULL,
	[ForeignEntityName] [nvarchar](50) NULL,
	[Foreign_MUID] [uniqueidentifier] NULL,
	[ForeignName] [nvarchar](100) NULL,
	[ForeignType_ID] [tinyint] NOT NULL,
	[ManyToManyChildAttribute_MUID] [uniqueidentifier] NULL,
	[ManyToManyChildAttributeName] [nvarchar](100) NULL,
	[DisplayName] [nvarchar](100) NOT NULL,
	[IsVisible] [bit] NOT NULL,
	[LevelNumber] [int] NOT NULL
)
GO
/****** Object:  UserDefinedTableType [mdm].[Entity]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE TYPE [mdm].[Entity] AS TABLE(
	[Model_MUID] [uniqueidentifier] NULL,
	[ModelName] [nvarchar](50) NULL,
	[Entity_MUID] [uniqueidentifier] NULL,
	[EntityName] [nvarchar](50) NULL,
	[Description] [nvarchar](500) NULL,
	[IsBase] [bit] NULL,
	[StagingBase] [nvarchar](60) NULL DEFAULT (N''),
	[CodeGenSeed] [int] NULL,
	[DataCompression] [tinyint] NULL,
	[TransactionLogType] [tinyint] NULL,
	[RequireApproval] [bit] NULL
)
GO
/****** Object:  UserDefinedTableType [mdm].[ExplicitHierarchy]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE TYPE [mdm].[ExplicitHierarchy] AS TABLE(
	[Model_MUID] [uniqueidentifier] NULL,
	[ModelName] [nvarchar](50) NULL,
	[Entity_MUID] [uniqueidentifier] NULL,
	[EntityName] [nvarchar](50) NULL,
	[Hierarchy_MUID] [uniqueidentifier] NULL,
	[HierarchyName] [nvarchar](50) NULL,
	[IsMandatory] [bit] NULL
)
GO
/****** Object:  UserDefinedTableType [mdm].[HierarchyMembers]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE TYPE [mdm].[HierarchyMembers] AS TABLE(
	[Hierarchy_ID] [int] NULL,
	[HierarchyName] [nvarchar](50) NULL,
	[Parent_ID] [int] NULL,
	[ParentCode] [nvarchar](250) NULL,
	[Child_ID] [int] NULL,
	[ChildCode] [nvarchar](250) NULL,
	[ChildMemberType_ID] [tinyint] NULL,
	[Target_ID] [int] NULL,
	[TargetCode] [nvarchar](250) NULL,
	[TargetMemberType_ID] [tinyint] NULL,
	[TargetType_ID] [tinyint] NULL
)
GO
/****** Object:  UserDefinedTableType [mdm].[Identifier]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE TYPE [mdm].[Identifier] AS TABLE(
	[MUID] [uniqueidentifier] NULL,
	[Name] [nvarchar](250) NULL,
	[ID] [int] NULL
)
GO
/****** Object:  UserDefinedTableType [mdm].[IdList]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE TYPE [mdm].[IdList] AS TABLE(
	[ID] [int] NULL
)
GO
/****** Object:  UserDefinedTableType [mdm].[MemberAttributes]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE TYPE [mdm].[MemberAttributes] AS TABLE(
	[MemberCode] [nvarchar](max) NULL,
	[MemberMUID] [uniqueidentifier] NULL,
	[AttributeName] [nvarchar](max) NULL,
	[AttributeValue] [nvarchar](max) NULL,
	[TransactionAnnotation] [nvarchar](max) NULL
)
GO
/****** Object:  UserDefinedTableType [mdm].[MemberAttributeValues]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE TYPE [mdm].[MemberAttributeValues] AS TABLE(
	[MemberRowID] [int] NULL,
	[AttributeID] [int] NULL,
	[AttributeValue] [nvarchar](max) NULL,
	[TransactionAnnotation] [nvarchar](max) NULL
)
GO
/****** Object:  UserDefinedTableType [mdm].[MemberCodes]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE TYPE [mdm].[MemberCodes] AS TABLE(
	[MemberCode] [nvarchar](max) NULL,
	[MemberName] [nvarchar](max) NULL,
	[HierarchyName] [nvarchar](max) NULL,
	[TransactionAnnotation] [nvarchar](max) NULL,
	[MUID] [uniqueidentifier] NULL
)
GO
/****** Object:  UserDefinedTableType [mdm].[MemberGetCriteria]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE TYPE [mdm].[MemberGetCriteria] AS TABLE(
	[ID] [int] NULL,
	[SchemaName] [sysname] NULL,
	[ObjectName] [sysname] NOT NULL,
	[Operator] [nvarchar](15) NOT NULL,
	[OperatorParameters] [nvarchar](max) NULL,
	[GroupId] [int] NOT NULL,
	[Value] [nvarchar](max) NULL
)
GO
/****** Object:  UserDefinedTableType [mdm].[MemberId]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE TYPE [mdm].[MemberId] AS TABLE(
	[ID] [int] NULL,
	[MemberType_ID] [tinyint] NULL,
	[Code] [nvarchar](250) NULL,
	[MUID] [uniqueidentifier] NULL
)
GO
/****** Object:  UserDefinedTableType [mdm].[MemberSaveList]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE TYPE [mdm].[MemberSaveList] AS TABLE(
	[RowID] [int] NOT NULL,
	[MemberCode] [nvarchar](max) NULL,
	[MemberName] [nvarchar](max) NULL,
	[MemberMUID] [uniqueidentifier] NULL,
	[TransactionAnnotation] [nvarchar](max) NULL,
	[RevisionID] [bigint] NULL,
	PRIMARY KEY CLUSTERED 
(
	[RowID] ASC
)WITH (IGNORE_DUP_KEY = OFF)
)
GO
/****** Object:  UserDefinedTableType [mdm].[Model]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE TYPE [mdm].[Model] AS TABLE(
	[Model_MUID] [uniqueidentifier] NULL,
	[ModelName] [nvarchar](50) NULL,
	[Description] [nvarchar](500) NULL,
	[LogRetentionDays] [smallint] NULL
)
GO
/****** Object:  UserDefinedTableType [mdm].[NotificationQueue]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE TYPE [mdm].[NotificationQueue] AS TABLE(
	[ID] [uniqueidentifier] NOT NULL,
	[NotificationType_ID] [int] NOT NULL,
	[NotificationSourceID] [int] NULL,
	[Version_ID] [int] NULL,
	[Model_ID] [int] NULL,
	[Entity_ID] [int] NULL,
	[Hierarchy_ID] [int] NULL,
	[Member_ID] [int] NULL,
	[MemberCode] [nvarchar](250) NULL,
	[MemberType_ID] [tinyint] NULL,
	[RuleConditionText] [nvarchar](max) NULL,
	[RuleActionText] [nvarchar](max) NOT NULL,
	[RuleElseActionText] [nvarchar](max) NOT NULL,
	[BRBusinessRule_ID] [int] NULL,
	[PriorityRank] [nvarchar](250) NULL,
	[EnterDTM] [datetime2](3) NOT NULL,
	[EnterUserID] [int] NOT NULL,
	[DueDTM] [datetime2](3) NULL,
	[SentDTM] [datetime2](3) NULL
)
GO
/****** Object:  UserDefinedTableType [mdm].[ParentChildId]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE TYPE [mdm].[ParentChildId] AS TABLE(
	[ParentId] [uniqueidentifier] NULL,
	[ChildId] [uniqueidentifier] NULL
)
GO
/****** Object:  UserDefinedTableType [mdm].[ScriptArgument]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE TYPE [mdm].[ScriptArgument] AS TABLE(
	[Name] [sysname] NOT NULL,
	[ArgumentType] [int] NOT NULL,
	[ArgumentValue] [nvarchar](999) NOT NULL,
	[ArgumentScript] [nvarchar](max) NOT NULL
)
GO
/****** Object:  UserDefinedTableType [mdm].[SecurityMemberProcessEvent]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE TYPE [mdm].[SecurityMemberProcessEvent] AS TABLE(
	[User_ID] [int] NULL,
	[Entity_ID] [int] NOT NULL,
	[Version_ID] [int] NOT NULL
)
GO
/****** Object:  UserDefinedTableType [mdm].[VersionFlag]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE TYPE [mdm].[VersionFlag] AS TABLE(
	[Model_MUID] [uniqueidentifier] NULL,
	[ModelName] [nvarchar](50) NULL,
	[VersionFlag_MUID] [uniqueidentifier] NULL,
	[VersionFlagName] [nvarchar](50) NULL,
	[Description] [nvarchar](500) NULL,
	[CommittedOnly_ID] [bit] NULL
)
GO
/****** Object:  UserDefinedFunction [mdm].[udfAttributeGetIDByName]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
	SELECT mdm.udfAttributeGetIDByName(NULL, NULL, NULL, NULL, NULL, NULL, 1, 0)  
	SELECT mdm.udfAttributeGetIDByName(NULL, 'Product', NULL, 'Product', NULL, 'ModelName', 1, 0)  
	SELECT mdm.udfAttributeGetIDByName('8CDCE317-B147-4AC2-B877-C780A33D241B', NULL, NULL, 'Product', NULL, 'ModelName', 1, 0)  
	SELECT mdm.udfAttributeGetIDByName(NULL, NULL, NULL, NULL, 'C6BC0705-6EAC-4329-935C-E4C48B472818', NULL, 1, 0)  
  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE FUNCTION [mdm].[udfAttributeGetIDByName]  
(  
	@Model_MUID				UNIQUEIDENTIFIER,  
	@Model_Name				NVARCHAR(50),  
	@Entity_MUID			UNIQUEIDENTIFIER,   
	@Entity_Name			NVARCHAR(50),  
	@Attribute_MUID			UNIQUEIDENTIFIER,   
	@Attribute_Name			NVARCHAR(100),  
	@MemberType_ID			TINYINT,  
    @IsSystem               BIT = 0  
)   
RETURNS INT  
/*WITH SCHEMABINDING*/  
AS BEGIN  
  
    DECLARE @Entity_ID INT,  
            @Attribute_ID INT;  
          
    SET @IsSystem = ISNULL(@IsSystem, 0);  
      
	IF (@Entity_Name IS NOT NULL OR @Entity_MUID IS NOT NULL)  
	BEGIN  
	    SELECT @Entity_ID = mdm.udfEntityGetIDByName(@Model_MUID, @Model_Name, @Entity_MUID, @Entity_Name)   
        SELECT @Entity_ID = ISNULL(@Entity_ID, -2);  
  
	    IF (@Entity_ID < 0) --Invalid Model ID or Entity ID  
            RETURN @Entity_ID;  
  
	    SET @Attribute_ID = ISNULL((SELECT ID FROM mdm.tblAttribute WHERE   
	        (@Attribute_MUID IS NULL OR MUID = @Attribute_MUID) AND (@Attribute_Name IS NULL OR [Name] = @Attribute_Name) AND (@Attribute_MUID IS NOT NULL OR @Attribute_Name IS NOT NULL)  
	        AND IsSystem = @IsSystem AND Entity_ID = @Entity_ID AND MemberType_ID = @MemberType_ID), -1);  
  
    END  
    ELSE  
	    SET @Attribute_ID = ISNULL((SELECT ID FROM mdm.tblAttribute WHERE   
	        @Attribute_MUID IS NOT NULL AND MUID = @Attribute_MUID AND IsSystem = @IsSystem), -1);  
      
	RETURN @Attribute_ID;  
END; --fn
GO
/****** Object:  UserDefinedFunction [mdm].[udfBusinessRuleAttributeMemberControllerNameGetByID]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
    SELECT mdm.udfBusinessRuleAttributeMemberControllerNameGetByID(32,1)  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE FUNCTION [mdm].[udfBusinessRuleAttributeMemberControllerNameGetByID]  
(  
    @Entity_ID      INT,  
    @EntityType_ID  TINYINT  
)   
RETURNS sysname  
/*WITH SCHEMABINDING*/  
AS BEGIN  
    DECLARE @ControllerName SYSNAME,  
            @ModelID INT,  
  
            @MemberType_Leaf            TINYINT = 1,  
            @MemberType_Consolidated    TINYINT = 2,  
            @MemberType_Collection      TINYINT = 3;  
  
    SELECT @ModelID = Model_ID FROM mdm.tblEntity WHERE ID = @Entity_ID;  
  
    SET @ControllerName = CONCAT(N'udp_SYSTEM_', @ModelID, N'_', @Entity_ID, N'_',  
        CASE @EntityType_ID  
            WHEN @MemberType_Leaf THEN N'CHILDATTRIBUTES'  
            WHEN @MemberType_Consolidated THEN N'PARENTATTRIBUTES'  
            WHEN @MemberType_Collection THEN N'COLLECTIONATTRIBUTES'  
        END, N'_ProcessRules')  
  
    RETURN @ControllerName;  
END --fn
GO
/****** Object:  UserDefinedFunction [mdm].[udfBusinessRuleGetBRItemAppliesToID]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    Returns the tblBRItemTypeAppliesTo.ID value that applies to the given item criteria  
*/  
CREATE FUNCTION [mdm].[udfBusinessRuleGetBRItemAppliesToID]  
(  
    @BRItemType_ID INT,     
    @BRItemCategory_ID INT, /* 1 = Condition, 2 = Then Action 3 = Else Action*/    
    @MemberType_ID TINYINT /* 1 = Leaf, 2 = Consolidated*/    
)     
RETURNS INT    
/*WITH SCHEMABINDING*/    
AS BEGIN    
    DECLARE @Result INT     
    SET @Result =     
       (SELECT TOP 1 AppliesTo_ID     
        FROM mdm.viw_SYSTEM_SCHEMA_BUSINESSRULE_ITEMTYPES     
        WHERE    
            ApplyToCategoryID = 2 AND /* 2 = "BRItemTypeCategory" */    
            BRSubTypeIsVisible = 1 AND    
            BRTypeID = @BRItemCategory_ID AND -- condition or action    
            BRItemType_ID = @BRItemType_ID AND	-- operation    
            BRItemType_ID IN    
            (    
                SELECT BRItemType_ID     
                FROM mdm.viw_SYSTEM_SCHEMA_BUSINESSRULE_ITEMTYPES     
                WHERE    
                    ApplyToCategoryID = 1 AND /*1 = "BRType"*/	    
                    BRSubTypeID = @MemberType_ID     
            )    
         ORDER BY AppliesTo_ID ASC    
       )    
    RETURN @Result    
END --fn
GO
/****** Object:  UserDefinedFunction [mdm].[udfBusinessRuleGetNewStatusID]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
SELECT mdm.udfBusinessRuleGetNewStatusID(1,0)  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE FUNCTION [mdm].[udfBusinessRuleGetNewStatusID]  
(  
	@Action_ID	INT,  
	@CurrentStatus_ID INT  
)   
RETURNS INT  
/*WITH SCHEMABINDING*/  
AS BEGIN  
	DECLARE @NewStatus_ID INT  
	  
	SELECT 	@NewStatus_ID = st.NewStatus_ID  
	FROM	mdm.tblBRStatusTransition st  
	WHERE	st.Action_ID = @Action_ID  
	AND		st.CurrentStatus_ID = @CurrentStatus_ID  
		  
	RETURN ISNULL(@NewStatus_ID, @CurrentStatus_ID)  
  
END --fn
GO
/****** Object:  UserDefinedFunction [mdm].[udfBusinessRuleIsItemTypeCompatible]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE FUNCTION [mdm].[udfBusinessRuleIsItemTypeCompatible]  
(  
    @AttributeType int,  
    @Datatype int,  
    @BRItemType_ID int  
)   
RETURNS BIT  
/*WITH SCHEMABINDING*/  
AS BEGIN  
  
    RETURN CASE WHEN EXISTS(  
        SELECT 1  
        FROM mdm.tblBRItemTypeAppliesTo a   
        INNER JOIN mdm.tblListRelationship l   
        ON  a.ApplyTo_ID = l.ID AND   
            l.ListRelationshipType_ID = 3 AND -- DataType  
            l.Parent_ID = @AttributeType AND   
            l.Child_ID = @Datatype AND  
            a.BRItemType_ID = @BRItemType_ID  
        )  
        THEN 1 ELSE 0 END;  
  
END --fn
GO
/****** Object:  UserDefinedFunction [mdm].[udfConvertCharListToTable]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE FUNCTION [mdm].[udfConvertCharListToTable]  
(  
	@List      NVARCHAR(MAX),  
    @Delimiter NCHAR(1) = N',',  
    @AreValuesQuoted bit = 0  
)  
RETURNS @tbl TABLE   
(  
	Ordinal int IDENTITY(1, 1) NOT NULL,  
    Value NVARCHAR(MAX) NOT NULL  
)   
/*WITH SCHEMABINDING*/  
AS  
BEGIN  
  
    DECLARE     @end                INT,  
                @start              INT,  
                @current            INT,  
                @chunkLength        INT,  
                @workingValue       NVARCHAR(MAX),  
                @remainingValue     NVARCHAR(MAX),  
                @parsedValue        NVARCHAR(MAX)  
  
    SET @current = 1  
    SET @remainingValue = CAST(N'' AS NVARCHAR(max))  
  
  
    WHILE @current <= DATALENGTH(@List) / 2  
    BEGIN  
        SET @chunkLength = 4000 - DATALENGTH(@remainingValue) / 2  
        SET @workingValue = @remainingValue + SUBSTRING(@List, @current, @chunkLength)  
        SET @current = @current + @chunkLength  
  
        SET @start = 0  
  
        SET @end = CHARINDEX(@Delimiter COLLATE database_default, @workingValue)  
  
  
        WHILE @end > 0  
  
        BEGIN  
  
            SET @parsedValue = LTRIM(RTRIM(SUBSTRING(@workingValue, @start + 1, @end - @start - 1)))  
            IF @AreValuesQuoted = 1  
                SET @parsedValue = SUBSTRING(@parsedValue,2,len(@parsedValue)-2)  
              
            INSERT @tbl (Value) VALUES(@parsedValue)  
  
            SET @start = @end  
  
            SET @end = CHARINDEX(@Delimiter COLLATE database_default, @workingValue, @start + 1)  
  
        END  
  
		SET @remainingValue = LTRIM(RTRIM(RIGHT(@workingValue, DATALENGTH(@workingValue) / 2 - @start)))  
        IF @AreValuesQuoted = 1  
			BEGIN  
				SET @remainingValue = SUBSTRING(@remainingValue, 2, len(@remainingValue)-2)  
			END  
  
    END  
  
    --insert the last piece of the string  
    INSERT @tbl(Value)  
          VALUES (LTRIM(RTRIM(@remainingValue)))  
    RETURN  
END
GO
/****** Object:  UserDefinedFunction [mdm].[udfConvertColumnListToTable]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
select * from mdm.udfConvertColumnListToTable('T.Name, T.AccountType, Operator as Op' )  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE FUNCTION [mdm].[udfConvertColumnListToTable]  
(  
	@List      NVARCHAR(MAX)   
)  
RETURNS @tbl TABLE   
(  
	Ordinal int IDENTITY(1, 1) NOT NULL,  
	SchemaName	sysname NULL,  
	ObjectName	sysname NOT NULL,  
    Alias		sysname NULL  
)   
/*WITH SCHEMABINDING*/              
AS  
BEGIN  
  
        DECLARE     @end            INT,  
                @start              INT,  
                @current            INT,  
                @chunkLength        INT,  
				@alias				sysname,  
                @workingValue       NVARCHAR(MAX),  
                @remainingValue     NVARCHAR(MAX),  
                @parsedValue        NVARCHAR(MAX),  
				@delimiter NCHAR(1),  
				@as nchar(4)   
				  
	SET @as = CAST(N' AS ' AS NVARCHAR(4))  
	SET @delimiter = N','  
    SET @current = 1  
    SET @remainingValue = CAST(N'' AS NVARCHAR(max))  
    IF @List IS NULL RETURN  
  
    WHILE @current <= DATALENGTH(@List) / 2  
    BEGIN  
        SET @chunkLength = 4000 - DATALENGTH(@remainingValue) / 2  
        SET @workingValue = @remainingValue + SUBSTRING(@List, @current, @chunkLength)  
        SET @current = @current + @chunkLength  
  
        SET @start = 0  
  
        SET @end = CHARINDEX(@delimiter COLLATE database_default, @workingValue)  
  
  
        WHILE @end > 0  
  
        BEGIN  
  
            SET @parsedValue = LTRIM(RTRIM(SUBSTRING(@workingValue, @start + 1, @end - @start - 1)))  
			SET @alias = NULL  
			IF CHARINDEX(@as, UPPER(@parsedValue)) <> 0  
				BEGIN  
				SET @alias = LTRIM(RTRIM(SUBSTRING(@parsedValue  
										,CHARINDEX(@as, UPPER(@parsedValue) ) + LEN(@as)  
										, LEN(@parsedValue) - CHARINDEX(@parsedValue, @as) + LEN(@as))))  
				--trailing spaces cause incorrect results for parsename!  
				SET @parsedValue = LTRIM(RTRIM(LEFT(@parsedValue, CHARINDEX(@as, UPPER(@parsedValue) ))))  
				  
				END              
  
            INSERT @tbl (SchemaName, ObjectName, Alias)   
			VALUES(LTRIM(RTRIM(PARSENAME(@parsedValue,2)))   
					,LTRIM(RTRIM(PARSENAME(@parsedValue, 1)))  
					,@alias  
					)  
            SET @start = @end  
  
            SET @end = CHARINDEX(@delimiter COLLATE database_default, @workingValue, @start + 1)  
  
        END  
  
        SET @remainingValue = RIGHT(@workingValue, DATALENGTH(@workingValue) / 2 - @start)  
		IF CHARINDEX(@as, UPPER(@remainingValue)) <> 0  
				BEGIN  
					SET @alias = LTRIM(RTRIM(SUBSTRING(@remainingValue  
										,CHARINDEX(@as, UPPER(@remainingValue) ) + LEN(@as)  
										, LEN(@remainingValue) - CHARINDEX(@remainingValue, @as) + LEN(@as))))  
				  
					--trailing spaces cause incorrect results for parsename!  
					SET @remainingValue = LTRIM(RTRIM(LEFT(@remainingValue, CHARINDEX(@as, UPPER(@remainingValue) ))))  
				  
				END              
    END  
  
    --insert the last piece of the string  
    INSERT @tbl(SchemaName, ObjectName, Alias)  
          VALUES (LTRIM(RTRIM(PARSENAME(@remainingValue,2)))   
					,LTRIM(RTRIM(PARSENAME(@remainingValue, 1) ))  
					,@alias  
					)  
    RETURN  
END
GO
/****** Object:  UserDefinedFunction [mdm].[udfDBErrorsGetMessageByIDLanguage]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
  
Assumptions:  
        1) Assume that ONLY values to be subtituted are marked with a % followed by a number as %1, %2 etc..  
        2) Assume the values are incremental and not higher than 9  
          
  
select mdm.udfDBErrorsGetMessageByIDLanguage(500001, 1036, NULL)  
  
  
*/  
/*==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE function [mdm].[udfDBErrorsGetMessageByIDLanguage]  
(  
   @ID				INT,  
   @Language_ID		INT,  
   @Values          NVARCHAR(4000) = NULL   
)  
RETURNS NVARCHAR(4000)  
/*WITH SCHEMABINDING*/  
AS BEGIN  
      
    DECLARE @Message NVARCHAR(4000),  
            @ReplaceValue NVARCHAR(4000),  
            @MessageIndex INT,  
            @ValuesIndex INT,  
			@Count	INT;  
      
    IF @Language_ID = 0 SET @Language_ID = 1033   
	SELECT @Message = [Text]  
	FROM mdm.tblDBErrors e  
	WHERE e.ID = @ID   
		AND e.Language_ID = @Language_ID;  
  
    IF @Values IS NULL SET @Values = CAST(N'' AS NVARCHAR(4000));  
    IF @Message IS NULL SET @Message = CAST(N'Message not found in error table' AS NVARCHAR(4000));  
      
  /* Assumptions:  
        1) Assume that ONLY values to be subtituted are marked with a % followed by a number as %1, %2 etc..  
        2) Assume the values are incremental and not higher than 9  
    */   
    SET @MessageIndex = CHARINDEX('%', @Message);  
   --Get the first value to be substituted  
   SET @ValuesIndex = CHARINDEX('%', @Values);  
  
    SET @Count = 0  
      
    WHILE (@MessageIndex > 0 AND @ValuesIndex > 0 AND @Count < 10)  
    BEGIN  
         
		--keep track of how many values we are replacing  
		SET @Count = @Count + 1    
  
		--get the value to replace with  
		SET @ReplaceValue = SUBSTRING(@Values, 1, @ValuesIndex - 1);  
  
		-- Perform the substitution  
		SET @Message = REPLACE(@Message, SUBSTRING(@Message, @MessageIndex , 2), @ReplaceValue);  
  
		-- Remove the substituted value  
		SET @Values =  SUBSTRING(@Values, @ValuesIndex + 1, LEN(@Values) - @ValuesIndex)      
  
		--Get the next value to be substituted  
		SET @MessageIndex = CHARINDEX('%', @Message);  
		SET @ValuesIndex = CHARINDEX('%', @Values);  
	  
    END;  
      
	--Perform the last replacement  
	IF @MessageIndex > 0 AND @ValuesIndex = 0 AND LEN(@Values) > 0  
       SET @Message = REPLACE(@Message, SUBSTRING(@Message, @MessageIndex, 2), @Values);  
  
	RETURN @Message;  
    	  
END
GO
/****** Object:  UserDefinedFunction [mdm].[udfDBObjectExist]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
	SELECT mdm.udfDBObjectExist('tblEntity', 'T')  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE FUNCTION [mdm].[udfDBObjectExist]  
(  
	@DBObjectName	sysname,  
	@DBObjectType	NCHAR(1)  
)   
RETURNS BIT  
/*WITH*/  
AS BEGIN  
	SET @DBObjectType = UPPER(@DBObjectType);  
	  
	IF @DBObjectType = N'P' BEGIN  
		IF EXISTS(  
			SELECT	1  
			FROM	INFORMATION_SCHEMA.ROUTINES  
			WHERE	ROUTINE_SCHEMA = N'mdm'  
			AND ROUTINE_NAME = @DBObjectName  
			AND	ROUTINE_TYPE = N'PROCEDURE'  
			AND	SPECIFIC_CATALOG = DB_NAME()  
		) RETURN 1;  
	  
	END ELSE IF @DBObjectType = N'F' BEGIN  
		IF EXISTS(  
			SELECT	1  
			FROM	INFORMATION_SCHEMA.ROUTINES  
			WHERE	ROUTINE_SCHEMA = N'mdm'  
			AND ROUTINE_NAME = @DBObjectName  
			AND	ROUTINE_TYPE = N'FUNCTION'  
			AND	SPECIFIC_CATALOG = DB_NAME()  
		) RETURN 1;  
  
	END ELSE IF @DBObjectType = N'T' BEGIN  
		IF EXISTS(  
			SELECT 	1  
			FROM	INFORMATION_SCHEMA.TABLES  
			WHERE	TABLE_NAME = @DBObjectName  
			AND TABLE_SCHEMA = N'mdm'  
			AND	TABLE_TYPE = N'BASE TABLE'  
			AND	TABLE_CATALOG = DB_NAME()  
		) RETURN 1;  
  
	END ELSE IF @DBObjectType = N'V' BEGIN  
		IF EXISTS(  
			SELECT 	1  
			FROM	INFORMATION_SCHEMA.TABLES  
			WHERE	TABLE_NAME = @DBObjectName  
			AND TABLE_SCHEMA = N'mdm'  
			AND	TABLE_TYPE = N'VIEW'  
			AND	TABLE_CATALOG = DB_NAME()  
		) RETURN 1;  
  
	END; --if  
	  
	RETURN 0;  
END --fn
GO
/****** Object:  UserDefinedFunction [mdm].[udfEntityGetIDByName]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
	SELECT mdm.udfEntityGetIDByName(NULL, 'Product', NULL, 'Product')  
  
	SELECT mdm.udfEntityGetIDByName(NULL, 'Account', '65DC94B4-FD16-4FB8-9440-43DB0E14F6A4', 'Product')  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE FUNCTION [mdm].[udfEntityGetIDByName]  
(  
	@Model_MUID				UNIQUEIDENTIFIER,  
	@Model_Name				NVARCHAR(50),  
	@Entity_MUID			UNIQUEIDENTIFIER,   
	@Entity_Name			NVARCHAR(50)  
)   
RETURNS INT  
/*WITH SCHEMABINDING*/  
AS BEGIN  
  
    DECLARE @Model_ID INT,  
            @Entity_ID INT;  
          
      
	IF (@Model_Name IS NOT NULL OR @Model_MUID IS NOT NULL)   
	BEGIN  
  
		SELECT @Model_ID = mdm.udfModelGetIDByName(@Model_MUID, @Model_Name)   
  
		IF (@Model_ID IS NULL) --Invalid Model ID  
        BEGIN  
	        RETURN -3;  
              
        END  
  
	    SET @Entity_ID = ISNULL((SELECT ID FROM mdm.tblEntity WHERE   
	        (@Entity_MUID IS NULL OR MUID = @Entity_MUID) AND (@Entity_Name IS NULL OR [Name] = @Entity_Name) AND (@Entity_MUID IS NOT NULL OR @Entity_Name IS NOT NULL)  
	        AND Model_ID = @Model_ID),-2);  
    END  
    ELSE  
	        SET @Entity_ID = ISNULL((SELECT ID FROM mdm.tblEntity WHERE   
                @Entity_MUID IS NOT NULL AND MUID = @Entity_MUID), -1);  
  
  
	RETURN @Entity_ID;  
END; --fn
GO
/****** Object:  UserDefinedFunction [mdm].[udfFileIDReferencesGetSQL]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
Gets a dynamic SQL query string that when executed gets the IDs of all File attribute values (tblFile.ID) that are referenced by the given entity.   
*/  
CREATE FUNCTION [mdm].[udfFileIDReferencesGetSQL]  
(  
     @Entity_ID              INT  
    ,@MemberType_ID          TINYINT = NULL -- When null, all member types in entity will be included  
    ,@FileAttribute_ID       INT = NULL -- When null, all File attributes in the entity will be included  
    ,@SoftDeletedMembersOnly BIT = 0 -- Set to 1 to only look at soft-deleted members.  
)  
RETURNS NVARCHAR(MAX)  
/*WITH SCHEMABINDING*/  
AS  
BEGIN  
  
    DECLARE   
         @AttributeType_File        TINYINT = 4  
  
        ,@MemberType_Leaf           TINYINT = 1  
        ,@MemberType_Consolidated   TINYINT = 2  
        ,@MemberType_Collection     TINYINT = 3  
  
        ,@Status_Deactivated        TINYINT = 2  
  
        ,@SQL                       NVARCHAR(MAX) = N'';  
  
    WITH attributeInfoCte AS  
    (  
        SELECT  
             a.ID  
            ,a.TableColumn  
            ,CASE a.MemberType_ID  
                WHEN @MemberType_Leaf THEN e.EntityTable  
                WHEN @MemberType_Consolidated THEN e.HierarchyParentTable  
                WHEN @MemberType_Collection THEN e.CollectionTable   
                END AS TableName  
        FROM mdm.tblAttribute a  
        INNER JOIN mdm.tblEntity e  
        ON a.Entity_ID = e.ID  
        WHERE a.Entity_ID           = @Entity_ID  
            AND a.ID                = ISNULL(@FileAttribute_ID, a.ID)  
            AND a.AttributeType_ID  = @AttributeType_File  
    )  
    SELECT @SQL += CONCAT(CASE WHEN LEN(@SQL) > 0 THEN N'  
UNION ALL' END, N'  
SELECT ', QUOTENAME(TableColumn), N' ID  
FROM mdm.', QUOTENAME(TableName), N'  
WHERE   ', QUOTENAME(TableColumn), N' IS NOT NULL',   
    CASE WHEN @SoftDeletedMembersOnly = 1 THEN CONCAT(N'  
    AND Status_ID = ', @Status_Deactivated) END)  
    FROM attributeInfoCte;  
  
    RETURN @SQL  
END
GO
/****** Object:  UserDefinedFunction [mdm].[udfGetHistoryOutputQuery]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
SELECT mdm.udfGetHistoryOutputQuery(27, 1, NULL, NULL)  
SELECT mdm.udfGetHistoryOutputQuery(27, 2, NULL, NULL)  
SELECT mdm.udfGetHistoryOutputQuery(27, 3, NULL, NULL)  
SELECT mdm.udfGetHistoryOutputQuery(27, 4, NULL, NULL)  
SELECT mdm.udfGetHistoryOutputQuery(27, 5, NULL, NULL)  
*/  
CREATE FUNCTION [mdm].[udfGetHistoryOutputQuery]  
(  
    @Entity_ID      INT,  
    @MemberType_ID  TINYINT,  
    @User_ID        NVARCHAR(MAX) = NULL,  
    @LastChgDTM     NVARCHAR(MAX) = NULL  
)  
RETURNS NVARCHAR(MAX)  
/*WITH SCHEMABINDING*/  
AS BEGIN  
    DECLARE @SQL                            NVARCHAR(MAX) = N'',  
            @HistoryTable                   SYSNAME,  
            @IsHierarchyEnabled             BIT,  
            @MemberType_Leaf                TINYINT = 1,  
            @MemberType_Consolidated        TINYINT = 2,  
            @MemberType_Collection          TINYINT = 3,  
            @MemberType_Hierarchy           TINYINT = 4,  
            @MemberType_CollectionMember    TINYINT = 5;  
  
    SET @User_ID = COALESCE(@User_ID, N'INSERTED.[LastChgUserID]');  
    SET @LastChgDTM = COALESCE(@LastChgDTM, N'INSERTED.[LastChgDTM]');  
  
    SELECT @HistoryTable =  
        CASE @MemberType_ID  
            WHEN @MemberType_Leaf THEN EntityTable   
            WHEN @MemberType_Consolidated THEN HierarchyParentTable   
            WHEN @MemberType_Collection THEN CollectionTable   
            WHEN @MemberType_Hierarchy THEN HierarchyTable   
            WHEN @MemberType_CollectionMember THEN CollectionMemberTable  
            ELSE NULL  
        END,  
        @IsHierarchyEnabled = CASE WHEN HierarchyParentTable IS NOT NULL THEN 1 ELSE 0 END  
    FROM mdm.tblEntity   
    WHERE ID = @Entity_ID;  
  
    IF @HistoryTable IS NULL  
    BEGIN  
        RETURN @SQL;  
    END  
  
    SET @HistoryTable = QUOTENAME(@HistoryTable + N'_HS');  
  
    IF (@MemberType_ID = @MemberType_Leaf OR @MemberType_ID = @MemberType_Consolidated OR @MemberType_ID = @MemberType_Collection)  
    BEGIN  
        DECLARE @OutputColumns NVARCHAR(MAX) = CONCAT(N'  
        OUTPUT DELETED.[Version_ID]  
            , DELETED.[LastChgTS]  
            , DELETED.[ID]',  
            CASE @MemberType_ID   
                WHEN @MemberType_Leaf THEN N''  
                WHEN @MemberType_Consolidated THEN N'  
            , DELETED.[Hierarchy_ID]'   
                WHEN @MemberType_Collection THEN N'  
            , DELETED.[Owner_ID]  
            , DELETED.[Description]'  
            END,  
            N'  
            , DELETED.[Status_ID]  
            , DELETED.[Name]  
            , DELETED.[Code]  
            , DELETED.[MUID]  
            , DELETED.[LastChgDTM]  
            , DELETED.[LastChgUserID]  
            , ', @LastChgDTM, N'  
            , ', @User_ID),  
            @InputColumns NVARCHAR(MAX) = CONCAT(N'  
              [Version_ID]  
            , [ID]',   
            CASE @MemberType_ID   
                WHEN @MemberType_Leaf THEN N'  
            , [EN_ID]'   
                WHEN @MemberType_Consolidated THEN N'  
            , [HP_ID]  
            , [Hierarchy_ID]'   
                WHEN @MemberType_Collection THEN N'  
            , [CN_ID]  
            , [Owner_ID]  
            , [Description]'  
            END,  
            N'  
            , [Status_ID]  
            , [Name]  
            , [Code]  
            , [MUID]  
            , [EnterDTM]  
            , [EnterUserID]  
            , [LastChgDTM]  
            , [LastChgUserID]');  
  
        SELECT  @OutputColumns += CONCAT(N'  
            , DELETED.' , QUOTENAME(TableColumn)),  
                @InputColumns +=  CONCAT(N'  
            , ' , QUOTENAME(TableColumn))  
        FROM mdm.tblAttribute  
        WHERE [Entity_ID] = @Entity_ID AND MemberType_ID = @MemberType_ID AND IsSystem <> 1  
  
        SET @SQL = CONCAT(@OutputColumns, N'  
        INTO [mdm].', @HistoryTable, N'(', @InputColumns, N'  
        )');  
    END  
    ELSE IF @MemberType_ID = @MemberType_Hierarchy  
    BEGIN  
        SET @SQL = CONCAT(N'  
        OUTPUT DELETED.[Version_ID]  
            , DELETED.[LastChgTS]  
            , DELETED.[ID]  
            , DELETED.[Status_ID]  
            , DELETED.[Hierarchy_ID]  
            , DELETED.[Parent_HP_ID]  
            , DELETED.[ChildType_ID]  
            , DELETED.[Child_EN_ID]  
            , DELETED.[Child_HP_ID]  
            , DELETED.[SortOrder]  
            , DELETED.[LevelNumber]  
            , DELETED.[LastChgDTM]  
            , DELETED.[LastChgUserID]  
            , ', @LastChgDTM, N'  
            , ', @User_ID, N'  
            , DELETED.[MUID]  
        INTO [mdm].', @HistoryTable ,N'(  
            [Version_ID]  
            ,[ID]  
            ,[HR_ID]  
            ,[Status_ID]  
            ,[Hierarchy_ID]  
            ,[Parent_HP_ID]  
            ,[ChildType_ID]  
            ,[Child_EN_ID]  
            ,[Child_HP_ID]  
            ,[SortOrder]  
            ,[LevelNumber]  
            ,[EnterDTM]  
            ,[EnterUserID]  
            ,[LastChgDTM]  
            ,[LastChgUserID]  
            ,[MUID]  
        )  
');  
    END  
    ELSE  
    BEGIN  
        SET @SQL = CONCAT(N'  
        OUTPUT DELETED.[Version_ID]  
            , DELETED.[LastChgTS]  
            , DELETED.[ID]  
            , DELETED.[Status_ID]  
            , DELETED.[Parent_CN_ID]  
            , DELETED.[ChildType_ID]  
            , DELETED.[Child_EN_ID]',  
            CASE @IsHierarchyEnabled   
                WHEN 1 THEN N'  
            , DELETED.[Child_HP_ID]'   
                ELSE N''  
            END,  
            N'  
            , DELETED.[Child_CN_ID]  
            , DELETED.[SortOrder]  
            , DELETED.[Weight]  
            , DELETED.[LastChgDTM]  
            , DELETED.[LastChgUserID]  
            , ', @LastChgDTM, N'  
            , ', @User_ID, N'  
            , DELETED.[MUID]  
        INTO [mdm].', @HistoryTable ,N'(  
              [Version_ID]  
            , [ID]  
            , [CM_ID]  
            , [Status_ID]  
            , [Parent_CN_ID]  
            , [ChildType_ID]  
            , [Child_EN_ID]',  
            CASE @IsHierarchyEnabled   
                WHEN 1 THEN N'  
            , [Child_HP_ID]'  
                ELSE N''  
            END,  
            N'        
            , [Child_CN_ID]  
            , [SortOrder]  
            , [Weight]  
            , [EnterDTM]  
            , [EnterUserID]  
            , [LastChgDTM]  
            , [LastChgUserID]  
            , [MUID]  
        )  
');  
    END  
  
    RETURN @SQL;  
END; --fn
GO
/****** Object:  UserDefinedFunction [mdm].[udfGetIndexOptions]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE FUNCTION [mdm].[udfGetIndexOptions]  
(  
    @dataCompression    TINYINT,  
    @modelId            INT = NULL  
)  
RETURNS NVARCHAR(MAX)  
/*WITH SCHEMABINDING*/  
AS BEGIN  
    DECLARE @dataCompressionOption    NVARCHAR(MAX) = N'NONE',  
            @fillFactor               INT,  
            @indexOptions             NVARCHAR(MAX);  
  
    IF mdm.udfIsEnterpriseEdition() = 1  
    BEGIN  
        SET @dataCompressionOption = CASE @dataCompression WHEN 1 THEN N'ROW' WHEN 2 THEN N'PAGE' ELSE N'NONE' END;  
    END  
    SET @fillFactor = CONVERT(INT, mdm.udfSystemSettingGet(N'IndexFillFactor'));  
    -- Default fill factor 80.  
    IF @fillFactor IS NULL OR @fillFactor <= 0 OR @fillFactor > 100 SET @fillFactor = 80  
    SET @indexOptions = CONCAT(N'WITH (DATA_COMPRESSION = ', @dataCompressionOption, N', FILLFACTOR = ', CAST(@fillFactor AS NVARCHAR(3)) , N')');  
  
    IF mdm.udfIsEnterpriseEdition() = 1 AND @modelId IS NOT NULL  
    BEGIN  
        SET @indexOptions = CONCAT(@indexOptions, N' ON udpsModel_', @modelId, N'([Version_ID])');  
    END  
    RETURN @indexOptions;  
END; --fn
GO
/****** Object:  UserDefinedFunction [mdm].[udfGetLatestDBUpgradeVersion]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
	SELECT mdm.udfGetHighestDBVersion()  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE FUNCTION [mdm].[udfGetLatestDBUpgradeVersion]()   
RETURNS INT  
/*WITH*/  
AS BEGIN  
    DECLARE @DBVersion INT;  
         
    SELECT TOP(1) @DBVersion = DBVersion  
    FROM mdm.tblDBUpgradeHistory   
    ORDER BY DBVersion DESC;  
      
    --Do not return null if no upgrades exist. Return zero  
    SELECT @DBVersion = ISNULL(@DBVersion, 0)  
  
    RETURN @DBVersion;  
END --fn
GO
/****** Object:  UserDefinedFunction [mdm].[udfGetStringOccurrenceCount]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
Returns the number of times that @SearchString appears in @InputString  
  
DECLARE   
     @InputString NVARCHAR(MAX) = '35/31/34/33/32/31'  
    ,@SearchString NVARCHAR(100) = '31';  
  
SELECT   
    @InputString AS InputString,  
    LEN(@InputString) AS [Len Input String],  
    REPLACE(@InputString, @SearchString, '') AS [InputString Replace],  
    LEN(REPLACE(@InputString, @SearchString, '')) AS [Len InputString Replace],  
    @SearchString AS SearchString,  
    LEN(@SearchString) AS [Len SearchString],  
    (LEN(@InputString) - LEN(REPLACE(@InputString, @SearchString, ''))) AS [Len Diff],  
    (LEN(@InputString) - LEN(REPLACE(@InputString, @SearchString, ''))) / LEN(@SearchString) AS [Len Diff / Len SearchString]  
  
SELECT mdm.udfGetStringOccurrenceCount(@InputString, @SearchString);  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE FUNCTION [mdm].[udfGetStringOccurrenceCount]  
(   
    @InputString  NVARCHAR(MAX),   
    @SearchString NVARCHAR(100)   
)  
RETURNS INT  
BEGIN  
  
    RETURN (LEN(@InputString) - LEN(REPLACE(@InputString, @SearchString, N''))) / LEN(@SearchString)  
  
END
GO
/****** Object:  UserDefinedFunction [mdm].[udfGetTableOptions]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE FUNCTION [mdm].[udfGetTableOptions]  
(  
    @dataCompression    TINYINT,  
    @modelId            INT = NULL  
)  
RETURNS NVARCHAR(MAX)  
/*WITH SCHEMABINDING*/  
AS BEGIN  
    DECLARE @dataCompressionOption    NVARCHAR(MAX) = N'NONE',  
            @tableOptions             NVARCHAR(MAX) = N'';  
  
    IF mdm.udfIsEnterpriseEdition() = 1 AND @modelId IS NOT NULL  
    BEGIN  
        SET @tableOptions = CONCAT(N' ON udpsModel_', @modelId, N'([Version_ID])');  
    END  
  
    IF mdm.udfIsEnterpriseEdition() = 1  
    BEGIN  
        SET @dataCompressionOption = CASE @dataCompression WHEN 1 THEN N'ROW' WHEN 2 THEN N'PAGE' ELSE N'NONE' END;  
    END  
    SET @tableOptions = CONCAT(@tableOptions, N' WITH (DATA_COMPRESSION = ', @dataCompressionOption, N')');  
  
    RETURN @tableOptions;  
END; --fn
GO
/****** Object:  UserDefinedFunction [mdm].[udfGetTransactionAnnotationTableName]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
	SELECT mdm.udfGetTransactionAnnotationTableName(7)  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE FUNCTION [mdm].[udfGetTransactionAnnotationTableName]  
(  
	@Model_ID   INT  
)   
RETURNS sysname  
/*WITH SCHEMABINDING*/  
AS BEGIN  
  
	RETURN CONCAT(N'tbl_', @Model_ID, N'_AN');  
  
END; --fn
GO
/****** Object:  UserDefinedFunction [mdm].[udfGetTransactionAnnotationViewName]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
    SELECT mdm.udfGetTransactionAnnotationViewName(7)  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE FUNCTION [mdm].[udfGetTransactionAnnotationViewName]  
(  
    @Model_ID   INT  
)   
RETURNS sysname  
/*WITH SCHEMABINDING*/  
AS BEGIN  
  
    RETURN CONCAT(N'viw_SYSTEM_', @Model_ID, N'_TRANSACTIONS_ANNOTATIONS');  
  
END; --fn
GO
/****** Object:  UserDefinedFunction [mdm].[udfGetTransactionTableName]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
    SELECT mdm.udfGetTransactionTableName(7)  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE FUNCTION [mdm].[udfGetTransactionTableName]  
(  
    @Model_ID   INT  
)   
RETURNS sysname  
/*WITH SCHEMABINDING*/  
AS BEGIN  
  
    RETURN CONCAT(N'tbl_', @Model_ID, N'_TR');  
  
END; --fn
GO
/****** Object:  UserDefinedFunction [mdm].[udfGetTransactionViewName]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
    SELECT mdm.udfGetTransactionViewName(7)  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE FUNCTION [mdm].[udfGetTransactionViewName]  
(  
    @Model_ID   INT  
)   
RETURNS sysname  
/*WITH SCHEMABINDING*/  
AS BEGIN  
  
    RETURN CONCAT(N'viw_SYSTEM_', @Model_ID, N'_TRANSACTIONS');  
  
END; --fn
GO
/****** Object:  UserDefinedFunction [mdm].[udfGetUserValidationViewName]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
    SELECT mdm.udfGetUserValidationViewName(7)  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE FUNCTION [mdm].[udfGetUserValidationViewName]  
(  
    @Model_ID   INT  
)   
RETURNS sysname  
/*WITH SCHEMABINDING*/  
AS BEGIN  
  
    RETURN CONCAT(N'viw_SYSTEM_', @Model_ID, N'_USER_VALIDATION');  
  
END; --fn
GO
/****** Object:  UserDefinedFunction [mdm].[udfGetValidationLogTableName]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
    SELECT mdm.udfGetValidationLogTableName(7)  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE FUNCTION [mdm].[udfGetValidationLogTableName]  
(  
    @Model_ID   INT  
)   
RETURNS sysname  
/*WITH SCHEMABINDING*/  
AS BEGIN  
  
    RETURN CONCAT(N'tbl_', @Model_ID, N'_VL');  
  
END; --fn
GO
/****** Object:  UserDefinedFunction [mdm].[udfGetValidationLogViewName]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
 SELECT mdm.udfGetValidationLogViewName(7)  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE FUNCTION [mdm].[udfGetValidationLogViewName]  
(  
 @Model_ID   INT  
)   
RETURNS sysname  
/*WITH SCHEMABINDING*/  
AS BEGIN  
  
    RETURN CONCAT(N'viw_SYSTEM_', @Model_ID, N'_ISSUE_VALIDATION');  
  
END; --fn
GO
/****** Object:  UserDefinedFunction [mdm].[udfHierarchyGetIDByName]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
	SELECT mdm.udfHierarchyGetIDByName(NULL, 'Metadata', NULL, 'Attribute Metadata Definition', NULL, 'Main')  
	SELECT mdm.udfHierarchyGetIDByName(NULL, 'Product', NULL, 'Product', '6AB728F2-90B1-429A-ADBE-87CA045B287D', NULL)  
  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE FUNCTION [mdm].[udfHierarchyGetIDByName]  
(  
	@Model_MUID				UNIQUEIDENTIFIER,  
	@Model_Name				NVARCHAR(50),  
	@Entity_MUID			UNIQUEIDENTIFIER,   
	@Entity_Name			NVARCHAR(50),  
	@Hierarchy_MUID			UNIQUEIDENTIFIER,   
	@Hierarchy_Name			NVARCHAR(50)  
)   
RETURNS INT  
/*WITH SCHEMABINDING*/  
AS BEGIN  
  
    DECLARE @Entity_ID INT,  
            @Hierarchy_ID INT;  
          
	IF (@Entity_Name IS NOT NULL OR @Entity_MUID IS NOT NULL)  
	BEGIN  
	    SELECT @Entity_ID = mdm.udfEntityGetIDByName(@Model_MUID, @Model_Name, @Entity_MUID, @Entity_Name)   
        SELECT @Entity_ID = ISNULL(@Entity_ID, -2);  
  
	    IF (@Entity_ID < 0) --Invalid Model ID or Entity ID  
            RETURN @Entity_ID;  
  
	    SET @Hierarchy_ID = ISNULL((SELECT ID FROM mdm.tblHierarchy WHERE   
	        (@Hierarchy_MUID IS NULL OR MUID = @Hierarchy_MUID) AND (@Hierarchy_Name IS NULL OR [Name] = @Hierarchy_Name) AND (@Hierarchy_MUID IS NOT NULL OR @Hierarchy_Name IS NOT NULL)  
	        AND Entity_ID = @Entity_ID),-1);  
  
    END  
    ELSE  
	     SET @Hierarchy_ID = ISNULL((SELECT ID FROM mdm.tblHierarchy WHERE   
         @Hierarchy_MUID IS NOT NULL AND MUID = @Hierarchy_MUID), -1);  
  
	RETURN @Hierarchy_ID;  
END; --fn
GO
/****** Object:  UserDefinedFunction [mdm].[udfIsEnterpriseEdition]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE FUNCTION [mdm].[udfIsEnterpriseEdition]()  
RETURNS BIT  
/*WITH SCHEMABINDING*/  
AS BEGIN  
    DECLARE @Ret BIT;  
    SELECT @Ret = CASE CHARINDEX(N'Business',CONVERT(NVARCHAR(128), SERVERPROPERTY ('Edition'))) WHEN 0 THEN 1 ELSE 0 END;  
    RETURN @Ret;  
END; --fn
GO
/****** Object:  UserDefinedFunction [mdm].[udfIsValidListOptionID]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
	SELECT mdm.udfIsValidListOptionID('lstAuthenticationMode', 1, NULL)  
	SELECT mdm.udfIsValidListOptionID('lstAuthenticationMode', 5, NULL)  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE FUNCTION [mdm].[udfIsValidListOptionID]  
(  
    @ListCode   NVARCHAR(50),  
    @OptionID   INT,  
    @Group_ID   INT  
)   
RETURNS BIT  
/*WITH SCHEMABINDING*/  
AS BEGIN  
	  
	IF EXISTS(  
	        SELECT  
	           ID  
			  ,ListCode  
			  ,ListName  
			  ,Seq  
			  ,ListOption  
			  ,OptionID  
			  ,IsVisible  
			  ,Group_ID  
	        FROM  
	           mdm.tblList  
	        WHERE  
	           ListCode = @ListCode AND  
	           OptionID = @OptionID AND  
	           Group_ID = ISNULL(@Group_ID, Group_ID)   
		) RETURN 1;  
	  
	RETURN 0;  
END --fn
GO
/****** Object:  UserDefinedFunction [mdm].[udfItemReservedWordCheck]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
Date:      : Monday, June 12, 2006  
Function   : mdm.udfItemReservedWordCheck  
Component  : All  
Description: mdm.udfItemReservedWordCheck verifies an input value against a list of reserved MDS words for a specific object type  
Parameters : Object type; Value (to be verified)   
Return     : Boolean (0 = passes verification; 1 = fails verification)  
Example 1  : SELECT mdm.udfItemReservedWordCheck(3, 'Code')   --1 = Fails verification (reserved word)  
Example 2  : SELECT mdm.udfItemReservedWordCheck(4, 'Status') --1 = Fails verification (reserved word)  
Example 3  : SELECT mdm.udfItemReservedWordCheck(3, 'Test')   --0 = Passes verification (not a reserved word)  
Example 4  : SELECT mdm.udfItemReservedWordCheck(12, 'Root')  --1 = Fails verification (reserved word)  
*/  
CREATE FUNCTION [mdm].[udfItemReservedWordCheck] (@ObjectType_ID INT, @Code NVARCHAR(250))   
RETURNS BIT  
/*WITH SCHEMABINDING*/  
AS BEGIN   
    -- First check for TABS , CR and LF characters  
    SET @Code = REPLACE(REPLACE(REPLACE(@Code, CHAR(9),''), CHAR(13), '') , CHAR(10), '')  
      
    -- Trim all leading and trailing spaces  
   SET @Code = LTRIM(RTRIM(@Code))     
   RETURN  
      CASE  
         WHEN UPPER(@Code) IN (SELECT UPPER(ReservedWord) FROM mdm.udfItemReservedWordsGet(@ObjectType_ID))  
         THEN 1  
         ELSE 0  
      END   
END --fn
GO
/****** Object:  UserDefinedFunction [mdm].[udfItemReservedWordsGet]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
Gets a table containing all reserved words for the given object type.  
  
*/  
CREATE FUNCTION [mdm].[udfItemReservedWordsGet] (@ObjectType_ID INT)   
RETURNS @ReservedWords TABLE (ReservedWord NVARCHAR(250) PRIMARY KEY)  
/*WITH SCHEMABINDING*/  
AS BEGIN   
    IF @ObjectType_ID IN (3, 4) --3=Entity; 4=Attribute  
    BEGIN  
        INSERT INTO @ReservedWords   
        VALUES  
            (N'ID'),   
            (N'Code'),   
            (N'Name'),   
            (N'EnterDTM'),   
            (N'EnterUserID'),   
            (N'LastChgDTM'),   
            (N'LastChgUserID'),  
            (N'Status'),   
            (N'Status_ID'),   
            (N'ValidationStatus_ID'),  
            (N'MDMMemberStatus'),  
            (N'ValidationStatus'),  
            (N'EnterDateTime'),  
            (N'EnterUserName'),  
            (N'LastChgDateTime'),  
            (N'LastChgUserName');  
    END ELSE  
    IF @ObjectType_ID IN (12, 13, 14) --12=Leaf member; 13=Consolidated member; 14=Collection member  
    BEGIN  
        INSERT INTO @ReservedWords   
        VALUES  
            (N'ROOT'),   
            (N'MDMUNUSED'),   
            (N'MDMMemberStatus');  
    END;   
    RETURN;  
END;
GO
/****** Object:  UserDefinedFunction [mdm].[udfListCodeIDGetByName]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
SELECT mdm.udfListCodeIDGetByName('lstVersionStatus', 'Leaf')  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE FUNCTION [mdm].[udfListCodeIDGetByName]  
(  
	@ListCode NVARCHAR(50),  
	@ListOption NVARCHAR(250)  
)   
RETURNS INT  
/*WITH SCHEMABINDING*/  
AS BEGIN  
	DECLARE @ListCodeID INT  
		  
	SELECT	@ListCodeID = OptionID   
	FROM 	mdm.tblList   
	WHERE 	ListCode = @ListCode  
	AND 	ListOption = @ListOption  
		  
	RETURN @ListCodeID	     
  
END --fn
GO
/****** Object:  UserDefinedFunction [mdm].[udfLocalizedStringGet]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
	DECLARE @LocalizedEmailSubject		NVARCHAR(MAX) = N'MDS Notification';  
	SELECT @LocalizedEmailSubject = mdm.udfLocalizedStringGet(N'NotificationSubject', 1033, @LocalizedEmailSubject);  
	SELECT @LocalizedEmailSubject;  
	  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE FUNCTION [mdm].[udfLocalizedStringGet]  
(  
	 @ResourceName		 	NVARCHAR(100)  
	,@CurrentLanguageCode	INT = 1033   
	,@DefaultValue			NVARCHAR(MAX) = N''  
)   
RETURNS NVARCHAR(MAX)  
/*WITH SCHEMABINDING*/  
AS BEGIN  
  
	DECLARE @LocalizedValue 	NVARCHAR(MAX);  
  
	SELECT	@LocalizedValue = LocalizedValue  
	FROM	mdm.tblLocalizedStrings   
	WHERE	LanguageCode = @CurrentLanguageCode   
	AND		ResourceName = @ResourceName;   
  
	SELECT	@LocalizedValue = ISNULL(@LocalizedValue,@DefaultValue)   
	  
	RETURN @LocalizedValue;  
	  
END; --fn
GO
/****** Object:  UserDefinedFunction [mdm].[udfMin]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
	Function   : mdm.udfMIN  
	Component  : Security  
	Description: This function returns the smaller of two values  
	Parameters : First value, Second value  
	Return     : Value  
	Example 1  : SELECT mdm.udfMin(3, 2)  
	Example 2  : SELECT mdm.udfMin(1, 2)  
	Example 3  : SELECT mdm.udfMin(3, NULL)  
	Example 4  : SELECT mdm.udfMin(NULL, 3)  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE FUNCTION [mdm].[udfMin]  
(  
	@Value1 INT,   
	@Value2 INT  
)   
RETURNS INT  
/*WITH SCHEMABINDING*/  
AS BEGIN  
	SET @Value1 = COALESCE(@Value1, @Value2);  
	SET @Value2 = COALESCE(@Value2, @Value1);  
	RETURN CASE WHEN @Value1 < @Value2 THEN @Value1 ELSE @Value2 END;  
END; --fn
GO
/****** Object:  UserDefinedFunction [mdm].[udfModelGetIDByName]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    SELECT mdm.udfModelGetIDByName(NULL, 'Product')  
    SELECT mdm.udfModelGetIDByName(NULL, 'Account')  
    SELECT mdm.udfModelGetIDByName(NULL, NULL)  
*/  
CREATE FUNCTION [mdm].[udfModelGetIDByName]  
(  
    @Model_MUID UNIQUEIDENTIFIER,  
    @Model_Name NVARCHAR(50)  
)   
RETURNS INT  
/*WITH SCHEMABINDING*/  
AS BEGIN  
  
    DECLARE @Model_ID INT;  
  
    -- Clean input  
    SELECT  
         @Model_MUID = NULLIF(@Model_MUID, 0x0)  
        ,@Model_Name = NULLIF(LTRIM(RTRIM(@Model_Name)), N'' COLLATE Latin1_General_BIN -- collation prevents some special chars (like Chinese) from being considered equal to N''  
            )  
  
    IF @Model_MUID IS NOT NULL OR @Model_Name IS NOT NULL  
    BEGIN  
        SELECT @Model_ID = ID   
        FROM mdm.tblModel   
        WHERE   (@Model_MUID IS NULL OR MUID = @Model_MUID)   
            AND (@Model_Name IS NULL OR [Name] = @Model_Name)   
    END  
  
    RETURN @Model_ID;  
END; --fn
GO
/****** Object:  UserDefinedFunction [mdm].[udfNotificationGetChangesetStatusChangeHeader]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
SELECT CONVERT(XML, mdm.udfNotificationGetChangesetStatusChangeHeader());  
*/  
CREATE FUNCTION [mdm].[udfNotificationGetChangesetStatusChangeHeader]()  
RETURNS NVARCHAR(MAX)  
/*WITH SCHEMABINDING*/  
AS BEGIN  
  
    DECLARE  
         @HeaderElement NVARCHAR(MAX)  
        ,@LocalizedNotificationTypeName NVARCHAR(MAX) = N'Changeset Status Change'  
        ,@LocalizedModelHeader NVARCHAR(MAX) = N'Model'  
        ,@LocalizedVersionHeader NVARCHAR(MAX) = N'Version'  
        ,@LocalizedEntityHeader NVARCHAR(MAX) = N'Entity'  
        ,@LocalizedChangesetHeader NVARCHAR(MAX) = N'Changeset'  
        ,@LocalizedPriorStatusHeader NVARCHAR(MAX) = N'Prior status'  
        ,@LocalizedNewStatusHeader NVARCHAR(MAX) = N'New status'  
        ,@LocalizedLink NVARCHAR(MAX) = N'Click to view'  
        ,@LocalizedProductName NVARCHAR(MAX) = N'SQL Server Master Data Services'  
        ,@CurrentLanguageCode INT = 1033 -- Default language code is English (US).  
        ,@StringLanguageCode NVARCHAR(MAX) = N'1033'  
        ,@RootUrl NVARCHAR(MAX)  
  
    -- Use default language code to get the notification language code.  
    SET @StringLanguageCode = mdm.udfLocalizedStringGet(N'NotificationLCID', @CurrentLanguageCode, @StringLanguageCode);  
  
    IF @StringLanguageCode <> N'' BEGIN  
        SET @CurrentLanguageCode = CONVERT(INT, @StringLanguageCode)  
    END; -- if  
  
    -- Get the localized message texts based on the notification language code in tblLocalizedStrings.  
    SET @LocalizedModelHeader = mdm.udfLocalizedStringGet(N'NotificationHeaderModel', @CurrentLanguageCode, @LocalizedModelHeader);  
    SET @LocalizedVersionHeader = mdm.udfLocalizedStringGet(N'NotificationHeaderVersion', @CurrentLanguageCode, @LocalizedVersionHeader);  
    SET @LocalizedEntityHeader = mdm.udfLocalizedStringGet(N'NotificationHeaderEntity', @CurrentLanguageCode, @LocalizedEntityHeader);  
    SET @LocalizedChangesetHeader = mdm.udfLocalizedStringGet(N'NotificationHeaderChangeset', @CurrentLanguageCode, @LocalizedChangesetHeader);  
    SET @LocalizedPriorStatusHeader = mdm.udfLocalizedStringGet(N'NotificationHeaderPriorStatus', @CurrentLanguageCode, @LocalizedPriorStatusHeader);  
    SET @LocalizedNewStatusHeader = mdm.udfLocalizedStringGet(N'NotificationHeaderNewStatus', @CurrentLanguageCode, @LocalizedNewStatusHeader);  
    SET @LocalizedLink = mdm.udfLocalizedStringGet(N'NotificationLinkTextVerbose', @CurrentLanguageCode, @LocalizedLink);  
    SET @LocalizedProductName = mdm.udfLocalizedStringGet(N'NotificationProductName', @CurrentLanguageCode, @LocalizedProductName);  
    SET @LocalizedNotificationTypeName = mdm.udfLocalizedStringGet(N'NotificationChangesetStatusChange', @CurrentLanguageCode, @LocalizedNotificationTypeName);  
  
    -- Get the MDS web application root URL  
    SET @RootUrl = mdm.udfSystemSettingGet(N'MDMRootURL');  
  
    IF RIGHT(@RootUrl, 1) != N'/'  
    BEGIN  
        SET @RootUrl = CONCAT(@RootUrl, N'/');  
    END  
  
    SET @HeaderElement = CONCAT(N'  
        <header>  
          <ProductName>', (SELECT @LocalizedProductName FOR XML PATH('')), N'</ProductName>  
          <Notification_type>' + (SELECT @LocalizedNotificationTypeName FOR XML PATH('')), N'</Notification_type>  
          <Model>', (SELECT @LocalizedModelHeader FOR XML PATH('')), N'</Model>  
          <Version>', (SELECT @LocalizedVersionHeader FOR XML PATH('')), N'</Version>  
          <Entity>', (SELECT @LocalizedEntityHeader FOR XML PATH('')), N'</Entity>  
          <Changeset>', (SELECT @LocalizedChangesetHeader FOR XML PATH('')), N'</Changeset>  
          <PriorStatus>', (SELECT @LocalizedPriorStatusHeader FOR XML PATH('')), N'</PriorStatus>  
          <NewStatus>', (SELECT @LocalizedNewStatusHeader FOR XML PATH('')), N'</NewStatus>  
          <link_text>', (SELECT @LocalizedLink FOR XML PATH('')), N'</link_text>  
          <root_url>', (SELECT @RootUrl FOR XML PATH('')), N'</root_url>  
        </header>');  
  
    RETURN @HeaderElement  
  
END --fn
GO
/****** Object:  UserDefinedFunction [mdm].[udfNotificationGetValidationIssueHeader]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
SELECT CONVERT(XML, mdm.udfNotificationGetValidationIssueHeader());  
*/  
CREATE FUNCTION [mdm].[udfNotificationGetValidationIssueHeader]()  
RETURNS NVARCHAR(MAX)  
/*WITH SCHEMABINDING*/  
AS BEGIN  
  
    DECLARE  
         @HeaderElement NVARCHAR(MAX)  
        ,@LocalizedNotificationTypeName NVARCHAR(MAX) = N'Validation Issue'  
        ,@LocalizedModelHeader NVARCHAR(MAX) = N'Model'  
        ,@LocalizedVersionHeader NVARCHAR(MAX) = N'Version'  
        ,@LocalizedEntityHeader NVARCHAR(MAX) = N'Entity'  
        ,@LocalizedLink NVARCHAR(MAX) = N'Link'  
        ,@LocalizedIDHeader NVARCHAR(MAX) = N'ID'  
        ,@LocalizedMemberCodeHeader NVARCHAR(MAX) = N'Member Code'  
        ,@LocalizedMessageHeader NVARCHAR(MAX) = N'Message'  
        ,@LocalizedIssuedHeader NVARCHAR(MAX) = N'Issued'  
        ,@LocalizedProductName NVARCHAR(MAX) = N'SQL Server Master Data Services'  
        ,@CurrentLanguageCode INT = 1033 -- Default language code is English (US).  
        ,@StringLanguageCode NVARCHAR(MAX) = N''  
        ,@RootUrl NVARCHAR(MAX)  
  
    -- Use default language code to get the notification language code.  
    SELECT @StringLanguageCode = mdm.udfLocalizedStringGet(N'NotificationLCID', @CurrentLanguageCode, 1033);  
  
    IF @StringLanguageCode <> N'' BEGIN  
        SELECT @CurrentLanguageCode = CONVERT(INT, @StringLanguageCode)  
    END; -- if  
  
    -- Get the localized message texts based on the notification language code in tblLocalizedStrings.  
    SELECT @LocalizedIDHeader = mdm.udfLocalizedStringGet(N'NotificationHeaderID', @CurrentLanguageCode, @LocalizedIDHeader);  
    SELECT @LocalizedModelHeader = mdm.udfLocalizedStringGet(N'NotificationHeaderModel', @CurrentLanguageCode, @LocalizedModelHeader);  
    SELECT @LocalizedVersionHeader = mdm.udfLocalizedStringGet(N'NotificationHeaderVersion', @CurrentLanguageCode, @LocalizedVersionHeader);  
    SELECT @LocalizedEntityHeader = mdm.udfLocalizedStringGet(N'NotificationHeaderEntity', @CurrentLanguageCode, @LocalizedEntityHeader);  
    SELECT @LocalizedMemberCodeHeader = mdm.udfLocalizedStringGet(N'NotificationHeaderMemberCode', @CurrentLanguageCode, @LocalizedMemberCodeHeader);  
    SELECT @LocalizedMessageHeader = mdm.udfLocalizedStringGet(N'NotificationHeaderMessage', @CurrentLanguageCode, @LocalizedMessageHeader);  
    SELECT @LocalizedIssuedHeader = mdm.udfLocalizedStringGet(N'NotificationHeaderIssued', @CurrentLanguageCode, @LocalizedIssuedHeader);  
    SELECT @LocalizedLink = mdm.udfLocalizedStringGet(N'NotificationLinkText', @CurrentLanguageCode, @LocalizedLink);  
    SELECT @LocalizedProductName = mdm.udfLocalizedStringGet(N'NotificationProductName', @CurrentLanguageCode, @LocalizedProductName);  
    SELECT @LocalizedNotificationTypeName = mdm.udfLocalizedStringGet(N'NotificationValidationIssue', @CurrentLanguageCode, @LocalizedNotificationTypeName);  
  
    -- Get the MDS web application root URL  
    SELECT @RootUrl = mdm.udfSystemSettingGet(N'MDMRootURL');  
  
    IF RIGHT(@RootUrl, 1) != N'/'  
    BEGIN  
        SET @RootUrl = CONCAT(@RootUrl, N'/');  
    END  
  
    SET @HeaderElement = CONCAT(N'  
        <header>  
          <ProductName>', (SELECT @LocalizedProductName FOR XML PATH('')), N'</ProductName>  
          <Notification_type>', (SELECT @LocalizedNotificationTypeName FOR XML PATH('')), N'</Notification_type>  
          <id>', (SELECT @LocalizedIDHeader FOR XML PATH('')), N'</id>  
          <Model>', (SELECT @LocalizedModelHeader FOR XML PATH('')), N'</Model>  
          <Version>', (SELECT @LocalizedVersionHeader FOR XML PATH('')), N'</Version>  
          <Entity>', (SELECT @LocalizedEntityHeader FOR XML PATH('')), N'</Entity>  
          <MemberCode>', (SELECT @LocalizedMemberCodeHeader FOR XML PATH('')), N'</MemberCode>  
          <Message>', (SELECT @LocalizedMessageHeader FOR XML PATH('')), N'</Message>  
          <Issued>', (SELECT @LocalizedIssuedHeader FOR XML PATH('')), N'</Issued>  
          <root_url>', (SELECT @RootUrl FOR XML PATH('')), N'</root_url>  
        </header>');  
  
    RETURN @HeaderElement  
  
END --fn
GO
/****** Object:  UserDefinedFunction [mdm].[udfNotificationGetVersionStatusChangeHeader]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
SELECT CONVERT(XML, mdm.udfNotificationGetVersionStatusChangeHeader());  
*/  
CREATE FUNCTION [mdm].[udfNotificationGetVersionStatusChangeHeader]()  
RETURNS NVARCHAR(MAX)  
/*WITH SCHEMABINDING*/  
AS BEGIN  
  
    DECLARE  
         @HeaderElement NVARCHAR(MAX)  
        ,@LocalizedNotificationTypeName NVARCHAR(MAX) = N'Version Status Change'  
        ,@LocalizedModelHeader NVARCHAR(MAX) = N'Model'  
        ,@LocalizedVersionHeader NVARCHAR(MAX) = N'Version'  
        ,@LocalizedPriorStatusHeader NVARCHAR(MAX) = N'Prior status'  
        ,@LocalizedNewStatusHeader NVARCHAR(MAX) = N'New status'  
        ,@LocalizedLink NVARCHAR(MAX) = N'Click to view'  
        ,@LocalizedIssuedHeader NVARCHAR(MAX) = N'Issued'  
        ,@LocalizedProductName NVARCHAR(MAX) = N'SQL Server Master Data Services'  
        ,@CurrentLanguageCode INT = 1033 -- Default language code is English (US).  
        ,@StringLanguageCode NVARCHAR(MAX) = N''  
        ,@RootUrl NVARCHAR(MAX)  
  
    -- Use default language code to get the notification language code.  
    SELECT @StringLanguageCode = mdm.udfLocalizedStringGet(N'NotificationLCID', @CurrentLanguageCode, 1033);  
  
    IF @StringLanguageCode <> N'' BEGIN  
        SELECT @CurrentLanguageCode = CONVERT(INT, @StringLanguageCode)  
    END; -- if  
  
    -- Get the localized message texts based on the notification language code in tblLocalizedStrings.  
    SELECT @LocalizedModelHeader = mdm.udfLocalizedStringGet(N'NotificationHeaderModel', @CurrentLanguageCode, @LocalizedModelHeader);  
    SELECT @LocalizedVersionHeader = mdm.udfLocalizedStringGet(N'NotificationHeaderVersion', @CurrentLanguageCode, @LocalizedVersionHeader);  
    SELECT @LocalizedPriorStatusHeader = mdm.udfLocalizedStringGet(N'NotificationHeaderPriorStatus', @CurrentLanguageCode, @LocalizedPriorStatusHeader);  
    SELECT @LocalizedNewStatusHeader = mdm.udfLocalizedStringGet(N'NotificationHeaderNewStatus', @CurrentLanguageCode, @LocalizedNewStatusHeader);  
    SELECT @LocalizedIssuedHeader = mdm.udfLocalizedStringGet(N'NotificationHeaderIssued', @CurrentLanguageCode, @LocalizedIssuedHeader);  
    SELECT @LocalizedLink = mdm.udfLocalizedStringGet(N'NotificationLinkTextVerbose', @CurrentLanguageCode, @LocalizedLink);  
    SELECT @LocalizedProductName = mdm.udfLocalizedStringGet(N'NotificationProductName', @CurrentLanguageCode, @LocalizedProductName);  
    SELECT @LocalizedNotificationTypeName = mdm.udfLocalizedStringGet(N'NotificationVersionStatusChange', @CurrentLanguageCode, @LocalizedNotificationTypeName);  
  
    -- Get the MDS web application root URL  
    SELECT @RootUrl = mdm.udfSystemSettingGet(N'MDMRootURL');  
  
    IF RIGHT(@RootUrl, 1) != N'/'  
    BEGIN  
        SET @RootUrl = CONCAT(@RootUrl, N'/');  
    END  
  
    SET @HeaderElement = CONCAT(N'  
        <header>  
          <ProductName>', (SELECT @LocalizedProductName FOR XML PATH('')), N'</ProductName>  
          <Notification_type>', (SELECT @LocalizedNotificationTypeName FOR XML PATH('')), N'</Notification_type>  
          <Model>', (SELECT @LocalizedModelHeader FOR XML PATH('')), N'</Model>  
          <Version>', (SELECT @LocalizedVersionHeader FOR XML PATH('')), N'</Version>  
          <PriorStatus>', (SELECT @LocalizedPriorStatusHeader FOR XML PATH('')), N'</PriorStatus>  
          <NewStatus>', (SELECT @LocalizedNewStatusHeader FOR XML PATH('')), N'</NewStatus>  
          <link_text>', (SELECT @LocalizedLink FOR XML PATH('')), N'</link_text>  
          <Issued>', (SELECT @LocalizedIssuedHeader FOR XML PATH('')), N'</Issued>  
          <root_url>', (SELECT @RootUrl FOR XML PATH('')), N'</root_url>  
        </header>')  
  
    RETURN @HeaderElement  
  
END --fn
GO
/****** Object:  UserDefinedFunction [mdm].[udfScriptExists]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*    
==============================================================================    
 Copyright (c) Microsoft Corporation. All Rights Reserved.    
==============================================================================    
*/    
CREATE FUNCTION [mdm].[udfScriptExists]    
(    
@ScriptName     NVARCHAR(250),            
    @ScriptType     INT, -- 1 function, 2 sproc          
    @SchemaName     SYSNAME          
)             
RETURNS BIT            
AS BEGIN            
    DECLARE @Result BIT = 0         
        ,@ScriptObjectId INT = NULL    
        ,@MaxParameterId INT = 0;        
             
    IF SCHEMA_ID(@SchemaName) IS NOT NULL          
    BEGIN          
        IF @ScriptType = 2 -- sproc          
        BEGIN          
            SELECT @ScriptObjectId = object_id           
            FROM sys.objects          
            WHERE type ='P' AND schema_id = SCHEMA_ID(@SchemaName) AND name = @ScriptName        
                
            IF @ScriptObjectId IS NOT NULL    
            BEGIN    
                SELECT @Result = (CASE COUNT(*) WHEN 5 THEN 1 ELSE 0 END)    
                    FROM sys.parameters WHERE object_id = @ScriptObjectId    
                IF @Result = 1    
                BEGIN    
                    SELECT @Result = 0    
                    FROM sys.parameters WHERE object_id = @ScriptObjectId    
                    AND (  
					    (parameter_id = 1 AND (TYPE_NAME(user_type_id) <> 'MemberId' OR name <>N'@MemberIdList' COLLATE DATABASE_DEFAULT))    
                        OR(parameter_id = 2 AND (TYPE_NAME(user_type_id) <>'nvarchar' OR max_length <> -1 OR name <>N'@ModelName' COLLATE DATABASE_DEFAULT))  
						OR(parameter_id = 3 AND (TYPE_NAME(user_type_id) <>'nvarchar' OR max_length <> -1 OR name <>N'@VersionName' COLLATE DATABASE_DEFAULT))  
						OR(parameter_id = 4 AND (TYPE_NAME(user_type_id) <>'nvarchar' OR max_length <> -1 OR name <>N'@EntityName' COLLATE DATABASE_DEFAULT))  
						OR(parameter_id = 5 AND (TYPE_NAME(user_type_id) <>'nvarchar' OR max_length <> -1 OR name <>N'@BusinessRuleName' COLLATE DATABASE_DEFAULT))  
                    )     
                END                
            END                  
                
        END          
        ELSE IF @ScriptType = 1 -- function          
        BEGIN           
            SELECT @ScriptObjectId = object_id           
            FROM sys.objects          
            WHERE type ='FN' AND schema_id = SCHEMA_ID(@SchemaName) AND name = @ScriptName        
        
            IF @ScriptObjectId IS NOT NULL        
            BEGIN        
                SELECT @Result = 1;        
                SELECT @Result = 0        
                FROM sys.parameters        
                WHERE object_id = @ScriptObjectId        
                AND ((is_output = 1 AND user_type_id <> TYPE_ID('bit'))        
                   OR (is_output = 0 AND       
                        ( user_type_id NOT IN (TYPE_ID('nvarchar'),TYPE_ID('datetime2'), TYPE_ID('decimal')) -- ONLY SUPPORT TYPE NVARCHAR, DATETIME2, AND DECIMAL      
                        OR (user_type_id = TYPE_ID('decimal') AND ([precision] <>38 OR scale>7)))))  -- IF TYPE IS DECIMAL, PRECISION SHOULD BE 38 WHICH IS THE DEFAULT ONE ,AND SCALE SHOULD BE IN THE ARRANGE OF 0 TO 7      
            END        
                    
                        
        END              
    END          
    RETURN @Result          
              
END
GO
/****** Object:  UserDefinedFunction [mdm].[udfSecurableIDGetByObjectID]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
  
CREATE FUNCTION [mdm].[udfSecurableIDGetByObjectID]  
(  
    @Object_ID      INT,  
    @Securable_MUID UNIQUEIDENTIFIER,  
    @Securable_Name NVARCHAR(100) = NULL --Model is the only parameter accepted here  
)   
RETURNS INT  
/*WITH SCHEMABINDING*/  
AS BEGIN  
    DECLARE @Securable_ID INT = NULL;  
      
    IF (@Securable_MUID IS NOT NULL AND @Securable_MUID <> CAST(0x0 AS UNIQUEIDENTIFIER)) BEGIN  
        IF @Object_ID = 1        -- Model  
            SELECT @Securable_ID = ID FROM mdm.tblModel WHERE MUID = @Securable_MUID;  
        ELSE IF @Object_ID = 3 or @Object_ID = 8 or @Object_ID = 9 or @Object_ID = 10 -- Entity  
            SELECT @Securable_ID = ID FROM mdm.tblEntity WHERE MUID = @Securable_MUID;  
        ELSE IF @Object_ID = 4    -- Attribute  
            SELECT @Securable_ID = ID FROM mdm.tblAttribute WHERE MUID = @Securable_MUID;  
        ELSE IF @Object_ID = 5    -- Attribute Group  
            SELECT @Securable_ID = ID FROM mdm.tblAttributeGroup WHERE MUID = @Securable_MUID;  
    END ELSE IF @Securable_Name IS NOT NULL BEGIN    
        IF @Object_ID = 1 -- Model  
            SELECT @Securable_ID = ID FROM mdm.tblModel WHERE Name = @Securable_Name;  
        ELSE --Securable id cannot be looked up by name for other object types return 0  
            SET @Securable_ID = 0;  
    END; --if  
      
    RETURN @Securable_ID;  
END; --fn
GO
/****** Object:  UserDefinedFunction [mdm].[udfSecurableNameGetByObjectID]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
SELECT mdm.udfSecurableNameGetByObjectID(8,26)  
  
  
select * from mdm.tblSecurityObject  
select * from mdm.viw_SYSTEM_SCHEMA_MODELS   
select * from mdm.viw_SYSTEM_SCHEMA_ATTRIBUTES  
select * from mdm.viw_SYSTEM_SCHEMA_ATTRIBUTEGROUPS   
SELECT * FROM mdm.viw_SYSTEM_SCHEMA_HIERARCHY_DERIVED  
  
*/  
  
CREATE FUNCTION [mdm].[udfSecurableNameGetByObjectID]  
(  
    @Object_ID        INT,  
    @Securable_ID    INT  
)   
RETURNS NVARCHAR(250)  
/*WITH SCHEMABINDING*/  
AS BEGIN  
    DECLARE @SecurableName NVARCHAR(250)  
      
    IF @Object_ID = 1 -- Model  
        SELECT TOP 1 @SecurableName = Model_Label FROM mdm.viw_SYSTEM_SCHEMA_MODELS WHERE Model_ID = @Securable_ID ORDER BY Model_ID  
    ELSE IF @Object_ID = 3 -- Entity  
        SELECT TOP 1 @SecurableName = Entity_Label FROM mdm.viw_SYSTEM_SCHEMA_MODELS WHERE Entity_ID = @Securable_ID ORDER BY Entity_ID  
    ELSE IF @Object_ID = 4 -- Attribute  
        SELECT TOP 1 @SecurableName = Attribute_FullyQualifiedName FROM mdm.viw_SYSTEM_SCHEMA_ATTRIBUTES WHERE Attribute_ID = @Securable_ID ORDER BY Attribute_ID  
    ELSE IF @Object_ID = 5 -- Attribute Group  
        SELECT TOP 1 @SecurableName = FullName FROM mdm.viw_SYSTEM_SCHEMA_ATTRIBUTEGROUPS WHERE ID = @Securable_ID ORDER BY ID  
    ELSE IF @Object_ID = 8 -- Leaf Member Type  
        SELECT TOP 1 @SecurableName = MemberType_Label FROM mdm.viw_SYSTEM_SCHEMA_MODELS WHERE MemberType_ID = 1 AND Entity_ID = @Securable_ID ORDER BY Entity_ID  
    ELSE IF @Object_ID = 9 -- Consolidated Member Type  
        SELECT TOP 1 @SecurableName = MemberType_Label FROM mdm.viw_SYSTEM_SCHEMA_MODELS WHERE MemberType_ID = 2 AND Entity_ID = @Securable_ID ORDER BY Entity_ID  
    ELSE IF @Object_ID = 10 -- Collection Member Type  
        SELECT TOP 1 @SecurableName = MemberType_Label FROM mdm.viw_SYSTEM_SCHEMA_MODELS WHERE MemberType_ID = 3 AND Entity_ID = @Securable_ID ORDER BY Entity_ID  
  
    RETURN @SecurableName         
  
END --fn
GO
/****** Object:  UserDefinedFunction [mdm].[udfSecurityGetUsersByFunction]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
Returns all users that have the given functional permission.  
  
*/  
CREATE FUNCTION [mdm].[udfSecurityGetUsersByFunction]   
(  
    @FunctionalPrivilege_ID TINYINT = NULL  
)  
RETURNS @UserId TABLE (ID INT PRIMARY KEY)  
/*WITH SCHEMABINDING*/  
AS  
BEGIN  
    INSERT INTO @UserId  
    SELECT DISTINCT [User_ID]  
    FROM viw_SYSTEM_SECURITY_USER_FUNCTION  
    WHERE   Function_ID = @FunctionalPrivilege_ID  
    RETURN;  
END
GO
/****** Object:  UserDefinedFunction [mdm].[udfSecurityObjectIDGetByCode]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
Date:      : Friday, September 8, 2006  
Function   : mdm.udfSecurityObjectIDGetByCode  
Component  : All  
Description: mdm.udfSecurityObjectIDGetByCode returns an ID associated with a security object code.  
Parameters : Object code  
Return     : String  
Example    :   
			SELECT mdm.udfSecurityObjectIDGetByCode('DIMATT')  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE FUNCTION [mdm].[udfSecurityObjectIDGetByCode] (@ObjectCode NVARCHAR(6))   
RETURNS INT  
/*WITH SCHEMABINDING*/  
AS BEGIN  
   RETURN (SELECT ID FROM mdm.tblSecurityObject WHERE Code = @ObjectCode)  
END --fn
GO
/****** Object:  UserDefinedFunction [mdm].[udfSecurityUserBusinessRuleList]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
Returns a list of business rule IDs available to the given user. A rule is excluded if  
the user cannot see one or more of the attributes referenced by the rule.  
  
    SELECT * FROM mdm.udfSecurityUserBusinessRuleList(2,31,1);  
  
    -- Gets rules for all Entities and MemberTypes.  
    SELECT * FROM mdm.udfSecurityUserBusinessRuleList(2, NULL, NULL);  
*/  
CREATE FUNCTION [mdm].[udfSecurityUserBusinessRuleList]  
(  
    @User_ID INT,  
    @Entity_ID INT = NULL,  
    @MemberType_ID TINYINT = NULL  
)  
RETURNS @tblBusinessRuleIdList TABLE  
(  
    BusinessRule_ID INT PRIMARY KEY CLUSTERED  
)  
AS BEGIN  
    -- Get all business rules for the specified Entity and MemberType.  
    INSERT INTO @tblBusinessRuleIdList (BusinessRule_ID)  
    SELECT  
        DISTINCT br.BusinessRule_ID  
    FROM mdm.viw_SYSTEM_SCHEMA_BUSINESSRULES br  
    WHERE  
        ((@Entity_ID IS NULL) OR (br.Entity_ID = @Entity_ID)) AND  
        ((@MemberType_ID IS NULL) OR (br.MemberType_ID = @MemberType_ID));  
  
  
    -- Determine if the user does not have access to any attributes referenced in the business rules.  These BR need to be excluded.  
  
    -- Get all attributes referenced by the BRs  
    DECLARE @BusinessRulesWithDenyAttributes TABLE (BusinessRule_ID INT, Item_ID INT, Attribute_ID INT, Attribute_Entity_ID INT, Attribute_MemberType_ID TINYINT);  
    INSERT INTO @BusinessRulesWithDenyAttributes (BusinessRule_ID, Item_ID, Attribute_ID, Attribute_Entity_ID, Attribute_MemberType_ID)  
    SELECT  
        brAtt.BusinessRule_ID, brAtt.Item_ID, brAtt.Attribute_ID, brAtt.Attribute_Entity_ID, brAtt.Attribute_MemberType_ID  
    FROM mdm.viw_SYSTEM_SCHEMA_BUSINESSRULE_PROPERTIES_ATTRIBUTES brAtt  
    INNER JOIN @tblBusinessRuleIdList br ON br.BusinessRule_ID = brAtt.BusinessRule_ID  
  
    -- Get a list of all unique Entity-MemberType pairs.  
    DECLARE @tblEntityMemberTypes TABLE  
    (  
        RowNumber INT IDENTITY(1,1) PRIMARY KEY CLUSTERED,  
        Attribute_Entity_ID INT,  
        Attribute_MemberType_ID TINYINT  
    )  
    INSERT INTO @tblEntityMemberTypes(Attribute_Entity_ID, Attribute_MemberType_ID)  
    SELECT DISTINCT  
        Attribute_Entity_ID,  
        Attribute_MemberType_ID  
    FROM  
        @BusinessRulesWithDenyAttributes  
  
    -- Loop through each Entity-MemberType, and remove from @BusinessRulesWithDenyAttributes those attributes which the user  
    -- can see. Those left over are not visible to the user.  
    DECLARE @Counter INT = 1,  
            @MaxCount INT = (SELECT MAX(RowNumber) FROM @tblEntityMemberTypes),  
            @Attribute_Entity_ID INT,  
            @Attribute_MemberType_ID TINYINT;  
    WHILE (@Counter <= @MaxCount)  
    BEGIN  
        -- Get the current Entity-MemberType IDs.  
        SELECT  
            @Attribute_Entity_ID = Attribute_Entity_ID,  
            @Attribute_MemberType_ID = Attribute_MemberType_ID  
        FROM  
            @tblEntityMemberTypes  
        WHERE RowNumber = @Counter;  
  
        -- Delete rows for the attributes that the user can see.  
        WITH attributesCte AS  
        (  
            SELECT att.ID  
            FROM mdm.viw_SYSTEM_SECURITY_USER_ATTRIBUTE sec  
            INNER JOIN mdm.tblAttribute att  
            ON att.ID = sec.ID  
            WHERE sec.User_ID = @User_ID  
                AND (@Attribute_Entity_ID IS NULL OR att.Entity_ID = @Attribute_Entity_ID)  
                AND (@Attribute_MemberType_ID IS NULL OR att.MemberType_ID = @Attribute_MemberType_ID)  
        )  
        DELETE br  
        FROM @BusinessRulesWithDenyAttributes br  
        INNER JOIN attributesCte a  
        ON br.Attribute_ID = a.ID  
        WHERE  
            br.Attribute_Entity_ID = @Attribute_Entity_ID AND  
            br.Attribute_MemberType_ID = @Attribute_MemberType_ID  
  
        SET @Counter += 1;  
    END  
  
    -- Remove from the results the rules that contain denied attributes.  
    DELETE FROM @tblBusinessRuleIdList  
    WHERE BusinessRule_ID IN (SELECT DISTINCT BusinessRule_ID FROM @BusinessRulesWithDenyAttributes)  
  
    RETURN;  
END
GO
/****** Object:  UserDefinedFunction [mdm].[udfSecurityUserExplicitMemberPermissions]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
Returns the member permissions that apply to the given principal, optionally  
including permissions inherited from groups.  
  
SELECT * FROM mdm.udfSecurityUserExplicitMemberPermissions(1,2,1,0)  
SELECT * FROM mdm.udfSecurityUserExplicitMemberPermissions(1,2,1,1) WHERE Entity_ID = 41  
SELECT * FROM mdm.udfSecurityUserExplicitMemberPermissions(1,2,1,1)  
SELECT * FROM mdm.udfSecurityUserExplicitMemberPermissions(1,11,1,1)  
*/  
CREATE FUNCTION [mdm].[udfSecurityUserExplicitMemberPermissions]  
(  
     @SystemUser_ID             INT -- The ID of the user requesting the permission info  
    ,@Principal_ID              INT  
    ,@PrincipalType_ID          INT  
    ,@IncludeGroupAssignments   BIT  
)  
RETURNS @UserPermissions TABLE  
(  
     RoleAccess_ID          INT  
    ,RoleAccess_MUID        UNIQUEIDENTIFIER  
    ,Privilege_ID           TINYINT  
    ,AccessPermission       TINYINT  
    ,Model_ID               INT  
    ,Model_MUID             UNIQUEIDENTIFIER  
    ,Model_Name             NVARCHAR(50) COLLATE DATABASE_DEFAULT  
    ,Version_ID             INT  
    ,Version_MUID           UNIQUEIDENTIFIER  
    ,Version_Name           NVARCHAR(50) COLLATE DATABASE_DEFAULT  
    ,IsModelAdministrator   BIT  
    ,HierarchyType_ID       TINYINT  
    ,Hierarchy_ID           INT  
    ,Hierarchy_MUID         UNIQUEIDENTIFIER  
    ,Hierarchy_Name         NVARCHAR(50) COLLATE DATABASE_DEFAULT  
    ,Entity_ID              INT  
    ,Entity_MUID            UNIQUEIDENTIFIER  
    ,Entity_Name            NVARCHAR(MAX) COLLATE DATABASE_DEFAULT  
    ,MemberType_ID          TINYINT  
    ,Member_ID              INT  
    ,PrincipalType_ID       TINYINT  
    ,Principal_ID           INT  
    ,Principal_MUID         UNIQUEIDENTIFIER  
    ,Principal_Name         NVARCHAR(355) COLLATE DATABASE_DEFAULT  
    ,EnterUserID            INT  
    ,EnterUserMUID          UNIQUEIDENTIFIER  
    ,EnterUser              NVARCHAR(256) COLLATE DATABASE_DEFAULT  
    ,EnterDTM               DATETIME2(3)  
    ,LastChgUserID          INT  
    ,LastChgUserMUID        UNIQUEIDENTIFIER  
    ,LastChgUser            NVARCHAR(256) COLLATE DATABASE_DEFAULT  
    ,LastChgDTM             DATETIME2(3)  
)  
/*WITH SCHEMABINDING*/  
AS BEGIN  
  
    DECLARE  
         @PrincipalType_User    TINYINT = 1  
        ,@PrincipalType_Group   TINYINT = 2  
        ,@Privilege_Deny        TINYINT = 1;  
  
    -- Explicit Object permissions  
    INSERT INTO @UserPermissions  
    SELECT  
         rac.RoleAccess_ID  
        ,rac.RoleAccess_MUID  
        ,rac.Privilege_ID  
        ,rac.AccessPermission  
        ,rac.Model_ID  
        ,rac.Model_MUID  
        ,rac.Model_Name  
        ,rac.Version_ID  
        ,rac.Version_MUID  
        ,rac.Version_Name  
        ,rac.IsModelAdministrator  
        ,rac.HierarchyType_ID  
        ,rac.Hierarchy_ID  
        ,rac.Hierarchy_MUID  
        ,rac.Hierarchy_Name  
        ,rac.Entity_ID  
        ,rac.Entity_MUID  
        ,rac.Entity_Name  
        ,rac.MemberType_ID  
        ,rac.Member_ID  
        ,rac.PrincipalType_ID  
        ,rac.Principal_ID  
        ,rac.Principal_MUID  
        ,rac.Principal_Name  
        ,rac.EnterUserID  
        ,rac.EnterUserMUID  
        ,rac.EnterUser  
        ,rac.EnterDTM  
        ,rac.LastChgUserID  
        ,rac.LastChgUserMUID  
        ,rac.LastChgUser  
        ,rac.LastChgDTM  
    FROM mdm.viw_SYSTEM_SECURITY_ROLE_ACCESSCONTROL_MEMBER rac  
    INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_MODEL modSec  
    ON      rac.Model_ID = modSec.ID  
    WHERE   modSec.User_ID = @SystemUser_ID  
        AND (modSec.Privilege_ID = 5 /*Admin*/                              -- User must be a model admin to see another user's permission on the model.  
             OR (   @SystemUser_ID = @Principal_ID                          -- User can see his own permissions (except Deny)  
                AND @PrincipalType_ID = @PrincipalType_User  
                AND COALESCE(rac.Privilege_ID, @Privilege_Deny) <> @Privilege_Deny))  
        AND rac.PrincipalType_ID = @PrincipalType_ID  
        AND rac.Principal_ID = @Principal_ID  
  
    IF (@PrincipalType_ID = @PrincipalType_User) AND (COALESCE(@IncludeGroupAssignments, 0) = 1)  
    BEGIN  
        -- Explicit permissions inherited from group assignments  
        INSERT INTO @UserPermissions  
        SELECT  
             rac.RoleAccess_ID  
            ,rac.RoleAccess_MUID  
            ,rac.Privilege_ID  
            ,rac.AccessPermission  
            ,rac.Model_ID  
            ,rac.Model_MUID  
            ,rac.Model_Name  
            ,rac.Version_ID  
            ,rac.Version_MUID  
            ,rac.Version_Name  
            ,rac.IsModelAdministrator  
            ,rac.HierarchyType_ID  
            ,rac.Hierarchy_ID  
            ,rac.Hierarchy_MUID  
            ,rac.Hierarchy_Name  
            ,rac.Entity_ID  
            ,rac.Entity_MUID  
            ,rac.Entity_Name  
            ,rac.MemberType_ID  
            ,rac.Member_ID  
            ,rac.PrincipalType_ID  
            ,rac.Principal_ID  
            ,rac.Principal_MUID  
            ,rac.Principal_Name  
            ,rac.EnterUserID  
            ,rac.EnterUserMUID  
            ,rac.EnterUser  
            ,rac.EnterDTM  
            ,rac.LastChgUserID  
            ,rac.LastChgUserMUID  
            ,rac.LastChgUser  
            ,rac.LastChgDTM  
        FROM mdm.viw_SYSTEM_SECURITY_ROLE_ACCESSCONTROL_MEMBER rac  
        INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_ROLE sur  
        ON      rac.Role_ID = sur.Role_ID  
            AND sur.User_ID = @Principal_ID  
        INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_MODEL modSec  
        ON      rac.Model_ID = modSec.ID  
        WHERE   modSec.User_ID = @SystemUser_ID  
            AND (modSec.Privilege_ID = 5 /*Admin*/                              -- User must be a model admin to see another user's permission on the model.  
                 OR (   @SystemUser_ID = @Principal_ID                          -- User can see his own permissions (except Deny)  
                    AND @PrincipalType_ID = @PrincipalType_User  
                    AND COALESCE(rac.Privilege_ID, @Privilege_Deny) <> @Privilege_Deny))  
            AND rac.PrincipalType_ID = @PrincipalType_Group  
    END  
  
    RETURN  
END --fn
GO
/****** Object:  UserDefinedFunction [mdm].[udfSecurityUserExplicitPermissions]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
Returns the object (model) permissions that apply to the given principal, optionally  
including permissions inherited from groups.  
  
SELECT * FROM mdm.udfSecurityUserExplicitPermissions(11,1,0,NULL)  
SELECT * FROM mdm.udfSecurityUserExplicitPermissions(27,1,1,NULL)  
SELECT * FROM mdm.udfSecurityUserExplicitPermissions(2,1,1,NULL)  
*/  
CREATE FUNCTION [mdm].[udfSecurityUserExplicitPermissions]  
(  
     @SystemUser_ID              INT -- The ID of the user requesting the permission info  
    ,@Principal_ID               INT  
    ,@PrincipalType_ID           INT  
    ,@IncludeGroupAssignments    BIT  
)  
RETURNS @UserPermissions TABLE  
(  
     RoleAccess_ID          INT  
    ,RoleAccess_MUID        UNIQUEIDENTIFIER  
    ,Privilege_ID           INT  
    ,AccessPermission       TINYINT  
    ,Object_ID              INT  
    ,Securable_ID           INT  
    ,Securable_MUID         UNIQUEIDENTIFIER  
    ,Securable_Name         NVARCHAR(MAX) COLLATE DATABASE_DEFAULT  
    ,Model_ID               INT  
    ,Model_MUID             UNIQUEIDENTIFIER  
    ,Model_Name             NVARCHAR(50) COLLATE DATABASE_DEFAULT  
    ,IsModelAdministrator   BIT  
    ,PrincipalType_ID       INT  
    ,Principal_ID           INT  
    ,Principal_MUID         UNIQUEIDENTIFIER  
    ,Principal_Name         NVARCHAR(MAX) COLLATE DATABASE_DEFAULT  
    ,EnterUserID            INT  
    ,EnterUserMUID          UNIQUEIDENTIFIER  
    ,EnterUserName          NVARCHAR(MAX) COLLATE DATABASE_DEFAULT  
    ,EnterDTM               DATETIME2(3)  
    ,LastChgUserID          INT  
    ,LastChgUserMUID        UNIQUEIDENTIFIER  
    ,LastChgUserName        NVARCHAR(MAX) COLLATE DATABASE_DEFAULT  
    ,LastChgDTM             DATETIME2(3)  
)  
/*WITH SCHEMABINDING*/  
AS BEGIN  
  
    DECLARE  
         @PrincipalType_User    TINYINT = 1  
        ,@PrincipalType_Group   TINYINT = 2  
        ,@Privilege_Deny        TINYINT = 1;  
  
    INSERT INTO @UserPermissions  
    SELECT  
         rac.RoleAccess_ID  
        ,rac.RoleAccess_MUID  
        ,rac.Privilege_ID  
        ,rac.AccessPermission  
        ,rac.Object_ID  
        ,rac.Securable_ID  
        ,rac.Securable_MUID  
        ,rac.Securable_Name  
        ,rac.Model_ID  
        ,rac.Model_MUID  
        ,rac.Model_Name  
        ,rac.IsModelAdministrator  
        ,rac.PrincipalType_ID  
        ,rac.Principal_ID  
        ,rac.Principal_MUID  
        ,rac.Principal_Name  
        ,rac.EnterUserID  
        ,rac.EnterUserMUID  
        ,rac.EnterUserName  
        ,rac.EnterDTM  
        ,rac.LastChgUserID  
        ,rac.LastChgUserMUID  
        ,rac.LastChgUserName  
        ,rac.LastChgDTM  
    FROM mdm.viw_SYSTEM_SECURITY_ROLE_ACCESSCONTROL rac  
    INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_MODEL modSec  
    ON      rac.Model_ID = modSec.ID  
    WHERE   modSec.User_ID = @SystemUser_ID  
        AND (modSec.Privilege_ID = 5 /*Admin*/                              -- User must be a model admin to see another user's permission on the model.  
             OR (   @SystemUser_ID = @Principal_ID                          -- User can see his own permissions (except Deny)  
                AND @PrincipalType_ID = @PrincipalType_User  
                AND COALESCE(rac.Privilege_ID, @Privilege_Deny) <> @Privilege_Deny))  
        AND rac.PrincipalType_ID = @PrincipalType_ID  
        AND rac.Principal_ID = @Principal_ID  
  
    IF (@PrincipalType_ID = @PrincipalType_User) AND (COALESCE(@IncludeGroupAssignments, 0) = 1)  
    BEGIN  
        -- Explicit permissions inherited from group assignments  
        INSERT INTO @UserPermissions  
        SELECT  
             rac.RoleAccess_ID  
            ,rac.RoleAccess_MUID  
            ,rac.Privilege_ID  
            ,rac.AccessPermission  
            ,rac.Object_ID  
            ,rac.Securable_ID  
            ,rac.Securable_MUID  
            ,rac.Securable_Name  
            ,rac.Model_ID  
            ,rac.Model_MUID  
            ,rac.Model_Name  
            ,rac.IsModelAdministrator  
            ,rac.PrincipalType_ID  
            ,rac.Principal_ID  
            ,rac.Principal_MUID  
            ,rac.Principal_Name  
            ,rac.EnterUserID  
            ,rac.EnterUserMUID  
            ,rac.EnterUserName  
            ,rac.EnterDTM  
            ,rac.LastChgUserID  
            ,rac.LastChgUserMUID  
            ,rac.LastChgUserName  
            ,rac.LastChgDTM  
        FROM mdm.viw_SYSTEM_SECURITY_ROLE_ACCESSCONTROL rac  
        INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_ROLE sur  
        ON      rac.Role_ID = sur.Role_ID  
            AND sur.User_ID = @Principal_ID  
        INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_MODEL modSec  
        ON      rac.Model_ID = modSec.ID  
        WHERE   modSec.User_ID = @SystemUser_ID  
            AND (modSec.Privilege_ID = 5 /*Admin*/                              -- User must be a model admin to see another user's permission on the model.  
                 OR (   @SystemUser_ID = @Principal_ID                          -- User can see his own permissions (except Deny)  
                    AND @PrincipalType_ID = @PrincipalType_User  
                    AND COALESCE(rac.Privilege_ID, @Privilege_Deny) <> @Privilege_Deny))  
            AND rac.PrincipalType_ID = @PrincipalType_Group  
    END  
  
    RETURN  
END
GO
/****** Object:  UserDefinedFunction [mdm].[udfSecurityUserFunctionIsAllowed]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
Returns whether the given user is allowed to execute operations pertaining to the given functional permission.  
Always true for users with super user functional permission.  
  
*/  
CREATE FUNCTION [mdm].[udfSecurityUserFunctionIsAllowed]  
(  
     @User_ID  INT  
    ,@Function TINYINT  
)  
RETURNS BIT  
/*WITH SCHEMABINDING*/    
AS  
BEGIN  
    DECLARE   
         @Function_SuperUser TINYINT = 6  
        ,@Function_Explorer  TINYINT = 1  
        ,@IsAllowed BIT = 0;  
  
    IF EXISTS (  
        SELECT 1   
        FROM mdm.udfSecurityUserFunctionList(@User_ID)   
        WHERE  Function_ID IN (@Function_SuperUser, @Function)  
            OR @Function = @Function_Explorer) -- The existence of any functional privilege infers Explorer privilege.  
    BEGIN  
        SET @IsAllowed = 1;  
    END;  
  
    RETURN @IsAllowed;  
END
GO
/****** Object:  UserDefinedFunction [mdm].[udfServiceGetConversationHandle]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
/*  
Function   : mdm.udfServiceGetConversationHandle  
Component  : Service Broker  
Description: mdm.udfServiceGetConversationHandle returns a GUID that is the current conversation handle between the two SSB services passed in.  
Parameters : sourceService, farService  
Return     : GUID queried from sys.conversation_endpoints  
Example 1  : SET @conversationHandle = mdm.udfServiceGetConversationHandle(N'microsoft/mdm/service/system', N'microsoft/mdm/service/securitymember')  
*/  
  
CREATE FUNCTION [mdm].[udfServiceGetConversationHandle]  
(  
    @sourceService NVARCHAR(100),   
    @farService NVARCHAR(100)  
)  
RETURNS UNIQUEIDENTIFIER  
WITH EXECUTE AS N'mds_schema_user' -- Execute as a user that, unlike mds_ssb_user, has permission to see the services defined in sys.services.  
AS  
BEGIN  
    DECLARE @conversationHandle UNIQUEIDENTIFIER = NULL;  
      
    --get the existing conversation handle if possible  
    SELECT   
        @conversationHandle = cep.conversation_handle  
    FROM sys.conversation_groups as cgs  
    INNER JOIN sys.services as svc  
        ON svc.service_id = cgs.service_id  
    INNER JOIN sys.conversation_endpoints as cep  
        ON cgs.conversation_group_id = cep.conversation_group_id  
    WHERE svc.name = @sourceService  
        AND cep.far_service = @farService  
        AND cep.state <> N'ER' --exclude conversations in a state of ERROR   
        AND cep.state <> N'CD' --CLOSED  
        AND cep.state <> N'DI' --Disconnected Inbound  
        AND cep.state <> N'DO' --Disconnected Outbound  
          
      
    RETURN @conversationHandle;  
END
GO
/****** Object:  UserDefinedFunction [mdm].[udfSystemSettingGet]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
	SELECT mdm.udfSystemSettingGet(N'MDMRootURL')  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE FUNCTION [mdm].[udfSystemSettingGet]  
(  
	@SettingName 	NVARCHAR(100)  
)   
RETURNS NVARCHAR(MAX)  
/*WITH SCHEMABINDING*/  
AS BEGIN  
  
	DECLARE @SettingValue 	NVARCHAR(MAX);  
  
	SELECT	@SettingValue = SettingValue  
	FROM	mdm.tblSystemSetting  
	WHERE	SettingName = @SettingName;  
  
	SET @SettingValue = ISNULL(@SettingValue, CAST(N'' AS NVARCHAR(MAX)))  
	  
	RETURN @SettingValue;  
	  
END; --fn
GO
/****** Object:  UserDefinedFunction [mdm].[udfTableNameGetByID]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
    SELECT mdm.udfTableNameGetByID(6, 1);  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE FUNCTION [mdm].[udfTableNameGetByID]  
(  
    @Entity_ID      INT,  
    @EntityType_ID  TINYINT  
)  
RETURNS sysname  
/*WITH SCHEMABINDING*/  
AS BEGIN  
    DECLARE @TableName sysname;  
  
    SELECT @TableName = CASE @EntityType_ID  
        WHEN 1 THEN EntityTable  
        WHEN 2 THEN HierarchyParentTable  
        WHEN 3 THEN CollectionTable  
        WHEN 4 THEN HierarchyTable  
        WHEN 5 THEN CollectionMemberTable  
        ELSE NULL  
    END --case  
    FROM mdm.tblEntity  
    WHERE ID = @Entity_ID;  
      
    RETURN @TableName;  
END; --fn
GO
/****** Object:  UserDefinedFunction [mdm].[udfUniqueStagingBaseGet]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
SELECT mdm.udfUniqueStagingBaseGet('Product')  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE FUNCTION [mdm].[udfUniqueStagingBaseGet]  
(  
    @StagingBaseName	NVARCHAR(50) -- An entity name or the first 50 characters of StagingBase.  
)   
RETURNS NVARCHAR(60)  
/*WITH SCHEMABINDING*/  
AS BEGIN  
    DECLARE @NewStagingBase NVARCHAR(60),  
            @Count			INT = 0,  
            @MaxNameLen		INT = 111;  
          
    SET	@NewStagingBase = @StagingBaseName  
      
    -- If @NewStagingBase is not unique append the sequence number to make it unique.  
    WHILE EXISTS (SELECT 1 FROM mdm.tblEntity WHERE StagingBase = @NewStagingBase)  
    BEGIN  
        SET @Count = @Count + 1;  
        SET @NewStagingBase = LEFT(@StagingBaseName, @MaxNameLen - 6) + N'_' + CONVERT(NVARCHAR(5), @Count)   
    END; -- WHILE	  
          
    RETURN @NewStagingBase;	     
  
END --fn
GO
/****** Object:  UserDefinedFunction [mdm].[udfUseMemberSecurity]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
SELECT mdm.udfUseMemberSecurity(65,1,null,23,1,298)  
*/  
CREATE FUNCTION [mdm].[udfUseMemberSecurity]  
(  
    @User_ID            INT,  
    @Entity_ID          INT,  
    @Version_ID         INT,  
    @MemberType_ID      TINYINT = NULL  
)   
RETURNS BIT  
/*WITH SCHEMABINDING*/  
AS BEGIN  
    DECLARE @Ret                                    BIT = 0,  
            @MemberType_Leaf                        TINYINT = 1,  
            @MemberType_Consolidated                TINYINT = 2,  
            @MemberType_Collection                  TINYINT = 3;  
  
    IF @MemberType_ID = @MemberType_Collection  
    BEGIN  
        SET @Ret = 0;  
    END  
    ELSE IF EXISTS(  
        SELECT 1  
        FROM mdm.viw_SYSTEM_SECURITY_USER_ENTITY  
        WHERE [User_ID] = @User_ID  
            AND ID = @Entity_ID  
            AND Privilege_ID = 5 /*Admin*/)  
    BEGIN  
        SET @Ret = 0;  
    END  
    ELSE IF EXISTS(  
        SELECT 1  
        FROM mdm.viw_SYSTEM_SECURITY_ROLE_MEMBER srm  
        INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_ROLE ur  
        ON ur.Role_ID = srm.Role_ID  
        WHERE srm.IsInitialized != 0  
            AND srm.Version_ID = @Version_ID  
            AND ur.[User_ID] = @User_ID  
            AND srm.[Entity_ID] = @Entity_ID  
            AND (@MemberType_ID IS NULL OR @MemberType_ID = @MemberType_Leaf OR LeafOnly != 1))  
    BEGIN  
        SET @Ret = 1;  
    END  
    ELSE  
    BEGIN  
        SET @Ret = 0;  
    END  
    RETURN @Ret;  
END
GO
/****** Object:  UserDefinedFunction [mdm].[udfUserIDGetByUserName]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
	SELECT mdm.udfUserIDGetByUserName('Administrator')  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE FUNCTION [mdm].[udfUserIDGetByUserName]  
(  
	@UserName	NVARCHAR(100)  
)   
RETURNS INT  
/*WITH SCHEMABINDING*/  
AS BEGIN  
	DECLARE @User_ID INT;  
	  
	SELECT 	@User_ID = U.ID   
	FROM 	mdm.tblUser AS U  
	WHERE	U.UserName = @UserName COLLATE Latin1_General_CI_AS  
	AND U.Status_ID = 1;  
		  
	RETURN @User_ID;  
END; --fn
GO
/****** Object:  UserDefinedFunction [mdm].[udfUserNameGetByUserID]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
  
SELECT mdm.udfUserNameGetByUserID(1)  
select * from mdm.tblUser  
  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE FUNCTION [mdm].[udfUserNameGetByUserID]  
(  
	@User_ID	INT  
)   
RETURNS NVARCHAR(100)  
/*WITH SCHEMABINDING*/  
AS BEGIN  
	DECLARE @UserName NVARCHAR(100)  
	  
	SELECT   
		@UserName = U.UserName   
	  
	FROM   
		mdm.tblUser U  
	  
	WHERE  
		U.ID = @User_ID  
	  
	  
	RETURN @UserName	     
  
END --fn
GO
/****** Object:  UserDefinedFunction [mdm].[udfViewNameGet]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
      
    SELECT mdm.udfViewNameGet(5, 42, 1, 0)  
*/  
CREATE FUNCTION [mdm].[udfViewNameGet]  
(  
    @Model_ID       INT,  
    @Entity_ID      INT,  
    @MemberType_ID  TINYINT,  
    @IsExplodedView BIT = 0, -- When 1, adds a 'EXP' suffix to the view name, which is exploded by hierarchy parent  
    @ViewType       TINYINT = 0 -- 0 EN, 1 PD, 2 HS  
)   
RETURNS SYSNAME  
/*WITH SCHEMABINDING*/  
AS BEGIN  
    DECLARE   
         @ViewNameSuffix                    SYSNAME  
        ,@MemberType_Leaf                   TINYINT = 1  
        ,@MemberType_Consolidated           TINYINT = 2  
        ,@MemberType_Collection             TINYINT = 3  
        ,@MemberType_ParentChild            TINYINT = 4  
        ,@MemberType_CollectionParentChild  TINYINT = 5  
  
        ,@ViewType_EN                       TINYINT = 0  
        ,@ViewType_PD                       TINYINT = 1  
        ,@ViewType_HS                       TINYINT = 2;  
  
    --Suffix for view name  
    IF @IsExplodedView = 1  
    BEGIN  
        SET @ViewNameSuffix = N'_EXP'  
    END;   
      
  
    RETURN CONCAT(N'viw_SYSTEM_', @Model_ID, N'_', @Entity_ID,  
        CASE @MemberType_ID  
            WHEN @MemberType_Leaf THEN  
                CASE @ViewType  
                    WHEN @ViewType_EN THEN CONCAT(N'_CHILDATTRIBUTES', @ViewNameSuffix)  
                    WHEN @ViewType_PD THEN N'_CHILDATTRIBUTES_PENDING'  
                    WHEN @ViewType_HS THEN CONCAT(N'_CHILDATTRIBUTES_HISTORY', @ViewNameSuffix)  
                 END  
            WHEN @MemberType_Consolidated THEN  
                CASE @ViewType  
                    WHEN @ViewType_EN THEN CONCAT(N'_PARENTATTRIBUTES', @ViewNameSuffix)  
                    WHEN @ViewType_HS THEN CONCAT(N'_PARENTATTRIBUTES_HISTORY', @ViewNameSuffix)  
                END  
            WHEN @MemberType_Collection THEN  
                CASE @ViewType  
                    WHEN @ViewType_EN THEN CONCAT(N'_COLLECTIONATTRIBUTES', @ViewNameSuffix)  
                    WHEN @ViewType_HS THEN CONCAT(N'_COLLECTIONATTRIBUTES_HISTORY', @ViewNameSuffix)  
                END  
            WHEN @MemberType_ParentChild THEN  
                CASE @ViewType  
                    WHEN @ViewType_EN THEN N'_PARENTCHILD'  
                    WHEN @ViewType_HS THEN N'_PARENTCHILD_HISTORY'  
                END  
            WHEN @MemberType_CollectionParentChild THEN  
                CASE @ViewType  
                    WHEN @ViewType_EN THEN N'_COLLECTIONPARENTCHILD'  
                    WHEN @ViewType_HS THEN N'_COLLECTIONPARENTCHILD_HISTORY'  
                END  
        END --case  
        );  
END; --fn
GO
/****** Object:  UserDefinedFunction [mdm].[udfViewNameGetByID]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
      
    SELECT mdm.udfViewNameGetByID(42,NULL,0)  
*/  
CREATE FUNCTION [mdm].[udfViewNameGetByID]  
(  
    @Entity_ID      INT,  
    @MemberType_ID  TINYINT = NULL,  
    @IsExplodedView BIT = 0, -- When 1, adds a 'EXP' suffix to the view name, which is exploded by hierarchy parent  
    @ViewType       TINYINT = 0 -- 0 EN, 1 PD, 2 HS  
)   
RETURNS sysname  
/*WITH SCHEMABINDING*/  
AS BEGIN  
    DECLARE @ViewName       SYSNAME,  
            @MemberType_Leaf                    TINYINT = 1,  
            @MemberType_Consolidated            TINYINT = 2,  
            @MemberType_Collection              TINYINT = 3,  
            @MemberType_ParentChild             TINYINT = 4,  
            @MemberType_CollectionParentChild   TINYINT = 5;  
  
    SELECT @ViewName = mdm.udfViewNameGet(Model_ID, @Entity_ID, @MemberType_ID, @IsExplodedView, @ViewType)  
    FROM mdm.tblEntity   
    WHERE ID = @Entity_ID  
        -- Ensure that the requested member type is supported  
        AND (@MemberType_ID = @MemberType_Leaf -- Leaf is always supported  
            OR (@MemberType_ID IN (@MemberType_Collection, @MemberType_CollectionParentChild) AND CollectionTable IS NOT NULL)  
            OR (@MemberType_ID IN (@MemberType_Consolidated, @MemberType_ParentChild) AND HierarchyTable IS NOT NULL)  
            )  
      
    RETURN @ViewName;  
END; --fn
GO
/****** Object:  UserDefinedFunction [mdq].[DateToString]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
CREATE FUNCTION [mdq].[DateToString](@input [datetime], @dateFormat [nvarchar](max))
RETURNS [nvarchar](max) WITH EXECUTE AS CALLER
AS 
EXTERNAL NAME [Microsoft.MasterDataServices.DataQuality].[Microsoft.MasterDataServices.DataQuality.SqlClr].[DateToString]
GO
/****** Object:  UserDefinedFunction [mdq].[IsBigInt]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
CREATE FUNCTION [mdq].[IsBigInt](@input [nvarchar](max))
RETURNS [bit] WITH EXECUTE AS CALLER
AS 
EXTERNAL NAME [Microsoft.MasterDataServices.DataQuality].[Microsoft.MasterDataServices.DataQuality.SqlClr].[IsBigInt]
GO
/****** Object:  UserDefinedFunction [mdq].[IsDateTime2]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
CREATE FUNCTION [mdq].[IsDateTime2](@input [nvarchar](max))
RETURNS [bit] WITH EXECUTE AS CALLER
AS 
EXTERNAL NAME [Microsoft.MasterDataServices.DataQuality].[Microsoft.MasterDataServices.DataQuality.SqlClr].[IsDateTime2]
GO
/****** Object:  UserDefinedFunction [mdq].[IsLink]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
CREATE FUNCTION [mdq].[IsLink](@input [nvarchar](max))
RETURNS [bit] WITH EXECUTE AS CALLER
AS 
EXTERNAL NAME [Microsoft.MasterDataServices.DataQuality].[Microsoft.MasterDataServices.DataQuality.SqlClr].[IsLink]
GO
/****** Object:  UserDefinedFunction [mdq].[IsNumber]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
CREATE FUNCTION [mdq].[IsNumber](@input [nvarchar](max))
RETURNS [bit] WITH EXECUTE AS CALLER
AS 
EXTERNAL NAME [Microsoft.MasterDataServices.DataQuality].[Microsoft.MasterDataServices.DataQuality.SqlClr].[IsNumber]
GO
/****** Object:  UserDefinedFunction [mdq].[NGrams]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
CREATE FUNCTION [mdq].[NGrams](@input [nvarchar](4000), @n [tinyint] = 3, @padSpace [bit] = False)
RETURNS  TABLE (
	[Sequence] [int] NULL,
	[Token] [nvarchar](255) NULL
) WITH EXECUTE AS CALLER
AS 
EXTERNAL NAME [Microsoft.MasterDataServices.DataQuality].[Microsoft.MasterDataServices.DataQuality.SqlClr].[NGrams]
GO
/****** Object:  UserDefinedFunction [mdq].[RegexExtract]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
CREATE FUNCTION [mdq].[RegexExtract](@input [nvarchar](4000), @pattern [nvarchar](4000), @group [nvarchar](4000), @mask [tinyint])
RETURNS [nvarchar](4000) WITH EXECUTE AS CALLER, RETURNS NULL ON NULL INPUT
AS 
EXTERNAL NAME [Microsoft.MasterDataServices.DataQuality].[Microsoft.MasterDataServices.DataQuality.SqlClr].[RegexExtract]
GO
/****** Object:  UserDefinedFunction [mdq].[RegexIsMatch]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
CREATE FUNCTION [mdq].[RegexIsMatch](@input [nvarchar](4000), @pattern [nvarchar](4000), @mask [tinyint])
RETURNS [bit] WITH EXECUTE AS CALLER, RETURNS NULL ON NULL INPUT
AS 
EXTERNAL NAME [Microsoft.MasterDataServices.DataQuality].[Microsoft.MasterDataServices.DataQuality.SqlClr].[RegexIsMatch]
GO
/****** Object:  UserDefinedFunction [mdq].[RegexIsValid]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
CREATE FUNCTION [mdq].[RegexIsValid](@pattern [nvarchar](4000))
RETURNS [bit] WITH EXECUTE AS CALLER, RETURNS NULL ON NULL INPUT
AS 
EXTERNAL NAME [Microsoft.MasterDataServices.DataQuality].[Microsoft.MasterDataServices.DataQuality.SqlClr].[RegexIsValid]
GO
/****** Object:  UserDefinedFunction [mdq].[RegexMask]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
CREATE FUNCTION [mdq].[RegexMask](@cultureInvariant [bit], @explicitCapture [bit], @ignoreCase [bit], @ignorePatternWhiteSpace [bit], @multiline [bit], @rightToLeft [bit], @singleLine [bit])
RETURNS [tinyint] WITH EXECUTE AS CALLER, RETURNS NULL ON NULL INPUT
AS 
EXTERNAL NAME [Microsoft.MasterDataServices.DataQuality].[Microsoft.MasterDataServices.DataQuality.SqlClr].[RegexMask]
GO
/****** Object:  UserDefinedFunction [mdq].[RegexMatches]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
CREATE FUNCTION [mdq].[RegexMatches](@input [nvarchar](4000), @pattern [nvarchar](4000), @mask [tinyint] = 0)
RETURNS  TABLE (
	[Sequence] [int] NULL,
	[Token] [nvarchar](4000) NULL
) WITH EXECUTE AS CALLER
AS 
EXTERNAL NAME [Microsoft.MasterDataServices.DataQuality].[Microsoft.MasterDataServices.DataQuality.SqlClr].[RegexMatches]
GO
/****** Object:  UserDefinedFunction [mdq].[RegexReplace]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
CREATE FUNCTION [mdq].[RegexReplace](@input [nvarchar](4000), @pattern [nvarchar](4000), @replace [nvarchar](4000), @mask [tinyint])
RETURNS [nvarchar](4000) WITH EXECUTE AS CALLER, RETURNS NULL ON NULL INPUT
AS 
EXTERNAL NAME [Microsoft.MasterDataServices.DataQuality].[Microsoft.MasterDataServices.DataQuality.SqlClr].[RegexReplace]
GO
/****** Object:  UserDefinedFunction [mdq].[RegexSplit]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
CREATE FUNCTION [mdq].[RegexSplit](@input [nvarchar](4000), @splitPattern [nvarchar](4000), @tokenPattern [nvarchar](4000), @mask [tinyint])
RETURNS  TABLE (
	[Sequence] [int] NULL,
	[Token] [nvarchar](4000) NULL,
	[IsValid] [bit] NULL
) WITH EXECUTE AS CALLER
AS 
EXTERNAL NAME [Microsoft.MasterDataServices.DataQuality].[Microsoft.MasterDataServices.DataQuality.SqlClr].[RegexSplitWithCheck]
GO
/****** Object:  UserDefinedFunction [mdq].[Similarity]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
CREATE FUNCTION [mdq].[Similarity](@input1 [nvarchar](4000), @input2 [nvarchar](4000), @method [tinyint], @containmentBias [float], @minScoreHint [float])
RETURNS [float] WITH EXECUTE AS CALLER, RETURNS NULL ON NULL INPUT
AS 
EXTERNAL NAME [Microsoft.MasterDataServices.DataQuality].[Microsoft.MasterDataServices.DataQuality.SqlClr].[Similarity]
GO
/****** Object:  UserDefinedFunction [mdq].[SimilarityDate]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
CREATE FUNCTION [mdq].[SimilarityDate](@date1 [datetime], @date2 [datetime])
RETURNS [float] WITH EXECUTE AS CALLER, RETURNS NULL ON NULL INPUT
AS 
EXTERNAL NAME [Microsoft.MasterDataServices.DataQuality].[Microsoft.MasterDataServices.DataQuality.SqlClr].[SimilarityDate]
GO
/****** Object:  UserDefinedFunction [mdq].[Split]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
CREATE FUNCTION [mdq].[Split](@input [nvarchar](4000), @separators [nvarchar](10), @removeEmpty [bit], @tokenPattern [nvarchar](4000), @mask [tinyint])
RETURNS  TABLE (
	[Sequence] [int] NULL,
	[Token] [nvarchar](4000) NULL,
	[IsValid] [bit] NULL
) WITH EXECUTE AS CALLER
AS 
EXTERNAL NAME [Microsoft.MasterDataServices.DataQuality].[Microsoft.MasterDataServices.DataQuality.SqlClr].[SplitWithCheck]
GO
/****** Object:  UserDefinedFunction [mdq].[XmlTransform]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
CREATE FUNCTION [mdq].[XmlTransform](@xml [xml], @xslt [xml])
RETURNS [nvarchar](max) WITH EXECUTE AS CALLER, RETURNS NULL ON NULL INPUT
AS 
EXTERNAL NAME [Microsoft.MasterDataServices.DataQuality].[Microsoft.MasterDataServices.DataQuality.SqlClr].[XmlTransform]
GO
/****** Object:  Table [mdm].[tblList]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [mdm].[tblList](
	[ID] [int] IDENTITY(1,1) NOT NULL,
	[ListCode] [nvarchar](50) NOT NULL,
	[ListName] [nvarchar](50) NOT NULL,
	[Seq] [int] NOT NULL,
	[ListOption] [nvarchar](250) NOT NULL,
	[OptionID] [int] NOT NULL,
	[IsVisible] [bit] NOT NULL,
	[Group_ID] [int] NOT NULL,
 CONSTRAINT [pk_tblList] PRIMARY KEY CLUSTERED 
(
	[ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  UserDefinedFunction [mdm].[udfTransactionGetByTransactionType]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
--SELECT * FROM mdm.udfTransactionGetByTransactionType(2)  
  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE FUNCTION [mdm].[udfTransactionGetByTransactionType] (@TransactionType_ID INT)   
RETURNS TABLE  
/*WITH SCHEMABINDING*/  
AS  
RETURN  
	SELECT OptionID ID, ListOption Code   
	FROM mdm.tblList   
	WHERE ListCode = CAST(N'lstTransaction' AS NVARCHAR(50)) AND Group_ID = @TransactionType_ID
GO
/****** Object:  Table [mdm].[tblUserGroupAssignment]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [mdm].[tblUserGroupAssignment](
	[ID] [int] IDENTITY(1,1) NOT NULL,
	[MUID] [uniqueidentifier] NOT NULL,
	[UserGroup_ID] [int] NOT NULL,
	[User_ID] [int] NOT NULL,
	[EnterDTM] [datetime2](3) NOT NULL,
	[EnterUserID] [int] NOT NULL,
	[LastChgDTM] [datetime2](3) NOT NULL,
	[LastChgUserID] [int] NOT NULL,
 CONSTRAINT [pk_tblUserGroupAssignment] PRIMARY KEY CLUSTERED 
(
	[ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [mdm].[tblSecurityAccessControl]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [mdm].[tblSecurityAccessControl](
	[ID] [int] IDENTITY(1,1) NOT NULL,
	[PrincipalType_ID] [int] NOT NULL,
	[Principal_ID] [int] NOT NULL,
	[Role_ID] [int] NOT NULL,
	[Description] [nvarchar](110) NULL,
	[EnterDTM] [datetime2](3) NOT NULL,
	[EnterUserID] [int] NOT NULL,
	[LastChgDTM] [datetime2](3) NOT NULL,
	[LastChgUserID] [int] NOT NULL,
	[MUID] [uniqueidentifier] NOT NULL,
 CONSTRAINT [pk_tblSecurityAccessControl] PRIMARY KEY CLUSTERED 
(
	[ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [mdm].[tblUser]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [mdm].[tblUser](
	[ID] [int] IDENTITY(1,1) NOT NULL,
	[MUID] [uniqueidentifier] NOT NULL,
	[Status_ID] [tinyint] NOT NULL,
	[SID] [nvarchar](250) NULL,
	[UserName] [nvarchar](100) NOT NULL,
	[DisplayName] [nvarchar](256) NOT NULL,
	[Description] [nvarchar](500) NULL,
	[EmailAddress] [nvarchar](100) NULL,
	[LastLoginDTM] [datetime2](3) NULL,
	[EnterDTM] [datetime2](3) NOT NULL,
	[EnterUserID] [int] NOT NULL,
	[LastChgDTM] [datetime2](3) NOT NULL,
	[LastChgUserID] [int] NOT NULL,
 CONSTRAINT [pk_tblUser] PRIMARY KEY CLUSTERED 
(
	[ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [mdm].[tblSecurityRoleAccessFunctional]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [mdm].[tblSecurityRoleAccessFunctional](
	[ID] [int] IDENTITY(1,1) NOT NULL,
	[MUID] [uniqueidentifier] NOT NULL,
	[Role_ID] [int] NOT NULL,
	[FunctionalPrivilege_ID] [tinyint] NOT NULL,
	[EnterDTM] [datetime2](3) NOT NULL,
	[EnterUserID] [int] NOT NULL,
	[LastChgDTM] [datetime2](3) NOT NULL,
	[LastChgUserID] [int] NOT NULL,
 CONSTRAINT [pk_tblSecurityRoleAccessFunctional] PRIMARY KEY CLUSTERED 
(
	[ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [mdm].[tblUserGroup]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [mdm].[tblUserGroup](
	[ID] [int] IDENTITY(1,1) NOT NULL,
	[MUID] [uniqueidentifier] NOT NULL,
	[UserGroupType_ID] [tinyint] NOT NULL,
	[Status_ID] [tinyint] NOT NULL,
	[SID] [nvarchar](250) NULL,
	[Name] [nvarchar](355) NOT NULL,
	[Description] [nvarchar](500) NULL,
	[EnterDTM] [datetime2](3) NOT NULL,
	[EnterUserID] [int] NOT NULL,
	[LastChgDTM] [datetime2](3) NOT NULL,
	[LastChgUserID] [int] NOT NULL,
 CONSTRAINT [pk_tblUserGroup] PRIMARY KEY CLUSTERED 
(
	[ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [mdm].[tblSecurityPrivilegeFunctional]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [mdm].[tblSecurityPrivilegeFunctional](
	[ID] [tinyint] IDENTITY(1,1) NOT NULL,
	[Name] [nvarchar](50) NOT NULL,
 CONSTRAINT [pk_tblSecurityPrivilegeFunctional] PRIMARY KEY CLUSTERED 
(
	[ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  View [mdm].[viw_SYSTEM_SECURITY_ROLE_ACCESSCONTROL_FUNCTIONAL]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE VIEW [mdm].[viw_SYSTEM_SECURITY_ROLE_ACCESSCONTROL_FUNCTIONAL]  
/*WITH SCHEMABINDING*/  
AS  
  
SELECT   
     ra.ID                      RoleAccess_ID  
    ,ra.MUID                    RoleAccess_MUID  
    ,ra.Role_ID  
  
    ,ac.Principal_ID  
    ,CASE ac.PrincipalType_ID WHEN 1 /*User*/ THEN u.MUID ELSE ug.MUID END Principal_MUID  
    ,ac.PrincipalType_ID  
    ,CASE ac.PrincipalType_ID WHEN 1 /*User*/ THEN u.UserName ELSE ug.Name END Principal_Name  
  
    ,ra.FunctionalPrivilege_ID  Function_ID  
    ,f.Name                     Function_Name  
  
    --Auditing  
    ,ra.EnterDTM  
    ,ra.EnterUserID  
    ,COALESCE(eu.MUID, CONVERT(UNIQUEIDENTIFIER, 0x0))  EnterUserMUID  
    ,COALESCE(eu.UserName, N'')                         EnterUserName  
    ,ra.LastChgDTM  
    ,ra.LastChgUserID  
    ,COALESCE(lcu.MUID, CONVERT(UNIQUEIDENTIFIER, 0x0)) LastChgUserMUID  
    ,COALESCE(lcu.UserName, N'')                        LastChgUserName  
FROM mdm.tblSecurityRoleAccessFunctional ra  
INNER JOIN mdm.tblSecurityPrivilegeFunctional f  
ON ra.FunctionalPrivilege_ID = f.ID  
INNER JOIN  mdm.tblSecurityAccessControl ac  
ON ra.Role_ID = ac.Role_ID  
LEFT JOIN mdm.tblUserGroup ug  
ON      ac.PrincipalType_ID = 2 -- Group  
    AND ac.Principal_ID = ug.ID  
    AND ug.Status_ID = 1 -- Active  
LEFT JOIN mdm.tblUser u  
ON      ac.PrincipalType_ID = 1 -- User  
    AND ac.Principal_ID = u.ID  
    AND u.Status_ID = 1 -- Active  
LEFT JOIN  mdm.tblUser eu  
ON ra.EnterUserID = eu.ID  
LEFT JOIN  mdm.tblUser lcu  
ON ra.LastChgUserID = lcu.ID
GO
/****** Object:  View [mdm].[viw_SYSTEM_SECURITY_USER_FUNCTION]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE VIEW [mdm].[viw_SYSTEM_SECURITY_USER_FUNCTION]  
/*WITH SCHEMABINDING*/  
AS  
SELECT  
     RoleAccess_ID  
    ,RoleAccess_MUID  
  
    ,Principal_ID   [User_ID]  
    ,Principal_MUID User_MUID  
    ,Principal_Name UserName  
  
    ,Principal_ID  
    ,Principal_MUID  
    ,PrincipalType_ID  
    ,Principal_Name  
  
    ,Function_ID  
    ,Function_Name  
  
    --Auditing  
    ,EnterDTM  
    ,EnterUserID  
    ,EnterUserMUID  
    ,EnterUserName  
    ,LastChgDTM  
    ,LastChgUserID  
    ,LastChgUserMUID  
    ,LastChgUserName  
FROM mdm.viw_SYSTEM_SECURITY_ROLE_ACCESSCONTROL_FUNCTIONAL  
WHERE PrincipalType_ID = 1 -- User  
  
UNION ALL  
SELECT  
     f.RoleAccess_ID  
    ,f.RoleAccess_MUID  
  
    ,u.ID   [User_ID]  
    ,u.MUID User_MUID  
    ,u.UserName  
  
    ,f.Principal_ID  
    ,f.Principal_MUID  
    ,f.PrincipalType_ID  
    ,f.Principal_Name  
  
    ,f.Function_ID  
    ,f.Function_Name  
  
    --Auditing  
    ,f.EnterDTM  
    ,f.EnterUserID  
    ,f.EnterUserMUID  
    ,f.EnterUserName  
    ,f.LastChgDTM  
    ,f.LastChgUserID  
    ,f.LastChgUserMUID  
    ,f.LastChgUserName  
FROM mdm.viw_SYSTEM_SECURITY_ROLE_ACCESSCONTROL_FUNCTIONAL f  
INNER JOIN mdm.tblUserGroup AS ug   
ON f.Principal_ID = ug.ID AND ug.Status_ID = 1 -- Active  
INNER JOIN mdm.tblUserGroupAssignment AS uga  
ON ug.ID = uga.UserGroup_ID  
INNER JOIN mdm.tblUser AS u   
ON uga.[User_ID] = u.ID   AND u.Status_ID = 1 -- Active  
WHERE f.PrincipalType_ID = 2 -- Group
GO
/****** Object:  UserDefinedFunction [mdm].[udfSecurityUserFunctionList]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
Returns a list of functions available for an active user  
  
Example 1  : SELECT * FROM mdm.udfSecurityUserFunctionList(NULL)  
Example 2  : SELECT * FROM mdm.udfSecurityUserFunctionList(2)  
*/  
CREATE FUNCTION [mdm].[udfSecurityUserFunctionList]   
(  
    @User_ID INT = NULL  
)  
RETURNS TABLE   
/*WITH SCHEMABINDING*/  
AS RETURN  
    WITH permission AS (  
        SELECT RoleAccess_ID  
            ,RoleAccess_MUID  
  
            ,Principal_ID  
            ,Principal_MUID  
            ,PrincipalType_ID  
            ,Principal_Name  
  
            ,Function_ID  
            ,Function_Name  
  
            --Auditing  
            ,EnterDTM  
            ,EnterUserID  
            ,EnterUserMUID  
            ,EnterUserName  
            ,LastChgDTM  
            ,LastChgUserID  
            ,LastChgUserMUID  
            ,LastChgUserName  
            ,ROW_NUMBER() OVER (PARTITION BY Function_ID ORDER BY PrincipalType_ID, RoleAccess_ID DESC) AS rk  
        FROM mdm.viw_SYSTEM_SECURITY_USER_FUNCTION  
        WHERE @User_ID IS NULL OR @User_ID = [User_ID]  
    )  
    SELECT  
         RoleAccess_ID  
        ,RoleAccess_MUID  
  
        ,Principal_ID  
        ,Principal_MUID  
        ,PrincipalType_ID  
        ,Principal_Name  
  
        ,Function_ID  
        ,Function_Name  
  
        --Auditing  
        ,EnterDTM  
        ,EnterUserID  
        ,EnterUserMUID  
        ,EnterUserName  
        ,LastChgDTM  
        ,LastChgUserID  
        ,LastChgUserMUID  
        ,LastChgUserName  
    FROM permission  
    WHERE rk = 1
GO
/****** Object:  Table [mdm].[tblEntity]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [mdm].[tblEntity](
	[ID] [int] IDENTITY(1,1) NOT NULL,
	[MUID] [uniqueidentifier] NOT NULL,
	[Model_ID] [int] NOT NULL,
	[Name] [nvarchar](50) NOT NULL,
	[Description] [nvarchar](500) NULL,
	[EntityTable] [sysname] NOT NULL,
	[HierarchyTable] [sysname] NULL,
	[HierarchyParentTable] [sysname] NULL,
	[CollectionTable] [sysname] NULL,
	[CollectionMemberTable] [sysname] NULL,
	[IsBase] [bit] NOT NULL,
	[EnterDTM] [datetime2](3) NOT NULL,
	[EnterUserID] [int] NOT NULL,
	[EnterVersionID] [int] NOT NULL,
	[LastChgDTM] [datetime2](3) NOT NULL,
	[LastChgUserID] [int] NOT NULL,
	[LastChgVersionID] [int] NOT NULL,
	[LastChgTS] [timestamp] NOT NULL,
	[StagingBase] [nvarchar](60) NULL,
	[StagingLeafName]  AS ([StagingBase]+'_Leaf'),
	[StagingConsolidatedName]  AS ([StagingBase]+'_Consolidated'),
	[StagingRelationshipName]  AS ([StagingBase]+'_Relationship'),
	[DataCompression] [tinyint] NOT NULL,
	[TransactionLogType] [tinyint] NOT NULL,
	[RequireApproval] [bit] NOT NULL,
 CONSTRAINT [pk_tblEntity] PRIMARY KEY CLUSTERED 
(
	[ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY],
 CONSTRAINT [ux_tblEntity_Model_ID_Name] UNIQUE NONCLUSTERED 
(
	[Model_ID] ASC,
	[Name] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY],
 CONSTRAINT [ux_tblEntity_MUID] UNIQUE NONCLUSTERED 
(
	[MUID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [mdm].[tblAttribute]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [mdm].[tblAttribute](
	[ID] [int] IDENTITY(1,1) NOT NULL,
	[MUID] [uniqueidentifier] NOT NULL,
	[Source_ID] [int] NULL,
	[Source_LastChgTS] [varbinary](8) NULL,
	[Entity_ID] [int] NOT NULL,
	[MemberType_ID] [tinyint] NOT NULL,
	[DisplayName] [nvarchar](250) NOT NULL,
	[Name] [nvarchar](100) NOT NULL,
	[Description] [nvarchar](500) NULL,
	[TableColumn] [sysname] NOT NULL,
	[AttributeType_ID] [tinyint] NOT NULL,
	[DataType_ID] [tinyint] NOT NULL,
	[DataTypeInformation] [int] NULL,
	[InputMask_ID] [int] NOT NULL,
	[DisplayWidth] [int] NOT NULL,
	[SortOrder] [int] NOT NULL,
	[DomainEntity_ID] [int] NULL,
	[ChangeTrackingGroup] [int] NOT NULL,
	[FilterParentAttribute_ID] [int] NULL,
	[FilterHierarchyDetail_ID] [int] NULL,
	[IsCode] [bit] NOT NULL,
	[IsName] [bit] NOT NULL,
	[IsSystem] [bit] NOT NULL,
	[IsReadOnly] [bit] NOT NULL,
	[IsRequired] [bit] NOT NULL,
	[EnterDTM] [datetime2](3) NOT NULL,
	[EnterUserID] [int] NOT NULL,
	[EnterVersionID] [int] NOT NULL,
	[LastChgDTM] [datetime2](3) NOT NULL,
	[LastChgUserID] [int] NOT NULL,
	[LastChgVersionID] [int] NOT NULL,
	[LastChgTS] [timestamp] NOT NULL,
 CONSTRAINT [pk_tblAttribute] PRIMARY KEY CLUSTERED 
(
	[ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY],
 CONSTRAINT [ux_tblAttribute_Entity_ID_MemberType_ID_DisplayName] UNIQUE NONCLUSTERED 
(
	[Entity_ID] ASC,
	[MemberType_ID] ASC,
	[DisplayName] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY],
 CONSTRAINT [ux_tblAttribute_Entity_ID_MemberType_ID_Name] UNIQUE NONCLUSTERED 
(
	[Entity_ID] ASC,
	[MemberType_ID] ASC,
	[Name] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY],
 CONSTRAINT [ux_tblAttribute_Entity_ID_MemberType_ID_TableColumn] UNIQUE NONCLUSTERED 
(
	[Entity_ID] ASC,
	[MemberType_ID] ASC,
	[TableColumn] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY],
 CONSTRAINT [ux_tblAttribute_MUID] UNIQUE NONCLUSTERED 
(
	[MUID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  UserDefinedFunction [mdm].[udfEntityDependencyTree]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    Gets the default entity processing sequence for a model.  The default processing sequence is based on the relationships between entities via  
    domain-based attributes.  
  
    SELECT * FROM mdm.udfEntityDependencyTree(1) ORDER BY [Level];  
    SELECT * FROM mdm.udfEntityDependencyTree(7) ORDER BY [Level];  
    SELECT * FROM mdm.udfEntityDependencyTree(NULL) ORDER BY [Level];  
*/  
CREATE FUNCTION [mdm].[udfEntityDependencyTree]   
(  
    @Model_ID   INT    --NULL returns all Models  
)  
RETURNS TABLE   
/*WITH SCHEMABINDING*/  
AS   
    RETURN  
    --The [Base] CTE contains all data from the Entity table, in a convenient but unfiltered format  
    WITH Base AS (  
        SELECT DISTINCT  
            E.Model_ID,  
            E.ID AS Entity_ID,   
            E.[Name], --included for debugging purposes  
            A.MemberType_ID,  
            CASE A.MemberType_ID  
                WHEN 1 THEN E.EntityTable  
                WHEN 2 THEN E.HierarchyParentTable  
                WHEN 3 THEN E.CollectionTable  
                WHEN 4 THEN E.HierarchyTable  
                WHEN 5 THEN E.CollectionMemberTable  
            END AS TableName,  
            NULLIF(A.DomainEntity_ID, E.ID) AS DomainEntity_ID --Ignore self referencing DBA  
        FROM mdm.tblEntity AS E  
        INNER JOIN mdm.tblAttribute AS A ON E.ID = A.Entity_ID  
        WHERE E.Model_ID = ISNULL(@Model_ID, Model_ID)  
    ),  
    --The [Recurse] CTE uses leaf DBAs as the root, and recurses all Entities that point to them  
    Recurse AS (  
        --Anchor clause returns all Entities that are leaf DBAs (ie have no DBAs themselves)  
        SELECT DISTINCT  
            Entity_ID  
            ,0 AS [Level]   
            ,CAST(Entity_ID AS NVARCHAR(MAX)) AS EntityIDPath -- Used to prevent endless loop with circular references.  
            ,0 AS [EntityOccurrenceCount] -- Used to prevent endless loop with circular references.  
        FROM Base  
        WHERE DomainEntity_ID IS NULL   
        AND Entity_ID = ISNULL(NULL, Entity_ID)  
  
        UNION ALL --Recursive conjunct  
  
        --Recursive clause returns all Entities that point to the leaf DBAs  
        SELECT   
             b.Entity_ID  
            ,r.[Level] + 1   
            ,r.EntityIDPath + N'/' + CAST(b.Entity_ID AS NVARCHAR(MAX)) AS EntityIDPath -- Used to prevent endless loop with circular references.  
            ,mdm.udfGetStringOccurrenceCount(r.EntityIDPath, b.Entity_ID) AS EntityOccurrenceCount -- Used to prevent endless loop with circular references.  
        FROM Base AS b   
        INNER JOIN Recurse AS r   
            ON (b.DomainEntity_ID = r.Entity_ID)  
            AND EntityOccurrenceCount < 2 -- A value > 1 indicates a circular reference.]  
    ),  
    --The [Explode] CTE adds back in all the other member tables (_HP, CN, etc) since the recursed tables are only _EN  
    Explode AS (  
        SELECT b.Model_ID, b.Entity_ID, b.[Name], b.MemberType_ID, b.TableName, b.DomainEntity_ID, r.[Level]  
        FROM Base AS b   
        INNER JOIN Recurse AS r ON (b.Entity_ID = r.Entity_ID)  
    ),  
    --Finally we group the results (since there might be duplicates due to common DBAs) and return them to the caller  
    Final AS (  
        SELECT Model_ID, Entity_ID, MemberType_ID, [Name], TableName, MAX([Level]) AS [Level]  
        FROM Explode  
        GROUP BY Model_ID, Entity_ID, MemberType_ID, [Name], TableName  
    )  
    SELECT   
        Model_ID, Entity_ID, MemberType_ID, [Name], TableName,  
        ROW_NUMBER() OVER (ORDER BY Model_ID, [Level], Entity_ID, MemberType_ID) AS [Level]  
    FROM Final;
GO
/****** Object:  UserDefinedFunction [mdm].[udfEntityGetProcessingSequence]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
    Gets the entity processing sequence for a model.  The default processing sequence is based on the relationships between entities via  
    domain-based attributes.  However, because of circular relationships this default sequence cannot be deterministically ordered.  In   
    this case derived hierarchies (there can be multiple) can be used to drive the relationship sequencing.    
      
    Here is how the DH Priority is used.  The way to read this is a priority of �1� is the most important therefore will go last  
    in the process.    
  
    DH  Priority             Processed  
    --- -------------------- ---------  
    DH3 3 (least important)  1st   
    DH2 2                    2nd   
    DH1 1 (most important)   3rd   
   
    Assume a scenario where multiple DHs are marked with a processing priority.  Using the sample Product model.  The product model  
    has these entities, in no particular order.  
  
    ID Name  
    -- ------------  
    33 Category  
    37 Class  
    35 Color  
    39 CountryRegion  
    31 Product  
    34 ProductGroup  
    36 SizeRange  
    38 Style  
    32 SubCategory  
   
    Given these two DHs.  
  
    Category: Priority = 1  
  
    Level ID Name  
    ----- -- -------------  
    3     34 ProductGroup  
    2     33 Category  
    1     32 SubCategory  
    0     31 Product  
   
    Market: Priority = 2  
    Level ID Name  
    ----- -- -------------  
    1     39 CountryRegion  
    0     31 Product  
   
    Any DHs that have a Priority > 1 will have duplicate entities filtered out, so Market DH will have the Product entity filtered out.    
    And the other entity, CountryRegion, will be processed before the ProductGroup entity, which is defined in the Category DH.  Assuming we have  
    a circular ref where the ProductGroup entity has a DBA for Product (ProductGroup.ProductDba) calling udpEntityGetProcessingSequence   
    gives us this sequence.  
  
    Entity_ID Processing Sequence  
    --------- -------------------  
    39        1  
    38        2  
    37        3  
    36        4  
    35        5  
    34        6  
    33        7  
    32        8  
    31        9  
  
    If there is a circular ref situation and two DHs that defined the relationship both ways can be handled as well.  Given a circular   
    ref between Product and SubCategory so:  
  
    Product.SubCategoryDba --> SubCategory  
    SubCategory.ProductDba --> Product  
  
    DH1: ProcessingPriority = 1  
    Level ID Name  
    ----- -- -------------  
    1     32 SubCategory  
    0     31 Product  
  
    DH2: ProcessingPriority = 2  
    Level ID Name  
    ----- -- -------------  
    1     31 Product  
    0     32 SubCategory  
   
    Because both entities of DH2 have already been defined in DH1 and DH1 has a �higher� priority the DH2 entities are ignored or filtered out.  
  
	SELECT Entity_ID, [Level] AS RelativeOrder_ID FROM mdm.udfEntityDependencyTree(7) WHERE MemberType_ID = 1 ORDER BY [Level] DESC;  
	SELECT * FROM mdm.udfEntityGetProcessingSequence(7) ORDER BY [Level];  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE FUNCTION [mdm].[udfEntityGetProcessingSequence]  
(  
	@Model_ID	INT  
)  
RETURNS TABLE   
/*WITH SCHEMABINDING*/  
AS   
	RETURN  
      
    WITH ProcessPriorityExplode AS (  
        --Gets sequence based solely on entity relationships.  This is our default sequence and is given a low priority    
        --so the DH processing priorities, if specified, will be ranked higher.  If entity circular references are in place  
        --udfEntityDependencyTree, which uses a recursive CTE, will return an entity sequence, but it will be   
        --non-deterministic.    
        SELECT   
             2147483647 AS Priority   
            ,[Level] AS RelativeOrder_ID  
            ,Entity_ID  
        FROM mdm.udfEntityDependencyTree(@Model_ID)   
        WHERE MemberType_ID = 1 -- Leaf   
    ),  
    --Gives a distinct list of entities, associated with the lowest Priority they are associated with (removes duplicates)  
    EntityProcessPriority AS (  
        SELECT   
             MIN(Priority) AS Priority  
            ,Entity_ID           
        FROM ProcessPriorityExplode   
        GROUP BY Entity_ID  
    )    
    --Get the overall ranking from the explode and combine to give distinct entity records, eliminating the duplicates from less important   
    --DHs, this orders by DH priority in DESC and then sorts within that by the relative level DESC.  
    SELECT   
         epp.Entity_ID  
        ,ROW_NUMBER() OVER (ORDER BY epp.Priority DESC, explode.RelativeOrder_ID DESC) AS [Level]  
    FROM ProcessPriorityExplode AS explode  
    INNER JOIN EntityProcessPriority AS epp   
        ON explode.Priority = epp.Priority AND explode.Entity_ID = epp.Entity_ID;
GO
/****** Object:  Table [mdm].[tblListRelationship]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [mdm].[tblListRelationship](
	[ID] [int] IDENTITY(1,1) NOT NULL,
	[ParentListCode] [nvarchar](50) NOT NULL,
	[Parent_ID] [int] NOT NULL,
	[ChildListCode] [nvarchar](50) NOT NULL,
	[Child_ID] [int] NOT NULL,
	[ListRelationshipType_ID] [int] NOT NULL,
 CONSTRAINT [pk_tblListRelationship] PRIMARY KEY CLUSTERED 
(
	[ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [mdm].[tblBRItemTypeAppliesTo]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [mdm].[tblBRItemTypeAppliesTo](
	[ID] [int] IDENTITY(1,1) NOT NULL,
	[BRItemType_ID] [int] NOT NULL,
	[ApplyTo_ID] [int] NOT NULL,
	[Sequence] [int] NULL,
 CONSTRAINT [pk_tblBRItemTypeAppliesTo] PRIMARY KEY CLUSTERED 
(
	[ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [mdm].[tblListRelationshipType]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [mdm].[tblListRelationshipType](
	[ID] [int] IDENTITY(1,1) NOT NULL,
	[Name] [nvarchar](50) NOT NULL,
 CONSTRAINT [pk_tblListRelationshipType] PRIMARY KEY CLUSTERED 
(
	[ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  View [mdm].[viw_SYSTEM_SCHEMA_BUSINESSRULE_ITEMTYPES]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    SELECT * FROM mdm.viw_SYSTEM_SCHEMA_BUSINESSRULE_ITEMTYPES  
    SELECT * FROM mdm.viw_SYSTEM_SCHEMA_BUSINESSRULE_ITEMTYPES WHERE ApplyToCategoryID = 2 AND BRSubTypeIsVisible = 1 order by DisplaySequence, DisplaySubSequence  
    SELECT * FROM mdm.viw_SYSTEM_SCHEMA_BUSINESSRULE_ITEMTYPES WHERE BRItemType_ID = 28  
*/  
CREATE VIEW [mdm].[viw_SYSTEM_SCHEMA_BUSINESSRULE_ITEMTYPES]  
/*WITH SCHEMABINDING*/  
AS  
SELECT  
        apl.ID AS AppliesTo_ID,  
        apl.ApplyTo_ID,  
        lrt.ID AS ApplyToCategoryID,  
        lrt.Name AS ApplyToCategory,  
        1 AS BRTypeID,  
        lr.Child_ID  AS BRSubTypeID,  
        1 AS BRSubTypeIsVisible,  
        apl.BRItemType_ID,  
        lr.Child_ID AS DisplaySequence,  
        ISNULL(apl.Sequence,-1) AS DisplaySubSequence  
FROM    mdm.tblBRItemTypeAppliesTo apl INNER JOIN  
        mdm.tblListRelationship lr ON lr.ID = apl.ApplyTo_ID INNER JOIN  
        mdm.tblListRelationshipType lrt ON lrt.ID = lr.ListRelationshipType_ID and lrt.ID = 1  
UNION ALL  
SELECT  
        apl.ID AS AppliesTo_ID,  
        apl.ApplyTo_ID,  
        lrt.ID AS ApplyToCategoryID,  
        lrt.Name AS ApplyToCategory,  
        p.OptionID AS BRTypeID,  
        c.OptionID AS BRSubTypeID,  
        c.IsVisible AS BRSubTypeIsVisible,  
        apl.BRItemType_ID,  
        c.Seq AS DisplaySequence,  
        ISNULL(apl.Sequence,-1) AS DisplaySubSequence  
FROM    mdm.tblBRItemTypeAppliesTo apl INNER JOIN  
        mdm.tblListRelationship lr ON lr.ID = apl.ApplyTo_ID INNER JOIN  
        mdm.tblListRelationshipType lrt ON lrt.ID = lr.ListRelationshipType_ID and lrt.ID = 2 INNER JOIN  
        mdm.tblList p ON p.OptionID = lr.Parent_ID AND p.ListCode = N'lstBRItemTypeCategory' INNER JOIN  
        mdm.tblList c ON c.OptionID = lr.Child_ID AND c.ListCode = N'lstBRItemTypeSubCategory'
GO
/****** Object:  Table [mdm].[tblSystemSetting]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [mdm].[tblSystemSetting](
	[ID] [int] IDENTITY(1,1) NOT NULL,
	[IsVisible] [bit] NOT NULL,
	[SettingName] [nvarchar](100) NOT NULL,
	[SettingValue] [nvarchar](max) NOT NULL,
	[DisplayName] [nvarchar](100) NOT NULL,
	[Description] [nvarchar](250) NOT NULL,
	[SettingType_ID] [tinyint] NOT NULL,
	[DataType_ID] [tinyint] NOT NULL,
	[MinValue] [nvarchar](200) NULL,
	[MaxValue] [nvarchar](200) NULL,
	[ListCode] [nvarchar](50) NULL,
	[EnterDTM] [datetime] NOT NULL,
	[EnterUserID] [int] NOT NULL,
	[LastChgDTM] [datetime] NOT NULL,
	[LastChgUserID] [int] NOT NULL,
	[MUID] [uniqueidentifier] NOT NULL,
	[SystemSettingGroup_ID] [int] NOT NULL,
	[DisplaySequence] [int] NOT NULL,
 CONSTRAINT [pk_tblSystemSetting] PRIMARY KEY CLUSTERED 
(
	[ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
GO
/****** Object:  View [mdm].[viw_SYSTEM_SCHEMA_SYSTEMSETTINGS]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
	SELECT * FROM mdm.viw_SYSTEM_SCHEMA_SYSTEMSETTINGS  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE VIEW [mdm].[viw_SYSTEM_SCHEMA_SYSTEMSETTINGS]  
/*WITH SCHEMABINDING*/  
AS  
SELECT  
    sys.ID  
    ,sys.MUID  
    ,sys.SettingName  
    ,sys.DisplayName  
    ,sys.Description  
    ,sys.SettingType_ID  
    ,[SettingType_Name] =   
        CASE sys.SettingType_ID  
        WHEN 1 THEN N'Freeform'  
        WHEN 2 THEN N'Domain'  
        WHEN 3 THEN N'System'  
        WHEN 4 THEN N'File'  
        END  
  
    ,sys.DataType_ID  
    ,[DataType_Name] =     CASE sys.DataType_ID  
        WHEN 1  THEN N'Text'  
        WHEN 2  THEN N'Number'  
        WHEN 3  THEN N'DateTime'  
        WHEN 6  THEN N'Link'  
        END  
    ,[SettingValue] = sys.SettingValue  
    ,[SettingValueDomainName] = sys.ListCode  
    ,[MinValue] = sys.MinValue  
    ,[MaxValue] = sys.MaxValue  
    ,sys.IsVisible  
    ,sys.DisplaySequence  
    ,sys.SystemSettingGroup_ID  
  
FROM mdm.tblSystemSetting sys
GO
/****** Object:  Table [mdm].[tblviwSystemSecurityRole]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [mdm].[tblviwSystemSecurityRole](
	[Role_ID] [int] NULL,
	[Model_ID] [int] NULL,
	[Model_PrivilegeID] [int] NULL,
	[Model_AccessPermission] [int] NULL,
	[Model_IsExplicit] [int] NULL,
	[Entity_ID] [int] NULL,
	[Entity_PrivilegeID] [int] NULL,
	[Entity_AccessPermission] [int] NULL,
	[Entity_IsExplicit] [int] NULL,
	[MemberType_ID] [int] NULL,
	[MemberType_PrivilegeID] [int] NULL,
	[MemberType_AccessPermission] [int] NULL,
	[MemberType_IsExplicit] [int] NULL,
	[Attribute_ID] [int] NULL,
	[Attribute_PrivilegeID] [int] NULL,
	[Attribute_AccessPermission] [int] NULL,
	[Attribute_IsExplicit] [int] NULL
) ON [PRIMARY]
GO
/****** Object:  View [mdm].[viw_SYSTEM_SECURITY_ROLE]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE VIEW [mdm].[viw_SYSTEM_SECURITY_ROLE]  
/*WITH SCHEMABINDING*/  
AS  
  
SELECT  
    [Role_ID]  
	,[Model_ID]  
	,[Model_PrivilegeID]  
	,[Model_AccessPermission]  
	,[Model_IsExplicit]  
	,[Entity_ID]  
	,[Entity_PrivilegeID]  
	,[Entity_AccessPermission]  
	,[Entity_IsExplicit]  
	,[MemberType_ID]  
	,[MemberType_PrivilegeID]  
	,[MemberType_AccessPermission]  
	,[MemberType_IsExplicit]  
	,[Attribute_ID]  
	,[Attribute_PrivilegeID]  
	,[Attribute_AccessPermission]  
	,[Attribute_IsExplicit]  
FROM  
   mdm.tblviwSystemSecurityRole
GO
/****** Object:  Table [mdm].[tblModel]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [mdm].[tblModel](
	[ID] [int] IDENTITY(1,1) NOT NULL,
	[MUID] [uniqueidentifier] NOT NULL,
	[Name] [nvarchar](50) NOT NULL,
	[Description] [nvarchar](500) NULL,
	[LogRetentionDays] [int] NULL,
	[EnterDTM] [datetime2](3) NOT NULL,
	[EnterUserID] [int] NOT NULL,
	[LastChgDTM] [datetime2](3) NOT NULL,
	[LastChgUserID] [int] NOT NULL,
	[LastChgTS] [timestamp] NOT NULL,
 CONSTRAINT [pk_tblModel] PRIMARY KEY CLUSTERED 
(
	[ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY],
 CONSTRAINT [ux_tblModel_MUID] UNIQUE NONCLUSTERED 
(
	[MUID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY],
 CONSTRAINT [ux_tblModel_Name] UNIQUE NONCLUSTERED 
(
	[Name] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [mdm].[tblAttributeGroup]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [mdm].[tblAttributeGroup](
	[ID] [int] IDENTITY(1,1) NOT NULL,
	[MUID] [uniqueidentifier] NOT NULL,
	[Entity_ID] [int] NOT NULL,
	[MemberType_ID] [tinyint] NOT NULL,
	[Name] [nvarchar](50) NOT NULL,
	[SortOrder] [int] NOT NULL,
	[FreezeNameCode] [bit] NOT NULL,
	[IsSystem] [bit] NOT NULL,
	[EnterDTM] [datetime2](3) NOT NULL,
	[EnterUserID] [int] NOT NULL,
	[EnterVersionID] [int] NOT NULL,
	[LastChgDTM] [datetime2](3) NOT NULL,
	[LastChgUserID] [int] NOT NULL,
	[LastChgVersionID] [int] NOT NULL,
 CONSTRAINT [pk_tblAttributeGroup] PRIMARY KEY CLUSTERED 
(
	[ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY],
 CONSTRAINT [ux_tblAttributeGroup_Entity_ID_MemberType_ID_Name] UNIQUE NONCLUSTERED 
(
	[Entity_ID] ASC,
	[MemberType_ID] ASC,
	[Name] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY],
 CONSTRAINT [ux_tblAttributeGroup_MUID] UNIQUE NONCLUSTERED 
(
	[MUID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  View [mdm].[viw_SYSTEM_SCHEMA_ATTRIBUTEGROUPS]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
    SELECT * FROM mdm.viw_SYSTEM_SCHEMA_ATTRIBUTEGROUPS  
*/  
CREATE VIEW [mdm].[viw_SYSTEM_SCHEMA_ATTRIBUTEGROUPS]  
/*WITH SCHEMABINDING*/  
AS  
WITH attributeGroupsCte AS  
(  
    SELECT  
        ag.ID,  
        ag.Name,  
        ag.MUID,  
        e.Model_ID      Model_ID,  
        m.Name          Model_Name,  
        m.MUID          Model_MUID,  
        ag.Entity_ID    Entity_ID,   
        e.Name          Entity_Name,   
        e.MUID          Entity_MUID,  
        ag.MemberType_ID,  
        CASE ag.MemberType_ID   
            WHEN 1 THEN N'Leaf'  
            WHEN 2 THEN N'Consolidated'  
            WHEN 3 THEN N'Collection'  
            WHEN 4 THEN N'Hierarchy'  
            WHEN 5 THEN N'CollectionMember'  
            ELSE N'' END             MemberType_Name,  
        ag.SortOrder,  
        ag.FreezeNameCode IsNameCodeFrozen,   
        ag.IsSystem,  
        ag.EnterUserID EnteredUser_ID,  
        usrE.MUID EnteredUser_MUID,  
        usrE.UserName EnteredUser_UserName,  
        ag.EnterDTM EnteredUser_DTM,  
        ag.LastChgUserID LastChgUser_ID,  
        usrL.MUID LastChgUser_MUID,  
        usrL.UserName LastChgUser_UserName,  
        ag.LastChgDTM LastChgUser_DTM  
    FROM mdm.tblModel m   
    INNER JOIN mdm.tblEntity e  
    ON m.ID = e.Model_ID  
    INNER JOIN mdm.tblAttributeGroup ag   
    ON e.ID = ag.Entity_ID  
    LEFT JOIN mdm.tblUser usrE   
    ON ag.EnterUserID = usrE.ID  
    LEFT JOIN mdm.tblUser usrL   
    ON ag.LastChgUserID = usrL.ID  
)  
SELECT   
    *,-- Usually it is best to not SELECT *, but in this case it is okay because we are selecting from the CTE whose columns are defined above.  
    CONCAT(QUOTENAME(Model_Name), N':', QUOTENAME(Entity_Name), N':', QUOTENAME(MemberType_Name), N':', QUOTENAME(Name)) FullName  
FROM attributeGroupsCte
GO
/****** Object:  Table [mdm].[tblViwSystemSchemaAttributes]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [mdm].[tblViwSystemSchemaAttributes](
	[Model_ID] [int] NULL,
	[Model_MUID] [uniqueidentifier] NULL,
	[Model_Name] [nvarchar](50) NULL,
	[Entity_ID] [int] NULL,
	[Entity_MUID] [uniqueidentifier] NULL,
	[Entity_Name] [nvarchar](50) NULL,
	[Attribute_ID] [int] NULL,
	[Attribute_MUID] [uniqueidentifier] NULL,
	[Attribute_Name] [nvarchar](100) NULL,
	[Attribute_Description] [nvarchar](500) NULL,
	[Attribute_DisplayName] [nvarchar](250) NULL,
	[Attribute_DisplayWidth] [int] NULL,
	[Attribute_ChangeTrackingGroup] [int] NULL,
	[Attribute_Column] [nvarchar](128) NULL,
	[Attribute_IsSystem] [bit] NULL,
	[Attribute_IsReadOnly] [bit] NULL,
	[Attribute_IsCode] [bit] NULL,
	[Attribute_IsName] [bit] NULL,
	[Attribute_MemberType_ID] [tinyint] NULL,
	[Attribute_MemberType_Name] [nvarchar](16) NULL,
	[Attribute_Type_ID] [tinyint] NULL,
	[Attribute_Type_Name] [nvarchar](8) NULL,
	[Attribute_DBAEntity_ID] [int] NULL,
	[Attribute_DBAEntity_MUID] [uniqueidentifier] NULL,
	[Attribute_DBAEntity_Name] [nvarchar](50) NULL,
	[Attribute_DBAEntity_IsHierarchyEnabled] [int] NULL,
	[FilterParentAttribute_ID] [int] NULL,
	[FilterParentAttribute_MUID] [uniqueidentifier] NULL,
	[FilterParentAttribute_Name] [nvarchar](100) NULL,
	[FilterParentHierarchy_ID] [int] NULL,
	[FilterParentHierarchy_MUID] [uniqueidentifier] NULL,
	[FilterParentHierarchy_Name] [nvarchar](50) NULL,
	[FilterParentHierarchy_LevelNumber] [int] NULL,
	[Attribute_DataType_ID] [tinyint] NULL,
	[Attribute_DataType_Name] [nvarchar](8) NULL,
	[Attribute_DataType_Information] [int] NULL,
	[Attribute_DataMask_ID] [int] NULL,
	[Attribute_DataMask_Name] [nvarchar](250) NULL,
	[Entity_PhysicalTableName] [nvarchar](128) NULL,
	[Attribute_SortOrder] [int] NULL,
	[EnteredUser_ID] [int] NULL,
	[EnteredUser_MUID] [uniqueidentifier] NULL,
	[EnteredUser_UserName] [nvarchar](100) NULL,
	[EnteredUser_DTM] [datetime2](3) NULL,
	[LastChgUser_ID] [int] NULL,
	[LastChgUser_MUID] [uniqueidentifier] NULL,
	[LastChgUser_UserName] [nvarchar](100) NULL,
	[LastChgUser_DTM] [datetime2](3) NULL,
	[Attribute_FullyQualifiedName] [nvarchar](1035) NULL
) ON [PRIMARY]
GO
/****** Object:  View [mdm].[viw_SYSTEM_SCHEMA_ATTRIBUTES]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    SELECT * FROM mdm.viw_SYSTEM_SCHEMA_ATTRIBUTES WHERE Attribute_DBAEntity_ID > 0  
    SELECT * FROM mdm.viw_SYSTEM_SCHEMA_ATTRIBUTES WHERE Entity_ID = 23  
    SELECT * FROM mdm.viw_SYSTEM_SCHEMA_ATTRIBUTES WHERE Entity_ID = 31 AND Attribute_MemberType_ID = 1  
    SELECT * FROM mdm.viw_SYSTEM_SCHEMA_ATTRIBUTES WHERE Entity_ID = 23 AND Attribute_Name = 'Weight'  
    SELECT * FROM mdm.viw_SYSTEM_SCHEMA_ATTRIBUTES WHERE Attribute_ID = 1067  
*/  
CREATE VIEW [mdm].[viw_SYSTEM_SCHEMA_ATTRIBUTES]  
/*WITH SCHEMABINDING*/  
AS  
SELECT  
    [Model_ID]  
	,[Model_MUID]  
	,[Model_Name]  
	,[Entity_ID]  
	,[Entity_MUID]  
	,[Entity_Name]  
	,[Attribute_ID]  
	,[Attribute_MUID]  
	,[Attribute_Name]  
	,[Attribute_Description]  
	,[Attribute_DisplayName]  
	,[Attribute_DisplayWidth]  
	,[Attribute_ChangeTrackingGroup]  
	,[Attribute_Column]  
	,[Attribute_IsSystem]  
	,[Attribute_IsReadOnly]  
	,[Attribute_IsCode]  
	,[Attribute_IsName]  
	,[Attribute_MemberType_ID]  
	,[Attribute_MemberType_Name]  
	,[Attribute_Type_ID]  
	,[Attribute_Type_Name]  
	,[Attribute_DBAEntity_ID]  
	,[Attribute_DBAEntity_MUID]  
	,[Attribute_DBAEntity_Name]  
	,[Attribute_DBAEntity_IsHierarchyEnabled]  
	,[FilterParentAttribute_ID]  
	,[FilterParentAttribute_MUID]  
	,[FilterParentAttribute_Name]  
	,[FilterParentHierarchy_ID]  
	,[FilterParentHierarchy_MUID]  
	,[FilterParentHierarchy_Name]  
	,[FilterParentHierarchy_LevelNumber]  
	,[Attribute_DataType_ID]  
	,[Attribute_DataType_Name]  
	,[Attribute_DataType_Information]  
	,[Attribute_DataMask_ID]  
	,[Attribute_DataMask_Name]  
	,[Entity_PhysicalTableName]  
	,[Attribute_SortOrder]  
	,[EnteredUser_ID]  
	,[EnteredUser_MUID]  
	,[EnteredUser_UserName]  
	,[EnteredUser_DTM]  
	,[LastChgUser_ID]  
	,[LastChgUser_MUID]  
	,[LastChgUser_UserName]  
	,[LastChgUser_DTM]  
	,[Attribute_FullyQualifiedName]  
FROM mdm.tblViwSystemSchemaAttributes
GO
/****** Object:  Table [mdm].[tblCodeGenInfo]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [mdm].[tblCodeGenInfo](
	[EntityId] [int] NOT NULL,
	[Seed] [int] NOT NULL,
	[LargestCodeValue] [bigint] NULL,
 CONSTRAINT [PK_tblCodeGenInfo] PRIMARY KEY CLUSTERED 
(
	[EntityId] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  View [mdm].[viw_SYSTEM_SCHEMA_ENTITY]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    SELECT * FROM mdm.viw_SYSTEM_SCHEMA_ENTITY  
    SELECT * FROM mdm.viw_SYSTEM_SCHEMA_ENTITY WHERE ID = 31  
*/  
CREATE VIEW [mdm].[viw_SYSTEM_SCHEMA_ENTITY]  
/*WITH SCHEMABINDING*/  
AS  
SELECT  
     ent.ID  
    ,ent.ID Entity_ID  
    ,ent.MUID  
    ,ent.Name  
    ,ent.[Description]  
    ,ent.IsBase  
    ,ent.EntityTable  
    ,ent.HierarchyTable  
    ,ent.HierarchyParentTable  
    ,ent.CollectionTable  
    ,ent.CollectionMemberTable  
    ,ent.StagingBase  
    ,CASE WHEN ent.StagingBase IS NOT NULL THEN ent.StagingBase + N'_Leaf' ELSE NULL END AS StagingLeafTable  
    ,CASE WHEN ent.HierarchyTable IS NOT NULL AND ent.StagingBase IS NOT NULL THEN ent.StagingBase + N'_Consolidated' ELSE NULL END AS StagingConsolidatedTable  
    ,CASE WHEN ent.HierarchyTable IS NOT NULL AND ent.StagingBase IS NOT NULL THEN ent.StagingBase + N'_Relationship' ELSE NULL END AS StagingRelationshipTable  
    ,ent.Model_ID  
    ,mdl.MUID AS Model_MUID  
    ,mdl.Name AS Model_Name  
    ,COALESCE(ent.EnterUserID, 0) AS EnteredUser_ID  
    ,COALESCE(usrE.MUID, CAST(0x0 AS UNIQUEIDENTIFIER)) AS EnteredUser_MUID  
    ,usrE.UserName AS EnteredUser_UserName  
    ,ent.EnterDTM AS EnteredUser_DTM  
    ,COALESCE(ent.LastChgUserID, 0) AS LastChgUser_ID  
    ,COALESCE(usrL.MUID, CAST(0x0 AS UNIQUEIDENTIFIER)) AS LastChgUser_MUID  
    ,usrL.UserName AS LastChgUser_UserName  
    ,ent.LastChgDTM AS LastChgUser_DTM  
    ,CASE WHEN codegen.Seed IS NULL THEN 0 ELSE 1 END AS IsCodeGenerationEnabled  
    ,CASE WHEN codegen.Seed IS NULL THEN 0 ELSE codegen.Seed END as CodeGenerationSeed  
    ,ent.DataCompression  
    ,ent.TransactionLogType  
    ,ent.RequireApproval  
FROM  
    mdm.tblEntity AS ent   
    INNER JOIN mdm.tblModel AS mdl  
        ON mdl.ID = ent.Model_ID   
    LEFT JOIN mdm.tblUser AS usrE  
        ON ent.EnterUserID = usrE.ID  
    LEFT JOIN mdm.tblUser AS usrL  
        ON ent.LastChgUserID = usrL.ID  
    LEFT JOIN mdm.tblCodeGenInfo AS codegen  
        ON codegen.EntityId = ent.ID;
GO
/****** Object:  Table [mdm].[tblviwSystemSecurityUserAttribute]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [mdm].[tblviwSystemSecurityUserAttribute](
	[User_ID] [int] NOT NULL,
	[IsAdmin] [int] NULL,
	[ID] [int] NOT NULL,
	[Privilege_ID] [int] NULL,
	[AccessPermission] [int] NULL
) ON [PRIMARY]
GO
/****** Object:  View [mdm].[viw_SYSTEM_SECURITY_USER_ATTRIBUTE]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
Rank    Permission  
----    ---------------------  
1       Model Admin - ALL  
2       MemberType Deny - Deny  
3       No explicit permission, MemberType not inferred permission - MemberType permission  
4       No explicit permission on name/code, MemberType inferred permission - ReadOnly, some attribute has some permission, membertype is inferred read.  
5       Attribute permission, could be explicit attribute permission or null.  
  
SELECT * FROM mdm.viw_SYSTEM_SECURITY_USER_ATTRIBUTE WHERE User_ID = 118  
*/  
CREATE VIEW [mdm].[viw_SYSTEM_SECURITY_USER_ATTRIBUTE]  
/*WITH SCHEMABINDING*/  
AS  
SELECT   
	[User_ID]  
	,[IsAdmin]  
	,[ID]  
	,[Privilege_ID]  
	,[AccessPermission]  
FROM    
mdm.tblviwSystemSecurityUserAttribute
GO
/****** Object:  Table [mdm].[tblModelVersionFlag]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [mdm].[tblModelVersionFlag](
	[ID] [int] IDENTITY(1,1) NOT NULL,
	[MUID] [uniqueidentifier] NOT NULL,
	[Model_ID] [int] NOT NULL,
	[Name] [nvarchar](50) NOT NULL,
	[Description] [nvarchar](500) NULL,
	[Status_ID] [tinyint] NOT NULL,
	[CommittedOnly_ID] [tinyint] NULL,
	[EnterDTM] [datetime2](3) NOT NULL,
	[EnterUserID] [int] NOT NULL,
	[LastChgDTM] [datetime2](3) NOT NULL,
	[LastChgUserID] [int] NOT NULL,
	[LastChgTS] [timestamp] NOT NULL,
 CONSTRAINT [pk_tblModelVersionFlag] PRIMARY KEY CLUSTERED 
(
	[ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY],
 CONSTRAINT [ux_tblModelVersionFlag_Model_ID_Name] UNIQUE NONCLUSTERED 
(
	[Model_ID] ASC,
	[Name] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY],
 CONSTRAINT [ux_tblModelVersionFlag_MUID] UNIQUE NONCLUSTERED 
(
	[MUID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [mdm].[tblModelVersion]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [mdm].[tblModelVersion](
	[ID] [int] IDENTITY(1,1) NOT NULL,
	[MUID] [uniqueidentifier] NOT NULL,
	[Model_ID] [int] NOT NULL,
	[Name] [nvarchar](50) NOT NULL,
	[Description] [nvarchar](500) NULL,
	[Status_ID] [tinyint] NOT NULL,
	[Display_ID] [int] NOT NULL,
	[VersionFlag_ID] [int] NULL,
	[AsOfVersion_ID] [int] NULL,
	[EnterDTM] [datetime2](3) NOT NULL,
	[EnterUserID] [int] NOT NULL,
	[LastChgDTM] [datetime2](3) NOT NULL,
	[LastChgUserID] [int] NOT NULL,
	[LastChgTS] [timestamp] NOT NULL,
 CONSTRAINT [pk_tblModelVersion] PRIMARY KEY CLUSTERED 
(
	[ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY],
 CONSTRAINT [ux_tblModelVersion_Model_ID_Name] UNIQUE NONCLUSTERED 
(
	[Model_ID] ASC,
	[Name] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY],
 CONSTRAINT [ux_tblModelVersion_MUID] UNIQUE NONCLUSTERED 
(
	[MUID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [mdm].[tblHierarchy]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [mdm].[tblHierarchy](
	[ID] [int] IDENTITY(1,1) NOT NULL,
	[MUID] [uniqueidentifier] NOT NULL,
	[Entity_ID] [int] NOT NULL,
	[Name] [nvarchar](50) NOT NULL,
	[IsMandatory] [bit] NOT NULL,
	[EnterDTM] [datetime2](3) NOT NULL,
	[EnterUserID] [int] NOT NULL,
	[EnterVersionID] [int] NOT NULL,
	[LastChgDTM] [datetime2](3) NOT NULL,
	[LastChgUserID] [int] NOT NULL,
	[LastChgVersionID] [int] NOT NULL,
	[LastChgTS] [timestamp] NOT NULL,
 CONSTRAINT [pk_tblHierarchy] PRIMARY KEY CLUSTERED 
(
	[ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY],
 CONSTRAINT [ux_tblHierarchy_MUID] UNIQUE NONCLUSTERED 
(
	[MUID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY],
 CONSTRAINT [ux_tblHierarchy_Name] UNIQUE NONCLUSTERED 
(
	[Entity_ID] ASC,
	[Name] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  View [mdm].[viw_SYSTEM_SCHEMA_MODELS]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE VIEW [mdm].[viw_SYSTEM_SCHEMA_MODELS]  
/*WITH SCHEMABINDING*/  
AS  
WITH NonLeafMemberTypes (ID, Name)AS (  
    SELECT 2, N'Consolidated'  
    UNION ALL SELECT 3, N'Collection'  
)  
SELECT  
   -----Models, versions, and users (Consolidated and Collection members)  
   tMod.ID                 Model_ID,  
   tMod.MUID               Model_MUID,  
   tMod.Name               Model_Name,  
   QUOTENAME(tMod.Name)    Model_Label,  
   tMod.Description        Model_Description,  
   tVer.ID                 Version_ID,  
   tVer.MUID               Version_MUID,  
   tVer.Name               Version_Name,  
   tVer.Display_ID         Version_Number,  
   tVer.Description        Version_Description,  
   --  
   tVer.EnterUserID        Version_UserIDCreated,  
   Version_UserNameCreated = (SELECT UserName FROM mdm.tblUser WHERE ID = tVer.EnterUserID),  
   tVer.EnterDTM           Version_DateCreated,  
   tVer.LastChgUserID      Version_UserIDUpdated,  
   Version_UserNameUpdated = (SELECT UserName FROM mdm.tblUser WHERE ID = tVer.LastChgUserID),  
   tVer.LastChgDTM         Version_DateUpdated,  
   --  
   tVerStatus.ID           Version_StatusID,  
   tVerStatus.Name         Version_Status,  
   tVerFlag.ID             Version_FlagID,  
   tVerFlag.Name           Version_FlagName,  
   tVer.AsOfVersion_ID     Version_SourceVersionID,  
   -----Entities  
   tEnt.ID                    Entity_ID,  
   tEnt.MUID                Entity_MUID,  
   tEnt.Name                Entity_Name,  
   Entity_Label = CONCAT(QUOTENAME(tMod.Name), N':', QUOTENAME(tEnt.Name)),  
   tEnt.IsBase                Entity_IsBase,  
   Entity_HasHierarchy = CASE(LEN(tEnt.HierarchyTable)) WHEN 0 THEN 0 ELSE 1 END,  
   --  
   tEnt.EnterUserID            Entity_UserIDCreated,  
   Entity_UserNameCreated = (SELECT UserName FROM mdm.tblUser WHERE ID = tEnt.EnterUserID),  
   tEnt.EnterDTM            Entity_DateCreated,  
   tEnt.LastChgUserID        Entity_UserIDUpdated,  
   Entity_UserNameUpdated = (SELECT UserName FROM mdm.tblUser WHERE ID = tEnt.LastChgUserID),  
   tEnt.LastChgDTM            Entity_DateUpdated,  
   tEnt.LastChgVersionID    Entity_VersionIDUpdated,  
   --Tables  
   Entity_Table                    = tEnt.EntityTable,  
   Entity_HierarchyTable        = tEnt.HierarchyTable,  
   Entity_HierarchyParentTable    = tEnt.HierarchyParentTable,  
   Entity_CollectionTable        = tEnt.CollectionTable,  
   Entity_CollectionMemberTable = tEnt.CollectionMemberTable,  
   -----Hierarchies  
   tHir.ID          Hierarchy_ID,  
   tHir.MUID        Hierarchy_MUID,  
   tHir.Name        Hierarchy_Name,  
   Hierarchy_Label  = CONCAT(N'Explicit:', QUOTENAME(tEnt.Name), N':', QUOTENAME(tHir.Name)),  
   HierarchyType_ID = (SELECT OptionID FROM mdm.tblList WHERE ListCode = CAST(N'lstHierarchyType' AS NVARCHAR(50)) AND ListOption = CAST(N'Explicit' AS NVARCHAR(250))),  
   tHir.IsMandatory Hierarchy_IsMandatory,  
   --  
   tHir.EnterUserID          Hierarchy_UserIDCreated,  
   Hierarchy_UserNameCreated = (SELECT UserName FROM mdm.tblUser WHERE ID = tHir.EnterUserID),  
   tHir.EnterDTM             Hierarchy_DateCreated,  
   tHir.LastChgUserID        Hierarchy_UserIDUpdated,  
   Hierarchy_UserNameUpdated = (SELECT UserName FROM mdm.tblUser WHERE ID = tHir.LastChgUserID),  
   tHir.LastChgDTM           Hierarchy_DateUpdated,  
   tHir.LastChgVersionID     Hierarchy_VersionIDUpdated,  
   -----Member Types  
   MemberType_ID    = tType.ID,  
   MemberType_Name  = tType.Name,  
   MemberType_Label = CONCAT(QUOTENAME(tMod.Name) , N':', QUOTENAME(tEnt.Name), N':', QUOTENAME(tType.Name))  
FROM  
   mdm.tblModel AS tMod  
   INNER JOIN mdm.tblModelVersion tVer ON tMod.ID = tVer.Model_ID  
   INNER JOIN mdm.tblEntity tEnt ON tMod.ID = tEnt.Model_ID  
   INNER JOIN mdm.tblHierarchy tHir ON tEnt.ID = tHir.Entity_ID  
   INNER JOIN (SELECT OptionID ID, ListOption Name FROM mdm.tblList WHERE ListCode = CAST(N'lstVersionStatus' AS NVARCHAR(50))) tVerStatus ON tVer.Status_ID = tVerStatus.ID  
   LEFT JOIN (SELECT ID, Model_ID, Name FROM mdm.tblModelVersionFlag) tVerFlag ON tVer.VersionFlag_ID = tVerFlag.ID  
   CROSS JOIN NonLeafMemberTypes AS tType  
UNION  ALL  
  
SELECT  
   -----Models, versions, and users (Leaf members)  
   tMod.ID                 Model_ID,  
   tMod.MUID               Model_MUID,  
   tMod.Name               Model_Name,  
   QUOTENAME(tMod.Name)    Model_Label,  
   tMod.Description        Model_Description,  
   tVer.ID                 Version_ID,  
   tVer.MUID               Version_MUID,  
   tVer.Name               Version_Name,  
   tVer.Display_ID         Version_Number,  
   tVer.Description        Version_Description,  
   --  
   tVer.EnterUserID        Version_UserIDCreated,  
   Version_UserNameCreated = (SELECT UserName FROM mdm.tblUser WHERE ID = tVer.EnterUserID),  
   tVer.EnterDTM           Version_DateCreated,  
   tVer.LastChgUserID      Version_UserIDUpdated,  
   Version_UserNameUpdated = (SELECT UserName FROM mdm.tblUser WHERE ID = tVer.LastChgUserID),  
   tVer.LastChgDTM         Version_DateUpdated,  
   --  
   tVerStatus.ID           Version_StatusID,  
   tVerStatus.Name         Version_Status,  
   tVerFlag.ID             Version_FlagID,  
   tVerFlag.Name           Version_FlagName,  
   tVer.AsOfVersion_ID     Version_SourceVersionID,  
   -----Entities  
   tEnt.ID                    Entity_ID,  
   tEnt.MUID                Entity_MUID,  
   tEnt.Name                Entity_Name,  
   Entity_Label = CONCAT(QUOTENAME(tMod.Name), N':', QUOTENAME(tEnt.Name)),  
   tEnt.IsBase                Entity_IsBase,  
   Entity_HasHierarchy = CASE(LEN(tEnt.HierarchyTable)) WHEN 0 THEN 0 ELSE 1 END,  
   --  
   tEnt.EnterUserID            Entity_UserIDCreated,  
   Entity_UserNameCreated = (SELECT UserName FROM mdm.tblUser WHERE ID = tEnt.EnterUserID),  
   tEnt.EnterDTM            Entity_DateCreated,  
   tEnt.LastChgUserID        Entity_UserIDUpdated,  
   Entity_UserNameUpdated = (SELECT UserName FROM mdm.tblUser WHERE ID = tEnt.LastChgUserID),  
   tEnt.LastChgDTM            Entity_DateUpdated,  
   tEnt.LastChgVersionID    Entity_VersionIDUpdated,  
   --Tables  
   Entity_Table = tEnt.EntityTable,  
   Entity_HierarchyTable = tEnt.HierarchyTable,  
   Entity_HierarchyParentTable = tEnt.HierarchyParentTable,  
   Entity_CollectionTable = tEnt.CollectionTable,  
   Entity_CollectionMemberTable = tEnt.CollectionMemberTable,  
   -----Hierarchies  
   tHir.ID          Hierarchy_ID,  
   tHir.MUID        Hierarchy_MUID,  
   tHir.Name        Hierarchy_Name,  
   Hierarchy_Label  = CONCAT(N'Explicit:', QUOTENAME(tEnt.Name), N':', QUOTENAME(tHir.Name)),  
   HierarchyType_ID = (SELECT OptionID FROM mdm.tblList WHERE ListCode = CAST(N'lstHierarchyType' AS NVARCHAR(50)) AND ListOption = CAST(N'Explicit' AS NVARCHAR(250))),  
   tHir.IsMandatory Hierarchy_IsMandatory,  
   --  
   tHir.EnterUserID          Hierarchy_UserIDCreated,  
   Hierarchy_UserNameCreated = (SELECT UserName FROM mdm.tblUser WHERE ID = tHir.EnterUserID),  
   tHir.EnterDTM             Hierarchy_DateCreated,  
   tHir.LastChgUserID        Hierarchy_UserIDUpdated,  
   Hierarchy_UserNameUpdated = (SELECT UserName FROM mdm.tblUser WHERE ID = tHir.LastChgUserID),  
   tHir.LastChgDTM           Hierarchy_DateUpdated,  
   tHir.LastChgVersionID     Hierarchy_VersionIDUpdated,  
   -----Member Types  
   MemberType_ID    = 1 /*Leaf*/,  
   MemberType_Name  = N'Leaf',  
   MemberType_Label = CONCAT(QUOTENAME(tMod.Name), N':', QUOTENAME(tEnt.Name), N':', QUOTENAME(N'Leaf'))  
FROM  
   mdm.tblModel tMod  
   INNER JOIN mdm.tblModelVersion tVer ON tMod.ID = tVer.Model_ID  
   LEFT JOIN mdm.tblEntity tEnt ON tMod.ID = tEnt.Model_ID  
   LEFT JOIN mdm.tblHierarchy tHir ON tEnt.ID = tHir.Entity_ID  
   INNER JOIN (SELECT OptionID ID, ListOption Name FROM mdm.tblList WHERE ListCode = CAST(N'lstVersionStatus' AS NVARCHAR(50))) tVerStatus ON tVer.Status_ID = tVerStatus.ID  
   LEFT JOIN (SELECT ID, Model_ID, Name FROM mdm.tblModelVersionFlag) tVerFlag ON tVer.VersionFlag_ID = tVerFlag.ID
GO
/****** Object:  Table [mdm].[tblviwSystemSecurityUserMemberType]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [mdm].[tblviwSystemSecurityUserMemberType](
	[User_ID] [int] NOT NULL,
	[IsAdmin] [int] NULL,
	[IsSyncTarget] [int] NULL,
	[Entity_ID] [int] NULL,
	[ID] [int] NOT NULL,
	[Privilege_ID] [int] NULL,
	[AccessPermission] [int] NULL
) ON [PRIMARY]
GO
/****** Object:  View [mdm].[viw_SYSTEM_SECURITY_USER_MEMBERTYPE]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    SELECT * FROM mdm.viw_SYSTEM_SECURITY_USER_MEMBERTYPE ORDER BY User_ID, Entity_ID, ID  
  
    Rank    Permission  
----    ---------------------  
1       Model Admin - ALL  
2       Entity Deny - Deny  
3       No explicit permission, Entity not inferred permission - Entity permission  
4       MemberType permission, could be explicit permission or null.  
  
*/  
CREATE VIEW [mdm].[viw_SYSTEM_SECURITY_USER_MEMBERTYPE]  
/*WITH SCHEMABINDING*/  
AS  
SELECT  
    [User_ID]  
	,[IsAdmin]  
	,[IsSyncTarget]  
	,[Entity_ID]  
	,[ID]  
	,[Privilege_ID]  
	,[AccessPermission]  
FROM mdm.tblviwSystemSecurityUserMemberType
GO
/****** Object:  Table [mdm].[tblSystem]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [mdm].[tblSystem](
	[ID] [int] IDENTITY(1,1) NOT NULL,
	[SchemaVersion] [nvarchar](250) NOT NULL,
	[EnterDTM] [datetime2](3) NOT NULL,
	[EnterUserID] [nvarchar](250) NOT NULL,
	[LastChgUserID] [nvarchar](250) NOT NULL,
	[LastChgDTM] [datetime2](3) NOT NULL,
 CONSTRAINT [pk_tblSystem] PRIMARY KEY CLUSTERED 
(
	[ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  View [mdm].[viw_SYSTEM_VERSION]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
    SELECT * FROM mdm.viw_SYSTEM_VERSION  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE VIEW [mdm].[viw_SYSTEM_VERSION]  
/*WITH SCHEMABINDING*/  
AS  
    SELECT [SchemaVersion]  
    FROM [mdm].[tblSystem]
GO
/****** Object:  View [mdm].[viw_SYSTEM_SCHEMA_VERSION]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
SELECT * FROM mdm.viw_SYSTEM_SCHEMA_VERSION  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE VIEW [mdm].[viw_SYSTEM_SCHEMA_VERSION]  
/*WITH SCHEMABINDING*/  
AS  
SELECT   
   V.ID,  
   V.MUID,  
   V.Model_ID,  
   M.MUID Model_MUID,  
   M.Name Model_Name,  
   V.Status_ID,  
   L.ListOption as Status,  
   V.Display_ID as VersionNbr,  
   V.Name,  
   V.Description,  
   ISNULL(V.VersionFlag_ID, 0) as VersionFlag_ID,  
   ISNULL(F.MUID, CONVERT(UNIQUEIDENTIFIER, 0x0)) as Flag_MUID,  
   F.Name as Flag,  
   ISNULL(V.AsOfVersion_ID, 0) AS CopiedFrom_ID,  
   ISNULL(V2.MUID, CONVERT(UNIQUEIDENTIFIER, 0x0)) AS CopiedFrom_MUID,  
   V2.Name + N'(#' + CONVERT(NVARCHAR(100),V2.Display_ID) + N')' as CopiedFrom,  
   V.EnterUserID EnteredUser_ID,  
   usrE.MUID EnteredUser_MUID,  
   usrE.UserName EnteredUser_UserName,  
   V.EnterDTM EnteredUser_DTM,  
   V.LastChgUserID LastChgUser_ID,  
   usrL.MUID LastChgUser_MUID,  
   usrL.UserName LastChgUser_UserName,  
   V.LastChgDTM LastChgUser_DTM  
FROM   
    mdm.tblModelVersion V  
    INNER JOIN mdm.tblModel M ON V.Model_ID = M.ID  
    INNER JOIN mdm.tblList L ON L.ListCode = N'lstVersionStatus' AND L.OptionID = V.Status_ID  
    LEFT JOIN mdm.tblUser usrE ON V.EnterUserID = usrE.ID  
    LEFT JOIN mdm.tblUser usrL ON V.LastChgUserID = usrL.ID  
    LEFT JOIN mdm.tblModelVersionFlag F ON F.ID = V.VersionFlag_ID  
    LEFT JOIN mdm.tblModelVersion AS V2 ON V.AsOfVersion_ID = V2.ID
GO
/****** Object:  View [mdm].[viw_SYSTEM_SCHEMA_HIERARCHY_EXPLICIT]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
SELECT * FROM  mdm.viw_SYSTEM_SCHEMA_HIERARCHY_EXPLICIT  
  
*/  
CREATE VIEW [mdm].[viw_SYSTEM_SCHEMA_HIERARCHY_EXPLICIT]  
/*WITH SCHEMABINDING*/  
AS  
SELECT  
    tEnt.Model_ID     Model_ID,   
    tMod.MUID         Model_MUID,   
    tMod.Name         Model_Name,    
    tHir.Entity_ID    Entity_ID,  
    tEnt.MUID         Entity_MUID,  
    tEnt.Name         Entity_Name,  
    tHir.ID           Hierarchy_ID,   
    tHir.MUID         Hierarchy_MUID,   
    tHir.Name         Hierarchy_Name,  
    tHir.IsMandatory  Hierarchy_IsMandatory,   
    Hierarchy_Label  = N'Explicit: ' + tMod.Name + N': ' + tHir.Name,   
    --  
    COALESCE(tHir.EnterUserID, 0) EnteredUser_ID,  
    COALESCE(usrE.MUID, CAST(0x0 AS UNIQUEIDENTIFIER)) EnteredUser_MUID,  
    usrE.UserName EnteredUser_UserName,  
    tHir.EnterDTM EnteredUser_DTM,  
    COALESCE(tHir.LastChgUserID, 0) LastChgUser_ID,  
    COALESCE(usrL.MUID, CAST(0x0 AS UNIQUEIDENTIFIER)) LastChgUser_MUID,  
    usrL.UserName LastChgUser_UserName,  
    tHir.LastChgDTM LastChgUser_DTM  
FROM  
    mdm.tblHierarchy tHir  
    INNER JOIN mdm.tblEntity tEnt ON tEnt.ID = tHir.Entity_ID  
    INNER JOIN mdm.tblModel tMod ON tMod.ID = tEnt.Model_ID  
    LEFT JOIN mdm.tblUser usrE ON tHir.EnterUserID = usrE.ID  
    LEFT JOIN mdm.tblUser usrL ON tHir.LastChgUserID = usrL.ID
GO
/****** Object:  Table [mdm].[tblStgBatch]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [mdm].[tblStgBatch](
	[ID] [int] IDENTITY(1,1) NOT NULL,
	[OriginalBatch_ID] [int] NULL,
	[MUID] [uniqueidentifier] NOT NULL,
	[Entity_ID] [int] NULL,
	[MemberType_ID] [tinyint] NULL,
	[BatchTag] [nvarchar](50) NULL,
	[ExternalSystem_ID] [int] NULL,
	[Name] [nvarchar](50) NULL,
	[Version_ID] [int] NOT NULL,
	[TotalMemberCount] [int] NULL,
	[ErrorMemberCount] [int] NULL,
	[TotalMemberAttributeCount] [int] NULL,
	[ErrorMemberAttributeCount] [int] NULL,
	[TotalMemberRelationshipCount] [int] NULL,
	[ErrorMemberRelationshipCount] [int] NULL,
	[Status_ID] [tinyint] NOT NULL,
	[LastRunStartDTM] [datetime] NULL,
	[LastRunStartUserID] [int] NULL,
	[LastRunEndDTM] [datetime] NULL,
	[LastRunEndUserID] [int] NULL,
	[LastClearedDTM] [datetime] NULL,
	[LastClearedUserID] [int] NULL,
	[EnterDTM] [datetime] NOT NULL,
	[EnterUserID] [int] NOT NULL,
 CONSTRAINT [pk_tblStgBatch] PRIMARY KEY CLUSTERED 
(
	[ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  View [mdm].[viw_EntityStagingBatchesAllProcessed]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
-- Returns all the staging batches that are in the tblStgBatch table  
-- (and thus have at least started being processed by the system)  
CREATE VIEW [mdm].[viw_EntityStagingBatchesAllProcessed]  
AS  
    SELECT  
        Batch.ID                AS Batch_ID,  
        Batch.BatchTag          AS BatchTag,  
        Batch.Entity_ID         AS Entity_ID,  
        Batch.MemberType_ID     AS MemberTypeID,  
        V.MUID                  AS Version_MUID,  
        V.Name                  AS VersionName,  
        Batch.Status_ID         AS [Status],  
        Batch.LastRunStartDTM   AS ProcessStart,  
        Batch.LastRunEndDTM     AS ProcessEnd,  
        Batch.LastRunStartUserID AS ProcessUserID,  
        Batch.TotalMemberCount  AS TotalRows,  
        Batch.ErrorMemberCount  AS RowsInError,  
        M.ID AS Model_ID  
    FROM  
        mdm.tblStgBatch                 AS Batch  
        INNER JOIN mdm.tblModelVersion  AS V   
            ON V.ID=Batch.Version_ID    
        INNER JOIN mdm.tblModel         AS M  
            ON M.ID=V.Model_ID    
    WHERE  
    -- Return only records that are from the new entity staging process  
        (Entity_ID IS NOT NULL) AND  
        (MemberType_ID IS NOT NULL)
GO
/****** Object:  Table [mdm].[tblDerivedHierarchy]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [mdm].[tblDerivedHierarchy](
	[ID] [int] IDENTITY(1,1) NOT NULL,
	[MUID] [uniqueidentifier] NOT NULL,
	[Model_ID] [int] NOT NULL,
	[Name] [nvarchar](50) NOT NULL,
	[AnchorNullRecursions] [bit] NOT NULL,
	[EnterDTM] [datetime2](3) NOT NULL,
	[EnterUserID] [int] NOT NULL,
	[EnterVersionID] [int] NOT NULL,
	[LastChgDTM] [datetime2](3) NOT NULL,
	[LastChgUserID] [int] NOT NULL,
	[LastChgVersionID] [int] NOT NULL,
	[LastChgTS] [timestamp] NOT NULL,
 CONSTRAINT [pk_tblDerivedHierarchy] PRIMARY KEY CLUSTERED 
(
	[ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY],
 CONSTRAINT [ux_tblDerivedHierarchy_Model_ID_Name] UNIQUE NONCLUSTERED 
(
	[Model_ID] ASC,
	[Name] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY],
 CONSTRAINT [ux_tblDerivedHierarchy_MUID] UNIQUE NONCLUSTERED 
(
	[MUID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [mdm].[tblDerivedHierarchyDetail]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [mdm].[tblDerivedHierarchyDetail](
	[ID] [int] IDENTITY(1,1) NOT NULL,
	[MUID] [uniqueidentifier] NOT NULL,
	[DerivedHierarchy_ID] [int] NOT NULL,
	[Name] [nvarchar](100) NOT NULL,
	[DisplayName] [nvarchar](100) NOT NULL,
	[ForeignParent_ID] [int] NULL,
	[Foreign_ID] [int] NULL,
	[ForeignType_ID] [tinyint] NOT NULL,
	[ManyToManyChildAttribute_ID] [int] NULL,
	[Level_ID] [int] NULL,
	[IsVisible] [bit] NOT NULL,
	[EnterDTM] [datetime2](3) NOT NULL,
	[EnterUserID] [int] NOT NULL,
	[EnterVersionID] [int] NOT NULL,
	[LastChgDTM] [datetime2](3) NOT NULL,
	[LastChgUserID] [int] NOT NULL,
	[LastChgVersionID] [int] NOT NULL,
	[LastChgTS] [timestamp] NOT NULL,
 CONSTRAINT [pk_tblDerivedHierarchyDetail] PRIMARY KEY CLUSTERED 
(
	[ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY],
 CONSTRAINT [ck_tblDerivedHierarchyDetail_MUID] UNIQUE NONCLUSTERED 
(
	[MUID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  View [mdm].[viw_SYSTEM_SCHEMA_HIERARCHY_DERIVED_LEVELS]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE VIEW [mdm].[viw_SYSTEM_SCHEMA_HIERARCHY_DERIVED_LEVELS]  
/*WITH SCHEMABINDING*/  
AS  
SELECT  
    dh.Model_ID     Model_ID,  
    m.MUID          Model_MUID,  
    m.Name          Model_Name,  
    dhd.DerivedHierarchy_ID Hierarchy_ID,   
    dh.MUID         Hierarchy_MUID,   
    dh.Name         Hierarchy_Name,   
    --  
    dhd.ID,  
    dhd.MUID,  
    dhd.Name,   
    dhd.DisplayName,   
    COALESCE(dhd.ForeignType_ID, 0) ForeignType_ID,  
    CASE dhd.ForeignType_ID  
        WHEN 0 THEN N'Entity'  
        WHEN 1 THEN N'Dba'  
        WHEN 2 THEN N'Hierarchy'  
        WHEN 5 THEN N'ManyToMany'  
        END ForeignType_Name,  
    COALESCE(e.ID, a.ID, h.ID, mapParentDBA.ID)          Foreign_ID,  
    COALESCE(e.MUID, a.MUID, h.MUID, mapParentDBA.MUID)  Foreign_MUID,  
    COALESCE(e.Name, a.Name, h.Name, mapParentDBA.Name)  Foreign_Name,  
      
    COALESCE(fe.ID, 0)                                  ForeignEntity_ID,  
    COALESCE(fe.MUID, CAST(0x0 AS UNIQUEIDENTIFIER))    ForeignEntity_MUID,  
    COALESCE(fe.Name, N'')                              ForeignEntity_Name,  
  
    -- When displaying members for a level, they will be members of this entity  
    COALESCE(e.ID, de.ID, he.ID, mapParentEntity.ID)          [Entity_ID],  
    COALESCE(e.MUID, de.MUID, he.MUID, mapParentEntity.MUID)  [Entity_MUID],  
    COALESCE(e.Name, de.Name, he.Name, mapParentEntity.Name)  [Entity_Name],  
  
    COALESCE(mapChildDBA.ID, 0)                                ManyToManyChildAttribute_ID,  
    COALESCE(mapChildDBA.MUID, CAST(0x0 AS UNIQUEIDENTIFIER))  ManyToManyChildAttribute_MUID,  
    COALESCE(mapChildDBA.Name, N'')                            ManyToManyChildAttribute_Name,  
  
    (tLevels.LevelCount - dhd.Level_ID )    LevelNumber, -- Ordered top-to-bottom, zero-based: 0 = top, N - 1 = bottom  
    dhd.Level_ID,                                        -- Ordered bottom-to-top, one-based: N = top, 1 = bottom  
      
    dhd.IsVisible IsLevelVisible,  
    CASE WHEN dhd.ForeignType_ID = 2 -- Hierarchy  
        THEN 2 -- Consolidated  
        ELSE 1 -- Leaf  
        END MemberType_ID,  
    CASE WHEN dhd.ForeignType_ID = 2 -- Hierarchy  
        THEN N'Consolidated'  
        ELSE N'Leaf'  
        END MemberType_Name,  
    CASE WHEN a.Entity_ID = a.DomainEntity_ID THEN 1 ELSE 0 END IsRecursive,  
      
    -- Audit info  
    COALESCE(dhd.EnterUserID, 0)                            Detail_EnteredUser_ID,  
    COALESCE(usrDetE.MUID, CAST(0x0 AS UNIQUEIDENTIFIER))   Detail_EnteredUser_MUID,  
    usrDetE.UserName                                        Detail_EnteredUser_UserName,  
    dhd.EnterDTM                                            Detail_EnteredUser_DTM,  
    COALESCE(dhd.LastChgUserID, 0)                          Detail_LastChgUser_ID,  
    COALESCE(usrDetL.MUID, CAST(0x0 AS UNIQUEIDENTIFIER))   Detail_LastChgUser_MUID,  
    usrDetL.UserName                                        Detail_LastChgUser_UserName,  
    dhd.LastChgDTM                                          Detail_LastChgUser_DTM  
FROM mdm.tblModel m  
INNER JOIN mdm.tblDerivedHierarchy dh   
ON m.ID = dh.Model_ID  
INNER JOIN -- Get the number of levels for each hierarchy. Used to invert the ordering (levels are ordered bottom-to-top in the db but top-to-bottom in the DataContracts)  
(  
    SELECT   
         DerivedHierarchy_ID  
        ,COUNT(Level_ID) LevelCount   
    FROM mdm.tblDerivedHierarchyDetail   
    GROUP BY DerivedHierarchy_ID  
) tLevels   
ON dh.ID = tLevels.DerivedHierarchy_ID  
INNER JOIN mdm.tblDerivedHierarchyDetail dhd  
ON dh.ID = dhd.DerivedHierarchy_ID  
  
LEFT JOIN mdm.tblEntity e  
ON      dhd.Foreign_ID = e.ID  
    AND dhd.ForeignType_ID = 0 -- Entity  
  
LEFT JOIN mdm.tblAttribute a  
ON      dhd.Foreign_ID = a.ID  
    AND dhd.ForeignType_ID = 1 -- DBA  
LEFT JOIN mdm.tblEntity de  
ON a.DomainEntity_ID = de.ID  
  
LEFT JOIN mdm.tblHierarchy h  
ON      dhd.Foreign_ID = h.ID  
    AND dhd.ForeignType_ID = 2 -- Explicit Hierarchy  
LEFT JOIN mdm.tblEntity he  
ON h.Entity_ID = he.ID  
  
LEFT JOIN mdm.tblAttribute mapParentDBA  
ON      dhd.Foreign_ID = mapParentDBA.ID  
    AND dhd.ForeignType_ID = 5 -- ManyToMany  
LEFT JOIN mdm.tblAttribute mapChildDBA  
ON      dhd.ManyToManyChildAttribute_ID = mapChildDBA.ID  
    AND dhd.ForeignType_ID = 5 -- ManyToMany  
LEFT JOIN mdm.tblEntity mapParentEntity -- The parent Entity referenced by the mapping Entity  
ON mapParentDBA.DomainEntity_ID = mapParentEntity.ID  
  
LEFT JOIN mdm.tblEntity fe  
ON ISNULL(ISNULL(a.Entity_ID, h.Entity_ID), mapParentDBA.Entity_ID) = fe.ID  
  
LEFT JOIN mdm.tblUser usrDetE   
ON dhd.EnterUserID = usrDetE.ID  
LEFT JOIN mdm.tblUser usrDetL   
ON dhd.LastChgUserID = usrDetL.ID
GO
/****** Object:  Table [mdm].[tblBRBusinessRule]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [mdm].[tblBRBusinessRule](
	[ID] [int] IDENTITY(1,1) NOT NULL,
	[Name] [nvarchar](50) NOT NULL,
	[Description] [nvarchar](255) NULL,
	[RuleConditionText] [nvarchar](max) NULL,
	[RuleActionText] [nvarchar](max) NULL,
	[RuleElseActionText] [nvarchar](max) NULL,
	[Entity_ID] [int] NOT NULL,
	[MemberType_ID] [tinyint] NOT NULL,
	[Status_ID] [int] NOT NULL,
	[Priority] [int] NULL,
	[NotificationGroupID] [int] NULL,
	[NotificationUserID] [int] NULL,
	[EnterDTM] [datetime2](3) NOT NULL,
	[EnterUserID] [int] NOT NULL,
	[LastChgDTM] [datetime2](3) NOT NULL,
	[LastChgUserID] [int] NOT NULL,
	[LastChgTS] [timestamp] NOT NULL,
	[MUID] [uniqueidentifier] NOT NULL,
 CONSTRAINT [pk_tblBRBusinessRule] PRIMARY KEY CLUSTERED 
(
	[ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY],
 CONSTRAINT [ux_tblBRBusinessRule_MUID] UNIQUE NONCLUSTERED 
(
	[MUID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
GO
/****** Object:  Table [mdm].[tblBRItemProperties]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [mdm].[tblBRItemProperties](
	[ID] [int] IDENTITY(1,1) NOT NULL,
	[BRItem_ID] [int] NOT NULL,
	[PropertyType_ID] [int] NOT NULL,
	[PropertyName_ID] [int] NOT NULL,
	[Value] [nvarchar](999) NOT NULL,
	[Sequence] [int] NOT NULL,
	[IsLeftHandSide] [bit] NOT NULL,
	[Parent_ID] [int] NULL,
	[SuppressText] [bit] NULL,
	[MUID] [uniqueidentifier] NOT NULL,
 CONSTRAINT [pk_tblBRItemProperties] PRIMARY KEY CLUSTERED 
(
	[ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY],
 CONSTRAINT [ux_tblBRItemProperties_MUID] UNIQUE NONCLUSTERED 
(
	[MUID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [mdm].[tblBRLogicalOperatorGroup]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [mdm].[tblBRLogicalOperatorGroup](
	[ID] [int] IDENTITY(1,1) NOT NULL,
	[LogicalOperator_ID] [int] NULL,
	[Parent_ID] [int] NULL,
	[BusinessRule_ID] [int] NOT NULL,
	[Sequence] [int] NOT NULL,
	[MUID] [uniqueidentifier] NOT NULL,
 CONSTRAINT [pk_tblBRLogicalOperatorGroup] PRIMARY KEY CLUSTERED 
(
	[ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY],
 CONSTRAINT [ux_tblBRLogicalOperatorGroup_MUID] UNIQUE NONCLUSTERED 
(
	[MUID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [mdm].[tblBRItem]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [mdm].[tblBRItem](
	[ID] [int] IDENTITY(1,1) NOT NULL,
	[BRLogicalOperatorGroup_ID] [int] NOT NULL,
	[BRItemAppliesTo_ID] [int] NOT NULL,
	[Sequence] [int] NOT NULL,
	[ItemText] [nvarchar](max) NOT NULL,
	[AnchorName] [nvarchar](250) NULL,
	[AnchorAttributeType] [int] NULL,
	[MUID] [uniqueidentifier] NOT NULL,
 CONSTRAINT [pk_tblBRItem] PRIMARY KEY CLUSTERED 
(
	[ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY],
 CONSTRAINT [ux_tblBRItem_MUID] UNIQUE NONCLUSTERED 
(
	[MUID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
GO
/****** Object:  View [mdm].[viw_SYSTEM_SCHEMA_BUSINESSRULE_PROPERTIES_ATTRIBUTES]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
	SELECT * FROM mdm.viw_SYSTEM_SCHEMA_BUSINESSRULE_PROPERTIES_ATTRIBUTES WHERE BusinessRule_ID = 130  
	SELECT * FROM mdm.viw_SYSTEM_SCHEMA_BUSINESSRULE_PROPERTIES_ATTRIBUTES ORDER BY BusinessRule_ID  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE VIEW [mdm].[viw_SYSTEM_SCHEMA_BUSINESSRULE_PROPERTIES_ATTRIBUTES]  
/*WITH SCHEMABINDING*/  
AS  
SELECT	  
		tProp.ID					Property_ID,  
		tBr.ID						BusinessRule_ID,  
		tBr.MUID					BusinessRule_MUID,  
		tBr.Name					BusinessRule_Name,  
		tBr.Status_ID               BusinessRule_Status,  
		tItem.ID					Item_ID,  
		tItem.MUID					Item_MUID,  
		tItem.BRItemAppliesTo_ID	Item_AppliesTo_ID,  
		tProp.PropertyType_ID		,  
		tProp.Value					Property_Value,  
		tProp.Sequence				Property_Sequence,  
		tProp.IsLeftHandSide		Property_IsLeftHandSide,  
		tProp.Parent_ID				Property_Parent_ID,  
		tPropParent.PropertyType_ID	Property_Parent_PropertyType_ID,  
		tPropParent.PropertyName_ID	Property_Parent_PropertyName_ID,  
		tAtt.Model_ID				,  
		tAtt.Model_MUID				,  
		tAtt.Entity_ID				Attribute_Entity_ID,  
		tAtt.Entity_MUID			Attribute_Entity_MUID,  
		tAtt.Entity_Name			Attribute_Entity_Name,  
		tAtt.Attribute_ID,  
		tAtt.Attribute_MUID,  
		tAtt.Attribute_Name,  
		tAtt.Attribute_Column,  
		tAtt.Attribute_MemberType_ID,  
		tAtt.Attribute_DBAEntity_ID,  
		tAtt.Attribute_DBAEntity_MUID,  
		tAtt.Attribute_DBAEntity_Name,  
		tAtt.Attribute_ChangeTrackingGroup  
  
FROM	  
		mdm.tblBRItemProperties tProp   
		inner join mdm.tblBRItem tItem   
			ON tProp.BRItem_ID = tItem.ID  
		inner join mdm.tblBRLogicalOperatorGroup tOpr   
			on tItem.BRLogicalOperatorGroup_ID = tOpr.ID   
		inner join mdm.tblBRBusinessRule tBr   
			on tOpr.BusinessRule_ID = tBr.ID   
		inner join (SELECT OptionID ID, ListOption Name FROM mdm.tblList WHERE ListCode = CAST(N'lstBRItemPropertyType' AS NVARCHAR(50))) tPropertyType  
			ON tProp.PropertyType_ID = tPropertyType.ID  
		inner join (SELECT OptionID ID, ListOption Name FROM mdm.tblList WHERE ListCode = CAST(N'lstBRItemPropertyName' AS NVARCHAR(50))) tPropertyName  
			ON tProp.PropertyName_ID = tPropertyName.ID  
		INNER JOIN mdm.viw_SYSTEM_SCHEMA_ATTRIBUTES tAtt  
			ON (tProp.PropertyType_ID = 2 /*Attribute property */ OR tProp.PropertyType_ID = 4) /*DBA property */  
            AND CAST(tAtt.Attribute_ID AS NVARCHAR(MAX)) = tProp.Value  
        LEFT JOIN mdm.tblBRItemProperties tPropParent  
            ON tProp.Parent_ID = tPropParent.ID
GO
/****** Object:  View [mdm].[viw_SYSTEM_SCHEMA_MODEL]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
    SELECT * FROM mdm.viw_SYSTEM_SCHEMA_MODEL  
*/  
CREATE VIEW [mdm].[viw_SYSTEM_SCHEMA_MODEL]  
/*WITH SCHEMABINDING*/  
AS  
  
  
SELECT	  
    mod.ID,  
    mod.MUID,  
    mod.Name,  
    mod.[Description],  
    mod.LogRetentionDays LogRetentionDays,  
    COALESCE(mod.EnterUserID, 0) EnteredUser_ID,  
    COALESCE(usrE.MUID, CAST(0x0 AS UNIQUEIDENTIFIER)) EnteredUser_MUID,  
    usrE.UserName EnteredUser_UserName,  
    mod.EnterDTM EnteredUser_DTM,  
    COALESCE(mod.LastChgUserID, 0) LastChgUser_ID,  
    COALESCE(usrL.MUID, CAST(0x0 AS UNIQUEIDENTIFIER)) LastChgUser_MUID,  
    usrL.UserName LastChgUser_UserName,  
    mod.LastChgDTM LastChgUser_DTM  
  
FROM  
    mdm.tblModel [mod]   
    LEFT JOIN mdm.tblUser usrE  
        ON mod.EnterUserID = usrE.ID  
    LEFT JOIN mdm.tblUser usrL  
        ON mod.LastChgUserID = usrL.ID
GO
/****** Object:  View [mdm].[viw_SYSTEM_SCHEMA_BUSINESSRULES]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE VIEW [mdm].[viw_SYSTEM_SCHEMA_BUSINESSRULES]  
/*WITH SCHEMABINDING*/  
AS  
  
WITH brStatusCte AS  
(  
    SELECT   
         OptionID ID  
        ,ListOption Name   
    FROM mdm.tblList   
    WHERE ListCode = CAST(N'lstBRStatus' AS NVARCHAR(50))  
)  
SELECT   
    tMod.ID                 Model_ID  
   ,tMod.MUID               Model_MUID  
   ,tMod.Name               Model_Name  
   ,tBR.Entity_ID           Entity_ID  
   ,tEnt.MUID               Entity_MUID  
   ,tEnt.Name               Entity_Name  
   ,tBR.MemberType_ID       MemberType_ID  
   ,tBR.ID                  BusinessRule_ID  
   ,tBR.MUID                BusinessRule_MUID  
   ,tBR.Name                BusinessRule_Name  
   ,tBR.Description         BusinessRule_Description  
   ,tBR.RuleConditionText   BusinessRule_RuleConditionText  
   ,tBR.RuleActionText      BusinessRule_RuleActionText  
   ,tBR.RuleElseActionText  BusinessRule_RuleElseActionText  
   ,tBR.Status_ID           BusinessRule_StatusID  
   ,tStatus.Name            BusinessRule_StatusName  
   ,tBR.Priority            BusinessRule_Priority  
   ,tBR.NotificationGroupID BusinessRule_NotificationGroupID  
   ,ng.MUID                 BusinessRule_NotificationGroupMUID  
   ,ng.Name                 BusinessRule_NotificationGroupName  
   ,tBR.NotificationUserID  BusinessRule_NotificationUserID  
   ,nu.MUID                 BusinessRule_NotificationUserMUID  
   ,nu.UserName             BusinessRule_NotificationUserName  
   ,tBR.LastChgTS           BusinessRule_LastChgTS  
   ,tBR.EnterUserID         BusinessRule_CreatedUserID  
   ,cu.MUID                 BusinessRule_CreatedUserMUID  
   ,cu.UserName             BusinessRule_CreatedUserName  
   ,tBR.EnterDTM            BusinessRule_DateCreated  
   ,tBR.LastChgUserID       BusinessRule_UpdatedUserID  
   ,uu.MUID                 BusinessRule_UpdatedUserMUID  
   ,uu.UserName             BusinessRule_UpdatedUserName  
   ,tBR.LastChgDTM          BusinessRule_DateUpdated  
FROM mdm.tblBRBusinessRule tBR  
INNER JOIN mdm.tblEntity tEnt  
ON tBR.Entity_ID = tEnt.ID  
INNER JOIN mdm.tblModel tMod   
ON tEnt.Model_ID = tMod.ID  
INNER JOIN brStatusCte tStatus  
ON tBR.Status_ID = tStatus.ID  
LEFT JOIN mdm.tblUserGroup ng  
ON tBR.NotificationGroupID = ng.ID  
LEFT JOIN mdm.tblUser nu  
ON tBR.NotificationUserID = nu.ID  
LEFT JOIN mdm.tblUser cu  
ON tBR.EnterUserID = cu.ID  
LEFT JOIN mdm.tblUser uu  
ON tBR.LastChgUserID = uu.ID
GO
/****** Object:  View [mdm].[viw_SYSTEM_SCHEMA_HIERARCHY_DERIVED]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE VIEW [mdm].[viw_SYSTEM_SCHEMA_HIERARCHY_DERIVED]  
/*WITH SCHEMABINDING*/  
AS  
  
SELECT  
    tHir.Model_ID               Model_ID,   
    tMod.MUID                   Model_MUID,   
    tMod.Name                   Model_Name,    
    tHir.ID                     Hierarchy_ID,   
    tHir.MUID                   Hierarchy_MUID,   
    tHir.Name                   Hierarchy_Name,  
    tHir.AnchorNullRecursions   Hierarchy_AnchorNullRecursions,         
    Hierarchy_Label  = N'Derived: ' + tMod.Name + ': ' + tHir.Name,   
  
    COALESCE(tHir.EnterUserID, 0) EnteredUser_ID,  
    COALESCE(usrE.MUID, CAST(0x0 AS UNIQUEIDENTIFIER)) EnteredUser_MUID,  
    usrE.UserName EnteredUser_UserName,  
    tHir.EnterDTM EnteredUser_DTM,  
    COALESCE(tHir.LastChgUserID, 0) LastChgUser_ID,  
    COALESCE(usrL.MUID, CAST(0x0 AS UNIQUEIDENTIFIER)) LastChgUser_MUID,  
    usrL.UserName LastChgUser_UserName,  
    tHir.LastChgDTM LastChgUser_DTM  
FROM  
    mdm.tblModel tMod   
    INNER JOIN mdm.tblDerivedHierarchy tHir ON tMod.ID = tHir.Model_ID   
    LEFT JOIN mdm.tblUser usrE ON tHir.EnterUserID = usrE.ID  
    LEFT JOIN mdm.tblUser usrL ON tHir.LastChgUserID = usrL.ID
GO
/****** Object:  View [mdm].[viw_SYSTEM_SCHEMA_ATTRIBUTES_ORIGINAL]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    SELECT * FROM mdm.viw_SYSTEM_SCHEMA_ATTRIBUTES_ORIGINAL WHERE Attribute_DBAEntity_ID > 0  
    SELECT * FROM mdm.viw_SYSTEM_SCHEMA_ATTRIBUTES_ORIGINAL WHERE Entity_ID = 23  
    SELECT * FROM mdm.viw_SYSTEM_SCHEMA_ATTRIBUTES_ORIGINAL WHERE Entity_ID = 31 AND Attribute_MemberType_ID = 1  
    SELECT * FROM mdm.viw_SYSTEM_SCHEMA_ATTRIBUTES_ORIGINAL WHERE Entity_ID = 23 AND Attribute_Name = 'Weight'  
    SELECT * FROM mdm.viw_SYSTEM_SCHEMA_ATTRIBUTES_ORIGINAL WHERE Attribute_ID = 1067  
*/  
CREATE VIEW [mdm].[viw_SYSTEM_SCHEMA_ATTRIBUTES_ORIGINAL]  
/*WITH SCHEMABINDING*/  
AS  
WITH attributesCte AS  
(  
    SELECT  
        tEnt.Model_ID                Model_ID,  
        tMod.MUID                    Model_MUID,  
        tMod.Name                    Model_Name,  
        tAtt.Entity_ID               Entity_ID,  
        tEnt.MUID                    Entity_MUID,  
        tEnt.Name                    Entity_Name,  
        tAtt.ID                      Attribute_ID,  
        tAtt.MUID                    Attribute_MUID,  
        tAtt.Name                    Attribute_Name,  
        tAtt.Description             Attribute_Description,  
        tAtt.DisplayName             Attribute_DisplayName,  
        tAtt.DisplayWidth            Attribute_DisplayWidth,  
        tAtt.ChangeTrackingGroup     Attribute_ChangeTrackingGroup,  
        tAtt.TableColumn             Attribute_Column,  
        tAtt.IsSystem                Attribute_IsSystem,  
        tAtt.IsReadOnly              Attribute_IsReadOnly,  
        tAtt.IsCode                  Attribute_IsCode,  
        tAtt.IsName                  Attribute_IsName,  
        tAtt.MemberType_ID           Attribute_MemberType_ID,  
        CASE tAtt.MemberType_ID   
            WHEN 1 THEN N'Leaf'  
            WHEN 2 THEN N'Consolidated'  
            WHEN 3 THEN N'Collection'  
            WHEN 4 THEN N'Hierarchy'  
            WHEN 5 THEN N'CollectionMember'  
            ELSE N'' END             Attribute_MemberType_Name,  
        tAtt.AttributeType_ID        Attribute_Type_ID,  
        CASE tAtt.AttributeType_ID  
            WHEN 1 THEN N'Freeform'  
            WHEN 2 THEN N'Domain'  
            WHEN 3 THEN N'System'  
            WHEN 4 THEN N'File'  
            ELSE N'' END             Attribute_Type_Name,  
        COALESCE(tAtt.DomainEntity_ID, 0)                           Attribute_DBAEntity_ID,  
        COALESCE(tDBAEnt.MUID, 0x0)                                 Attribute_DBAEntity_MUID,  
        COALESCE(tDBAEnt.Name, N'')                                 Attribute_DBAEntity_Name,  
        CASE WHEN tDBAEnt.HierarchyTable IS NULL THEN 0 ELSE 1 END  Attribute_DBAEntity_IsHierarchyEnabled,  
  
        COALESCE(tAtt.FilterParentAttribute_ID, 0)          FilterParentAttribute_ID,  
        COALESCE(filterParent.MUID, 0x0)                    FilterParentAttribute_MUID,  
        COALESCE(filterParent.Name, N'')                    FilterParentAttribute_Name,  
        COALESCE(filterHierarchyLevel.Hierarchy_ID, 0)      FilterParentHierarchy_ID,  
        COALESCE(filterHierarchyLevel.Hierarchy_MUID, 0x0)  FilterParentHierarchy_MUID,  
        COALESCE(filterHierarchyLevel.Hierarchy_Name, N'')  FilterParentHierarchy_Name,  
        COALESCE(filterHierarchyLevel.LevelNumber, -1)      FilterParentHierarchy_LevelNumber,  
  
        tAtt.DataType_ID             Attribute_DataType_ID,  
        CASE tAtt.DataType_ID  
            WHEN 1  THEN N'Text'  
            WHEN 2  THEN N'Number'  
            WHEN 3  THEN N'DateTime'  
            WHEN 6  THEN N'Link'  
            ELSE N'' END             Attribute_DataType_Name,  
        tAtt.DataTypeInformation     Attribute_DataType_Information,  
        tAtt.InputMask_ID            Attribute_DataMask_ID,  
        tDataMask.ListOption         Attribute_DataMask_Name,  
        CASE tAtt.MemberType_ID  
            WHEN 1 THEN tEnt.EntityTable  
            WHEN 2 THEN tEnt.HierarchyParentTable  
            WHEN 3 THEN tEnt.CollectionTable  
            WHEN 4 THEN tEnt.HierarchyTable  
            WHEN 5 THEN tEnt.CollectionMemberTable  
            ELSE N'' END             Entity_PhysicalTableName,  
        tAtt.SortOrder              Attribute_SortOrder,  
        COALESCE(tAtt.EnterUserID, 0)   EnteredUser_ID,  
        COALESCE(usrE.MUID, 0x0)    EnteredUser_MUID,  
        usrE.UserName               EnteredUser_UserName,  
        tAtt.EnterDTM               EnteredUser_DTM,  
        COALESCE(tAtt.LastChgUserID, 0) LastChgUser_ID,  
        COALESCE(usrL.MUID, 0x0)    LastChgUser_MUID,  
        usrL.UserName               LastChgUser_UserName,  
        tAtt.LastChgDTM             LastChgUser_DTM  
    FROM mdm.tblModel tMod  
    INNER JOIN mdm.tblEntity tEnt   
    ON tMod.ID = tEnt.Model_ID  
    INNER JOIN mdm.tblAttribute tAtt   
    ON tEnt.ID = tAtt.Entity_ID  
    LEFT JOIN mdm.tblUser usrE   
    ON tAtt.EnterUserID = usrE.ID  
    LEFT JOIN mdm.tblUser usrL   
    ON tAtt.LastChgUserID = usrL.ID  
    LEFT JOIN mdm.tblList tDataMask   
    ON      tDataMask.ListCode = N'lstInputMask'   
        AND tAtt.InputMask_ID = tDataMask.OptionID   
        AND tAtt.DataType_ID = tDataMask.Group_ID  
    LEFT JOIN mdm.tblEntity tDBAEnt   
    ON tAtt.DomainEntity_ID = tDBAEnt.ID  
  
    -- Filtered DBA parents  
    LEFT JOIN mdm.tblAttribute filterParent  
    ON tAtt.FilterParentAttribute_ID = filterParent.ID  
    LEFT JOIN mdm.viw_SYSTEM_SCHEMA_HIERARCHY_DERIVED_LEVELS filterHierarchyLevel  
    ON tAtt.FilterHierarchyDetail_ID = filterHierarchyLevel.ID  
)  
SELECT  
    *, -- Usually it is best to not SELECT *, but in this case it is okay because we are selecting from the CTE whose columns are defined above.  
    CONCAT(QUOTENAME(Model_Name), N':', QUOTENAME(Entity_Name), N':', QUOTENAME(Attribute_MemberType_Name), N':', QUOTENAME(Attribute_Name)) Attribute_FullyQualifiedName  
FROM attributesCte
GO
/****** Object:  View [mdm].[viw_SYSTEM_SCHEMA_VERSION_FLAGS]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
SELECT * FROM mdm.viw_SYSTEM_SCHEMA_VERSION_FLAGS  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE VIEW [mdm].[viw_SYSTEM_SCHEMA_VERSION_FLAGS]  
/*WITH SCHEMABINDING*/  
AS  
SELECT   
    F.ID,  
    F.MUID,  
    F.Model_ID,  
    M.MUID Model_MUID,  
    M.Name Model_Name,  
    F.Status_ID,  
    CAST(F.CommittedOnly_ID AS BIT) AS IsCommittedOnly,  
    F.Name,  
    F.Description,  
    ISNULL(V.ID, 0) as AssignedVersion_ID,  
    ISNULL(V.MUID,0x0) as AssignedVersion_MUID,  
    ISNULL(V.Name,N'') as AssignedVersion_Name,  
    F.EnterUserID EnteredUser_ID,  
    usrE.MUID EnteredUser_MUID,  
    usrE.UserName EnteredUser_UserName,  
    F.EnterDTM EnteredUser_DTM,  
    F.LastChgUserID LastChgUser_ID,  
    usrL.MUID LastChgUser_MUID,  
    usrL.UserName LastChgUser_UserName,  
    F.LastChgDTM LastChgUser_DTM  
FROM   
    mdm.tblModelVersionFlag F  
    INNER JOIN mdm.tblModel M ON F.Model_ID = M.ID  
    LEFT JOIN mdm.tblUser usrE ON F.EnterUserID = usrE.ID  
    LEFT JOIN mdm.tblUser usrL ON F.LastChgUserID = usrL.ID  
    LEFT JOIN mdm.tblModelVersion V ON F.ID = V.VersionFlag_ID
GO
/****** Object:  Table [mdm].[tblSecurityRoleAccessMember]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [mdm].[tblSecurityRoleAccessMember](
	[ID] [int] IDENTITY(1,1) NOT NULL,
	[Role_ID] [int] NOT NULL,
	[Privilege_ID] [int] NOT NULL,
	[AccessPermission] [tinyint] NOT NULL,
	[Version_ID] [int] NOT NULL,
	[Entity_ID] [int] NOT NULL,
	[HierarchyType_ID] [tinyint] NOT NULL,
	[ExplicitHierarchy_ID] [int] NULL,
	[DerivedHierarchy_ID] [int] NULL,
	[Hierarchy_ID]  AS (case [HierarchyType_ID] when (0) then [ExplicitHierarchy_ID] when (1) then [DerivedHierarchy_ID]  end),
	[MemberType_ID] [tinyint] NOT NULL,
	[Member_ID] [int] NOT NULL,
	[Description] [nvarchar](250) NULL,
	[IsInitialized] [bit] NOT NULL,
	[EnterDTM] [datetime2](3) NOT NULL,
	[EnterUserID] [int] NOT NULL,
	[LastChgDTM] [datetime2](3) NOT NULL,
	[LastChgUserID] [int] NOT NULL,
	[MUID] [uniqueidentifier] NOT NULL,
 CONSTRAINT [pk_tblSecurityRoleAccessMember] PRIMARY KEY CLUSTERED 
(
	[ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  View [mdm].[viw_SYSTEM_SECURITY_ROLE_MEMBER]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE VIEW [mdm].[viw_SYSTEM_SECURITY_ROLE_MEMBER]  
/*WITH SCHEMABINDING*/  
AS  
SELECT  
    sra.Role_ID,  
    hsec.[Entity_ID],  
    hsec.LeafOnly,  
    sra.Version_ID,  
    hsec.ID [Hierarchy_ID],  
    hsec.HierarchyType_ID,  
    sra.IsInitialized  
FROM (  
    SELECT  
        dh.ID AS ID,  
        1 /*HierarchyType_Derived*/ AS HierarchyType_ID,  
        CASE ForeignType_ID  
            WHEN 2 /*HierarchyItemType_ExplicitHierarchy*/ THEN 0  
            ELSE 1  
        END AS LeafOnly,  
        CASE ForeignType_ID  
            WHEN 0 /*HierarchyItemType_Entity*/ THEN dhd.Foreign_ID  
            WHEN 1 /*HierarchyItemType_DBA*/ THEN dba.DomainEntity_ID  
            WHEN 2 /*HierarchyItemType_ExplicitHierarchy*/ THEN eh.[Entity_ID]  
            WHEN 5 /*HierarchyItemType_ManyToMany*/ THEN dba.DomainEntity_ID  
        END AS [Entity_ID]  
    FROM mdm.tblDerivedHierarchy dh    
    INNER JOIN mdm.tblDerivedHierarchyDetail dhd  
    ON dhd.DerivedHierarchy_ID = dh.ID  
    LEFT JOIN mdm.tblAttribute dba  
    ON (ForeignType_ID = 1 /*HierarchyItemType_DBA*/ OR ForeignType_ID = 5 /*HierarchyItemType_ManyToMany*/)  
        AND dba.ID = dhd.Foreign_ID  
    LEFT JOIN mdm.tblHierarchy eh  
    ON ForeignType_ID = 2 /*HierarchyItemType_ExplicitHierarchy*/ AND eh.ID = dhd.Foreign_ID  
    UNION ALL  
    SELECT  
        eh.ID,  
        0 /*HierarchyType_Explicit*/ AS HierarchyType_ID,  
        0 AS LeafOnly,  
        eh.[Entity_ID]  
    FROM mdm.tblHierarchy eh) hsec  
    INNER JOIN mdm.tblSecurityRoleAccessMember sra  
    ON (hsec.HierarchyType_ID = sra.HierarchyType_ID)  
        AND (hsec.ID = sra.DerivedHierarchy_ID AND sra.HierarchyType_ID = 1 /*HierarchyType_Derived*/)  
            OR (hsec.ID = sra.ExplicitHierarchy_ID AND sra.HierarchyType_ID = 0 /*HierarchyType_Explicit*/ )
GO
/****** Object:  View [mdm].[viw_SYSTEM_USERGROUP_USERS]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
    SELECT * FROM mdm.viw_SYSTEM_USERGROUP_USERS  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE VIEW [mdm].[viw_SYSTEM_USERGROUP_USERS]  
/*WITH SCHEMABINDING*/  
AS  
SELECT  
     ug.ID UserGroup_ID  
    ,ug.MUID UserGroup_MUID  
    ,ug.SID UserGroup_SID  
    ,ug.Name UserGroup_Name  
    ,u.ID [User_ID]  
    ,u.MUID User_MUID  
    ,u.SID [User_SID]  
    ,u.UserName [User_Name]  
FROM  
    mdm.tblUserGroup ug  
    INNER JOIN mdm.tblUserGroupAssignment uga  
        ON uga.UserGroup_ID = ug.ID  
        AND ug.Status_ID = 1 -- Active  
    INNER JOIN mdm.tblUser u  
        ON u.ID = uga.[User_ID]  
        AND u.Status_ID = 1 -- Active
GO
/****** Object:  View [mdm].[viw_SYSTEM_SECURITY_USER_ROLE_ORIGINAL]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE VIEW [mdm].[viw_SYSTEM_SECURITY_USER_ROLE_ORIGINAL]  
/*WITH SCHEMABINDING*/  
AS  
SELECT  
   COALESCE(uga.User_ID, sac.Principal_ID) User_ID,   
   sac.Role_ID,  
   CASE WHEN uga.User_ID IS NULL THEN 0 ELSE 1 END IsUserGroupAssignment  
FROM mdm.tblSecurityAccessControl sac  
LEFT JOIN mdm.tblUserGroupAssignment uga  
ON      sac.PrincipalType_ID = 2-- Group  
    AND sac.Principal_ID = uga.UserGroup_ID  
WHERE   sac.PrincipalType_ID = 1--User  
    OR  uga.User_ID IS NOT NULL -- exclude groups that have no users
GO
/****** Object:  View [mdm].[viw_SYSTEM_SCHEMA_BUSINESSRULE_PROPERTIES]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
	SELECT * FROM mdm.viw_SYSTEM_SCHEMA_BUSINESSRULE_PROPERTIES WHERE BusinessRule_ID = 130  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE VIEW [mdm].[viw_SYSTEM_SCHEMA_BUSINESSRULE_PROPERTIES]  
/*WITH SCHEMABINDING*/  
AS  
SELECT	  
		tProp.ID					Property_ID,  
		tBr.ID						BusinessRule_ID,  
		tBr.MUID					BusinessRule_MUID,  
		tBr.Name					BusinessRule_Name,  
		tBr.Status_ID               BusinessRule_Status,  
		tLogicalOperator.ID			LogicalOperator_ID,  
		tOpr.MUID					LogicalOperator_MUID,  
		tLogicalOperator.Name		LogicalOperator_Name,  
		tItem.ID					Item_ID,  
		tItem.MUID					Item_MUID,  
		tItem.ItemText				Item_Text,  
		tItem.Sequence				Item_Sequence,  
		tItem.BRItemAppliesTo_ID	Item_AppliesTo_ID,  
		tPropertyType.ID			PropertyType_ID,  
		tPropertyType.Name			PropertyType_Name,  
		tPropertyName.ID			PropertyName_ID,  
		tPropertyName.Name			PropertyName_Name,  
		tProp.Value					Property_Value,  
		tProp.Sequence				Property_Sequence,  
		tProp.IsLeftHandSide		Property_IsLeftHandSide,  
		tProp.Parent_ID				Property_Parent_ID,  
		tProp.SuppressText			Property_SuppressText  
  
FROM	  
		mdm.tblBRItemProperties tProp   
		inner join mdm.tblBRItem tItem   
			ON tProp.BRItem_ID = tItem.ID  
		inner join mdm.tblBRLogicalOperatorGroup tOpr   
			on tItem.BRLogicalOperatorGroup_ID = tOpr.ID   
		inner join mdm.tblBRBusinessRule tBr   
			on tOpr.BusinessRule_ID = tBr.ID   
		inner join (SELECT OptionID ID, ListOption Name FROM mdm.tblList WHERE ListCode = CAST(N'lstBRItemPropertyType' AS NVARCHAR(50))) tPropertyType  
			ON tProp.PropertyType_ID = tPropertyType.ID  
		inner join (SELECT OptionID ID, ListOption Name FROM mdm.tblList WHERE ListCode = CAST(N'lstBRItemPropertyName' AS NVARCHAR(50))) tPropertyName  
			ON tProp.PropertyName_ID = tPropertyName.ID  
		inner join (SELECT OptionID ID, ListOption Name FROM mdm.tblList WHERE ListCode = CAST(N'lstBRLogicalOperator' AS NVARCHAR(50))) tLogicalOperator  
			ON tOpr.LogicalOperator_ID = tLogicalOperator.ID
GO
/****** Object:  Table [mdm].[tblIndex]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [mdm].[tblIndex](
	[ID] [int] IDENTITY(1,1) NOT NULL,
	[MUID] [uniqueidentifier] NOT NULL,
	[Entity_ID] [int] NOT NULL,
	[SysIndex_ID] [int] NULL,
	[Name] [nvarchar](50) NOT NULL,
	[IsUnique] [bit] NOT NULL,
	[EnterDTM] [datetime2](3) NOT NULL,
	[EnterUserID] [int] NOT NULL,
	[LastChgDTM] [datetime2](3) NOT NULL,
	[LastChgUserID] [int] NOT NULL,
	[LastChgTS] [timestamp] NOT NULL,
 CONSTRAINT [pk_tblIndex] PRIMARY KEY CLUSTERED 
(
	[ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY],
 CONSTRAINT [ux_tblIndex_Entity_ID_Name] UNIQUE NONCLUSTERED 
(
	[Entity_ID] ASC,
	[Name] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY],
 CONSTRAINT [ux_tblIndex_MUID] UNIQUE NONCLUSTERED 
(
	[MUID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  View [mdm].[viw_SYSTEM_SCHEMA_INDEXES]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*    
	SELECT * FROM mdm.viw_SYSTEM_SCHEMA_INDEXES    
*/    
/*    
==============================================================================    
 Copyright (c) Microsoft Corporation. All Rights Reserved.    
==============================================================================    
*/    
CREATE VIEW [mdm].[viw_SYSTEM_SCHEMA_INDEXES]    
/*WITH SCHEMABINDING*/    
AS    
SELECT    
    tEnt.Model_ID       Model_ID,     
    tMod.MUID           Model_MUID,     
    tMod.Name           Model_Name,      
    tInd.Entity_ID      Entity_ID,    
    tEnt.MUID           Entity_MUID,    
    tEnt.Name           Entity_Name,    
    tInd.ID             Index_ID,     
    tInd.MUID           Index_MUID,     
    tInd.Name           Index_Name,  
    tInd.SysIndex_ID    SysIndex_ID,    
    tInd.IsUnique       Index_IsUnique,       
    --    
    COALESCE(tInd.EnterUserID, 0) EnteredUser_ID,    
    COALESCE(usrE.MUID, CAST(0x0 AS UNIQUEIDENTIFIER)) EnteredUser_MUID,    
    usrE.UserName EnteredUser_UserName,    
    tInd.EnterDTM EnteredUser_DTM,    
    COALESCE(tInd.LastChgUserID, 0) LastChgUser_ID,    
    COALESCE(usrL.MUID, CAST(0x0 AS UNIQUEIDENTIFIER)) LastChgUser_MUID,    
    usrL.UserName LastChgUser_UserName,    
    tInd.LastChgDTM LastChgUser_DTM    
FROM    
    mdm.tblIndex tInd  
    INNER JOIN mdm.tblEntity tEnt ON tEnt.ID = tInd.Entity_ID    
    INNER JOIN mdm.tblModel tMod ON tMod.ID = tEnt.Model_ID    
    LEFT JOIN mdm.tblUser usrE ON tInd.EnterUserID = usrE.ID    
    LEFT JOIN mdm.tblUser usrL ON tInd.LastChgUserID = usrL.ID
GO
/****** Object:  Table [mdm].[tblSecurityRoleAccess]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [mdm].[tblSecurityRoleAccess](
	[ID] [int] IDENTITY(1,1) NOT NULL,
	[Role_ID] [int] NOT NULL,
	[Privilege_ID] [int] NOT NULL,
	[AccessPermission] [tinyint] NOT NULL,
	[Model_ID] [int] NOT NULL,
	[Securable_ID] [int] NOT NULL,
	[Object_ID] [int] NOT NULL,
	[Description] [nvarchar](250) NULL,
	[EnterDTM] [datetime2](3) NOT NULL,
	[EnterUserID] [int] NOT NULL,
	[LastChgDTM] [datetime2](3) NOT NULL,
	[LastChgUserID] [int] NOT NULL,
	[MUID] [uniqueidentifier] NOT NULL,
 CONSTRAINT [pk_tblSecurityRoleAccess] PRIMARY KEY CLUSTERED 
(
	[ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  View [mdm].[viw_SYSTEM_SECURITY_ROLE_ORIGINAL]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE VIEW [mdm].[viw_SYSTEM_SECURITY_ROLE_ORIGINAL]  
/*WITH SCHEMABINDING*/  
AS  
--Model permissions  
SELECT  
    tModSec.Role_ID,  
    tModSec.Model_ID,  
    tModSec.Privilege_ID Model_PrivilegeID,  
    tModSec.AccessPermission Model_AccessPermission,  
    1 Model_IsExplicit,  
    0 Entity_ID,  
    0 Entity_PrivilegeID,  
    0 Entity_AccessPermission,  
    0 Entity_IsExplicit,  
    0 MemberType_ID,  
    0 MemberType_PrivilegeID,  
    0 MemberType_AccessPermission,  
    0 MemberType_IsExplicit,  
    0 Attribute_ID,  
    0 Attribute_PrivilegeID,  
    0 Attribute_AccessPermission,  
    0 Attribute_IsExplicit  
FROM  
   mdm.tblSecurityRoleAccess  tModSec  
WHERE Object_ID = 1  
  
--Entity permissions (leaf member, consolidation, and collection member type security is defined at the entity level; i.e., the Securable_ID represents the entity)  
UNION ALL  
SELECT  
    tEntSec.Role_ID,  
    tEnt.Model_ID,  
    CASE tEntSec.Privilege_ID WHEN 1 THEN NULL ELSE 99 END Model_PrivilegeID,  
    0 Model_AccessPermission,  
    0 Model_IsExplicit,  
    tEnt.ID Entity_ID,  
    tEntSec.Privilege_ID Entity_PrivilegeID,  
    tEntSec.AccessPermission Entity_AccessPermission,  
    1 Entity_IsExplicit,  
    0 MemberType_ID,  
    0 MemberType_PrivilegeID,  
    0 MemberType_AccessPermission,  
    0 MemberType_IsExplicit,  
    0 Attribute_ID,  
    0 Attribute_PrivilegeID,  
    0 Attribute_AccessPermission,  
    0 Attribute_IsExplicit  
FROM mdm.tblEntity tEnt  
JOIN mdm.tblSecurityRoleAccess tEntSec  
     ON Object_ID = 3  
     AND tEnt.ID = tEntSec.Securable_ID  
  
--Member type permissions (leaf member, consolidation, and collection member type security is defined at the entity level; i.e., the Securable_ID represents the entity)  
UNION ALL  
SELECT  
    tTypSec.Role_ID,  
    tEnt.Model_ID,  
    CASE tTypSec.Privilege_ID WHEN 1 THEN NULL ELSE 99 END Model_PrivilegeID,  
    0 Model_AccessPermission,  
    0 Model_IsExplicit,  
    tEnt.ID Entity_ID,  
    CASE tTypSec.Privilege_ID WHEN 1 THEN NULL ELSE 99 END Entity_PrivilegeID,  
    0 Entity_AccessPermission,  
    0 Entity_IsExplicit,  
    Object_ID-7 MemberType_ID,  
    tTypSec.Privilege_ID MemberType_PrivilegeID,  
    tTypSec.AccessPermission MemberType_AccessPermission,  
    1 MemberType_IsExplicit,  
    0 Attribute_ID,  
    0 Attribute_PrivilegeID,  
    0 Attribute_AccessPermission,  
    0 Attribute_IsExplicit  
FROM mdm.tblEntity tEnt  
JOIN mdm.tblSecurityRoleAccess tTypSec  
  ON Object_ID BETWEEN 8 AND 10  
  AND tEnt.ID = tTypSec.Securable_ID  
  
UNION ALL  
--Attribute permissions  
SELECT  
    tAttSec.Role_ID,  
    tEnt.Model_ID,  
    CASE tAttSec.Privilege_ID WHEN 1 THEN NULL ELSE 99 END Model_PrivilegeID,  
    0 Model_AccessPermission,  
    0 Model_IsExplicit,  
    tAtt.Entity_ID,  
    CASE tAttSec.Privilege_ID WHEN 1 THEN NULL ELSE 99 END Entity_PrivilegeID,  
    0 Entity_AccessPermission,  
    0 Entity_IsExplicit,  
    tAtt.MemberType_ID,  
    CASE tAttSec.Privilege_ID WHEN 1 THEN NULL ELSE 99 END MemberType_PrivilegeID,  
    0 MemberType_AccessPermission,  
    0 MemberType_IsExplicit,  
    tAtt.ID Attribute_ID,  
    tAttSec.Privilege_ID Attribute_PrivilegeID,  
    tAttSec.AccessPermission Attribute_AccessPermission,  
    1 Attribute_IsExplicit  
FROM mdm.tblAttribute tAtt  
JOIN mdm.tblSecurityRoleAccess tAttSec  
  ON Object_ID = 4  
  AND tAtt.ID = tAttSec.Securable_ID  
JOIN mdm.tblEntity tEnt ON tAtt.Entity_ID = tEnt.ID  
  
UNION ALL  
  
--DBA: If entity is referred by DBA, and DBA permission is Access, then referred entity leaf name and code are inferred read.  
--     The permission could come from entity, membertype and attribute permission of dest entity.  
SELECT  
    referredEntity.Role_ID,  
    tEnt.Model_ID,  
    99 Model_PrivilegeID,  
    0 Model_AccessPermission,  
    0 Model_IsExplicit,  
    refa.Entity_ID,  
    99,  
    0 Entity_AccessPermission,  
    0 Entity_IsExplicit,  
    refa.MemberType_ID,  
    99,  
    0 MemberType_AccessPermission,  
    0 MemberType_IsExplicit,  
    refa.ID Attribute_ID,  
    4 Attribute_PrivilegeID,  
    0 Attribute_AccessPermission,  
    0 Attribute_IsExplicit -- Can be overwritten by MemberType  
FROM  
mdm.tblAttribute refa  
INNER JOIN (  
    SELECT Role_ID AS Role_ID, SourceEntityID AS Entity_ID  
    FROM(  
        SELECT sec.Role_ID AS Role_ID, dba.Entity_ID AS DestEntityId, DomainEntity_ID AS SourceEntityID, MIN(sec.Privilege_ID) AS Privilege_ID  
        FROM mdm.tblAttribute dba  
        INNER JOIN mdm.tblSecurityRoleAccess sec  
            ON ((Object_ID = 3 AND sec.Securable_ID = dba.Entity_ID) -- Any dba attribute on this entity  
               -- Do not use between which leading to bad excution plan  
               OR (Object_ID = 8 AND sec.Securable_ID = dba.Entity_ID AND dba.MemberType_ID = 1) --Any dba attribute on this leaf type  
               OR (Object_ID = 9 AND sec.Securable_ID = dba.Entity_ID AND dba.MemberType_ID = 2) --Any dba attribute on this consolidate type  
               OR (Object_ID = 10 AND sec.Securable_ID = dba.Entity_ID AND dba.MemberType_ID = 3) --Any dba attribute on this collection type  
               OR (Object_ID = 4 AND sec.Securable_ID = dba.ID)) --Any dba attribute  
        WHERE dba.DomainEntity_ID IS NOT NULL  
                AND dba.DomainEntity_ID != dba.Entity_ID -- Exclude self reference  
        GROUP BY sec.Role_ID, dba.Entity_ID, dba.DomainEntity_ID  
        ) AS referredEntityPerDest  
    GROUP BY Role_ID, SourceEntityID  
    HAVING MAX(Privilege_ID) = 4  
    ) AS referredEntity  
    ON ((refa.IsCode = 1 OR refa.IsName = 1) /*Name And Code*/  
        AND refa.Entity_ID = referredEntity.Entity_ID  
        AND refa.MemberType_ID = 1) -- Always refer leaf member  
INNER JOIN mdm.tblEntity tEnt ON refa.Entity_ID = tEnt.ID  
  
UNION ALL  
--DBA: If referred entity is permission deny, the DBA should be deny regardless.  
--     The permission could come from entity and membertype of referred entity.  
SELECT  
    sec.Role_ID,  
    tEnt.Model_ID,  
    99 Model_PrivilegeID,  
    0 Model_AccessPermission,  
    0 Model_IsExplicit,  
    dba.Entity_ID,  
    99,  
    0 Entity_AccessPermission,  
    0 Entity_IsExplicit,  
    dba.MemberType_ID,  
    99,  
    0 MemberType_AccessPermission,  
    0 MemberType_IsExplicit,  
    dba.ID Attribute_ID,  
    1 Attribute_PrivilegeID,  
    0 Attribute_AccessPermission,  
    1 Attribute_IsExplicit -- Cannot be overwritten by MemberType  
FROM  
mdm.tblAttribute dba  
INNER JOIN mdm.tblSecurityRoleAccess sec  
    ON dba.DomainEntity_ID IS NOT NULL  
       AND ((Object_ID = 3 AND sec.Securable_ID = dba.DomainEntity_ID) -- Entity is deny  
           OR (Object_ID = 8 AND sec.Securable_ID = dba.DomainEntity_ID AND dba.MemberType_ID = 1)) --Leaf is deny  
INNER JOIN mdm.tblEntity tEnt ON dba.Entity_ID = tEnt.ID  
WHERE sec.Privilege_ID = 1 /*Deny*/
GO
/****** Object:  View [mdm].[viw_SYSTEM_SCHEMA_ENTITY_MEMBERTYPE]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    SELECT * FROM mdm.viw_SYSTEM_SCHEMA_ENTITY_MEMBERTYPE  
*/  
CREATE VIEW [mdm].[viw_SYSTEM_SCHEMA_ENTITY_MEMBERTYPE]  
/*WITH SCHEMABINDING*/  
AS  
SELECT ID AS Entity_ID, 1 AS MemberType_ID FROM mdm.tblEntity  
UNION ALL  
SELECT ID AS Entity_ID, 2 AS MemberType_ID FROM mdm.tblEntity WHERE HierarchyTable IS NOT NULL  
UNION ALL  
SELECT ID AS Entity_ID, 3  AS MemberType_ID FROM mdm.tblEntity;
GO
/****** Object:  Table [mdm].[tblviwSystemSecurityUserRole]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [mdm].[tblviwSystemSecurityUserRole](
	[User_ID] [int] NULL,
	[Role_ID] [int] NOT NULL,
	[IsUserGroupAssignment] [int] NOT NULL
) ON [PRIMARY]
GO
/****** Object:  View [mdm].[viw_SYSTEM_SECURITY_USER_ROLE]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE VIEW [mdm].[viw_SYSTEM_SECURITY_USER_ROLE]  
/*WITH SCHEMABINDING*/  
AS  
SELECT  
     [User_ID]  
	,[Role_ID]  
	,[IsUserGroupAssignment]  
FROM mdm.tblviwSystemSecurityUserRole
GO
/****** Object:  View [mdm].[viw_SYSTEM_BUSINESSRULES_ATTRIBUTE_INHERITANCE_HIERARCHY]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
  
     SELECT * FROM mdm.viw_SYSTEM_BUSINESSRULES_ATTRIBUTE_INHERITANCE_HIERARCHY WHERE ParentEntityID = 81  
     SELECT * FROM mdm.viw_SYSTEM_BUSINESSRULES_ATTRIBUTE_INHERITANCE_HIERARCHY WHERE ParentEntityID = 80  
     SELECT * FROM mdm.viw_SYSTEM_BUSINESSRULES_ATTRIBUTE_INHERITANCE_HIERARCHY WHERE ParentEntityID = 79  
     SELECT * FROM mdm.viw_SYSTEM_BUSINESSRULES_ATTRIBUTE_INHERITANCE_HIERARCHY WHERE ParentEntityID = 78  
     SELECT * FROM mdm.viw_SYSTEM_BUSINESSRULES_ATTRIBUTE_INHERITANCE_HIERARCHY WHERE ParentModelID = 9  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE VIEW [mdm].[viw_SYSTEM_BUSINESSRULES_ATTRIBUTE_INHERITANCE_HIERARCHY]  
/*WITH SCHEMABINDING*/  
AS  
  
SELECT  
        a.Model_ID AS ParentModelID,  
        a.Attribute_Entity_ID AS ParentEntityID,  
        a.Attribute_Entity_Name AS ParentEntityName,  
        a.Attribute_Name AS ParentAttributeName,  
        a.Attribute_Column AS ParentAttributeColumnName,  
        dba.Attribute_Entity_ID ChildEntityID,  
        dba.Attribute_Entity_Name AS ChildEntityName,  
        dba.Attribute_Name AS ChildAttributeName,  
        dba.Attribute_Column AS ChildAttributeColumnName,  
        a.Attribute_MemberType_ID  
FROM    mdm.viw_SYSTEM_SCHEMA_BUSINESSRULE_PROPERTIES_ATTRIBUTES a  
        INNER JOIN mdm.viw_SYSTEM_SCHEMA_BUSINESSRULE_PROPERTIES_ATTRIBUTES dba  
            ON a.PropertyType_ID = 2  
            AND a.Property_IsLeftHandSide = 0  
            AND dba.PropertyType_ID = 4 -- DBA attribute  
            AND a.Property_Parent_ID = dba.Property_ID  
            AND a.BusinessRule_Status = 1 -- Active  
        INNER JOIN mdm.viw_SYSTEM_SCHEMA_BUSINESSRULE_ITEMTYPES itm  
            ON itm.BRSubTypeID = 3 -- Change value (Equals, Equals concatenated)  
            AND a.Item_AppliesTo_ID = itm.AppliesTo_ID
GO
/****** Object:  View [mdm].[viw_SYSTEM_SECURITY_USER]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE VIEW [mdm].[viw_SYSTEM_SECURITY_USER]  
--SELECT * FROM mdm.viw_SYSTEM_SECURITY_USER  
/*WITH SCHEMABINDING*/  
AS  
SELECT  
    tUserAccess.User_ID,  
    tRole.Role_ID,  
    tRole.Model_ID,  
    tRole.Model_PrivilegeID,  
    tRole.Model_AccessPermission,  
    tRole.Model_IsExplicit,  
    tRole.Entity_ID,  
    tRole.Entity_PrivilegeID,  
    tRole.Entity_AccessPermission,  
    tRole.Entity_IsExplicit,  
    tRole.MemberType_ID,  
    tRole.MemberType_PrivilegeID,  
    tRole.MemberType_AccessPermission,  
    tRole.MemberType_IsExplicit,  
    tRole.Attribute_ID,  
    tRole.Attribute_PrivilegeID,  
    tRole.Attribute_AccessPermission,  
    tRole.Attribute_IsExplicit,  
    tUserAccess.IsUserGroupAssignment  
FROM  
    mdm.viw_SYSTEM_SECURITY_ROLE tRole  
    JOIN mdm.viw_SYSTEM_SECURITY_USER_ROLE tUserAccess ON tRole.Role_ID = tUserAccess.Role_ID
GO
/****** Object:  View [mdm].[viw_EntityStagingBatchesAllProcessedExceptCleared]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
-- Returns all the staging batches that are in the tblStgBatch table  
-- (and thus have at least started being processed by the system)  
-- AND that have not been marked as "cleared"  
CREATE VIEW [mdm].[viw_EntityStagingBatchesAllProcessedExceptCleared]  
AS	  
    SELECT  
        *  
    FROM  
        mdm.viw_EntityStagingBatchesAllProcessed  
    WHERE  
        [Status] != 5 -- Cleared
GO
/****** Object:  View [mdm].[viw_SYSTEM_SECURITY_USER_ATTRIBUTEGROUP]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE VIEW [mdm].[viw_SYSTEM_SECURITY_USER_ATTRIBUTEGROUP]  
/*WITH SCHEMABINDING*/  
AS  
WITH allPermissions AS (  
    SELECT  
        User_ID,  
        ID,  
        MIN(Privilege_ID) Privilege_ID,  
        SUM(Distinct(AccessPermission & 0x1)) +  
        SUM(Distinct(AccessPermission & 0x2)) +  
        SUM(Distinct(AccessPermission & 0x4)) AS AccessPermission  
    FROM  
        (  
        SELECT   
            mtSec.User_ID,  
            tAtt.ID,  
            Privilege_ID =  
                CASE  
                    WHEN mtSec.IsAdmin = 1 THEN 4 /*Access*/  
                    WHEN mtSec.Privilege_ID = 1 /*Deny*/ THEN 1 /*Deny*/  
                    -- No explicit permission on attribute group and non-inferred permission on memberType, use memberType permision  
                    ELSE tExp.Privilege_ID  
                END,  
            AccessPermission =  
                CASE  
                    WHEN mtSec.IsAdmin = 1 THEN 7 /*All*/  
                    WHEN mtSec.Privilege_ID = 1 /*Deny*/ THEN 0 /*None*/  
                    -- No explicit permission on attribute group and non-inferred permission on memberType, use memberType permision  
                    ELSE tExp.AccessPermission  
                END  
        FROM mdm.tblAttributeGroup tAtt  
            INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_MEMBERTYPE mtSec  
            ON tAtt.Entity_ID = mtSec.Entity_ID  
               AND tAtt.MemberType_ID = mtSec.ID  
            LEFT JOIN (  
               SELECT User_ID, Securable_ID AS ID, Privilege_ID, AccessPermission  
               FROM mdm.tblSecurityRoleAccess tAcc  
                   INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_ROLE tRol  
                   ON tRol.Role_ID = tAcc.Role_ID  
               WHERE tAcc.Privilege_ID IS NOT NULL AND  
                  tAcc.Object_ID = 5 /*AttriubteGroup*/  
            ) tExp  
            ON tExp.ID = tAtt.ID AND tExp.[User_ID] = mtSec.[User_ID]  
        ) tSec  
    WHERE  
        Privilege_ID IS NOT NULL  
    GROUP BY  
        User_ID,  
        ID  
)  
SELECT  
    [User_ID],  
    ID,  
    Privilege_ID,  
    CASE Privilege_ID WHEN 4 /*Access*/ THEN AccessPermission ELSE NULL END AccessPermission  
FROM allPermissions  
WHERE Privilege_ID > 1 /*Deny*/
GO
/****** Object:  View [mdm].[viw_SYSTEM_BUSINESSRULES_HIERARCHY_CHANGEVALUE_INHERITANCE]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
    SELECT * FROM mdm.viw_SYSTEM_BUSINESSRULES_HIERARCHY_CHANGEVALUE_INHERITANCE   
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE VIEW [mdm].[viw_SYSTEM_BUSINESSRULES_HIERARCHY_CHANGEVALUE_INHERITANCE]  
/*WITH SCHEMABINDING*/  
AS  
    SELECT  
        DISTINCT   
          br.Model_ID AS ModelID  
         ,br.Entity_ID AS EntityID  
         ,br.Entity_Name AS EntityName  
         ,a.Name AS AttributeName  
         ,a.TableColumn AS AttributeColumnName  
         ,h.ID AS [HierarchyID]  
         ,h.Name AS HierarchyName  
    FROM mdm.viw_SYSTEM_SCHEMA_BUSINESSRULE_PROPERTIES p  
    INNER JOIN mdm.viw_SYSTEM_SCHEMA_BUSINESSRULE_ITEMTYPES itm  
        on itm.BRSubTypeID = 3 /*Change value*/ AND itm.BRItemType_ID IN (14,16) -- Equals, Equals concatenated  
        and p.Item_AppliesTo_ID = itm.AppliesTo_ID  
        and p.PropertyType_ID = 2 -- Attribute  
        and p.Property_IsLeftHandSide = 0   
    INNER JOIN mdm.viw_SYSTEM_SCHEMA_BUSINESSRULES br  
        on  p.BusinessRule_ID = br.BusinessRule_ID  
        and p.BusinessRule_Status = 1 -- Active   
    INNER JOIN mdm.tblAttribute a  
        on a.ID = CAST(p.Property_Value AS INT)  
    INNER JOIN mdm.viw_SYSTEM_SCHEMA_BUSINESSRULE_PROPERTIES hier_p  
        on  hier_p.BusinessRule_ID = br.BusinessRule_ID  
        and hier_p.PropertyType_ID = 3 -- Hierarchy  
    INNER JOIN mdm.tblHierarchy h  
        on h.ID = CAST(hier_p.Property_Value AS INT)
GO
/****** Object:  View [mdm].[viw_SYSTEM_SECURITY_USER_ATTRIBUTE_ORIGINAL]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
Rank    Permission  
----    ---------------------  
1       Model Admin - ALL  
2       MemberType Deny - Deny  
3       No explicit permission, MemberType not inferred permission - MemberType permission  
4       No explicit permission on name/code, MemberType inferred permission - ReadOnly, some attribute has some permission, membertype is inferred read.  
5       Attribute permission, could be explicit attribute permission or null.  
  
SELECT * FROM mdm.viw_SYSTEM_SECURITY_USER_ATTRIBUTE WHERE User_ID = 118  
*/  
CREATE VIEW [mdm].[viw_SYSTEM_SECURITY_USER_ATTRIBUTE_ORIGINAL]  
/*WITH SCHEMABINDING*/  
AS  
WITH allPermissions AS (  
    SELECT  
        User_ID,  
        MAX(IsAdmin) IsAdmin,  
        ID,  
        MIN(Privilege_ID) Privilege_ID,  
        SUM(Distinct(AccessPermission & 0x1)) +  
        SUM(Distinct(AccessPermission & 0x2)) +  
        SUM(Distinct(AccessPermission & 0x4)) AS AccessPermission  
    FROM  
        (  
        SELECT  
            tTypSec.User_ID,  
            tTypSec.IsAdmin,  
            tAtt.ID,  
            Privilege_ID =  
                CASE  
                    WHEN tTypSec.IsAdmin = 1 THEN 4 /*Access*/  
                    WHEN tTypSec.Privilege_ID = 1 /*Deny*/ THEN 1 /*Deny*/  
                    -- No explicit permission on attribute and non-inferred permission on memberType, use memberType permission  
                    WHEN ISNULL(tHasExplicit.HasExplicit, 0) != 1 AND tTypSec.Privilege_ID <> 99  
                        THEN tTypSec.Privilege_ID  
                    -- No explicit permission on Name/Code and inferred permission on memberType, then give ReadOnly permission to Name/Code.  
                    WHEN ISNULL(tHasExplicit.HasExplicit, 0) != 1 AND tTypSec.Privilege_ID = 99 AND (tAtt.IsCode = 1 OR tAtt.IsName = 1)  
                        THEN 4 /*Access*/  
                    ELSE tExp.Attribute_PrivilegeID  
                END,  
            AccessPermission =  
                CASE  
                    WHEN tTypSec.IsSyncTarget = 1 THEN 0 -- An entity that is the target of a sync relationship is read-only  
                    WHEN tTypSec.IsAdmin = 1 THEN 7 /*All*/  
                    WHEN tTypSec.Privilege_ID = 1  /*Deny*/ THEN 0 /*None*/  
                    WHEN ISNULL(tHasExplicit.HasExplicit, 0) != 1 AND tTypSec.Privilege_ID <> 99  
                        THEN tTypSec.AccessPermission  
                    WHEN ISNULL(tHasExplicit.HasExplicit, 0) != 1 AND tTypSec.Privilege_ID = 99 AND (tAtt.IsCode = 1 OR tAtt.IsName = 1)  
                        THEN 0 /*Read*/  
                    ELSE tExp.Attribute_AccessPermission  
                END  
            FROM mdm.tblAttribute tAtt  
            -- Check entity security  
            INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_MEMBERTYPE tTypSec  
            ON      tAtt.Entity_ID = tTypSec.Entity_ID  
                AND tAtt.MemberType_ID = tTypSec.ID  
                AND (tAtt.AttributeType_ID <> 3) -- Exclude system attribute  
  
            LEFT JOIN mdm.viw_SYSTEM_SECURITY_USER tExp  
             ON     tAtt.ID = tExp.Attribute_ID  
                AND tTypSec.User_ID = tExp.User_ID  
  
             -- Check if attribute has explicit permission  
            LEFT JOIN (  
                SELECT Attribute_ID, Role_ID, User_ID, MAX(Attribute_IsExplicit) AS HasExplicit  
                FROM mdm.viw_SYSTEM_SECURITY_USER  
                WHERE Attribute_IsExplicit > 0  
                GROUP BY Attribute_ID, Role_ID, User_ID  
            ) AS tHasExplicit  
            ON tAtt.ID = tHasExplicit.Attribute_ID AND tExp.User_ID = tHasExplicit.User_ID AND tExp.Role_ID = tHasExplicit.Role_ID  
        ) tSec  
    WHERE  
        Privilege_ID IS NOT NULL  
    GROUP BY  
        User_ID,  
        ID  
)  
SELECT  
    [User_ID],  
    IsAdmin,  
    ID,  
    Privilege_ID,  
    CASE Privilege_ID WHEN 4 /*Access*/ THEN AccessPermission ELSE NULL END AccessPermission  
FROM allPermissions  
WHERE Privilege_ID > 1 /*Deny*/
GO
/****** Object:  View [mdm].[viw_SYSTEM_SECURITY_USER_MODEL]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    SELECT * FROM mdm.viw_SYSTEM_SECURITY_USER_MODEL;  
*/  
CREATE VIEW [mdm].[viw_SYSTEM_SECURITY_USER_MODEL]  
/*WITH SCHEMABINDING*/  
AS  
WITH superUsersCte AS  
(  
    SELECT DISTINCT User_ID  
    FROM mdm.viw_SYSTEM_SECURITY_USER_FUNCTION  
    WHERE Function_ID = 6 -- Super User  
)  
,users AS  
(  
    SELECT   
         u.ID User_ID  
        ,CASE WHEN su.User_ID IS NULL THEN 0 ELSE 1 END IsSuperUser  
    FROM mdm.tblUser u  
    LEFT JOIN superUsersCte su  
    ON u.ID = su.User_ID  
    WHERE u.Status_ID = 1 -- Active  
)  
,allPermissions AS  
(  
    SELECT  
         u.User_ID  
        ,model.ID ID  
        ,Privilege_ID =  
            CASE  
                WHEN u.IsSuperUser = 1 THEN -5 /*-Admin, use -5 to make sure Admin won over Deny 1 and Access 4*/   
                WHEN ssu.Model_PrivilegeID = 5 /*Admin*/ THEN -5 /*-Admin*/  
                ELSE ssu.Model_PrivilegeID  
            END  
        ,AccessPermission =  
            CASE  
                WHEN u.IsSuperUser = 1 THEN 0  
                ELSE ssu.Model_AccessPermission  
            END  
    FROM mdm.tblModel model  
    CROSS JOIN users u  
    LEFT JOIN mdm.viw_SYSTEM_SECURITY_USER ssu  
    ON      u.[User_ID] = ssu.[User_ID]   
        AND model.ID = ssu.Model_ID   
        AND u.IsSuperUser = 0  
)  
,combinedPermissions AS  
(  
    SELECT  
         [User_ID]  
        ,ID  
        ,ABS(MIN(Privilege_ID)) Privilege_ID -- Reset -Admin -5 to Admin 5  
        ,SUM(Distinct(AccessPermission & 0x1)) +  
            SUM(Distinct(AccessPermission & 0x2)) +  
            SUM(Distinct(AccessPermission & 0x4)) AS AccessPermission  
    FROM allPermissions  
    WHERE Privilege_ID IS NOT NULL  
    GROUP BY  
         [User_ID]  
        ,ID  
)  
SELECT  
     [User_ID]  
    ,ID  
    ,Privilege_ID  
    ,CASE Privilege_ID WHEN 4 /*Access*/ THEN AccessPermission ELSE NULL END AccessPermission  
FROM combinedPermissions
GO
/****** Object:  View [mdm].[viw_SYSTEM_SECURITY_USER_HIERARCHY]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
Explicit hierarchy requires both permission on leaf and consolidated member  
*/  
CREATE VIEW [mdm].[viw_SYSTEM_SECURITY_USER_HIERARCHY]  
/*WITH SCHEMABINDING*/  
AS  
WITH allPermissions AS (  
    SELECT   
        usr.User_ID,  
        tHir.ID,  
        Privilege_ID =  
            CASE  
                WHEN tMTLeafSec.Privilege_ID = 1 OR tMTConSec.Privilege_ID = 1 THEN 1 /*Deny*/  
                WHEN tMTLeafSec.Privilege_ID = 4 OR tMTConSec.Privilege_ID = 4 THEN 4 /*Access*/  
                ELSE 99 /*Inferred*/  
            END,  
        tMTLeafSec.AccessPermission & tMTConSec.AccessPermission AS AccessPermission  
    FROM mdm.tblHierarchy tHir  
    CROSS JOIN(  
            SELECT DISTINCT [User_ID] AS [User_ID]  
            FROM mdm.viw_SYSTEM_SECURITY_USER_FUNCTION  
        ) AS usr  
    LEFT JOIN mdm.viw_SYSTEM_SECURITY_USER_MEMBERTYPE tMTLeafSec  
    ON      tMTLeafSec.Entity_ID = tHir.Entity_ID   
        AND tMTLeafSec.ID = 1   
        AND tMTLeafSec.User_ID = usr.User_ID  
    LEFT JOIN  mdm.viw_SYSTEM_SECURITY_USER_MEMBERTYPE tMTConSec  
    ON      tMTConSec.Entity_ID = tHir.Entity_ID   
        AND tMTConSec.ID = 2   
        AND tMTConSec.User_ID = usr.User_ID  
    WHERE   tMTLeafSec.Privilege_ID IS NOT NULL  
        AND tMTConSec.Privilege_ID IS NOT NULL  
)  
SELECT  
    [User_ID],  
    ID,  
    Privilege_ID,  
    CASE Privilege_ID WHEN 4 /*Access*/ THEN AccessPermission ELSE NULL END AccessPermission  
FROM allPermissions  
WHERE Privilege_ID > 1 /*Deny*/
GO
/****** Object:  View [mdm].[viw_SYSTEM_SECURITY_USER_HIERARCHY_DERIVED]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    SELECT * FROM mdm.viw_SYSTEM_SECURITY_USER_HIERARCHY_DERIVED ORDER BY User_ID  
*/  
CREATE VIEW [mdm].[viw_SYSTEM_SECURITY_USER_HIERARCHY_DERIVED]  
/*WITH SCHEMABINDING*/  
AS  
WITH allPermissions AS (  
    SELECT  
        User_ID,  
        ID,  
        MIN(Privilege_ID) Privilege_ID,  
        Avg(AccessPermission & 0x1) / 0x1 * 0x1 +  
        Avg(AccessPermission & 0x2) / 0x2 * 0x2 +  
        Avg(AccessPermission & 0x4) / 0x4 * 0x4 AS AccessPermission  
    FROM  
        (  
        SELECT  
            usr.User_ID,  
            dh.ID,  
            Privilege_ID =  
                CASE  
                    WHEN dhd.ForeignType_ID IS NULL THEN 4 /*Access*/  
                    WHEN dhd.ForeignType_ID = 0/*Entity*/ THEN ISNULL(mtSec.Privilege_ID, 1 /*Deny*/)  
                    WHEN dhd.ForeignType_ID = 1/*DBA*/ OR dhd.ForeignType_ID = 5/*Many To Many*/ THEN ISNULL(attSec.Privilege_ID, 1 /*Deny*/)  
                    WHEN dhd.ForeignType_ID = 2/*Explicit Hierarchy*/ THEN ISNULL(ehSec.Privilege_ID, 1 /*Deny*/)  
                END,  
            AccessPermission =  
                CASE  
                    WHEN dhd.ForeignType_ID IS NULL THEN 7 /*All*/  
                    WHEN dhd.ForeignType_ID = 0/*Entity*/ THEN ISNULL(mtSec.AccessPermission, 0 /*None*/)  
                    WHEN dhd.ForeignType_ID = 1/*DBA*/ OR dhd.ForeignType_ID = 5/*Many To Many*/ THEN ISNULL(attSec.AccessPermission, 0 /*None*/)  
                    WHEN dhd.ForeignType_ID = 2 /*Explicit Hierarchy*/THEN ISNULL(ehSec.AccessPermission, 0 /*None*/)  
                END  
        FROM mdm.tblDerivedHierarchy dh  
        CROSS JOIN(  
            SELECT DISTINCT [User_ID] AS [User_ID] -- All users that have at least one functional permission  
            FROM mdm.viw_SYSTEM_SECURITY_USER_FUNCTION  
        ) AS usr  
        LEFT JOIN mdm.tblDerivedHierarchyDetail dhd  
        ON dhd.DerivedHierarchy_ID = dh.ID  
        LEFT JOIN mdm.viw_SYSTEM_SECURITY_USER_MEMBERTYPE mtSec  
        ON      dhd.ForeignType_ID = 0/*Entity*/   
            AND mtSec.ID = 1   
            AND dhd.Foreign_ID = mtSec.Entity_ID   
            AND usr.User_ID = mtSec.User_ID  
        LEFT JOIN mdm.viw_SYSTEM_SECURITY_USER_ATTRIBUTE attSec  
        ON      dhd.ForeignType_ID IN (1/*DBA*/, 5/*Many To Many*/)   
            AND (dhd.Foreign_ID = attSec.ID OR dhd.ManyToManyChildAttribute_ID = attSec.ID)  
            AND usr.User_ID = attSec.User_ID  
        LEFT JOIN mdm.viw_SYSTEM_SECURITY_USER_HIERARCHY ehSec  
        ON      dhd.ForeignType_ID = 2/*Explicit Hierarchy*/   
            AND dhd.Foreign_ID = ehSec.ID   
            AND usr.User_ID = ehSec.User_ID  
        ) dhdSec  
    GROUP BY  
        User_ID,  
        ID  
)  
SELECT  
    [User_ID],  
    ID,  
    Privilege_ID,  
    CASE Privilege_ID WHEN 4 /*Access*/ THEN AccessPermission ELSE NULL END AccessPermission  
FROM allPermissions  
WHERE Privilege_ID > 1 /*Deny*/
GO
/****** Object:  Table [mdm].[tblSecurityRole]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [mdm].[tblSecurityRole](
	[ID] [int] IDENTITY(1,1) NOT NULL,
	[MUID] [uniqueidentifier] NOT NULL,
	[Name] [nvarchar](115) NOT NULL,
	[Description] [nvarchar](100) NULL,
	[EnterDTM] [datetime2](3) NOT NULL,
	[EnterUserID] [int] NOT NULL,
	[LastChgDTM] [datetime2](3) NOT NULL,
	[LastChgUserID] [int] NOT NULL,
 CONSTRAINT [pk_tblSecurityRole] PRIMARY KEY CLUSTERED 
(
	[ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  View [mdm].[viw_SYSTEM_SECURITY_ROLE_ACCESSCONTROL_MEMBER]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
SELECT * FROM mdm.viw_SYSTEM_SECURITY_ROLE_ACCESSCONTROL_MEMBER  
  
*/  
CREATE VIEW [mdm].[viw_SYSTEM_SECURITY_ROLE_ACCESSCONTROL_MEMBER]  
/*WITH SCHEMABINDING*/  
AS  
SELECT  
     ra.ID AS RoleAccess_ID  
    ,ra.MUID AS RoleAccess_MUID  
    ,ra.Privilege_ID  
    ,ra.AccessPermission  
    ,mdl.ID AS Model_ID  
    ,mdl.MUID AS Model_MUID  
    ,mdl.Name AS Model_Name  
    ,CASE modSec.Privilege_ID WHEN 5 /*Admin*/ THEN 1 ELSE 0 END IsModelAdministrator  
    ,ra.Version_ID  
    ,modv.MUID AS Version_MUID  
    ,modv.Name as Version_Name  
    ,ra.HierarchyType_ID  
    ,ra.Hierarchy_ID  
    ,ISNULL(hi.MUID, dh.MUID) AS Hierarchy_MUID  
    ,ISNULL(hi.Name, dh.Name) AS Hierarchy_Name  
    ,ra.Entity_ID  
    ,ent.MUID AS Entity_MUID  
    ,ent.Name AS Entity_Name  
    ,ra.MemberType_ID  
    ,ra.Member_ID  
    ,ra.Role_ID  
    ,ac.PrincipalType_ID  
    ,ac.Principal_ID  
    ,CASE ac.PrincipalType_ID WHEN 1/*User*/ THEN u.MUID     ELSE ug.MUID END AS Principal_MUID  
    ,CASE ac.PrincipalType_ID WHEN 1/*User*/ THEN u.UserName ELSE ug.Name END AS Principal_Name  
    ,ra.EnterUserID  
    ,eu.MUID AS EnterUserMUID  
    ,eu.DisplayName AS EnterUser  
    ,ra.EnterDTM  
    ,ra.LastChgUserID  
    ,lcu.MUID AS LastChgUserMUID  
    ,lcu.DisplayName AS LastChgUser  
    ,ra.LastChgDTM  
FROM mdm.tblSecurityRole r  
INNER JOIN mdm.tblSecurityAccessControl ac   
ON r.ID = ac.Role_ID  
INNER JOIN mdm.tblSecurityRoleAccessMember ra   
ON ra.Role_ID = r.ID  
LEFT JOIN mdm.tblEntity ent   
ON ra.Entity_ID = ent.ID   
LEFT JOIN mdm.tblModelVersion modv   
ON ra.Version_ID = modv.ID  
LEFT JOIN mdm.tblModel mdl   
ON modv.Model_ID = mdl.ID  
LEFT JOIN mdm.viw_SYSTEM_SECURITY_USER_MODEL modSec  
ON      ac.PrincipalType_ID = 1/*User*/  
    AND ac.Principal_ID = modSec.User_ID  
    AND mdl.ID = modSec.ID  
LEFT JOIN mdm.tblHierarchy hi   
ON      ra.Hierarchy_ID = hi.ID   
    AND ra.HierarchyType_ID = 0/*Explicit Hierarchy*/  
LEFT JOIN mdm.tblDerivedHierarchy dh   
ON      ra.Hierarchy_ID = dh.ID   
    AND ra.HierarchyType_ID = 1/*Derived Hierarchy*/  
LEFT JOIN mdm.tblUserGroup ug   
ON      ac.PrincipalType_ID = 2/* UserGroup*/   
    AND ac.Principal_ID = ug.ID   
    AND ug.Status_ID = 1 /*Active*/  
LEFT JOIN mdm.tblUser u   
ON      ac.PrincipalType_ID = 1/*User*/   
    AND ac.Principal_ID = u.ID   
LEFT JOIN mdm.tblUser eu   
ON ra.EnterUserID = eu.ID   
LEFT JOIN mdm.tblUser lcu   
ON ra.LastChgUserID = lcu.ID
GO
/****** Object:  Table [mdm].[tblSyncRelationship]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [mdm].[tblSyncRelationship](
	[ID] [int] IDENTITY(1,1) NOT NULL,
	[SourceVersion_ID] [int] NOT NULL,
	[SourceEntity_ID] [int] NOT NULL,
	[TargetVersion_ID] [int] NOT NULL,
	[TargetEntity_ID] [int] NOT NULL,
	[TargetEntityNameIsAliased] [bit] NOT NULL,
	[RefreshFrequencyInHours] [int] NULL,
	[LastSuccessfulSyncDTM] [datetime2](7) NULL,
	[LastSuccessfulSyncTimestamp] [varbinary](8) NULL,
	[LastSyncAttemptDTM] [datetime2](7) NULL,
	[LastSyncAttemptStatus] [tinyint] NOT NULL,
	[LastSyncAttemptErrorInfo] [nvarchar](max) NULL,
	[EnterDTM] [datetime2](7) NOT NULL,
	[EnterUserID] [int] NOT NULL,
	[LastChgDTM] [datetime2](7) NOT NULL,
	[LastChgUserID] [int] NOT NULL,
	[LastChgTS] [timestamp] NOT NULL,
 CONSTRAINT [pk_tblSyncRelationship] PRIMARY KEY CLUSTERED 
(
	[ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY],
 CONSTRAINT [ux_tblSyncRelationship_TargetVersion_ID_TargetEntity_ID] UNIQUE NONCLUSTERED 
(
	[TargetVersion_ID] ASC,
	[TargetEntity_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
GO
/****** Object:  View [mdm].[viw_SYSTEM_SECURITY_USER_ENTITY]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE VIEW [mdm].[viw_SYSTEM_SECURITY_USER_ENTITY]  
/*WITH SCHEMABINDING*/  
AS  
/*  
Determines the effective permissions for each entity. Effective permissions are determined based on the following:  
  
Rank    Permission  
----    ---------------------  
1       Model Admin - ALL  
2       Model Deny - Deny  
3       No explicit permission, Model not inferred permission - Model permission  
4       Entity permission, could be explicit permission or null.  
  
*/  
WITH syncTargets AS  
(  
    SELECT DISTINCT TargetEntity_ID ID  
    FROM mdm.tblSyncRelationship  
),  
allPermissions AS (  
    SELECT  
        tSec.User_ID,  
        MAX(tSec.IsSyncTarget) IsSyncTarget,  
        tSec.ID,  
        ABS(MIN(tSec.Privilege_ID)) Privilege_ID,  
        SUM(Distinct(tSec.AccessPermission & 0x1)) +  
        SUM(Distinct(tSec.AccessPermission & 0x2)) +  
        SUM(Distinct(tSec.AccessPermission & 0x4)) AS AccessPermission  
    FROM  
        (  
        SELECT  
            tModSec.User_ID,  
            IsSyncTarget = CASE WHEN sync.ID IS NULL THEN 0 ELSE 1 END,  
            tEnt.ID,  
            Privilege_ID =  
                CASE  
                    WHEN tModSec.Privilege_ID = 1 /*Deny*/ THEN 1 /*Deny*/  
                    WHEN tModSec.Privilege_ID = 5 /*Admin*/ THEN CASE WHEN sync.ID IS NOT NULL THEN 4 /*Access*/ ELSE -5 /*-Admin*/ END  
                    WHEN tExp.Entity_PrivilegeID = 5 /*Admin*/ THEN CASE WHEN sync.ID IS NOT NULL THEN 4 /*Access*/ ELSE -5 /*-Admin*/ END  
                    -- No explicit permission on entity per role and non-inferred permission on model, use model permision  
                    WHEN ISNULL(tHasExplicit.HasExplicit, 0) != 1 AND tModSec.Privilege_ID <> 99  
                         THEN tModSec.Privilege_ID  
                    ELSE tExp.Entity_PrivilegeID  
                END,  
            AccessPermission =  
            CASE  
                    WHEN tModSec.Privilege_ID = 1 /*Deny*/ THEN NULL /*None*/  
                    WHEN sync.ID IS NOT NULL THEN 0 -- An entity that is the target of a sync relationship is read-only  
                    WHEN tModSec.Privilege_ID = 5 /*Admin*/ THEN NULL /*None*/  
                    WHEN tExp.Entity_PrivilegeID = 5 /*Admin*/ THEN NULL /*None*/  
                    WHEN ISNULL(tHasExplicit.HasExplicit, 0) != 1 AND tModSec.Privilege_ID <> 99  
                         THEN tModSec.AccessPermission  
                    ELSE tExp.Entity_AccessPermission  
                    END  
        FROM mdm.tblEntity tEnt  
        -- Check Model security  
        INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_MODEL tModSec  
        ON tModSec.ID = tEnt.Model_ID  
  
        LEFT JOIN mdm.viw_SYSTEM_SECURITY_USER tExp  
        ON tEnt.ID = tExp.Entity_ID  
            AND tModSec.User_ID = tExp.User_ID  
  
        -- Check if entity has explicit permission per each role  
        LEFT JOIN (  
            SELECT Entity_ID, User_ID, Role_ID, MAX(Entity_IsExplicit) AS HasExplicit  
            FROM mdm.viw_SYSTEM_SECURITY_USER  
            WHERE Entity_IsExplicit > 0  
            GROUP BY Entity_ID, User_ID, Role_ID  
        ) AS tHasExplicit  
        ON tEnt.ID = tHasExplicit.Entity_ID AND tExp.User_ID = tHasExplicit.User_ID AND tExp.Role_ID = tHasExplicit.Role_ID  
  
        LEFT JOIN syncTargets sync  
        ON tEnt.ID = sync.ID  
    ) tSec  
  
    WHERE  
        tSec.Privilege_ID IS NOT NULL  
    GROUP BY  
        tSec.User_ID,  
        tSec.ID  
)  
SELECT  
    [User_ID],  
    IsSyncTarget,  
    ID,  
    Privilege_ID,  
    CASE Privilege_ID WHEN 4 /*Access*/ THEN AccessPermission ELSE NULL END AccessPermission  
FROM allPermissions
GO
/****** Object:  View [mdm].[viw_SYSTEM_SECURITY_USER_MEMBER]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE VIEW [mdm].[viw_SYSTEM_SECURITY_USER_MEMBER]  
/*WITH SCHEMABINDING*/  
AS  
SELECT  
    tRol.[User_ID],  
    MIN(tMbr.Privilege_ID) Privilege_ID,  
    SUM(Distinct(tMbr.AccessPermission & 0x1)) +  
    SUM(Distinct(tMbr.AccessPermission & 0x2)) +  
    SUM(Distinct(tMbr.AccessPermission & 0x4)) AS AccessPermission,  
    Version_ID,  
    Entity_ID,  
    Hierarchy_ID,  
    HierarchyType_ID,  
    Member_ID,  
    MemberType_ID,  
    tMbr.IsInitialized IsMapped  
FROM  
    mdm.tblSecurityRoleAccessMember tMbr  
    INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_ROLE tRol ON tMbr.Role_ID = tRol.Role_ID  
    LEFT JOIN mdm.viw_SYSTEM_SECURITY_USER_ENTITY e  
    ON      tMbr.Entity_ID = e.ID  
        AND tRol.[User_ID] = e.[User_ID]  
WHERE  
    HierarchyType_ID = 0 /*Explicit*/  
    AND e.Privilege_ID != 5 /*Admin*/-- Ignore member permissions if the user is a entity administrator.  
GROUP BY  
    tRol.[User_ID],  
    Version_ID,  
    Entity_ID,  
    Hierarchy_ID,  
    HierarchyType_ID,  
    Member_ID,  
    MemberType_ID,  
    tMbr.IsInitialized  
  
UNION ALL  
SELECT  
    tRol.[User_ID],  
    MIN(tMbr.Privilege_ID) Privilege_ID,  
    SUM(Distinct(tMbr.AccessPermission & 0x1)) +  
    SUM(Distinct(tMbr.AccessPermission & 0x2)) +  
    SUM(Distinct(tMbr.AccessPermission & 0x4)) AS AccessPermission,  
    Version_ID,  
    Entity_ID,  
    Hierarchy_ID,  
    HierarchyType_ID,  
    Member_ID,  
    MemberType_ID,  
    tMbr.IsInitialized IsMapped  
FROM  
    mdm.tblSecurityRoleAccessMember tMbr  
    JOIN mdm.viw_SYSTEM_SECURITY_USER_ROLE tRol ON tMbr.Role_ID = tRol.Role_ID  
    LEFT JOIN mdm.viw_SYSTEM_SECURITY_USER_ENTITY e  
    ON      tMbr.Entity_ID = e.ID  
        AND tRol.[User_ID] = e.[User_ID]  
WHERE  
    HierarchyType_ID = 1 /*Derived*/  
    AND e.Privilege_ID != 5 /*Admin*/-- Ignore member permissions if the user is a entity administrator.  
GROUP BY  
    tRol.[User_ID],  
    Version_ID,  
    Entity_ID,  
    Hierarchy_ID,  
    HierarchyType_ID,  
    Member_ID,  
    MemberType_ID,  
    tMbr.IsInitialized
GO
/****** Object:  View [mdm].[viw_SYSTEM_SECURITY_USER_MEMBERTYPE_ORIGINAL]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    SELECT * FROM mdm.viw_SYSTEM_SECURITY_USER_MEMBERTYPE_ORIGINAL ORDER BY User_ID, Entity_ID, ID  
  
    Rank    Permission  
----    ---------------------  
1       Model Admin - ALL  
2       Entity Deny - Deny  
3       No explicit permission, Entity not inferred permission - Entity permission  
4       MemberType permission, could be explicit permission or null.  
  
*/  
CREATE VIEW [mdm].[viw_SYSTEM_SECURITY_USER_MEMBERTYPE_ORIGINAL]  
/*WITH SCHEMABINDING*/  
AS  
WITH allPermissions AS (  
    SELECT  
        User_ID,  
        MAX(IsAdmin) IsAdmin,  
        MAX(IsSyncTarget) IsSyncTarget,  
        Entity_ID,  
        ID,  
        MIN(Privilege_ID) Privilege_ID,  
        SUM(Distinct(AccessPermission & 0x1)) +  
        SUM(Distinct(AccessPermission & 0x2)) +  
        SUM(Distinct(AccessPermission & 0x4)) AS AccessPermission  
    FROM  
        (  
        SELECT  
            tEntSec.User_ID,  
            tEntSec.ID AS Entity_ID,  
            CASE tEntSec.Privilege_ID WHEN 5 /*Admin*/ THEN 1 ELSE 0 END IsAdmin,  
            tEntSec.IsSyncTarget,  
            tMbrTyp.MemberType_ID AS ID,  
            Privilege_ID =  
                CASE  
                    WHEN tEntSec.Privilege_ID = 1 /*Deny*/ THEN 1 /*Deny*/  
                    WHEN tEntSec.Privilege_ID = 5 /*Admin*/ THEN 4 /*Access*/  
                    -- No explicit permission on membertype and non-inferred permission on entity, use entity permission  
                    WHEN ISNULL(tHasExplicit.HasExplicit, 0) != 1 AND tEntSec.Privilege_ID <> 99  
                        THEN tEntSec.Privilege_ID  
                    ELSE tExp.MemberType_PrivilegeID -- use Member Type permission  
                END,  
            AccessPermission =  
                CASE  
                    WHEN tEntSec.Privilege_ID = 1  /*Deny*/ THEN NULL /*None*/  
                    WHEN tEntSec.IsSyncTarget = 1 THEN 0 -- An entity that is the target of a sync relationship is read-only  
                    WHEN tEntSec.Privilege_ID = 5 /*Admin*/ THEN 7 /*All*/  
                    WHEN ISNULL(tHasExplicit.HasExplicit, 0) != 1 AND tEntSec.Privilege_ID <> 99  
                        THEN tEntSec.AccessPermission  
                    ELSE tExp.MemberType_AccessPermission -- use Member Type permission  
                END  
        FROM  
            mdm.viw_SYSTEM_SCHEMA_ENTITY_MEMBERTYPE tMbrTyp  
            -- Check entity security  
            INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_ENTITY tEntSec  
            ON tMbrTyp.Entity_ID = tEntSec.ID  
  
            LEFT JOIN mdm.viw_SYSTEM_SECURITY_USER tExp  
             ON tMbrTyp.Entity_ID = tExp.Entity_ID  
                 AND tMbrTyp.MemberType_ID = tExp.MemberType_ID  
                 AND tEntSec.User_ID = tExp.User_ID  
  
             -- Check if memberType has explicit permission  
            LEFT JOIN (  
                SELECT Entity_ID, MemberType_ID, Role_ID, User_ID, MAX(MemberType_IsExplicit) as HasExplicit  
                FROM mdm.viw_SYSTEM_SECURITY_USER  
                WHERE MemberType_IsExplicit > 0  
                GROUP BY Entity_ID, MemberType_ID, Role_ID, User_ID  
            ) AS tHasExplicit  
            ON tMbrTyp.Entity_ID = tHasExplicit.Entity_ID AND tMbrTyp.MemberType_ID = tHasExplicit.MemberType_ID AND tExp.User_ID = tHasExplicit.User_ID AND tExp.Role_ID = tHasExplicit.Role_ID  
        ) tSec  
    WHERE  
        Privilege_ID IS NOT NULL  
    GROUP BY  
        User_ID,  
        Entity_ID,  
        ID  
)  
SELECT  
    [User_ID],  
    IsAdmin,  
    IsSyncTarget,  
    Entity_ID,  
    ID,  
    Privilege_ID,  
    CASE Privilege_ID WHEN 4 /*Access*/ THEN AccessPermission ELSE NULL END AccessPermission  
FROM allPermissions
GO
/****** Object:  View [mdm].[viw_SYSTEM_SECURITY_USER_INDEX]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE VIEW [mdm].[viw_SYSTEM_SECURITY_USER_INDEX]  
/*WITH SCHEMABINDING*/  
AS  
WITH allPermissions AS (  
    SELECT  
        User_ID,  
        ID,  
        MIN(Privilege_ID) Privilege_ID,  
        SUM(Distinct(AccessPermission & 0x1)) +  
        SUM(Distinct(AccessPermission & 0x2)) +  
        SUM(Distinct(AccessPermission & 0x4)) AS AccessPermission  
    FROM  
        (  
        SELECT  
            entSec.User_ID,  
            tIdx.ID,  
            Privilege_ID =  
                CASE  
                    WHEN entSec.Privilege_ID = 5 THEN 4 /*Access*/  
                    WHEN entSec.Privilege_ID = 1 /*Deny*/ THEN 1 /*Deny*/  
                END,  
            AccessPermission =  
                CASE  
                    WHEN entSec.Privilege_ID = 5 THEN 7 /*All*/  
                    WHEN entSec.Privilege_ID = 1 /*Deny*/ THEN 0 /*None*/  
                END  
        FROM mdm.tblIndex tIdx  
            INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_ENTITY entSec  
            ON tIdx.Entity_ID = entSec.ID  
        ) tSec  
    WHERE  
        Privilege_ID IS NOT NULL  
    GROUP BY  
        User_ID,  
        ID  
)  
SELECT  
    [User_ID],  
    ID,  
    Privilege_ID,  
    CASE Privilege_ID WHEN 4 /*Access*/ THEN AccessPermission ELSE NULL END AccessPermission  
FROM allPermissions  
WHERE Privilege_ID > 1 /*Deny*/
GO
/****** Object:  View [mdm].[viw_SYSTEM_SECURITY_ROLE_ACCESSCONTROL]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
    SELECT * FROM mdm.viw_SYSTEM_SECURITY_ROLE_ACCESSCONTROL   
  
*/  
CREATE VIEW [mdm].[viw_SYSTEM_SECURITY_ROLE_ACCESSCONTROL]  
/*WITH SCHEMABINDING*/  
AS  
SELECT  
     ra.ID      RoleAccess_ID  
    ,ra.MUID    RoleAccess_MUID  
    ,ra.Role_ID  
    ,ac.Principal_ID  
    ,CASE ac.PrincipalType_ID WHEN 1 THEN u.MUID ELSE ug.MUID END AS Principal_MUID  
    ,ac.PrincipalType_ID  
    ,CASE ac.PrincipalType_ID WHEN 1 THEN u.UserName ELSE ug.Name END AS Principal_Name  
    ,ra.[Object_ID]  
    ,ra.Model_ID  
    ,mdl.MUID Model_MUID  
    ,mdl.Name Model_Name  
    ,CASE modSecUsr.Privilege_ID WHEN 5 /*Admin*/ THEN 1 ELSE 0 END IsModelAdministrator  
    ,ra.Securable_ID  
    ,CASE   
        WHEN ra.Object_ID = 1 THEN --Model  
            (SELECT MUID FROM mdm.tblModel WHERE ID = ra.Securable_ID)  
        WHEN ra.Object_ID = 3 OR ra.Object_ID = 8 OR ra.Object_ID = 9 OR ra.Object_ID = 10 THEN --Entity  
            (SELECT MUID FROM mdm.tblEntity WHERE ID = ra.Securable_ID)  
        WHEN ra.Object_ID = 4 THEN --Attribute  
            (SELECT MUID FROM mdm.tblAttribute WHERE ID = ra.Securable_ID)  
        WHEN ra.Object_ID = 5 THEN --Attribute Group  
            (SELECT MUID FROM mdm.tblAttributeGroup WHERE ID = ra.Securable_ID)  
        END Securable_MUID  
    ,mdm.udfSecurableNameGetByObjectID(ra.Object_ID, ra.Securable_ID) Securable_Name  
    ,ra.Privilege_ID  
    ,ra.AccessPermission  
    ,ra.EnterUserID  
    ,eu.MUID AS EnterUserMUID  
    ,eu.DisplayName EnterUserName  
    ,ra.EnterDTM  
    ,ra.LastChgUserID  
    ,lcu.MUID AS LastChgUserMUID  
    ,lcu.DisplayName AS LastChgUserName  
    ,ra.LastChgDTM  
FROM mdm.tblSecurityRole r  
INNER JOIN mdm.tblSecurityAccessControl ac   
ON r.ID = ac.Role_ID  
INNER JOIN mdm.tblSecurityRoleAccess ra  
ON ra.Role_ID = r.ID  
INNER JOIN  mdm.tblModel mdl  
ON ra.Model_ID = mdl.ID  
  
-- Get user ModelAdmin status.  
LEFT JOIN mdm.viw_SYSTEM_SECURITY_USER_MODEL modSecUsr  
ON      ac.PrincipalType_ID = 1/*User*/  
    AND ac.Principal_ID = modSecUsr.User_ID  
    AND mdl.ID = modSecUsr.ID  
  
LEFT JOIN mdm.tblUser eu   
ON ra.EnterUserID = eu.ID  
LEFT JOIN mdm.tblUser lcu   
ON ra.LastChgUserID = lcu.ID  
LEFT JOIN mdm.tblUserGroup ug   
ON      ac.PrincipalType_ID = 2/*Group*/   
    AND ac.Principal_ID = ug.ID  
LEFT JOIN mdm.tblUser u   
ON      ac.PrincipalType_ID = 1/*User*/   
    AND ac.Principal_ID = u.ID
GO
/****** Object:  UserDefinedFunction [mdm].[udfEntityAttributesGetList]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
    SELECT * FROM mdm.udfEntityAttributesGetList(1, 1);  
    SELECT * FROM mdm.udfEntityAttributesGetList(1, 2);  
    SELECT * FROM mdm.udfEntityAttributesGetList(1, 3);  
    SELECT * FROM mdm.udfEntityAttributesGetList(23, 1);  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE FUNCTION [mdm].[udfEntityAttributesGetList]  
(  
    @Entity_ID      INT,  
    @MemberType_ID  TINYINT  
)   
RETURNS TABLE  
/*WITH SCHEMABINDING*/  
AS RETURN  
    SELECT   
        DISTINCT -- OR clause in predicate brings back duplicate rows  
        A.Name AS ViewColumn,  
        A.TableColumn,  
        A.IsSystem,  
        A.IsReadOnly,  
        A.AttributeType_ID,  
        A.DataType_ID,  
        A.DomainEntity_ID,  
        E.EntityTable AS DomainTable,  
        A.SortOrder  
    FROM mdm.tblAttribute A   
    LEFT JOIN mdm.tblEntity E   
    ON A.DomainEntity_ID = E.ID  
    WHERE  
        A.Entity_ID = @Entity_ID AND  
        A.MemberType_ID = @MemberType_ID AND  
        --A.AttributeType_ID <> 3;  
        (A.IsSystem = 0 OR A.IsReadOnly = 0);
GO
/****** Object:  Table [dbo].[ChuyenNganh]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[ChuyenNganh](
	[MaChuyenNganh] [int] IDENTITY(1,1) NOT NULL,
	[TenChuyenNganh] [nvarchar](100) NULL,
 CONSTRAINT [PK_ChuyenNganh] PRIMARY KEY CLUSTERED 
(
	[MaChuyenNganh] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[DangKyMonHoc]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[DangKyMonHoc](
	[MaDangKy] [varchar](50) NOT NULL,
	[MaMonHoc] [varchar](50) NULL,
	[MaSV] [int] NULL,
	[ThoiGianDangKy] [datetime] NULL,
 CONSTRAINT [PK_DangKyMonHoc] PRIMARY KEY CLUSTERED 
(
	[MaDangKy] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[MonHoc]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[MonHoc](
	[MaMonHoc] [varchar](50) NOT NULL,
	[TenMonHoc] [nvarchar](50) NULL,
	[MaChuyenNganh] [int] NOT NULL,
 CONSTRAINT [PK_MonHoc] PRIMARY KEY CLUSTERED 
(
	[MaMonHoc] ASC,
	[MaChuyenNganh] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[SinhVien]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[SinhVien](
	[MaSV] [int] IDENTITY(1,1) NOT NULL,
	[HoTen] [nvarchar](50) NULL,
	[GioiTinh] [nvarchar](50) NULL,
 CONSTRAINT [PK_SinhVien] PRIMARY KEY CLUSTERED 
(
	[MaSV] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [mdm].[tblAttributeGroupDetail]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [mdm].[tblAttributeGroupDetail](
	[ID] [int] IDENTITY(1,1) NOT NULL,
	[MUID] [uniqueidentifier] NOT NULL,
	[AttributeGroup_ID] [int] NOT NULL,
	[Attribute_ID] [int] NOT NULL,
	[SortOrder] [int] NOT NULL,
	[EnterDTM] [datetime2](3) NOT NULL,
	[EnterUserID] [int] NOT NULL,
	[EnterVersionID] [int] NOT NULL,
	[LastChgDTM] [datetime2](3) NOT NULL,
	[LastChgUserID] [int] NOT NULL,
	[LastChgVersionID] [int] NOT NULL,
	[LastChgTS] [timestamp] NOT NULL,
 CONSTRAINT [pk_tblAttributeGroupDetail] PRIMARY KEY CLUSTERED 
(
	[ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY],
 CONSTRAINT [ux_tblAttributeGroupDetail_AttributeGroup_ID_Attribute_ID] UNIQUE NONCLUSTERED 
(
	[AttributeGroup_ID] ASC,
	[Attribute_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY],
 CONSTRAINT [ux_tblAttributeGroupDetail_MUID] UNIQUE NONCLUSTERED 
(
	[MUID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [mdm].[tblBRStatusTransition]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [mdm].[tblBRStatusTransition](
	[Action_ID] [int] NOT NULL,
	[CurrentStatus_ID] [int] NOT NULL,
	[NewStatus_ID] [int] NOT NULL,
 CONSTRAINT [pk_tblBRStatusTransition] PRIMARY KEY CLUSTERED 
(
	[Action_ID] ASC,
	[CurrentStatus_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [mdm].[tblDataQualityOperationsState]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [mdm].[tblDataQualityOperationsState](
	[CreateDTM] [datetime2](3) NOT NULL,
	[OperationId] [uniqueidentifier] NULL,
	[SerializedOperation] [nvarchar](max) NULL
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
GO
/****** Object:  Table [mdm].[tblDBErrors]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [mdm].[tblDBErrors](
	[ID] [int] NOT NULL,
	[Language_ID] [int] NOT NULL,
	[Text] [nvarchar](4000) NOT NULL,
	[Category] [nvarchar](250) NOT NULL,
	[Comment] [nvarchar](4000) NULL,
 CONSTRAINT [pk_tblDBErrors] PRIMARY KEY CLUSTERED 
(
	[ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [mdm].[tblDBUpgradeHistory]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [mdm].[tblDBUpgradeHistory](
	[ID] [int] IDENTITY(1,1) NOT NULL,
	[DBVersion] [int] NOT NULL,
	[EnterUser] [nvarchar](250) NOT NULL,
	[EnterDTM] [datetime2](3) NOT NULL,
 CONSTRAINT [pk_tblDBUpgradeHistory] PRIMARY KEY CLUSTERED 
(
	[ID] DESC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [mdm].[tblErrorCodesMapping]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [mdm].[tblErrorCodesMapping](
	[Bitmask] [int] NOT NULL,
	[UniqueErrorCode] [int] NOT NULL,
 CONSTRAINT [pk_tblErrorCodeMapping] PRIMARY KEY CLUSTERED 
(
	[Bitmask] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [mdm].[tblEvent]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [mdm].[tblEvent](
	[ID] [int] IDENTITY(1,1) NOT NULL,
	[MUID] [uniqueidentifier] NOT NULL,
	[Version_ID] [int] NULL,
	[Entity_ID] [int] NULL,
	[EventName] [nvarchar](100) NOT NULL,
	[EventStatus_ID] [tinyint] NOT NULL,
	[EnterDTM] [datetime2](3) NOT NULL,
	[EnterUserID] [int] NOT NULL,
	[LastChgDTM] [datetime2](3) NOT NULL,
	[LastChgUserID] [int] NOT NULL,
	[ErrorMsg] [nvarchar](max) NULL,
 CONSTRAINT [pk_tblEvent] PRIMARY KEY CLUSTERED 
(
	[ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
GO
/****** Object:  Table [mdm].[tblExternalSystem]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [mdm].[tblExternalSystem](
	[ID] [int] IDENTITY(1,1) NOT NULL,
	[MUID] [uniqueidentifier] NOT NULL,
	[Name] [nvarchar](50) NOT NULL,
	[Description] [nvarchar](2000) NULL,
	[Status_ID] [tinyint] NOT NULL,
	[EnterDTM] [datetime2](3) NOT NULL,
	[EnterUserID] [int] NULL,
	[LastChgDTM] [datetime2](3) NOT NULL,
	[LastChgUserID] [int] NULL,
 CONSTRAINT [pk_tblExternalSystem] PRIMARY KEY CLUSTERED 
(
	[ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [mdm].[tblFile]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [mdm].[tblFile](
	[ID] [int] IDENTITY(1,1) NOT NULL,
	[MUID] [uniqueidentifier] NOT NULL,
	[Source_ID] [int] NULL,
	[Source_LastChgTS] [varbinary](8) NULL,
	[FileName] [nvarchar](250) NOT NULL,
	[FileContentType] [nvarchar](200) NOT NULL,
	[FileContent] [varbinary](max) NULL,
	[EnterDTM] [datetime2](3) NOT NULL,
	[EnterUserID] [int] NOT NULL,
	[LastChgDTM] [datetime2](3) NOT NULL,
	[LastChgUserID] [int] NOT NULL,
	[LastChgTS] [timestamp] NOT NULL,
 CONSTRAINT [pk_tblFile] PRIMARY KEY CLUSTERED 
(
	[ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY],
 CONSTRAINT [ux_tblFile_MUID] UNIQUE NONCLUSTERED 
(
	[MUID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
GO
/****** Object:  Table [mdm].[tblLocalizedStrings]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [mdm].[tblLocalizedStrings](
	[ID] [int] IDENTITY(1,1) NOT NULL,
	[LanguageCode] [int] NOT NULL,
	[ResourceName] [nvarchar](100) NOT NULL,
	[LocalizedValue] [nvarchar](max) NULL,
 CONSTRAINT [PK_tblLocalizedStrings] PRIMARY KEY CLUSTERED 
(
	[ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
GO
/****** Object:  Table [mdm].[tblNotificationQueue]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [mdm].[tblNotificationQueue](
	[ID] [int] IDENTITY(1,1) NOT NULL,
	[NotificationType_ID] [int] NOT NULL,
	[Version_ID] [int] NULL,
	[Model_ID] [int] NULL,
	[Entity_ID] [int] NULL,
	[Member_ID] [int] NULL,
	[MemberType_ID] [tinyint] NULL,
	[Message] [nvarchar](max) NOT NULL,
	[BRBusinessRule_ID] [int] NULL,
	[PriorityRank] [nvarchar](255) NULL,
	[EnterDTM] [datetime2](3) NOT NULL,
	[EnterUserID] [int] NOT NULL,
	[DueDTM] [datetime2](3) NULL,
	[SentDTM] [datetime2](3) NULL,
 CONSTRAINT [pk_tblNotificationQueue] PRIMARY KEY CLUSTERED 
(
	[ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
GO
/****** Object:  Table [mdm].[tblNotificationUsers]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [mdm].[tblNotificationUsers](
	[ID] [int] IDENTITY(1,1) NOT NULL,
	[Notification_ID] [int] NOT NULL,
	[User_ID] [int] NOT NULL,
 CONSTRAINT [pk_tblNotificationUsers] PRIMARY KEY CLUSTERED 
(
	[ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [mdm].[tblSecurityObject]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [mdm].[tblSecurityObject](
	[ID] [int] IDENTITY(0,1) NOT NULL,
	[Code] [char](6) NOT NULL,
	[Name] [nvarchar](50) NOT NULL,
	[Description] [nvarchar](100) NULL,
	[ViewName] [sysname] NULL,
	[IsActive] [bit] NOT NULL,
 CONSTRAINT [pk_tblSecurityObject] PRIMARY KEY CLUSTERED 
(
	[ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [mdm].[tblSecurityPrivilege]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [mdm].[tblSecurityPrivilege](
	[ID] [int] NOT NULL,
	[Code] [nvarchar](15) NOT NULL,
	[Name] [nvarchar](50) NOT NULL,
	[Description] [nvarchar](100) NULL,
 CONSTRAINT [pk_tblSecurityPrivilege] PRIMARY KEY CLUSTERED 
(
	[ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [mdm].[tblStgErrorDetail]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [mdm].[tblStgErrorDetail](
	[ID] [int] IDENTITY(1,1) NOT NULL,
	[Batch_ID] [int] NOT NULL,
	[Code] [nvarchar](250) NULL,
	[AttributeName] [nvarchar](100) NOT NULL,
	[AttributeValue] [nvarchar](2000) NULL,
	[UniqueErrorCode] [int] NOT NULL,
 CONSTRAINT [pk_tblStgErrorDetail] PRIMARY KEY CLUSTERED 
(
	[ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [mdm].[tblSubscriptionView]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [mdm].[tblSubscriptionView](
	[ID] [int] IDENTITY(1,1) NOT NULL,
	[Entity_ID] [int] NULL,
	[Model_ID] [int] NOT NULL,
	[DerivedHierarchy_ID] [int] NULL,
	[ViewFormat_ID] [int] NOT NULL,
	[ModelVersion_ID] [int] NULL,
	[ModelVersionFlag_ID] [int] NULL,
	[Name] [sysname] NOT NULL,
	[Levels] [int] NULL,
	[MUID] [uniqueidentifier] NOT NULL,
	[Description] [nvarchar](500) NULL,
	[IncludeSoftDeletedMembers] [bit] NOT NULL,
	[EnterDTM] [datetime2](3) NOT NULL,
	[EnterUserID] [int] NULL,
	[EnterVersionID] [int] NOT NULL,
	[LastChgDTM] [datetime2](3) NOT NULL,
	[LastChgUserID] [int] NULL,
	[LastChgVersionID] [int] NOT NULL,
	[LastChgTS] [timestamp] NOT NULL,
 CONSTRAINT [pk_tblSubscriptionView] PRIMARY KEY CLUSTERED 
(
	[ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [mdm].[tblSystemSettingGroup]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [mdm].[tblSystemSettingGroup](
	[ID] [int] IDENTITY(1,1) NOT NULL,
	[MUID] [uniqueidentifier] NOT NULL,
	[GroupName] [nvarchar](50) NOT NULL,
	[DisplayName] [nvarchar](100) NOT NULL,
	[Description] [nvarchar](250) NOT NULL,
	[DisplaySequence] [int] NOT NULL,
 CONSTRAINT [pk_tblSystemSettingGroup] PRIMARY KEY CLUSTERED 
(
	[ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [mdm].[tblUserPreference]    Script Date: 12/10/2019 8:55:05 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [mdm].[tblUserPreference](
	[ID] [int] IDENTITY(1,1) NOT NULL,
	[User_ID] [int] NOT NULL,
	[PreferenceName] [nvarchar](100) NOT NULL,
	[PreferenceValue] [nvarchar](max) NOT NULL,
	[EnterDTM] [datetime2](3) NOT NULL,
	[EnterUserID] [int] NOT NULL,
	[LastChgDTM] [datetime2](3) NOT NULL,
	[LastChgUserID] [int] NOT NULL,
 CONSTRAINT [pk_tblUserPreference] PRIMARY KEY CLUSTERED 
(
	[ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
GO
/****** Object:  Index [ix_tblAttribute_DomainEntity_DomainEntity_Entity_ID_MemberType_ID_ID]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE NONCLUSTERED INDEX [ix_tblAttribute_DomainEntity_DomainEntity_Entity_ID_MemberType_ID_ID] ON [mdm].[tblAttribute]
(
	[DomainEntity_ID] ASC,
	[Entity_ID] ASC,
	[MemberType_ID] ASC,
	[ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
/****** Object:  Index [ix_tblAttribute_DomainEntity_ID]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE NONCLUSTERED INDEX [ix_tblAttribute_DomainEntity_ID] ON [mdm].[tblAttribute]
(
	[DomainEntity_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
/****** Object:  Index [ix_tblAttribute_Entity_ID_MemberType_ID_AttributeType_ID]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE NONCLUSTERED INDEX [ix_tblAttribute_Entity_ID_MemberType_ID_AttributeType_ID] ON [mdm].[tblAttribute]
(
	[Entity_ID] ASC,
	[MemberType_ID] ASC,
	[AttributeType_ID] ASC
)
INCLUDE([IsName],[IsCode]) WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
/****** Object:  Index [ix_tblAttribute_FilterHierarchyDetail_ID]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE NONCLUSTERED INDEX [ix_tblAttribute_FilterHierarchyDetail_ID] ON [mdm].[tblAttribute]
(
	[FilterHierarchyDetail_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
/****** Object:  Index [ix_tblAttribute_FilterParentAttribute_ID]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE NONCLUSTERED INDEX [ix_tblAttribute_FilterParentAttribute_ID] ON [mdm].[tblAttribute]
(
	[FilterParentAttribute_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
/****** Object:  Index [ix_tblAttribute_MemberType_ID]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE NONCLUSTERED INDEX [ix_tblAttribute_MemberType_ID] ON [mdm].[tblAttribute]
(
	[MemberType_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
/****** Object:  Index [ix_tblAttribute_Source_ID]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE NONCLUSTERED INDEX [ix_tblAttribute_Source_ID] ON [mdm].[tblAttribute]
(
	[Source_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
/****** Object:  Index [ix_tblAttributeGroup_MemberType_ID]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE NONCLUSTERED INDEX [ix_tblAttributeGroup_MemberType_ID] ON [mdm].[tblAttributeGroup]
(
	[MemberType_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
/****** Object:  Index [ix_tblAttributeGroupDetail_Attribute_ID]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE NONCLUSTERED INDEX [ix_tblAttributeGroupDetail_Attribute_ID] ON [mdm].[tblAttributeGroupDetail]
(
	[Attribute_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
/****** Object:  Index [ix_tblBRBusinessRule_Entity_ID_MemberType_ID]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE NONCLUSTERED INDEX [ix_tblBRBusinessRule_Entity_ID_MemberType_ID] ON [mdm].[tblBRBusinessRule]
(
	[Entity_ID] ASC,
	[MemberType_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
/****** Object:  Index [ix_tblBRItem_BRItemAppliesTo_ID]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE NONCLUSTERED INDEX [ix_tblBRItem_BRItemAppliesTo_ID] ON [mdm].[tblBRItem]
(
	[BRItemAppliesTo_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
/****** Object:  Index [ix_tblBRItem_BRLogicalOperatorGroup_ID]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE NONCLUSTERED INDEX [ix_tblBRItem_BRLogicalOperatorGroup_ID] ON [mdm].[tblBRItem]
(
	[BRLogicalOperatorGroup_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
/****** Object:  Index [ix_tblBRItemProperties_BRItem_ID]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE NONCLUSTERED INDEX [ix_tblBRItemProperties_BRItem_ID] ON [mdm].[tblBRItemProperties]
(
	[BRItem_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
/****** Object:  Index [ix_tblBRItemTypeAppliesTo_ApplyTo_ID]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE NONCLUSTERED INDEX [ix_tblBRItemTypeAppliesTo_ApplyTo_ID] ON [mdm].[tblBRItemTypeAppliesTo]
(
	[ApplyTo_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
/****** Object:  Index [ix_tblBRItemTypeAppliesTo_BRItemType_ID]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE NONCLUSTERED INDEX [ix_tblBRItemTypeAppliesTo_BRItemType_ID] ON [mdm].[tblBRItemTypeAppliesTo]
(
	[BRItemType_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
/****** Object:  Index [ix_tblBRLogicalOperatorGroup_BusinessRule_ID]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE NONCLUSTERED INDEX [ix_tblBRLogicalOperatorGroup_BusinessRule_ID] ON [mdm].[tblBRLogicalOperatorGroup]
(
	[BusinessRule_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
/****** Object:  Index [ix_tblDerivedHierarchyDetail_DerivedHierarchy_ID_ForeignType_ID_Foreign_ID_Level_ID]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE NONCLUSTERED INDEX [ix_tblDerivedHierarchyDetail_DerivedHierarchy_ID_ForeignType_ID_Foreign_ID_Level_ID] ON [mdm].[tblDerivedHierarchyDetail]
(
	[DerivedHierarchy_ID] ASC,
	[ForeignType_ID] ASC,
	[Foreign_ID] ASC,
	[Level_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
/****** Object:  Index [ix_tblDerivedHierarchyDetail_ManyToManyChildAttribute_ID]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE NONCLUSTERED INDEX [ix_tblDerivedHierarchyDetail_ManyToManyChildAttribute_ID] ON [mdm].[tblDerivedHierarchyDetail]
(
	[ManyToManyChildAttribute_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
/****** Object:  Index [ix_tblEvent_Version_ID_Entity_ID]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE NONCLUSTERED INDEX [ix_tblEvent_Version_ID_Entity_ID] ON [mdm].[tblEvent]
(
	[Version_ID] ASC,
	[Entity_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
/****** Object:  Index [ux_tblEvent_MUID]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE UNIQUE NONCLUSTERED INDEX [ux_tblEvent_MUID] ON [mdm].[tblEvent]
(
	[MUID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
/****** Object:  Index [ix_tblFile_Source_ID]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE NONCLUSTERED INDEX [ix_tblFile_Source_ID] ON [mdm].[tblFile]
(
	[Source_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
/****** Object:  Index [ix_tblIndex_SysIndex_ID]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE NONCLUSTERED INDEX [ix_tblIndex_SysIndex_ID] ON [mdm].[tblIndex]
(
	[SysIndex_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
SET ANSI_PADDING ON
GO
/****** Object:  Index [ix_tblList_ListCode_ListOption]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE UNIQUE NONCLUSTERED INDEX [ix_tblList_ListCode_ListOption] ON [mdm].[tblList]
(
	[ListCode] ASC,
	[ListOption] ASC
)
INCLUDE([OptionID]) WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
SET ANSI_PADDING ON
GO
/****** Object:  Index [ix_tblList_ListCode_OptionID_Group_ID]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE UNIQUE NONCLUSTERED INDEX [ix_tblList_ListCode_OptionID_Group_ID] ON [mdm].[tblList]
(
	[ListCode] ASC,
	[OptionID] ASC,
	[Group_ID] ASC
)
INCLUDE([ListOption]) WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
/****** Object:  Index [ix_tblListRelationship_ListRelationshipType_ID]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE NONCLUSTERED INDEX [ix_tblListRelationship_ListRelationshipType_ID] ON [mdm].[tblListRelationship]
(
	[ListRelationshipType_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
/****** Object:  Index [ix_tblModelVersion_VersionFlag_ID]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE NONCLUSTERED INDEX [ix_tblModelVersion_VersionFlag_ID] ON [mdm].[tblModelVersion]
(
	[VersionFlag_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
/****** Object:  Index [ix_tblNotificationQueue_MemberType_ID]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE NONCLUSTERED INDEX [ix_tblNotificationQueue_MemberType_ID] ON [mdm].[tblNotificationQueue]
(
	[MemberType_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
/****** Object:  Index [ix_tblNotificationQueue_Model_ID]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE NONCLUSTERED INDEX [ix_tblNotificationQueue_Model_ID] ON [mdm].[tblNotificationQueue]
(
	[Model_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
/****** Object:  Index [ix_tblNotificationQueue_NotificationType_ID]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE NONCLUSTERED INDEX [ix_tblNotificationQueue_NotificationType_ID] ON [mdm].[tblNotificationQueue]
(
	[NotificationType_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
/****** Object:  Index [ix_tblNotificationQueue_Version_ID]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE NONCLUSTERED INDEX [ix_tblNotificationQueue_Version_ID] ON [mdm].[tblNotificationQueue]
(
	[Version_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
/****** Object:  Index [ix_tblNotificationUsers_User_ID]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE NONCLUSTERED INDEX [ix_tblNotificationUsers_User_ID] ON [mdm].[tblNotificationUsers]
(
	[User_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
/****** Object:  Index [ix_tblSecurityAccessControl_PrincipalType_ID_Principal_ID]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE NONCLUSTERED INDEX [ix_tblSecurityAccessControl_PrincipalType_ID_Principal_ID] ON [mdm].[tblSecurityAccessControl]
(
	[PrincipalType_ID] ASC,
	[Principal_ID] ASC
)
INCLUDE([Role_ID]) WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
/****** Object:  Index [ix_tblSecurityAccessControl_Role_ID]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE NONCLUSTERED INDEX [ix_tblSecurityAccessControl_Role_ID] ON [mdm].[tblSecurityAccessControl]
(
	[Role_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
/****** Object:  Index [ux_tblSecurityRole_MUID]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE UNIQUE NONCLUSTERED INDEX [ux_tblSecurityRole_MUID] ON [mdm].[tblSecurityRole]
(
	[MUID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
/****** Object:  Index [ix_tblSecurityRoleAccess_Object_ID_Securable_ID_Privilege_ID]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE NONCLUSTERED INDEX [ix_tblSecurityRoleAccess_Object_ID_Securable_ID_Privilege_ID] ON [mdm].[tblSecurityRoleAccess]
(
	[Object_ID] ASC,
	[Securable_ID] ASC,
	[Privilege_ID] ASC
)
INCLUDE([Role_ID],[AccessPermission]) WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
/****** Object:  Index [ux_tblSecurityRoleAccess_Model_ID_Securable_ID_Object_ID_Role_ID]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE UNIQUE NONCLUSTERED INDEX [ux_tblSecurityRoleAccess_Model_ID_Securable_ID_Object_ID_Role_ID] ON [mdm].[tblSecurityRoleAccess]
(
	[Model_ID] ASC,
	[Securable_ID] ASC,
	[Object_ID] ASC,
	[Role_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
/****** Object:  Index [ix_tblSecurityRoleAccessFunctional_FunctionalPrivilege_ID]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE NONCLUSTERED INDEX [ix_tblSecurityRoleAccessFunctional_FunctionalPrivilege_ID] ON [mdm].[tblSecurityRoleAccessFunctional]
(
	[FunctionalPrivilege_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
/****** Object:  Index [ix_tblSecurityRoleAccessFunctional_Role_ID]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE NONCLUSTERED INDEX [ix_tblSecurityRoleAccessFunctional_Role_ID] ON [mdm].[tblSecurityRoleAccessFunctional]
(
	[Role_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
/****** Object:  Index [ix_tblSecurityRoleAccessMember_Privilege_ID]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE NONCLUSTERED INDEX [ix_tblSecurityRoleAccessMember_Privilege_ID] ON [mdm].[tblSecurityRoleAccessMember]
(
	[Privilege_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
/****** Object:  Index [ix_tblSecurityRoleAccessMember_Role_ID]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE NONCLUSTERED INDEX [ix_tblSecurityRoleAccessMember_Role_ID] ON [mdm].[tblSecurityRoleAccessMember]
(
	[Role_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
/****** Object:  Index [ux_tblSecurityRoleAccessMember_Entity_ID_Version_ID_Role_ID_ExplicitHierarchy_ID_DerivedHierarchy_ID_MemberType_ID_Member_ID]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE UNIQUE NONCLUSTERED INDEX [ux_tblSecurityRoleAccessMember_Entity_ID_Version_ID_Role_ID_ExplicitHierarchy_ID_DerivedHierarchy_ID_MemberType_ID_Member_ID] ON [mdm].[tblSecurityRoleAccessMember]
(
	[Entity_ID] ASC,
	[Version_ID] ASC,
	[Role_ID] ASC,
	[ExplicitHierarchy_ID] ASC,
	[DerivedHierarchy_ID] ASC,
	[MemberType_ID] ASC,
	[Member_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
/****** Object:  Index [ix_tblStgBatch_Entity_ID]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE NONCLUSTERED INDEX [ix_tblStgBatch_Entity_ID] ON [mdm].[tblStgBatch]
(
	[Entity_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
SET ANSI_PADDING ON
GO
/****** Object:  Index [ix_tblStgErrorDetail_Batch_ID_Code]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE NONCLUSTERED INDEX [ix_tblStgErrorDetail_Batch_ID_Code] ON [mdm].[tblStgErrorDetail]
(
	[Batch_ID] ASC,
	[Code] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
/****** Object:  Index [ix_tblStgErrorDetail_ID]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE NONCLUSTERED INDEX [ix_tblStgErrorDetail_ID] ON [mdm].[tblStgErrorDetail]
(
	[ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
/****** Object:  Index [ix_tblSubscriptionView_DerivedHierarchy_ID]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE NONCLUSTERED INDEX [ix_tblSubscriptionView_DerivedHierarchy_ID] ON [mdm].[tblSubscriptionView]
(
	[DerivedHierarchy_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
/****** Object:  Index [ix_tblSubscriptionView_Entity_ID]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE NONCLUSTERED INDEX [ix_tblSubscriptionView_Entity_ID] ON [mdm].[tblSubscriptionView]
(
	[Entity_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
/****** Object:  Index [ix_tblSubscriptionView_Model_ID]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE NONCLUSTERED INDEX [ix_tblSubscriptionView_Model_ID] ON [mdm].[tblSubscriptionView]
(
	[Model_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
/****** Object:  Index [ix_tblSubscriptionView_ModelVersion_ID]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE NONCLUSTERED INDEX [ix_tblSubscriptionView_ModelVersion_ID] ON [mdm].[tblSubscriptionView]
(
	[ModelVersion_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
/****** Object:  Index [ix_tblSyncRelationship_SourceEntity_ID]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE NONCLUSTERED INDEX [ix_tblSyncRelationship_SourceEntity_ID] ON [mdm].[tblSyncRelationship]
(
	[SourceEntity_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
/****** Object:  Index [ix_tblSyncRelationship_SourceVersion_ID]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE NONCLUSTERED INDEX [ix_tblSyncRelationship_SourceVersion_ID] ON [mdm].[tblSyncRelationship]
(
	[SourceVersion_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
SET ANSI_PADDING ON
GO
/****** Object:  Index [ix_tblSystemSetting_SettingName]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE UNIQUE NONCLUSTERED INDEX [ix_tblSystemSetting_SettingName] ON [mdm].[tblSystemSetting]
(
	[SettingName] ASC
)
INCLUDE([SettingValue]) WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
/****** Object:  Index [ix_tblSystemSetting_SystemSettingGroup_ID]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE NONCLUSTERED INDEX [ix_tblSystemSetting_SystemSettingGroup_ID] ON [mdm].[tblSystemSetting]
(
	[SystemSettingGroup_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
/****** Object:  Index [ux_tblSystemSetting_MUID]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE UNIQUE NONCLUSTERED INDEX [ux_tblSystemSetting_MUID] ON [mdm].[tblSystemSetting]
(
	[MUID] ASC
)
INCLUDE([ID]) WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
/****** Object:  Index [ux_tblSystemSettingGroup_MUID]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE UNIQUE NONCLUSTERED INDEX [ux_tblSystemSettingGroup_MUID] ON [mdm].[tblSystemSettingGroup]
(
	[MUID] ASC
)
INCLUDE([ID]) WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
/****** Object:  Index [ix_tblUser_Status_ID]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE NONCLUSTERED INDEX [ix_tblUser_Status_ID] ON [mdm].[tblUser]
(
	[Status_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
/****** Object:  Index [ux_tblUser_MUID]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE UNIQUE NONCLUSTERED INDEX [ux_tblUser_MUID] ON [mdm].[tblUser]
(
	[MUID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
SET ANSI_PADDING ON
GO
/****** Object:  Index [ux_tblUser_SID]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE UNIQUE NONCLUSTERED INDEX [ux_tblUser_SID] ON [mdm].[tblUser]
(
	[SID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
SET ANSI_PADDING ON
GO
/****** Object:  Index [ux_tblUser_UserName]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE UNIQUE NONCLUSTERED INDEX [ux_tblUser_UserName] ON [mdm].[tblUser]
(
	[UserName] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
/****** Object:  Index [ix_tblUserGroup_UserGroupType_ID]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE NONCLUSTERED INDEX [ix_tblUserGroup_UserGroupType_ID] ON [mdm].[tblUserGroup]
(
	[UserGroupType_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
/****** Object:  Index [ux_tblUserGroup_MUID]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE UNIQUE NONCLUSTERED INDEX [ux_tblUserGroup_MUID] ON [mdm].[tblUserGroup]
(
	[MUID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
SET ANSI_PADDING ON
GO
/****** Object:  Index [ux_tblUserGroup_Name]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE UNIQUE NONCLUSTERED INDEX [ux_tblUserGroup_Name] ON [mdm].[tblUserGroup]
(
	[Name] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
SET ANSI_PADDING ON
GO
/****** Object:  Index [ux_tblUserGroup_SID]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE UNIQUE NONCLUSTERED INDEX [ux_tblUserGroup_SID] ON [mdm].[tblUserGroup]
(
	[SID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
/****** Object:  Index [ux_tblUserGroupAssignment_MUID]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE UNIQUE NONCLUSTERED INDEX [ux_tblUserGroupAssignment_MUID] ON [mdm].[tblUserGroupAssignment]
(
	[MUID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
/****** Object:  Index [ux_tblUserGroupAssignment_User_ID_UserGroup_ID]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE UNIQUE NONCLUSTERED INDEX [ux_tblUserGroupAssignment_User_ID_UserGroup_ID] ON [mdm].[tblUserGroupAssignment]
(
	[User_ID] ASC,
	[UserGroup_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
/****** Object:  Index [ux_tblUserGroupAssignment_UserGroup_ID_User_ID]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE UNIQUE NONCLUSTERED INDEX [ux_tblUserGroupAssignment_UserGroup_ID_User_ID] ON [mdm].[tblUserGroupAssignment]
(
	[UserGroup_ID] ASC,
	[User_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
SET ANSI_PADDING ON
GO
/****** Object:  Index [ix_tblUserPreference_User_ID_PreferenceName]    Script Date: 12/10/2019 8:55:05 AM ******/
CREATE UNIQUE NONCLUSTERED INDEX [ix_tblUserPreference_User_ID_PreferenceName] ON [mdm].[tblUserPreference]
(
	[User_ID] ASC,
	[PreferenceName] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO
ALTER TABLE [mdm].[tblAttribute] ADD  CONSTRAINT [df_tblAttribute_MUID]  DEFAULT (newid()) FOR [MUID]
GO
ALTER TABLE [mdm].[tblAttribute] ADD  CONSTRAINT [df_tblAttribute_ChangeTrackingGroup]  DEFAULT ((0)) FOR [ChangeTrackingGroup]
GO
ALTER TABLE [mdm].[tblAttribute] ADD  CONSTRAINT [df_tblAttribute_IsCode]  DEFAULT ((0)) FOR [IsCode]
GO
ALTER TABLE [mdm].[tblAttribute] ADD  CONSTRAINT [df_tblAttribute_IsName]  DEFAULT ((0)) FOR [IsName]
GO
ALTER TABLE [mdm].[tblAttribute] ADD  CONSTRAINT [df_tblAttribute_IsSystem]  DEFAULT ((0)) FOR [IsSystem]
GO
ALTER TABLE [mdm].[tblAttribute] ADD  CONSTRAINT [df_tblAttribute_IsReadOnly]  DEFAULT ((0)) FOR [IsReadOnly]
GO
ALTER TABLE [mdm].[tblAttribute] ADD  CONSTRAINT [df_tblAttribute_IsRequired]  DEFAULT ((0)) FOR [IsRequired]
GO
ALTER TABLE [mdm].[tblAttribute] ADD  CONSTRAINT [df_tblAttribute_EnterDTM]  DEFAULT (getutcdate()) FOR [EnterDTM]
GO
ALTER TABLE [mdm].[tblAttribute] ADD  CONSTRAINT [df_tblAttribute_LastChgDTM]  DEFAULT (getutcdate()) FOR [LastChgDTM]
GO
ALTER TABLE [mdm].[tblAttributeGroup] ADD  CONSTRAINT [df_tblAttributeGroup_MUID]  DEFAULT (newid()) FOR [MUID]
GO
ALTER TABLE [mdm].[tblAttributeGroup] ADD  CONSTRAINT [df_tblAttributeGroup_FreezeNameCode]  DEFAULT ((0)) FOR [FreezeNameCode]
GO
ALTER TABLE [mdm].[tblAttributeGroup] ADD  CONSTRAINT [df_tblAttributeGroup_IsSystem]  DEFAULT ((0)) FOR [IsSystem]
GO
ALTER TABLE [mdm].[tblAttributeGroup] ADD  CONSTRAINT [df_tblAttributeGroup_EnterDTM]  DEFAULT (getutcdate()) FOR [EnterDTM]
GO
ALTER TABLE [mdm].[tblAttributeGroup] ADD  CONSTRAINT [df_tblAttributeGroup_LastChgDTM]  DEFAULT (getutcdate()) FOR [LastChgDTM]
GO
ALTER TABLE [mdm].[tblAttributeGroupDetail] ADD  CONSTRAINT [df_tblAttributeGroupDetail_MUID]  DEFAULT (newid()) FOR [MUID]
GO
ALTER TABLE [mdm].[tblAttributeGroupDetail] ADD  CONSTRAINT [df_tblAttributeGroupDetail_EnterDTM]  DEFAULT (getutcdate()) FOR [EnterDTM]
GO
ALTER TABLE [mdm].[tblAttributeGroupDetail] ADD  CONSTRAINT [df_tblAttributeGroupDetail_LastChgDTM]  DEFAULT (getutcdate()) FOR [LastChgDTM]
GO
ALTER TABLE [mdm].[tblBRBusinessRule] ADD  CONSTRAINT [df_tblBRBusinessRule_EnterDTM]  DEFAULT (getutcdate()) FOR [EnterDTM]
GO
ALTER TABLE [mdm].[tblBRBusinessRule] ADD  CONSTRAINT [df_tblBRBusinessRule_LastChgDTM]  DEFAULT (getutcdate()) FOR [LastChgDTM]
GO
ALTER TABLE [mdm].[tblBRBusinessRule] ADD  CONSTRAINT [df_tblBRBusinessRule_MUID]  DEFAULT (newid()) FOR [MUID]
GO
ALTER TABLE [mdm].[tblBRItem] ADD  CONSTRAINT [df_tblBRItem_MUID]  DEFAULT (newid()) FOR [MUID]
GO
ALTER TABLE [mdm].[tblBRItemProperties] ADD  CONSTRAINT [df_tblBRItemProperties_MUID]  DEFAULT (newid()) FOR [MUID]
GO
ALTER TABLE [mdm].[tblBRLogicalOperatorGroup] ADD  CONSTRAINT [df_tblBRLogicalOperatorGroup_MUID]  DEFAULT (newid()) FOR [MUID]
GO
ALTER TABLE [mdm].[tblDataQualityOperationsState] ADD  CONSTRAINT [df_tblDataQualityOperationsState_CreateDTM]  DEFAULT (getutcdate()) FOR [CreateDTM]
GO
ALTER TABLE [mdm].[tblDBErrors] ADD  CONSTRAINT [df_tblDBErrors_Language_ID]  DEFAULT ((1033)) FOR [Language_ID]
GO
ALTER TABLE [mdm].[tblDBUpgradeHistory] ADD  CONSTRAINT [df_tblDBUpgradeHistory_EnterUser]  DEFAULT (suser_sname()) FOR [EnterUser]
GO
ALTER TABLE [mdm].[tblDBUpgradeHistory] ADD  CONSTRAINT [df_tblDBUpgradeHistory_EnterDTM]  DEFAULT (getutcdate()) FOR [EnterDTM]
GO
ALTER TABLE [mdm].[tblDerivedHierarchy] ADD  CONSTRAINT [df_tblDerivedHierarchy_MUID]  DEFAULT (newid()) FOR [MUID]
GO
ALTER TABLE [mdm].[tblDerivedHierarchy] ADD  CONSTRAINT [df_tblDerivedHierarchy_AnchorNullRecursions]  DEFAULT ((1)) FOR [AnchorNullRecursions]
GO
ALTER TABLE [mdm].[tblDerivedHierarchy] ADD  CONSTRAINT [df_tblDerivedHierarchy_EnterDTM]  DEFAULT (getutcdate()) FOR [EnterDTM]
GO
ALTER TABLE [mdm].[tblDerivedHierarchy] ADD  CONSTRAINT [df_tblDerivedHierarchy_LastChgDTM]  DEFAULT (getutcdate()) FOR [LastChgDTM]
GO
ALTER TABLE [mdm].[tblDerivedHierarchyDetail] ADD  CONSTRAINT [df_tblDerivedHierarchyDetail_MUID]  DEFAULT (newid()) FOR [MUID]
GO
ALTER TABLE [mdm].[tblDerivedHierarchyDetail] ADD  CONSTRAINT [df_tblDerivedHierarchyDetail_EnterDTM]  DEFAULT (getutcdate()) FOR [EnterDTM]
GO
ALTER TABLE [mdm].[tblDerivedHierarchyDetail] ADD  CONSTRAINT [df_tblDerivedHierarchyDetail_LastChgDTM]  DEFAULT (getutcdate()) FOR [LastChgDTM]
GO
ALTER TABLE [mdm].[tblEntity] ADD  CONSTRAINT [df_tblEntity_MUID]  DEFAULT (newid()) FOR [MUID]
GO
ALTER TABLE [mdm].[tblEntity] ADD  CONSTRAINT [df_tblEntity_IsBase]  DEFAULT ((0)) FOR [IsBase]
GO
ALTER TABLE [mdm].[tblEntity] ADD  CONSTRAINT [df_tblEntity_EnterDTM]  DEFAULT (getutcdate()) FOR [EnterDTM]
GO
ALTER TABLE [mdm].[tblEntity] ADD  CONSTRAINT [df_tblEntity_LastChgDTM]  DEFAULT (getutcdate()) FOR [LastChgDTM]
GO
ALTER TABLE [mdm].[tblEntity] ADD  CONSTRAINT [df_tblEntity_DataCompression]  DEFAULT ((0)) FOR [DataCompression]
GO
ALTER TABLE [mdm].[tblEntity] ADD  CONSTRAINT [df_tblEntity_TransactionLogType]  DEFAULT ((1)) FOR [TransactionLogType]
GO
ALTER TABLE [mdm].[tblEntity] ADD  CONSTRAINT [df_tblEntity_RequireApproval]  DEFAULT ((0)) FOR [RequireApproval]
GO
ALTER TABLE [mdm].[tblEvent] ADD  CONSTRAINT [df_tblEvent_MUID]  DEFAULT (newid()) FOR [MUID]
GO
ALTER TABLE [mdm].[tblEvent] ADD  CONSTRAINT [df_tblEvent_EventStatus_ID]  DEFAULT ((1)) FOR [EventStatus_ID]
GO
ALTER TABLE [mdm].[tblEvent] ADD  CONSTRAINT [df_tblEvent_EnterDTM]  DEFAULT (getutcdate()) FOR [EnterDTM]
GO
ALTER TABLE [mdm].[tblEvent] ADD  CONSTRAINT [df_tblEvent_LastChgDTM]  DEFAULT (getutcdate()) FOR [LastChgDTM]
GO
ALTER TABLE [mdm].[tblExternalSystem] ADD  CONSTRAINT [df_tblExternalSystem_MUID]  DEFAULT (newid()) FOR [MUID]
GO
ALTER TABLE [mdm].[tblExternalSystem] ADD  CONSTRAINT [df_tblExternalSystem_Status_ID]  DEFAULT ((0)) FOR [Status_ID]
GO
ALTER TABLE [mdm].[tblExternalSystem] ADD  CONSTRAINT [df_tblExternalSystem_EnterDTM]  DEFAULT (getutcdate()) FOR [EnterDTM]
GO
ALTER TABLE [mdm].[tblExternalSystem] ADD  CONSTRAINT [df_tblExternalSystem_LastChgDTM]  DEFAULT (getutcdate()) FOR [LastChgDTM]
GO
ALTER TABLE [mdm].[tblFile] ADD  CONSTRAINT [df_tblFile_MUID]  DEFAULT (newid()) FOR [MUID]
GO
ALTER TABLE [mdm].[tblFile] ADD  CONSTRAINT [df_tblFile_EnterDTM]  DEFAULT (getutcdate()) FOR [EnterDTM]
GO
ALTER TABLE [mdm].[tblFile] ADD  CONSTRAINT [df_tblFile_LastChgDTM]  DEFAULT (getutcdate()) FOR [LastChgDTM]
GO
ALTER TABLE [mdm].[tblHierarchy] ADD  CONSTRAINT [df_tblHierarchy_MUID]  DEFAULT (newid()) FOR [MUID]
GO
ALTER TABLE [mdm].[tblHierarchy] ADD  CONSTRAINT [df_tblHierarchy_IsMandatory]  DEFAULT ((1)) FOR [IsMandatory]
GO
ALTER TABLE [mdm].[tblHierarchy] ADD  CONSTRAINT [df_tblHierarchy_EnterDTM]  DEFAULT (getutcdate()) FOR [EnterDTM]
GO
ALTER TABLE [mdm].[tblHierarchy] ADD  CONSTRAINT [df_tblHierarchy_LastChgDTM]  DEFAULT (getutcdate()) FOR [LastChgDTM]
GO
ALTER TABLE [mdm].[tblIndex] ADD  CONSTRAINT [df_tblIndex_MUID]  DEFAULT (newid()) FOR [MUID]
GO
ALTER TABLE [mdm].[tblIndex] ADD  CONSTRAINT [df_tblIndex_IsUnique]  DEFAULT ((0)) FOR [IsUnique]
GO
ALTER TABLE [mdm].[tblIndex] ADD  CONSTRAINT [df_tblIndex_EnterDTM]  DEFAULT (getutcdate()) FOR [EnterDTM]
GO
ALTER TABLE [mdm].[tblIndex] ADD  CONSTRAINT [df_tblIndex_LastChgDTM]  DEFAULT (getutcdate()) FOR [LastChgDTM]
GO
ALTER TABLE [mdm].[tblModel] ADD  CONSTRAINT [df_tblModel_MUID]  DEFAULT (newid()) FOR [MUID]
GO
ALTER TABLE [mdm].[tblModel] ADD  CONSTRAINT [df_tblModel_EnterDTM]  DEFAULT (getutcdate()) FOR [EnterDTM]
GO
ALTER TABLE [mdm].[tblModel] ADD  CONSTRAINT [df_tblModel_LastChgDTM]  DEFAULT (getutcdate()) FOR [LastChgDTM]
GO
ALTER TABLE [mdm].[tblModelVersion] ADD  CONSTRAINT [df_tblModelVersion_MUID]  DEFAULT (newid()) FOR [MUID]
GO
ALTER TABLE [mdm].[tblModelVersion] ADD  CONSTRAINT [df_tblModelVersion_Status_ID]  DEFAULT ((1)) FOR [Status_ID]
GO
ALTER TABLE [mdm].[tblModelVersion] ADD  CONSTRAINT [df_tblModelVersion_EnterDTM]  DEFAULT (getutcdate()) FOR [EnterDTM]
GO
ALTER TABLE [mdm].[tblModelVersion] ADD  CONSTRAINT [df_tblModelVersion_LastChgDTM]  DEFAULT (getutcdate()) FOR [LastChgDTM]
GO
ALTER TABLE [mdm].[tblModelVersionFlag] ADD  CONSTRAINT [df_tblModelVersionFlag_MUID]  DEFAULT (newid()) FOR [MUID]
GO
ALTER TABLE [mdm].[tblModelVersionFlag] ADD  CONSTRAINT [df_tblModelVersionFlag_Status_ID]  DEFAULT ((1)) FOR [Status_ID]
GO
ALTER TABLE [mdm].[tblModelVersionFlag] ADD  CONSTRAINT [df_tblModelVersionFlag_EnterDTM]  DEFAULT (getutcdate()) FOR [EnterDTM]
GO
ALTER TABLE [mdm].[tblModelVersionFlag] ADD  CONSTRAINT [df_tblModelVersionFlag_LastChgDTM]  DEFAULT (getutcdate()) FOR [LastChgDTM]
GO
ALTER TABLE [mdm].[tblNotificationQueue] ADD  CONSTRAINT [df_tblNotificationQueue_EnterDTM]  DEFAULT (getutcdate()) FOR [EnterDTM]
GO
ALTER TABLE [mdm].[tblSecurityAccessControl] ADD  CONSTRAINT [df_tblSecurityAccessControl_PrincipalType_ID]  DEFAULT ((0)) FOR [PrincipalType_ID]
GO
ALTER TABLE [mdm].[tblSecurityAccessControl] ADD  CONSTRAINT [df_tblSecurityAccessControl_EnterDTM]  DEFAULT (getutcdate()) FOR [EnterDTM]
GO
ALTER TABLE [mdm].[tblSecurityAccessControl] ADD  CONSTRAINT [df_tblSecurityAccessControl_EnterUserID]  DEFAULT ((-1)) FOR [EnterUserID]
GO
ALTER TABLE [mdm].[tblSecurityAccessControl] ADD  CONSTRAINT [df_tblSecurityAccessControl_LastChgDTM]  DEFAULT (getutcdate()) FOR [LastChgDTM]
GO
ALTER TABLE [mdm].[tblSecurityAccessControl] ADD  CONSTRAINT [df_tblSecurityAccessControl_LastChgUserID]  DEFAULT ((-1)) FOR [LastChgUserID]
GO
ALTER TABLE [mdm].[tblSecurityAccessControl] ADD  CONSTRAINT [df_tblSecurityAccessControl_MUID]  DEFAULT (newid()) FOR [MUID]
GO
ALTER TABLE [mdm].[tblSecurityObject] ADD  CONSTRAINT [df_tblSecurityObject_IsActive]  DEFAULT ((1)) FOR [IsActive]
GO
ALTER TABLE [mdm].[tblSecurityRole] ADD  CONSTRAINT [df_tblSecurityRole_MUID]  DEFAULT (newid()) FOR [MUID]
GO
ALTER TABLE [mdm].[tblSecurityRole] ADD  CONSTRAINT [df_tblSecurityRole_EnterDTM]  DEFAULT (getutcdate()) FOR [EnterDTM]
GO
ALTER TABLE [mdm].[tblSecurityRole] ADD  CONSTRAINT [df_tblSecurityRole_EnterUserID]  DEFAULT ((-1)) FOR [EnterUserID]
GO
ALTER TABLE [mdm].[tblSecurityRole] ADD  CONSTRAINT [df_tblSecurityRole_LastChgDTM]  DEFAULT (getutcdate()) FOR [LastChgDTM]
GO
ALTER TABLE [mdm].[tblSecurityRole] ADD  CONSTRAINT [df_tblSecurityRole_LastChgUserID]  DEFAULT ((-1)) FOR [LastChgUserID]
GO
ALTER TABLE [mdm].[tblSecurityRoleAccess] ADD  CONSTRAINT [df_tblSecurityRoleAccess_AccessPermission]  DEFAULT ((0)) FOR [AccessPermission]
GO
ALTER TABLE [mdm].[tblSecurityRoleAccess] ADD  CONSTRAINT [df_tblSecurityRoleAccess_EnterDTM]  DEFAULT (getutcdate()) FOR [EnterDTM]
GO
ALTER TABLE [mdm].[tblSecurityRoleAccess] ADD  CONSTRAINT [df_tblSecurityRoleAccess_EnterUserID]  DEFAULT ((-1)) FOR [EnterUserID]
GO
ALTER TABLE [mdm].[tblSecurityRoleAccess] ADD  CONSTRAINT [df_tblSecurityRoleAccess_LastChgDTM]  DEFAULT (getutcdate()) FOR [LastChgDTM]
GO
ALTER TABLE [mdm].[tblSecurityRoleAccess] ADD  CONSTRAINT [df_tblSecurityRoleAccess_LastChgUserID]  DEFAULT ((-1)) FOR [LastChgUserID]
GO
ALTER TABLE [mdm].[tblSecurityRoleAccess] ADD  CONSTRAINT [df_tblSecurityRoleAccess_MUID]  DEFAULT (newid()) FOR [MUID]
GO
ALTER TABLE [mdm].[tblSecurityRoleAccessFunctional] ADD  CONSTRAINT [df_tblSecurityRoleAccessFunctional_MUID]  DEFAULT (newid()) FOR [MUID]
GO
ALTER TABLE [mdm].[tblSecurityRoleAccessFunctional] ADD  CONSTRAINT [df_tblSecurityRoleAccessFunctional_EnterDTM]  DEFAULT (getutcdate()) FOR [EnterDTM]
GO
ALTER TABLE [mdm].[tblSecurityRoleAccessFunctional] ADD  CONSTRAINT [df_tblSecurityRoleAccessFunctional_LastChgDTM]  DEFAULT (getutcdate()) FOR [LastChgDTM]
GO
ALTER TABLE [mdm].[tblSecurityRoleAccessMember] ADD  CONSTRAINT [df_tblSecurityRoleAccessMember_AccessPermission]  DEFAULT ((0)) FOR [AccessPermission]
GO
ALTER TABLE [mdm].[tblSecurityRoleAccessMember] ADD  CONSTRAINT [df_tblSecurityRoleAccessMember_Status_ID]  DEFAULT ((0)) FOR [IsInitialized]
GO
ALTER TABLE [mdm].[tblSecurityRoleAccessMember] ADD  CONSTRAINT [df_tblSecurityRoleAccessMember_EnterDTM]  DEFAULT (getutcdate()) FOR [EnterDTM]
GO
ALTER TABLE [mdm].[tblSecurityRoleAccessMember] ADD  CONSTRAINT [df_tblSecurityRoleAccessMember_LastChgDTM]  DEFAULT (getutcdate()) FOR [LastChgDTM]
GO
ALTER TABLE [mdm].[tblSecurityRoleAccessMember] ADD  CONSTRAINT [df_tblSecurityRoleAccessMember_MUID]  DEFAULT (newid()) FOR [MUID]
GO
ALTER TABLE [mdm].[tblStgBatch] ADD  CONSTRAINT [df_tblStgBatch_MUID]  DEFAULT (newid()) FOR [MUID]
GO
ALTER TABLE [mdm].[tblStgBatch] ADD  CONSTRAINT [df_tblStgBatch_Status_ID]  DEFAULT ((0)) FOR [Status_ID]
GO
ALTER TABLE [mdm].[tblSubscriptionView] ADD  CONSTRAINT [df_tblSubscriptionView_MUID]  DEFAULT (newid()) FOR [MUID]
GO
ALTER TABLE [mdm].[tblSubscriptionView] ADD  CONSTRAINT [df_tblSubscriptionView_IncludeSoftDeletedMembers]  DEFAULT ((0)) FOR [IncludeSoftDeletedMembers]
GO
ALTER TABLE [mdm].[tblSubscriptionView] ADD  CONSTRAINT [df_tblSubscriptionView_EnterDTM]  DEFAULT (getutcdate()) FOR [EnterDTM]
GO
ALTER TABLE [mdm].[tblSubscriptionView] ADD  CONSTRAINT [df_tblSubscriptionView_LastChgDTM]  DEFAULT (getutcdate()) FOR [LastChgDTM]
GO
ALTER TABLE [mdm].[tblSyncRelationship] ADD  CONSTRAINT [df_tblSyncRelationship_TargetEntityNameIsAliased]  DEFAULT ((0)) FOR [TargetEntityNameIsAliased]
GO
ALTER TABLE [mdm].[tblSyncRelationship] ADD  CONSTRAINT [df_tblSyncRelationship_LastSyncAttemptStatus]  DEFAULT ((0)) FOR [LastSyncAttemptStatus]
GO
ALTER TABLE [mdm].[tblSyncRelationship] ADD  CONSTRAINT [df_tblSyncRelationship_EnterDTM]  DEFAULT (getutcdate()) FOR [EnterDTM]
GO
ALTER TABLE [mdm].[tblSyncRelationship] ADD  CONSTRAINT [df_tblSyncRelationship_LastChgDTM]  DEFAULT (getutcdate()) FOR [LastChgDTM]
GO
ALTER TABLE [mdm].[tblSystem] ADD  CONSTRAINT [df_tblSystem_EnterDTM]  DEFAULT (getutcdate()) FOR [EnterDTM]
GO
ALTER TABLE [mdm].[tblSystem] ADD  CONSTRAINT [df_tblSystem_EnterUserID]  DEFAULT (suser_sname()) FOR [EnterUserID]
GO
ALTER TABLE [mdm].[tblSystem] ADD  CONSTRAINT [df_tblSystem_LastChgUserID]  DEFAULT (suser_sname()) FOR [LastChgUserID]
GO
ALTER TABLE [mdm].[tblSystem] ADD  CONSTRAINT [df_tblSystem_LastChgDTM]  DEFAULT (getutcdate()) FOR [LastChgDTM]
GO
ALTER TABLE [mdm].[tblSystemSetting] ADD  CONSTRAINT [df_tblSystemSetting_SettingType_ID]  DEFAULT ((1)) FOR [SettingType_ID]
GO
ALTER TABLE [mdm].[tblSystemSetting] ADD  CONSTRAINT [df_tblSystemSetting_DataType_ID]  DEFAULT ((1)) FOR [DataType_ID]
GO
ALTER TABLE [mdm].[tblSystemSetting] ADD  CONSTRAINT [df_tblSystemSetting_EnterDTM]  DEFAULT (getutcdate()) FOR [EnterDTM]
GO
ALTER TABLE [mdm].[tblSystemSetting] ADD  CONSTRAINT [df_tblSystemSetting_LastChgDTM]  DEFAULT (getutcdate()) FOR [LastChgDTM]
GO
ALTER TABLE [mdm].[tblSystemSetting] ADD  CONSTRAINT [df_tblSystemSetting_MUID]  DEFAULT (newid()) FOR [MUID]
GO
ALTER TABLE [mdm].[tblSystemSetting] ADD  CONSTRAINT [df_tblSystemSetting_GroupID]  DEFAULT ((1)) FOR [SystemSettingGroup_ID]
GO
ALTER TABLE [mdm].[tblSystemSetting] ADD  CONSTRAINT [df_tblSystemSetting_DisplaySequence]  DEFAULT ((1)) FOR [DisplaySequence]
GO
ALTER TABLE [mdm].[tblSystemSettingGroup] ADD  CONSTRAINT [df_tblSystemSettingGroup_MUID]  DEFAULT (newid()) FOR [MUID]
GO
ALTER TABLE [mdm].[tblUser] ADD  CONSTRAINT [df_tblUser_MUID]  DEFAULT (newid()) FOR [MUID]
GO
ALTER TABLE [mdm].[tblUser] ADD  CONSTRAINT [df_tblUser_EnterDTM]  DEFAULT (getutcdate()) FOR [EnterDTM]
GO
ALTER TABLE [mdm].[tblUser] ADD  CONSTRAINT [df_tblUser_LastChgDTM]  DEFAULT (getutcdate()) FOR [LastChgDTM]
GO
ALTER TABLE [mdm].[tblUserGroup] ADD  CONSTRAINT [df_tblUserGroup_MUID]  DEFAULT (newid()) FOR [MUID]
GO
ALTER TABLE [mdm].[tblUserGroup] ADD  CONSTRAINT [df_tblUserGroup_EnterDTM]  DEFAULT (getutcdate()) FOR [EnterDTM]
GO
ALTER TABLE [mdm].[tblUserGroup] ADD  CONSTRAINT [df_tblUserGroup_LastChgDTM]  DEFAULT (getutcdate()) FOR [LastChgDTM]
GO
ALTER TABLE [mdm].[tblUserGroupAssignment] ADD  CONSTRAINT [df_tblUserGroupAssignment_MUID]  DEFAULT (newid()) FOR [MUID]
GO
ALTER TABLE [mdm].[tblUserGroupAssignment] ADD  CONSTRAINT [df_tblUserGroupAssignment_EnterDTM]  DEFAULT (getutcdate()) FOR [EnterDTM]
GO
ALTER TABLE [mdm].[tblUserGroupAssignment] ADD  CONSTRAINT [df_tblUserGroupAssignment_LastChgDTM]  DEFAULT (getutcdate()) FOR [LastChgDTM]
GO
ALTER TABLE [mdm].[tblUserPreference] ADD  CONSTRAINT [df_tblUserPreference_EnterDTM]  DEFAULT (getutcdate()) FOR [EnterDTM]
GO
ALTER TABLE [mdm].[tblUserPreference] ADD  CONSTRAINT [df_tblUserPreference_LastChgDTM]  DEFAULT (getutcdate()) FOR [LastChgDTM]
GO
ALTER TABLE [dbo].[DangKyMonHoc]  WITH CHECK ADD  CONSTRAINT [FK_DangKyMonHoc_SinhVien] FOREIGN KEY([MaSV])
REFERENCES [dbo].[SinhVien] ([MaSV])
GO
ALTER TABLE [dbo].[DangKyMonHoc] CHECK CONSTRAINT [FK_DangKyMonHoc_SinhVien]
GO
ALTER TABLE [dbo].[MonHoc]  WITH CHECK ADD  CONSTRAINT [FK_MonHoc_ChuyenNganh] FOREIGN KEY([MaChuyenNganh])
REFERENCES [dbo].[ChuyenNganh] ([MaChuyenNganh])
GO
ALTER TABLE [dbo].[MonHoc] CHECK CONSTRAINT [FK_MonHoc_ChuyenNganh]
GO
ALTER TABLE [mdm].[tblAttribute]  WITH CHECK ADD  CONSTRAINT [fk_tblAttribute_tblAttribute_FilterParentAttribute_ID] FOREIGN KEY([FilterParentAttribute_ID])
REFERENCES [mdm].[tblAttribute] ([ID])
GO
ALTER TABLE [mdm].[tblAttribute] CHECK CONSTRAINT [fk_tblAttribute_tblAttribute_FilterParentAttribute_ID]
GO
ALTER TABLE [mdm].[tblAttribute]  WITH CHECK ADD  CONSTRAINT [fk_tblAttribute_tblAttribute_Source_ID] FOREIGN KEY([Source_ID])
REFERENCES [mdm].[tblAttribute] ([ID])
GO
ALTER TABLE [mdm].[tblAttribute] CHECK CONSTRAINT [fk_tblAttribute_tblAttribute_Source_ID]
GO
ALTER TABLE [mdm].[tblAttribute]  WITH CHECK ADD  CONSTRAINT [fk_tblAttribute_tblDerivedHierarchyDetail_FilterHierarchyDetail_ID] FOREIGN KEY([FilterHierarchyDetail_ID])
REFERENCES [mdm].[tblDerivedHierarchyDetail] ([ID])
GO
ALTER TABLE [mdm].[tblAttribute] CHECK CONSTRAINT [fk_tblAttribute_tblDerivedHierarchyDetail_FilterHierarchyDetail_ID]
GO
ALTER TABLE [mdm].[tblAttribute]  WITH CHECK ADD  CONSTRAINT [fk_tblAttribute_tblEntity_DomainEntity_ID] FOREIGN KEY([DomainEntity_ID])
REFERENCES [mdm].[tblEntity] ([ID])
GO
ALTER TABLE [mdm].[tblAttribute] CHECK CONSTRAINT [fk_tblAttribute_tblEntity_DomainEntity_ID]
GO
ALTER TABLE [mdm].[tblAttribute]  WITH CHECK ADD  CONSTRAINT [fk_tblAttribute_tblEntity_Entity_ID] FOREIGN KEY([Entity_ID])
REFERENCES [mdm].[tblEntity] ([ID])
GO
ALTER TABLE [mdm].[tblAttribute] CHECK CONSTRAINT [fk_tblAttribute_tblEntity_Entity_ID]
GO
ALTER TABLE [mdm].[tblAttributeGroup]  WITH CHECK ADD  CONSTRAINT [fk_tblAttributeGroup_tblEntity_Entity_ID] FOREIGN KEY([Entity_ID])
REFERENCES [mdm].[tblEntity] ([ID])
ON DELETE CASCADE
GO
ALTER TABLE [mdm].[tblAttributeGroup] CHECK CONSTRAINT [fk_tblAttributeGroup_tblEntity_Entity_ID]
GO
ALTER TABLE [mdm].[tblAttributeGroupDetail]  WITH CHECK ADD  CONSTRAINT [fk_tblAttributeGroupDetail_tblAttribute_AttributeGroup_ID] FOREIGN KEY([AttributeGroup_ID])
REFERENCES [mdm].[tblAttributeGroup] ([ID])
ON DELETE CASCADE
GO
ALTER TABLE [mdm].[tblAttributeGroupDetail] CHECK CONSTRAINT [fk_tblAttributeGroupDetail_tblAttribute_AttributeGroup_ID]
GO
ALTER TABLE [mdm].[tblAttributeGroupDetail]  WITH CHECK ADD  CONSTRAINT [fk_tblAttributeGroupDetail_tblAttribute_AttributeID] FOREIGN KEY([Attribute_ID])
REFERENCES [mdm].[tblAttribute] ([ID])
ON DELETE CASCADE
GO
ALTER TABLE [mdm].[tblAttributeGroupDetail] CHECK CONSTRAINT [fk_tblAttributeGroupDetail_tblAttribute_AttributeID]
GO
ALTER TABLE [mdm].[tblBRBusinessRule]  WITH CHECK ADD  CONSTRAINT [fk_tblBRBusinessRule_tblEntity_Entity_ID] FOREIGN KEY([Entity_ID])
REFERENCES [mdm].[tblEntity] ([ID])
ON DELETE CASCADE
GO
ALTER TABLE [mdm].[tblBRBusinessRule] CHECK CONSTRAINT [fk_tblBRBusinessRule_tblEntity_Entity_ID]
GO
ALTER TABLE [mdm].[tblBRItem]  WITH CHECK ADD  CONSTRAINT [fk_tblBRItem_tblBRItemTypeAppliesTo_BRItemAppliesTo_ID] FOREIGN KEY([BRItemAppliesTo_ID])
REFERENCES [mdm].[tblBRItemTypeAppliesTo] ([ID])
GO
ALTER TABLE [mdm].[tblBRItem] CHECK CONSTRAINT [fk_tblBRItem_tblBRItemTypeAppliesTo_BRItemAppliesTo_ID]
GO
ALTER TABLE [mdm].[tblBRItem]  WITH CHECK ADD  CONSTRAINT [fk_tblBRItem_tblLogicalOperatorGroup_BRLogicalOperatorGroup_ID] FOREIGN KEY([BRLogicalOperatorGroup_ID])
REFERENCES [mdm].[tblBRLogicalOperatorGroup] ([ID])
GO
ALTER TABLE [mdm].[tblBRItem] CHECK CONSTRAINT [fk_tblBRItem_tblLogicalOperatorGroup_BRLogicalOperatorGroup_ID]
GO
ALTER TABLE [mdm].[tblBRItemProperties]  WITH CHECK ADD  CONSTRAINT [fk_tblBRItemProperties_tblBRItem_BRItem_ID] FOREIGN KEY([BRItem_ID])
REFERENCES [mdm].[tblBRItem] ([ID])
GO
ALTER TABLE [mdm].[tblBRItemProperties] CHECK CONSTRAINT [fk_tblBRItemProperties_tblBRItem_BRItem_ID]
GO
ALTER TABLE [mdm].[tblBRItemTypeAppliesTo]  WITH CHECK ADD  CONSTRAINT [fk_tblBRItemTypeAppliesTo_tblListRelationship_ApplyTo_ID] FOREIGN KEY([ApplyTo_ID])
REFERENCES [mdm].[tblListRelationship] ([ID])
GO
ALTER TABLE [mdm].[tblBRItemTypeAppliesTo] CHECK CONSTRAINT [fk_tblBRItemTypeAppliesTo_tblListRelationship_ApplyTo_ID]
GO
ALTER TABLE [mdm].[tblBRLogicalOperatorGroup]  WITH CHECK ADD  CONSTRAINT [fk_tblBRLogicalOperatorGroup_tblBRBusinessRule_BusinessRule_ID] FOREIGN KEY([BusinessRule_ID])
REFERENCES [mdm].[tblBRBusinessRule] ([ID])
GO
ALTER TABLE [mdm].[tblBRLogicalOperatorGroup] CHECK CONSTRAINT [fk_tblBRLogicalOperatorGroup_tblBRBusinessRule_BusinessRule_ID]
GO
ALTER TABLE [mdm].[tblCodeGenInfo]  WITH CHECK ADD  CONSTRAINT [FK_tblCodeGenInfo_tblEntity] FOREIGN KEY([EntityId])
REFERENCES [mdm].[tblEntity] ([ID])
GO
ALTER TABLE [mdm].[tblCodeGenInfo] CHECK CONSTRAINT [FK_tblCodeGenInfo_tblEntity]
GO
ALTER TABLE [mdm].[tblDerivedHierarchy]  WITH CHECK ADD  CONSTRAINT [fk_tblDerivedHierarchy_tblModel_Model_ID] FOREIGN KEY([Model_ID])
REFERENCES [mdm].[tblModel] ([ID])
ON DELETE CASCADE
GO
ALTER TABLE [mdm].[tblDerivedHierarchy] CHECK CONSTRAINT [fk_tblDerivedHierarchy_tblModel_Model_ID]
GO
ALTER TABLE [mdm].[tblDerivedHierarchyDetail]  WITH CHECK ADD  CONSTRAINT [fk_tblDerivedHierarchyDetail_ManyToManyChildAttribute_ID_tblAttribute_ID] FOREIGN KEY([ManyToManyChildAttribute_ID])
REFERENCES [mdm].[tblAttribute] ([ID])
ON DELETE CASCADE
GO
ALTER TABLE [mdm].[tblDerivedHierarchyDetail] CHECK CONSTRAINT [fk_tblDerivedHierarchyDetail_ManyToManyChildAttribute_ID_tblAttribute_ID]
GO
ALTER TABLE [mdm].[tblDerivedHierarchyDetail]  WITH CHECK ADD  CONSTRAINT [fk_tblDerivedHierarchyDetail_tblDerivedHierarchy_DerivedHierarchy_ID] FOREIGN KEY([DerivedHierarchy_ID])
REFERENCES [mdm].[tblDerivedHierarchy] ([ID])
ON DELETE CASCADE
GO
ALTER TABLE [mdm].[tblDerivedHierarchyDetail] CHECK CONSTRAINT [fk_tblDerivedHierarchyDetail_tblDerivedHierarchy_DerivedHierarchy_ID]
GO
ALTER TABLE [mdm].[tblEntity]  WITH CHECK ADD  CONSTRAINT [fk_tblEntity_tblModel_Model_ID] FOREIGN KEY([Model_ID])
REFERENCES [mdm].[tblModel] ([ID])
GO
ALTER TABLE [mdm].[tblEntity] CHECK CONSTRAINT [fk_tblEntity_tblModel_Model_ID]
GO
ALTER TABLE [mdm].[tblEvent]  WITH CHECK ADD  CONSTRAINT [fk_tblEvent_Entity_ID] FOREIGN KEY([Entity_ID])
REFERENCES [mdm].[tblEntity] ([ID])
ON DELETE CASCADE
GO
ALTER TABLE [mdm].[tblEvent] CHECK CONSTRAINT [fk_tblEvent_Entity_ID]
GO
ALTER TABLE [mdm].[tblEvent]  WITH CHECK ADD  CONSTRAINT [fk_tblEvent_Version_ID] FOREIGN KEY([Version_ID])
REFERENCES [mdm].[tblModelVersion] ([ID])
ON DELETE CASCADE
GO
ALTER TABLE [mdm].[tblEvent] CHECK CONSTRAINT [fk_tblEvent_Version_ID]
GO
ALTER TABLE [mdm].[tblFile]  WITH CHECK ADD  CONSTRAINT [fk_tblFile_tblFile_Source_ID] FOREIGN KEY([Source_ID])
REFERENCES [mdm].[tblFile] ([ID])
GO
ALTER TABLE [mdm].[tblFile] CHECK CONSTRAINT [fk_tblFile_tblFile_Source_ID]
GO
ALTER TABLE [mdm].[tblHierarchy]  WITH CHECK ADD  CONSTRAINT [fk_tblHierarchy_tblEntity_Entity_ID] FOREIGN KEY([Entity_ID])
REFERENCES [mdm].[tblEntity] ([ID])
GO
ALTER TABLE [mdm].[tblHierarchy] CHECK CONSTRAINT [fk_tblHierarchy_tblEntity_Entity_ID]
GO
ALTER TABLE [mdm].[tblIndex]  WITH CHECK ADD  CONSTRAINT [fk_tblIndex_tblEntity_Entity_ID] FOREIGN KEY([Entity_ID])
REFERENCES [mdm].[tblEntity] ([ID])
GO
ALTER TABLE [mdm].[tblIndex] CHECK CONSTRAINT [fk_tblIndex_tblEntity_Entity_ID]
GO
ALTER TABLE [mdm].[tblListRelationship]  WITH CHECK ADD  CONSTRAINT [fk_tblListRelationship_tblListRelationshipType_ListRelationshipType_ID] FOREIGN KEY([ListRelationshipType_ID])
REFERENCES [mdm].[tblListRelationshipType] ([ID])
GO
ALTER TABLE [mdm].[tblListRelationship] CHECK CONSTRAINT [fk_tblListRelationship_tblListRelationshipType_ListRelationshipType_ID]
GO
ALTER TABLE [mdm].[tblModelVersion]  WITH CHECK ADD  CONSTRAINT [fk_tblModelVersion_tblModel_Model_ID] FOREIGN KEY([Model_ID])
REFERENCES [mdm].[tblModel] ([ID])
ON DELETE CASCADE
GO
ALTER TABLE [mdm].[tblModelVersion] CHECK CONSTRAINT [fk_tblModelVersion_tblModel_Model_ID]
GO
ALTER TABLE [mdm].[tblModelVersion]  WITH CHECK ADD  CONSTRAINT [fk_tblModelVersion_tblModelVersionFlag_VersionFlag_ID] FOREIGN KEY([VersionFlag_ID])
REFERENCES [mdm].[tblModelVersionFlag] ([ID])
GO
ALTER TABLE [mdm].[tblModelVersion] CHECK CONSTRAINT [fk_tblModelVersion_tblModelVersionFlag_VersionFlag_ID]
GO
ALTER TABLE [mdm].[tblModelVersionFlag]  WITH CHECK ADD  CONSTRAINT [fk_tblModelVersionFlag_tblModel_Model_ID] FOREIGN KEY([Model_ID])
REFERENCES [mdm].[tblModel] ([ID])
ON DELETE CASCADE
GO
ALTER TABLE [mdm].[tblModelVersionFlag] CHECK CONSTRAINT [fk_tblModelVersionFlag_tblModel_Model_ID]
GO
ALTER TABLE [mdm].[tblNotificationQueue]  WITH CHECK ADD  CONSTRAINT [fk_tblNotificationQueue_tblModel_Model_ID] FOREIGN KEY([Model_ID])
REFERENCES [mdm].[tblModel] ([ID])
GO
ALTER TABLE [mdm].[tblNotificationQueue] CHECK CONSTRAINT [fk_tblNotificationQueue_tblModel_Model_ID]
GO
ALTER TABLE [mdm].[tblNotificationQueue]  WITH CHECK ADD  CONSTRAINT [fk_tblNotificationQueue_tblModelVersion_Version_ID] FOREIGN KEY([Version_ID])
REFERENCES [mdm].[tblModelVersion] ([ID])
GO
ALTER TABLE [mdm].[tblNotificationQueue] CHECK CONSTRAINT [fk_tblNotificationQueue_tblModelVersion_Version_ID]
GO
ALTER TABLE [mdm].[tblNotificationUsers]  WITH CHECK ADD  CONSTRAINT [fk_tblNotificationUsers_tblUser_UserID] FOREIGN KEY([User_ID])
REFERENCES [mdm].[tblUser] ([ID])
GO
ALTER TABLE [mdm].[tblNotificationUsers] CHECK CONSTRAINT [fk_tblNotificationUsers_tblUser_UserID]
GO
ALTER TABLE [mdm].[tblSecurityAccessControl]  WITH CHECK ADD  CONSTRAINT [fk_tblSecurityAccessControl_tblSecurityRole_Role_ID] FOREIGN KEY([Role_ID])
REFERENCES [mdm].[tblSecurityRole] ([ID])
GO
ALTER TABLE [mdm].[tblSecurityAccessControl] CHECK CONSTRAINT [fk_tblSecurityAccessControl_tblSecurityRole_Role_ID]
GO
ALTER TABLE [mdm].[tblSecurityRoleAccess]  WITH CHECK ADD  CONSTRAINT [fk_tblSecurityRoleAccess_tblModel_Model_ID] FOREIGN KEY([Model_ID])
REFERENCES [mdm].[tblModel] ([ID])
ON DELETE CASCADE
GO
ALTER TABLE [mdm].[tblSecurityRoleAccess] CHECK CONSTRAINT [fk_tblSecurityRoleAccess_tblModel_Model_ID]
GO
ALTER TABLE [mdm].[tblSecurityRoleAccess]  WITH CHECK ADD  CONSTRAINT [fk_tblSecurityRoleAccess_tblSecurityPrivilege_Privilege_ID] FOREIGN KEY([Privilege_ID])
REFERENCES [mdm].[tblSecurityPrivilege] ([ID])
GO
ALTER TABLE [mdm].[tblSecurityRoleAccess] CHECK CONSTRAINT [fk_tblSecurityRoleAccess_tblSecurityPrivilege_Privilege_ID]
GO
ALTER TABLE [mdm].[tblSecurityRoleAccess]  WITH CHECK ADD  CONSTRAINT [fk_tblSecurityRoleAccess_tblSecurityRole_Role_ID] FOREIGN KEY([Role_ID])
REFERENCES [mdm].[tblSecurityRole] ([ID])
ON DELETE CASCADE
GO
ALTER TABLE [mdm].[tblSecurityRoleAccess] CHECK CONSTRAINT [fk_tblSecurityRoleAccess_tblSecurityRole_Role_ID]
GO
ALTER TABLE [mdm].[tblSecurityRoleAccessFunctional]  WITH CHECK ADD  CONSTRAINT [fk_tblSecurityRoleAccessFunctional_tblSecurityFunctionalPrivilege_FunctionalPrivilege_ID] FOREIGN KEY([FunctionalPrivilege_ID])
REFERENCES [mdm].[tblSecurityPrivilegeFunctional] ([ID])
GO
ALTER TABLE [mdm].[tblSecurityRoleAccessFunctional] CHECK CONSTRAINT [fk_tblSecurityRoleAccessFunctional_tblSecurityFunctionalPrivilege_FunctionalPrivilege_ID]
GO
ALTER TABLE [mdm].[tblSecurityRoleAccessFunctional]  WITH CHECK ADD  CONSTRAINT [fk_tblSecurityRoleAccessFunctional_tblSecurityRole_Role_ID] FOREIGN KEY([Role_ID])
REFERENCES [mdm].[tblSecurityRole] ([ID])
ON DELETE CASCADE
GO
ALTER TABLE [mdm].[tblSecurityRoleAccessFunctional] CHECK CONSTRAINT [fk_tblSecurityRoleAccessFunctional_tblSecurityRole_Role_ID]
GO
ALTER TABLE [mdm].[tblSecurityRoleAccessMember]  WITH CHECK ADD  CONSTRAINT [fk_tblSecurityRoleAccessMember_tblEntity_Entity_ID] FOREIGN KEY([Entity_ID])
REFERENCES [mdm].[tblEntity] ([ID])
ON DELETE CASCADE
GO
ALTER TABLE [mdm].[tblSecurityRoleAccessMember] CHECK CONSTRAINT [fk_tblSecurityRoleAccessMember_tblEntity_Entity_ID]
GO
ALTER TABLE [mdm].[tblSecurityRoleAccessMember]  WITH CHECK ADD  CONSTRAINT [fk_tblSecurityRoleAccessMember_tblHierarchy_DerivedHierarchy_ID] FOREIGN KEY([DerivedHierarchy_ID])
REFERENCES [mdm].[tblDerivedHierarchy] ([ID])
ON DELETE CASCADE
GO
ALTER TABLE [mdm].[tblSecurityRoleAccessMember] CHECK CONSTRAINT [fk_tblSecurityRoleAccessMember_tblHierarchy_DerivedHierarchy_ID]
GO
ALTER TABLE [mdm].[tblSecurityRoleAccessMember]  WITH CHECK ADD  CONSTRAINT [fk_tblSecurityRoleAccessMember_tblHierarchy_ExplicitHierarchy_ID] FOREIGN KEY([ExplicitHierarchy_ID])
REFERENCES [mdm].[tblHierarchy] ([ID])
ON DELETE CASCADE
GO
ALTER TABLE [mdm].[tblSecurityRoleAccessMember] CHECK CONSTRAINT [fk_tblSecurityRoleAccessMember_tblHierarchy_ExplicitHierarchy_ID]
GO
ALTER TABLE [mdm].[tblSecurityRoleAccessMember]  WITH CHECK ADD  CONSTRAINT [fk_tblSecurityRoleAccessMember_tblModelVersion_Version_ID] FOREIGN KEY([Version_ID])
REFERENCES [mdm].[tblModelVersion] ([ID])
GO
ALTER TABLE [mdm].[tblSecurityRoleAccessMember] CHECK CONSTRAINT [fk_tblSecurityRoleAccessMember_tblModelVersion_Version_ID]
GO
ALTER TABLE [mdm].[tblSecurityRoleAccessMember]  WITH CHECK ADD  CONSTRAINT [fk_tblSecurityRoleAccessMember_tblSecurityPrivilege_Privilege_ID] FOREIGN KEY([Privilege_ID])
REFERENCES [mdm].[tblSecurityPrivilege] ([ID])
GO
ALTER TABLE [mdm].[tblSecurityRoleAccessMember] CHECK CONSTRAINT [fk_tblSecurityRoleAccessMember_tblSecurityPrivilege_Privilege_ID]
GO
ALTER TABLE [mdm].[tblSecurityRoleAccessMember]  WITH CHECK ADD  CONSTRAINT [fk_tblSecurityRoleAccessMember_tblSecurityRole_Role_ID] FOREIGN KEY([Role_ID])
REFERENCES [mdm].[tblSecurityRole] ([ID])
ON DELETE CASCADE
GO
ALTER TABLE [mdm].[tblSecurityRoleAccessMember] CHECK CONSTRAINT [fk_tblSecurityRoleAccessMember_tblSecurityRole_Role_ID]
GO
ALTER TABLE [mdm].[tblStgBatch]  WITH CHECK ADD  CONSTRAINT [fk_tblStgBatch_tblEntity_Entity_ID] FOREIGN KEY([Entity_ID])
REFERENCES [mdm].[tblEntity] ([ID])
GO
ALTER TABLE [mdm].[tblStgBatch] CHECK CONSTRAINT [fk_tblStgBatch_tblEntity_Entity_ID]
GO
ALTER TABLE [mdm].[tblSubscriptionView]  WITH CHECK ADD  CONSTRAINT [fk_tblSubscriptionView_tblDerivedHierarchy] FOREIGN KEY([DerivedHierarchy_ID])
REFERENCES [mdm].[tblDerivedHierarchy] ([ID])
GO
ALTER TABLE [mdm].[tblSubscriptionView] CHECK CONSTRAINT [fk_tblSubscriptionView_tblDerivedHierarchy]
GO
ALTER TABLE [mdm].[tblSubscriptionView]  WITH CHECK ADD  CONSTRAINT [fk_tblSubscriptionView_tblEntity] FOREIGN KEY([Entity_ID])
REFERENCES [mdm].[tblEntity] ([ID])
GO
ALTER TABLE [mdm].[tblSubscriptionView] CHECK CONSTRAINT [fk_tblSubscriptionView_tblEntity]
GO
ALTER TABLE [mdm].[tblSubscriptionView]  WITH CHECK ADD  CONSTRAINT [fk_tblSubscriptionView_tblModel] FOREIGN KEY([Model_ID])
REFERENCES [mdm].[tblModel] ([ID])
GO
ALTER TABLE [mdm].[tblSubscriptionView] CHECK CONSTRAINT [fk_tblSubscriptionView_tblModel]
GO
ALTER TABLE [mdm].[tblSubscriptionView]  WITH CHECK ADD  CONSTRAINT [fk_tblSubscriptionView_tblModelVersion] FOREIGN KEY([ModelVersion_ID])
REFERENCES [mdm].[tblModelVersion] ([ID])
GO
ALTER TABLE [mdm].[tblSubscriptionView] CHECK CONSTRAINT [fk_tblSubscriptionView_tblModelVersion]
GO
ALTER TABLE [mdm].[tblSyncRelationship]  WITH CHECK ADD  CONSTRAINT [fk_tblSyncRelationship_tblEntity_SourceEntity_ID] FOREIGN KEY([SourceEntity_ID])
REFERENCES [mdm].[tblEntity] ([ID])
GO
ALTER TABLE [mdm].[tblSyncRelationship] CHECK CONSTRAINT [fk_tblSyncRelationship_tblEntity_SourceEntity_ID]
GO
ALTER TABLE [mdm].[tblSyncRelationship]  WITH CHECK ADD  CONSTRAINT [fk_tblSyncRelationship_tblEntity_TargetEntity_ID] FOREIGN KEY([TargetEntity_ID])
REFERENCES [mdm].[tblEntity] ([ID])
GO
ALTER TABLE [mdm].[tblSyncRelationship] CHECK CONSTRAINT [fk_tblSyncRelationship_tblEntity_TargetEntity_ID]
GO
ALTER TABLE [mdm].[tblSyncRelationship]  WITH CHECK ADD  CONSTRAINT [fk_tblSyncRelationship_tblVersion_SourceVersion_ID] FOREIGN KEY([SourceVersion_ID])
REFERENCES [mdm].[tblModelVersion] ([ID])
GO
ALTER TABLE [mdm].[tblSyncRelationship] CHECK CONSTRAINT [fk_tblSyncRelationship_tblVersion_SourceVersion_ID]
GO
ALTER TABLE [mdm].[tblSyncRelationship]  WITH CHECK ADD  CONSTRAINT [fk_tblSyncRelationship_tblVersion_TargetVersion_ID] FOREIGN KEY([TargetVersion_ID])
REFERENCES [mdm].[tblModelVersion] ([ID])
GO
ALTER TABLE [mdm].[tblSyncRelationship] CHECK CONSTRAINT [fk_tblSyncRelationship_tblVersion_TargetVersion_ID]
GO
ALTER TABLE [mdm].[tblSystemSetting]  WITH CHECK ADD  CONSTRAINT [fk_tblSystemSetting_tblSystemSettingGroup] FOREIGN KEY([SystemSettingGroup_ID])
REFERENCES [mdm].[tblSystemSettingGroup] ([ID])
GO
ALTER TABLE [mdm].[tblSystemSetting] CHECK CONSTRAINT [fk_tblSystemSetting_tblSystemSettingGroup]
GO
ALTER TABLE [mdm].[tblUserGroupAssignment]  WITH CHECK ADD  CONSTRAINT [fk_tblUserGroupAssignment_tblUser_UserID] FOREIGN KEY([User_ID])
REFERENCES [mdm].[tblUser] ([ID])
ON DELETE CASCADE
GO
ALTER TABLE [mdm].[tblUserGroupAssignment] CHECK CONSTRAINT [fk_tblUserGroupAssignment_tblUser_UserID]
GO
ALTER TABLE [mdm].[tblUserGroupAssignment]  WITH CHECK ADD  CONSTRAINT [fk_tblUserGroupAssignment_tblUserGroup_UserGroupID] FOREIGN KEY([UserGroup_ID])
REFERENCES [mdm].[tblUserGroup] ([ID])
ON DELETE CASCADE
GO
ALTER TABLE [mdm].[tblUserGroupAssignment] CHECK CONSTRAINT [fk_tblUserGroupAssignment_tblUserGroup_UserGroupID]
GO
ALTER TABLE [mdm].[tblUserPreference]  WITH CHECK ADD  CONSTRAINT [fk_tblUserPreference_tblUserPreference_User_ID] FOREIGN KEY([User_ID])
REFERENCES [mdm].[tblUser] ([ID])
ON DELETE CASCADE
GO
ALTER TABLE [mdm].[tblUserPreference] CHECK CONSTRAINT [fk_tblUserPreference_tblUserPreference_User_ID]
GO
ALTER TABLE [mdm].[tblAttribute]  WITH CHECK ADD  CONSTRAINT [ck_tblAttribute_AttributeType_ID] CHECK  (([AttributeType_ID]>=(1) AND [AttributeType_ID]<=(4)))
GO
ALTER TABLE [mdm].[tblAttribute] CHECK CONSTRAINT [ck_tblAttribute_AttributeType_ID]
GO
ALTER TABLE [mdm].[tblAttribute]  WITH CHECK ADD  CONSTRAINT [ck_tblAttribute_DataType_ID] CHECK  (([DataType_ID]>=(0) AND [DataType_ID]<=(7)))
GO
ALTER TABLE [mdm].[tblAttribute] CHECK CONSTRAINT [ck_tblAttribute_DataType_ID]
GO
ALTER TABLE [mdm].[tblAttributeGroup]  WITH CHECK ADD  CONSTRAINT [ck_tblAttributeGroup_MemberType_ID] CHECK  (([MemberType_ID]>=(1) AND [MemberType_ID]<=(3)))
GO
ALTER TABLE [mdm].[tblAttributeGroup] CHECK CONSTRAINT [ck_tblAttributeGroup_MemberType_ID]
GO
ALTER TABLE [mdm].[tblDerivedHierarchyDetail]  WITH CHECK ADD  CONSTRAINT [ck_tblDerivedHierarchyDetail_ForeignType_ID] CHECK  (([ForeignType_ID]>=(0) AND [ForeignType_ID]<=(5)))
GO
ALTER TABLE [mdm].[tblDerivedHierarchyDetail] CHECK CONSTRAINT [ck_tblDerivedHierarchyDetail_ForeignType_ID]
GO
ALTER TABLE [mdm].[tblEvent]  WITH CHECK ADD  CONSTRAINT [ck_tblEvent_EventStatus_ID] CHECK  (([EventStatus_ID]>=(1) AND [EventStatus_ID]<=(3)))
GO
ALTER TABLE [mdm].[tblEvent] CHECK CONSTRAINT [ck_tblEvent_EventStatus_ID]
GO
ALTER TABLE [mdm].[tblExternalSystem]  WITH CHECK ADD  CONSTRAINT [ck_tblExternalSystem_Status_ID] CHECK  (([Status_ID]>=(0) AND [Status_ID]<=(6)))
GO
ALTER TABLE [mdm].[tblExternalSystem] CHECK CONSTRAINT [ck_tblExternalSystem_Status_ID]
GO
ALTER TABLE [mdm].[tblModelVersion]  WITH CHECK ADD  CONSTRAINT [ck_tblModelVersion_Status_ID] CHECK  (([Status_ID]>=(1) AND [Status_ID]<=(3)))
GO
ALTER TABLE [mdm].[tblModelVersion] CHECK CONSTRAINT [ck_tblModelVersion_Status_ID]
GO
ALTER TABLE [mdm].[tblModelVersionFlag]  WITH CHECK ADD  CONSTRAINT [ck_tblModelVersionFlag_CommittedOnly_ID] CHECK  (([CommittedOnly_ID]>=(0) AND [CommittedOnly_ID]<=(2)))
GO
ALTER TABLE [mdm].[tblModelVersionFlag] CHECK CONSTRAINT [ck_tblModelVersionFlag_CommittedOnly_ID]
GO
ALTER TABLE [mdm].[tblModelVersionFlag]  WITH CHECK ADD  CONSTRAINT [ck_tblModelVersionFlag_Status_ID] CHECK  (([Status_ID]>=(1) AND [Status_ID]<=(3)))
GO
ALTER TABLE [mdm].[tblModelVersionFlag] CHECK CONSTRAINT [ck_tblModelVersionFlag_Status_ID]
GO
ALTER TABLE [mdm].[tblSecurityAccessControl]  WITH CHECK ADD  CONSTRAINT [ck_tblSecurityAccessControl_PrincipalType_ID] CHECK  (([PrincipalType_ID]>=(0) AND [PrincipalType_ID]<=(2)))
GO
ALTER TABLE [mdm].[tblSecurityAccessControl] CHECK CONSTRAINT [ck_tblSecurityAccessControl_PrincipalType_ID]
GO
ALTER TABLE [mdm].[tblSecurityObject]  WITH CHECK ADD  CONSTRAINT [ck_tblSecurityObject_Code] CHECK  ((len(ltrim(rtrim([Code])))=(6)))
GO
ALTER TABLE [mdm].[tblSecurityObject] CHECK CONSTRAINT [ck_tblSecurityObject_Code]
GO
ALTER TABLE [mdm].[tblSecurityRoleAccessMember]  WITH CHECK ADD  CONSTRAINT [ck_tblSecurityRoleAccessMember_HierarchyType_ID] CHECK  (([HierarchyType_ID]=(1) OR [HierarchyType_ID]=(0)))
GO
ALTER TABLE [mdm].[tblSecurityRoleAccessMember] CHECK CONSTRAINT [ck_tblSecurityRoleAccessMember_HierarchyType_ID]
GO
ALTER TABLE [mdm].[tblSecurityRoleAccessMember]  WITH CHECK ADD  CONSTRAINT [ck_tblSecurityRoleAccessMember_MemberType_ID] CHECK  (([MemberType_ID]=(2) OR [MemberType_ID]=(1)))
GO
ALTER TABLE [mdm].[tblSecurityRoleAccessMember] CHECK CONSTRAINT [ck_tblSecurityRoleAccessMember_MemberType_ID]
GO
ALTER TABLE [mdm].[tblStgBatch]  WITH CHECK ADD  CONSTRAINT [ck_tblStgBatch_Status_ID] CHECK  (([Status_ID]>=(0) AND [Status_ID]<=(7)))
GO
ALTER TABLE [mdm].[tblStgBatch] CHECK CONSTRAINT [ck_tblStgBatch_Status_ID]
GO
ALTER TABLE [mdm].[tblSystem]  WITH CHECK ADD  CONSTRAINT [ck_tblSystem_ID] CHECK  (([ID]=(1)))
GO
ALTER TABLE [mdm].[tblSystem] CHECK CONSTRAINT [ck_tblSystem_ID]
GO
ALTER TABLE [mdm].[tblUser]  WITH CHECK ADD  CONSTRAINT [ck_tblUser_Status_ID] CHECK  (([Status_ID]>=(1) AND [Status_ID]<=(3)))
GO
ALTER TABLE [mdm].[tblUser] CHECK CONSTRAINT [ck_tblUser_Status_ID]
GO
ALTER TABLE [mdm].[tblUserGroup]  WITH CHECK ADD  CONSTRAINT [ck_tblUserGroup_Status_ID] CHECK  (([Status_ID]>=(1) AND [Status_ID]<=(3)))
GO
ALTER TABLE [mdm].[tblUserGroup] CHECK CONSTRAINT [ck_tblUserGroup_Status_ID]
GO
/****** Object:  StoredProcedure [dqs].[udpGrantPermissions]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
EXEC [dqs].[udpGrantPermissions]  
  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [dqs].[udpGrantPermissions]  
(  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
AS   
BEGIN  
  
-- If user doesn't exist, create the login and give it Schema access.  
-- This SPROC will called on every MDS service load, as DQS can be installed after MDS.  
IF NOT EXISTS(SELECT principal_id FROM sys.database_principals WHERE name='##MS_dqs_service_login##')  
BEGIN  
CREATE USER ##MS_dqs_service_login## FOR LOGIN ##MS_dqs_service_login## with default_schema=dqs;  
  
GRANT CONTROL ON SCHEMA :: dqs  
TO [##MS_dqs_service_login##];  
  
END;  
  
END -- Proc
GO
/****** Object:  StoredProcedure [mdm].[udpAnnotationDelete]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
/*  
--This can be called to delete Annotations for a transaction  
EXEC udpAnnotationDelete 7, 1  
*/  
CREATE PROCEDURE [mdm].[udpAnnotationDelete]  
(  
    @Model_ID       INT,  
    @AnnotationID	INT	,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    DECLARE @AnnotationTableName    sysname,  
            @SQL                    NVARCHAR(MAX);  
  
    SET @AnnotationTableName = mdm.udfGetTransactionAnnotationTableName(@Model_ID);  
  
    --Delete the annotation  
    SET @SQL = N'DELETE FROM [mdm].' + QUOTENAME(@AnnotationTableName) + N' WHERE ID = @AnnotationID';  
    EXEC sp_executesql @SQL, N'@AnnotationID INT', @AnnotationID;  
  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpAnnotationGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
--This can be called to get Annotations for a transaction OR for a member.  
  
--via Transaction  
EXEC mdm.udpAnnotationGet null,null,null,null,31  
  
--via Member Account/Version 3/Account/1110  
exec mdm.udpAnnotationGet 7,4,7,41,1,null  
  
--invalid  
EXEC mdm.udpAnnotationGet null,null,null,null,null,null  
*/  
CREATE PROCEDURE [mdm].[udpAnnotationGet]  
(  
    @Model_ID       INT = NULL,  
    @Version_ID		INT = NULL,  
    @EntityID		INT = NULL,  
    @MemberID		INT = NULL,  
    @MemberTypeID	TINYINT = NULL,  
    @TransactionID	INT = NULL,  
    @AnnotationID	INT = NULL,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
  
    DECLARE @AnnotationType         INT, --Either 1(ByTransaction) or 2(ByMember) or 3(ByAnnotation)  
            @SQL                    NVARCHAR(MAX),  
            @AnnotationViewName     sysname,  
            @TransactionTableName   sysname,  
            -- This pseudo-constant is for use in string concatenation operations to prevent string truncation. When concatenating two or more strings,  
            -- if none of the strings is an NVARCHAR(MAX) or an NVARCHAR constant that is longer than 4,000 characters, then the resulting string   
            -- will be silently truncated to 4,000 characters. Concatenating with this empty NVARCHAR(MAX), is sufficient to prevent truncation.  
            -- See http://connect.microsoft.com/SQLServer/feedback/details/283368/nvarchar-max-concatenation-yields-silent-truncation.  
            @TruncationGuard        NVARCHAR(MAX) = N'';  
  
    --Validate Input  
    IF @Model_ID IS NULL OR (@AnnotationID IS NULL AND @TransactionID IS NULL AND (@Version_ID IS NULL OR @EntityID IS NULL OR @MemberID IS NULL OR @MemberTypeID IS NULL))  
    BEGIN  
        RAISERROR('MDSERR100010|The Parameters are not valid.', 16, 1);  
        RETURN(1);  
    END  
  
    --Get the name of the annotation and transaction objects  
    SET @AnnotationViewName = mdm.udfGetTransactionAnnotationViewName(@Model_ID);  
    SELECT @TransactionTableName = mdm.udfGetTransactionTableName(@Model_ID);  
      
    --Figure out Annotation Type  
    IF @AnnotationID IS NOT NULL  
        BEGIN  
            SET @AnnotationType = 3;  
        END  
    ELSE IF @TransactionID IS NOT NULL  
    BEGIN  
        SET @AnnotationType = 2;  
    END  
    ELSE  
    BEGIN  
        SET @AnnotationType = 1;  
    END  
  
  
    IF @AnnotationType = 1  
    BEGIN  
        SET @SQL = @TruncationGuard + N'  
        SELECT   
            A.ID  
            ,A.[Transaction ID]  
            ,A.[User Comment]  
            ,A.[Date Time]  
            ,A.[User Name]  
            ,A.[User ID]  
            ,A.User_MUID  
            ,A.LastChgDateTime  
            ,A.LastChgUserName  
            ,A.LastChgUserID  
            ,A.LastChgUserMUID  
            ,Version_ID    
            ,TransactionType_ID   
            ,OriginalTransaction_ID   
            ,Hierarchy_ID   
            ,Entity_ID     
            ,Attribute_ID   
            ,Member_ID     
            ,MemberType_ID   
            ,MemberCode                                                                                                                                                                                                                                                   
            ,OldValue                                                                                                                                                                                                                                                           
            ,OldCode                                                                                                                                                                                                                                                            
            ,NewValue                                                                                                                                                                                                                                                           
            ,NewCode                                                                                                                                                                                                                                                            
            ,Batch_ID      
            ,EnterDTM                  
            ,EnterUserID   
            ,LastChgDTM                
            ,Code                                                 
            ,Description  
        FROM [mdm].' + QUOTENAME(@AnnotationViewName) + N' A  
            INNER JOIN [mdm].' + QUOTENAME(@TransactionTableName) + N' T  
                ON T.ID = A.[Transaction ID]  
        WHERE   
            T.Version_ID = @Version_ID  
            AND T.Entity_ID = @EntityID  
            AND T.Member_ID = @MemberID  
            AND T.MemberType_ID = @MemberTypeID  
            AND T.TransactionType_ID = 6 /*MEMBER_ANNOTATE*/  
        ';  
        EXEC sp_executesql @SQL, N'@Version_ID INT, @EntityID INT, @MemberID INT, @MemberTypeID TINYINT',  
                                   @Version_ID,     @EntityID,     @MemberID,     @MemberTypeID;  
  
    END  
    ELSE IF @AnnotationType=2  
    BEGIN  
        SET @SQL = @TruncationGuard + N'  
        SELECT 			  
            ID  
            ,[Transaction ID]  
            ,[User Comment]  
            ,[Date Time]  
            ,[User Name]  
            ,[User ID]  
            ,User_MUID  
            ,LastChgDateTime  
            ,LastChgUserName  
            ,LastChgUserID  
            ,LastChgUserMUID   
            FROM [mdm].' + QUOTENAME(@AnnotationViewName) + N'  
            WHERE [Transaction ID] = @TransactionID  
        ';  
        EXEC sp_executesql @SQL, N'@TransactionID INT', @TransactionID;  
    END  
    ELSE IF @AnnotationType = 3  
    BEGIN  
        SET @SQL = @TruncationGuard + N'  
        SELECT   
        ID  
        ,[Transaction ID]  
        ,[User Comment]  
        ,[Date Time]  
        ,[User Name]  
        ,[User ID]       
        ,[User_MUID]  
        ,[LastChgDateTime]  
        ,[LastChgUserName]  
        ,[LastChgUserID]  
        ,[LastChgUserMUID]  
        FROM [mdm].' + QUOTENAME(@AnnotationViewName) + N'  
        WHERE ID = @AnnotationID;		  
        ';  
        EXEC sp_executesql @SQL, N'@AnnotationID INT', @AnnotationID;  
    END  
  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpAnnotationSave]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
--This can be called to save or create a new Annotations  
--new annotation Transaction  
  
--new via Member: Account/Version 3/Account/1110  
exec mdm.udpAnnotationSave 1,7,4,null,41,"test annotation 1"  
  
--update existing  
exec mdm.udpAnnotationSave @UserID=1,@Model_ID=7,@AnnotationID=8,@Version_ID=2,@TransactionID=NULL,@Comment=N'Updated annotation: 20081001235440'  
  
*/  
CREATE PROCEDURE [mdm].[udpAnnotationSave]  
(  
    @UserID         INT,  
    @Model_ID       INT,  
    @Version_ID     INT,  
    @AnnotationID   INT = NULL,  
    @TransactionID  INT = NULL,  
    @Comment        NVARCHAR(500),  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
  
    --Validate Input  
    IF @Model_ID IS NULL OR @Version_ID IS NULL OR (@AnnotationID IS NULL AND @TransactionID IS NULL)  
    BEGIN  
        RAISERROR('MDSERR100010|The Parameters are not valid.', 16, 1);  
        RETURN(1);  
    END  
  
    IF @AnnotationID IS NOT NULL  
    BEGIN  
        DECLARE @AnnotationTableName    SYSNAME = mdm.udfGetTransactionAnnotationTableName(@Model_ID)  
                ,@SQL                   NVARCHAR(MAX);  
  
        SET @SQL = N'  
        UPDATE [mdm].' + QUOTENAME(@AnnotationTableName) + N'  
        SET Comment = @Comment,  
            LastChgDTM = GETUTCDATE(),  
            LastChgUserID = @UserID  
        WHERE ID = @AnnotationID AND Version_ID = @Version_ID  
        ';  
        EXEC sp_executesql @SQL, N'@Version_ID INT, @AnnotationID INT, @Comment NVARCHAR(500), @UserID INT', @Version_ID, @AnnotationID, @Comment, @UserID;  
    END ELSE  
    IF @TransactionID IS NOT NULL  
    BEGIN  
        EXEC [mdm].[udpTransactionAnnotationSave] @UserID, @Model_ID, @Version_ID, @TransactionID, @Comment  
    END  
  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpAttributeAndAttributeGroupIDResolve]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
/*  
Resolves Attribute and AttributeGroup MUID and Name to ID.   
If ID is already provided, it is returned with no validation.  
If ID is NULL and MUID/Name match an ID, the ID is returned.  
If no matching ID is found for the given (MUID,Name) pair, ID is set to -1  
*/  
CREATE PROCEDURE [mdm].[udpAttributeAndAttributeGroupIDResolve]  
	@EntityID		INT,  
	@MemberTypeID	TINYINT,  
	@Attribute_MUID	UNIQUEIDENTIFIER = NULL,  
	@Attribute_Name	NVARCHAR(100) = NULL,  
	@AttributeGroup_MUID	UNIQUEIDENTIFIER = NULL,  
	@AttributeGroup_Name	NVARCHAR(50) = NULL,  
	@Attribute_ID	INT OUTPUT,	  
	@AttributeGroup_ID	INT OUTPUT	,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
AS BEGIN  
	DECLARE @Invalid_ID INT = -1  
  
	IF @Attribute_ID IS NULL  
		IF @Attribute_MUID IS NOT NULL OR @Attribute_Name IS NOT NULL  
		BEGIN  
			SELECT @Attribute_ID = ID FROM mdm.tblAttribute WHERE (MUID = ISNULL(@Attribute_MUID, MUID)) AND (Name = ISNULL(@Attribute_Name, Name))   
			AND (Entity_ID = ISNULL(@EntityID, Entity_ID)) AND (MemberType_ID = ISNULL(@MemberTypeID, MemberType_ID))  
  
			IF @Attribute_ID IS NULL  
			BEGIN		  
				SELECT @Attribute_ID = @Invalid_ID  
			END  
		END  
	  
	IF @AttributeGroup_ID IS NULL  
		IF @AttributeGroup_MUID IS NOT NULL OR @AttributeGroup_Name IS NOT NULL  
		BEGIN  
			SELECT @AttributeGroup_ID = ID FROM mdm.tblAttributeGroup WHERE (MUID = ISNULL(@AttributeGroup_MUID, MUID)) AND (Name = ISNULL(@AttributeGroup_Name, Name))   
				AND (Entity_ID = ISNULL(@EntityID, Entity_ID)) AND (MemberType_ID = ISNULL(@MemberTypeID, MemberType_ID))  
			IF @AttributeGroup_ID IS NULL		  
			BEGIN  
				SELECT @AttributeGroup_ID = @Invalid_ID  
			END  
		END  
END
GO
/****** Object:  StoredProcedure [mdm].[udpAttributeChange]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
Description:  
This SProc takes an existing attribute and changes its name and/or its data type. If a datatype is changed, a new attribute is created and all  
previous attribute values are copied into it  
Example:  
declare @p16 bit  
set @p16=0  
declare @p17 bit  
set @p17=0  
exec mdm.udpAttributeChange  
@Attribute_MUID='D0D9A3BD-239F-4F18-9A71-FD40832459F1',  
@AttributeNewName=N'May15',  
@AttributeType_ID=1,  
@DisplayName=N'May15',  
@DisplayWidth=100,@DomainEntity_MUID='00000000-0000-0000-0000-000000000000',@DomainEntity_Name=default,  
@DataType_ID=1, --1 text, 2 number, 3 datetime , 6 link  
@DataTypeInformation=5,  
@InputMask_Name=N'None',@ChangeTrackingGroup=0,  
@User_ID=1  
  
This takes the attribute with MUID : D0D9A3BD-239F-4F18-9A71-FD40832459F1  
and changes its type  
*/  
CREATE PROCEDURE [mdm].[udpAttributeChange]  
(  
    @User_ID                        INT,    
    @Attribute_MUID                 UNIQUEIDENTIFIER,    
    @AttributeNewName               NVARCHAR(100),    
    @AttributeType_ID               TINYINT,    
    @Description                    NVARCHAR(500) = NULL,    
    @DisplayName                    NVARCHAR(250) = NULL,    
    @DisplayWidth                   INT,    
    @DomainEntity_MUID              UNIQUEIDENTIFIER = NULL,    
    @DomainEntity_Name              NVARCHAR(MAX) = NULL,    
    @FilterParentAttribute_MUID     UNIQUEIDENTIFIER = NULL,    
    @FilterParentAttribute_Name     NVARCHAR(100) = NULL,    
    @FilterHierarchy_MUID           UNIQUEIDENTIFIER = NULL,    
    @FilterHierarchyName            NVARCHAR(50) = NULL,    
    @FilterHierarchyLevelNumber     INT = NULL,    
    @DataType_ID                    TINYINT = NULL,    
    @DataTypeInformation            INT = NULL,    
    @InputMask_Name                 NVARCHAR(250) = NULL,    
    @ChangeTrackingGroup            INT = 0,    
    @IsSync                         BIT = 0,    
    @Return_DeprecatedAttributeName NVARCHAR(100) = NULL OUTPUT,    
    @Return_NewAttribute_MUID       UNIQUEIDENTIFIER = NULL OUTPUT,    
    @Return_NewAttribute_ID         INT = NULL OUTPUT,    
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability    
)    
WITH EXECUTE AS 'mds_schema_user'    
AS BEGIN    
    SET NOCOUNT ON;    
    
    SET @Return_NewAttribute_MUID = NULL;    
    SET @Return_NewAttribute_ID = NULL;    
    
    -- Constants    
    -- AttributeDataType constants    
    DECLARE    
        @DataTypeText           TINYINT = 1,    
        @DataTypeNumber         TINYINT = 2,    
        @DataTypeDateTime       TINYINT = 3,    
        @DataTypeLink           TINYINT = 6,    
    
        -- AttributeType constants    
        @AttributeTypeFreeform  TINYINT = 1,    
        @AttributeTypeDomain    TINYINT = 2,    
        @AttributeTypeSystem    TINYINT = 3,    
        @AttributeTypeFile      TINYINT = 4,    
    
        -- MemberType constants    
        @MemberType_Leaf         TINYINT = 1,    
        @MemberType_Consolidated TINYINT = 2,    
        @MemberType_Collection   TINYINT = 3,    
    
        @FunctionalPrivilege_SysAdmin  TINYINT = 5,    
    
        @MaxLength_Name         INT = 100,    
        @MaxLength_DisplayName  INT = 250;    
    
    
    IF mdm.udfSecurityUserFunctionIsAllowed(@User_ID, @FunctionalPrivilege_SysAdmin) = 0    
    BEGIN    
        RAISERROR('MDSERR120002|The user does not have permission to perform this operation.', 16, 1);    
        RETURN;    
    END    
    -- Get current attribute type information    
   DECLARE    
       -- IDs of input parameters (i.e. convert attribute MUID to ID)    
        @Attribute_ID               INT,    
        @Model_ID                   INT,    
        @Model_Privilege            INT,    
        @Entity_ID                  INT,    
        @IsHierarchyEnabled         BIT = NULL,    
        @IsCollectionEnabled        BIT = NULL,    
        @DataCompression            TINYINT = NULL,    
        @TableName                  SYSNAME = NULL,    
        @StagingTableName           SYSNAME = NULL,    
        @MemberType_ID              TINYINT,    
        @DomainEntity_ID            INT,    
        @FilterParentAttribute_ID   INT = NULL,    
        @FilterHierarchyDetail_ID   INT = NULL,    
        @InputMask_ID               INT,    
        -- IDs/Names of the current values stored for the given attribute    
        @InputMask_ID_Current       INT ,    
        @DomainEntity_ID_Current    INT,    
        @FilterParentAttribute_ID_Current   INT = NULL,    
        @FilterHierarchyDetail_ID_Current   INT = NULL,    
        @AttributeType_ID_Current   TINYINT,    
        @AttributeName_Current      NVARCHAR(100),    
        @AttributeDisplayName_Current   NVARCHAR(250),    
        @Description_Current        NVARCHAR(500),    
        @DataType_ID_Current        TINYINT,    
        @DataTypeInformation_Current    INT ,    
        @DisplayName_Current        NVARCHAR(250),    
        @DisplayWidth_Current       INT ,    
        @ChangeTrackingGroup_Current    INT,    
        @LastVersion                INT,    
        @IsSystem                   BIT,    
        @IsName                     BIT,    
        @IsCode                     BIT,    
        @MembersWithErrors          XML = NULL, -- If any errors occurred, will hold the codes of the members that failed    
        @OriginalSortOrder          INT,    
        -- Booleans to figure out what kind of change we encountered    
        @HasTypeChange              BIT,    
        @HasNameChange              BIT,    
        @HasDescriptionChange       BIT,    
        @HasDisplayWidthChange      BIT,    
        @HasChangeTrackingChange    BIT,    
        @HasDisplayNameChange       BIT,    
        @HasFilterChange            BIT,    
        @TranCommitted              INT = 0, -- 0: Not committed, 1: Committed.    
        @EditMode_Create            TINYINT = 0,    
        @EditMode_Update            TINYINT = 1,    
        @EditMode_Clone             TINYINT = 4;    
    
    
    -- Get the currently stored values for the original attribute given in the parameter    
    SELECT    
        @Attribute_ID = a.ID,    
        @AttributeName_Current = a.Name,    
        @AttributeDisplayName_Current = a.DisplayName,    
        @Description_Current = a.[Description],    
        @AttributeType_ID_Current = a.AttributeType_ID,    
        @Entity_ID = e.ID,    
        @IsHierarchyEnabled = CASE WHEN e.HierarchyParentTable IS NULL THEN 0 ELSE 1 END,    
        @IsCollectionEnabled = CASE WHEN e.CollectionTable IS NULL THEN 0 ELSE 1 END,    
        @DataCompression = e.DataCompression,    
        @TableName = CASE a.MemberType_ID    
                    WHEN @MemberType_Leaf           THEN e.EntityTable    
                    WHEN @MemberType_Consolidated   THEN e.HierarchyParentTable    
                    WHEN @MemberType_Collection     THEN e.CollectionTable    
                    END, --TableName    
        @StagingTableName = CASE a.MemberType_ID    
                    WHEN @MemberType_Leaf           THEN e.StagingLeafName    
                    WHEN @MemberType_Consolidated   THEN e.StagingConsolidatedName    
                    WHEN @MemberType_Collection     THEN NULL    
                    END, -- StagingTableName    
        @Model_ID = e.Model_ID,    
        @Model_Privilege = sec.Privilege_ID,    
        @MemberType_ID = a.MemberType_ID,    
        @DataType_ID_Current = a.DataType_ID,    
        @DataTypeInformation_Current = a.DataTypeInformation,    
        @InputMask_ID_Current = a.InputMask_ID,    
        @DomainEntity_ID_Current = a.DomainEntity_ID,    
        @FilterParentAttribute_ID_Current = a.FilterParentAttribute_ID,    
        @FilterHierarchyDetail_ID_Current = a.FilterHierarchyDetail_ID,    
        @DisplayWidth_Current = a.DisplayWidth,    
        @DisplayName_Current = a.DisplayName,    
        @OriginalSortOrder = a.SortOrder,    
        @ChangeTrackingGroup_Current = a.ChangeTrackingGroup,    
        @IsSystem = a.IsSystem,    
        @IsCode = a.IsCode,    
        @IsName = a.IsName    
    FROM mdm.tblAttribute a    
    INNER JOIN mdm.tblEntity e    
    ON a.Entity_ID = e.ID    
    INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_MODEL sec    
    ON sec.ID = e.Model_ID    
        AND sec.User_ID = @User_ID     
        AND sec.Privilege_ID <> 1 /*Deny*/    
    WHERE a.MUID = @Attribute_MUID    
    
    --If the user is not a model admin, raise an error now    
    IF @Model_Privilege != 5 /*Admin*/    
    BEGIN    
        RAISERROR('MDSERR120003|The user does not have permission or the object ID is not valid.', 16, 1);    
        RETURN;    
    END;    
    
    SET @DisplayName = NULLIF(LTRIM(RTRIM(@DisplayName)), N'')    
    SET @DisplayName = ISNULL(@DisplayName,@DisplayName_Current)    
    
    
    -- If supplied, find the Domain Entity *ID* from the given Domain entity MUID OR the Domain entity NAME (we already know the model/entity IDs)    
    SELECT @DomainEntity_ID = ID    
    FROM mdm.tblEntity    
    WHERE (MUID = @DomainEntity_MUID)    
        OR (Model_ID = @Model_ID    
            AND Name = @DomainEntity_Name);    
    
    DECLARE @GetVersionSql NVARCHAR(MAX)    
    SET @GetVersionSql = N'    
                        SELECT @LastVersion = MAX(m.ID)    
                        FROM mdm.tblModelVersion as m where Model_ID =' + CONVERT(NVARCHAR, @Model_ID);    
    EXEC sp_executesql @GetVersionSql, N'@LastVersion INT OUTPUT ', @LastVersion OUTPUT;    
    
    -- Validate input    
    -- A valid attribute is required    
    IF @Attribute_ID IS NULL    
    BEGIN    
        RAISERROR('MDSERR200016|The attribute cannot be saved. The attribute ID is not valid.', 16, 1);    
        RETURN;    
    END;    
    
    -- We don't support System attributes    
    IF @IsSystem = 1 AND @IsCode = 0 AND @IsName = 0    
    BEGIN    
        RAISERROR('MDSERR100041|A system attribute cannot be updated.', 16, 1);    
        RETURN;    
    END;    
    
    -- Verify the entity is not a sync target.    
    IF @IsSync = 0    
    BEGIN    
        IF EXISTS(SELECT 1 FROM mdm.tblSyncRelationship WHERE TargetEntity_ID = @Entity_ID)-- This query is in a nested IF statement, rather than in the parent IF statement, for efficiency because SQL does not guarantee Boolean short circuiting.    
        BEGIN    
            RAISERROR('MDSERR200215|The attribute cannot be saved. The entity is the target of a sync relationship.', 16, 1);    
            RETURN;    
        END    
    END    
    
    -- Verify and lookup the InputMask_ID (from the InputMask_Name)    
    IF (@InputMask_Name IS NULL)    
    BEGIN    
        -- If input mask wasn't given, that is OK, continue with the ID as NULL    
        SET @InputMask_ID = NULL    
    END ELSE    
    BEGIN    
        -- If the input mask was given, make sure it exists    
        SET @InputMask_ID = ISNULL((SELECT OptionID FROM mdm.tblList WHERE ListCode = CAST(N'lstInputMask' AS NVARCHAR(50)) AND ListOption = @InputMask_Name), -1);    
    
        IF (@InputMask_ID < 0)    
        BEGIN    
            RAISERROR('MDSERR200085|The attribute cannot be saved. The input mask is not valid.', 16, 1);    
            RETURN;    
        END    
    END    
    
    
    IF @FilterParentAttribute_MUID IS NOT NULL OR NULLIF(@FilterParentAttribute_Name, N'') IS NOT NULL    
    BEGIN    
        -- Lookup attribute filter info    
    
        DECLARE @AttributeFilters mdm.AttributeFilter;    
        INSERT INTO @AttributeFilters    
        (    
             AttributeRow_ID    
            ,ParentAttribute_MUID    
            ,ParentAttributeName    
            ,Hierarchy_MUID    
            ,HierarchyName    
            ,HierarchyLevelNumber    
        )    
        VALUES    
        (    
             1    
            ,@FilterParentAttribute_MUID    
            ,@FilterParentAttribute_Name    
            ,@FilterHierarchy_MUID    
            ,@FilterHierarchyName    
            ,@FilterHierarchyLevelNumber    
        );    
    
        -- The schema of this table should match that defined in udpMetadataSave    
        CREATE TABLE #AttributesToProcess    
        (    
            Row_ID              INT NOT NULL PRIMARY KEY,    
            Model_ID            INT NULL,    
            Model_MUID          UNIQUEIDENTIFIER NULL,    
            ModelName           NVARCHAR(50) COLLATE DATABASE_DEFAULT NULL,    
            Version_ID          INT NULL,    
            Entity_ID           INT NULL,    
            Entity_MUID         UNIQUEIDENTIFIER NULL,    
            EntityName          NVARCHAR(50) COLLATE DATABASE_DEFAULT NULL,    
            IsHierarchyEnabled  BIT NULL,    
            IsCollectionEnabled BIT NULL,    
            DataCompression     TINYINT NULL,    
            TableName           SYSNAME NULL,    
            StagingTableName    SYSNAME NULL,    
            MemberType_ID       TINYINT NOT NULL,    
            ID                  INT NULL,    
            MUID                UNIQUEIDENTIFIER NULL,    
            Name                NVARCHAR(100) COLLATE DATABASE_DEFAULT NOT NULL,    
            [Description]       NVARCHAR(500) COLLATE DATABASE_DEFAULT NULL,    
            AttributeType_ID    TINYINT NULL,    
            DisplayName         NVARCHAR(250) COLLATE DATABASE_DEFAULT NULL,    
            DisplayWidth        INT NOT NULL,    
            DomainEntity_ID     INT NULL,    
            FilterParentAttribute_ID    INT NULL,    
            FilterHierarchyDetail_ID    INT NULL,    
            DataType_ID         TINYINT NULL,    
            DataTypeInformation INT NULL,    
            InputMask_ID        INT NULL,    
            ChangeTrackingGroup INT DEFAULT 0,    
            SortOrder           INT NULL,    
            DidNameChange       BIT NULL,    
            Error               NVARCHAR(MAX) COLLATE DATABASE_DEFAULT NULL    
        );    
    
        INSERT INTO #AttributesToProcess    
        (    
             Row_ID    
            ,Model_ID    
            ,Entity_ID    
            ,MemberType_ID    
            ,ID    
            ,Name    
            ,DisplayWidth    
            ,DomainEntity_ID    
        )    
        VALUES    
        (    
             1    
            ,@Model_ID    
            ,@Entity_ID    
            ,@MemberType_ID    
            ,@Attribute_ID    
            ,@AttributeNewName    
            ,@DisplayWidth    
            ,@DomainEntity_ID    
        )    
    
        EXEC mdm.udpMetadataSaveHelper_LookupAttributeFilterIds @AttributeFilters    
    
        DECLARE @Error NVARCHAR(MAX) = NULL    
    
        SELECT TOP 1    
             @FilterParentAttribute_ID = FilterParentAttribute_ID    
            ,@FilterHierarchyDetail_ID = FilterHierarchyDetail_ID    
            ,@Error = Error    
        FROM #AttributesToProcess    
    
        IF @Error IS NOT NULL    
        BEGIN    
            SET @Error = REPLACE(@Error, '%', '%%')-- escape out format specifier  
            RAISERROR(@Error, 16, 1);    
        END    
    END    
    
    --    
    -- Now that was have all the information on the current state of the attribute and the intended state,    
    -- check the type and/or the name have changed    
    SELECT @HasTypeChange =    
    CASE    
        WHEN    
        (    
        @AttributeType_ID_Current != @AttributeType_ID OR    
        @DataType_ID_Current != @DataType_ID OR    
        @DataTypeInformation_Current != @DataTypeInformation OR    
        @InputMask_ID_Current != @InputMask_ID OR    
        @DomainEntity_ID_Current != @DomainEntity_ID    
        )    
        THEN 1    
        ELSE 0    
    END    
    
    SELECT @HasFilterChange =     
    CASE WHEN    
        (    
         COALESCE(@FilterParentAttribute_ID_Current, 0) != COALESCE(@FilterParentAttribute_ID, 0) OR    
         COALESCE(@FilterHierarchyDetail_ID_Current, 0) != COALESCE(@FilterHierarchyDetail_ID, 0)    
        )    
        THEN 1    
        ELSE 0    
    END    
    
    SELECT @HasNameChange =    
    CASE    
        WHEN (@AttributeName_Current != @AttributeNewName)    
        THEN 1    
        ELSE 0    
    END    
    
    SELECT @HasDescriptionChange =    
    CASE    
        WHEN (ISNULL(@Description_Current, N'') != ISNULL(LTRIM(RTRIM(@Description)), N''))    
        THEN 1    
        ELSE 0    
    END    
    
    
    SELECT @HasDisplayNameChange =    
    CASE    
        WHEN (@DisplayName_Current != @DisplayName)    
        THEN 1    
        ELSE 0    
    END    
    
    
    SELECT @HasDisplayWidthChange =    
    CASE    
    WHEN (@DisplayWidth_Current != @DisplayWidth)    
        THEN 1    
        ELSE 0    
    END    
    
    
    SELECT @HasChangeTrackingChange =    
    CASE    
    WHEN(@ChangeTrackingGroup_Current != @ChangeTrackingGroup)    
        THEN 1    
        ELSE 0    
    END    
    
    IF (@HasNameChange = 1 OR @HasTypeChange = 1) AND ( @IsCode = 1 OR @IsName = 1 )    
    BEGIN    
        RAISERROR(N'MDSERR110019|Only Display Name can be changed for attribute Name and Code.', 16, 1);    
            RETURN;    
    END    
    
    -- Check the new attribute name, to make sure it isn't duplicate    
    IF @HasNameChange = 1    
    BEGIN    
        IF EXISTS (SELECT * FROM mdm.tblAttribute WHERE Name=@AttributeNewName AND Entity_ID=@Entity_ID AND MemberType_ID=@MemberType_ID)    
        BEGIN    
            RAISERROR(N'MDSERR110003|The name already exists. Type a different name.', 16, 1);    
            RETURN;    
        END    
    END    
    
    IF @HasDisplayNameChange = 1    
    BEGIN-- DisplayName validation    
        -- make sure it is not duplicated    
        IF EXISTS (SELECT * FROM mdm.tblAttribute WHERE DisplayName = @DisplayName AND Entity_ID=@Entity_ID AND MemberType_ID=@MemberType_ID)    
        BEGIN    
            RAISERROR(N'MDSERR110018|The display name already exists. Type a different name.', 16, 1);    
            RETURN;    
        END    
    END    
    
    --Check dependencies on this attribute: if there is any related business rule or derived hierarchy then attribute type change is not allowed.    
    IF @HasTypeChange = 1    
    BEGIN    
        BEGIN TRY    
            EXEC mdm.udpObjectDeleteCheckByMUID @Object_MUID = @Attribute_MUID, @ObjectType_ID = 7/*Attribute*/;    
        END TRY    
        BEGIN CATCH    
    
            -- Get error info.    
            DECLARE @ReturnErrorMessage NVARCHAR(4000)    
            EXEC mdm.udpGetErrorInfo @ErrorMessage = @ReturnErrorMessage OUTPUT    
    
            SET @ReturnErrorMessage =    
                CASE    
                WHEN @ReturnErrorMessage LIKE N'MDSERR200028%' THEN 'MDSERR200108|The attribute cannot be edited because it is referenced by a derived hierarchy.'    
                WHEN @ReturnErrorMessage LIKE N'MDSERR200027%' THEN 'MDSERR200109|The attribute cannot be edited because it is referenced by a business rule.'    
                ELSE @ReturnErrorMessage    
                END;    
            RAISERROR(@ReturnErrorMessage, 16, 1);    
            RETURN;    
        END CATCH    
    
        --check for user defined indexes on the attribute    
        IF @MemberType_ID = @MemberType_Leaf    
        BEGIN    
            DECLARE @UniqueIndexPrefix SYSNAME, @NonUniqueIndexPrefix SYSNAME    
            SET @UniqueIndexPrefix = CONCAT(N'uixud_', @TableName, N'_Version_ID_');    
            SET @NonUniqueIndexPrefix = CONCAT(N'ixud_', @TableName, N'_Version_ID_');    
            DECLARE @table_ID INT = OBJECT_ID(N'[mdm].' + QUOTENAME(@TableName));    
            DECLARE @cnt INT;    
            IF EXISTS(SELECT * FROM sys.indexes  WHERE object_id = @table_ID AND (name like @UniqueIndexPrefix + '%' + CAST(@Attribute_ID AS VARCHAR)  + '%') OR (name like @NonUniqueIndexPrefix + '%' + CAST(@Attribute_ID AS VARCHAR) + '%'))    
            BEGIN    
                RAISERROR('MDSERR200300|The attribute cannot be edited because it is included in at least one custom index.', 16, 1);    
                RETURN;    
            END    
        END    
    END    
    
    --    
    -- Start the process of attribute updates    
    --    
    
    IF @HasNameChange = 0 AND @HasTypeChange = 0 AND @HasFilterChange = 0 AND @HasDisplayNameChange = 0 AND @HasDescriptionChange = 0 AND @HasDisplayWidthChange = 0 AND @HasChangeTrackingChange = 0    
    BEGIN    
        -- Nothing has changed, leave    
        RETURN;    
    END;    
    
    DECLARE @TemporaryNewName NVARCHAR(100)    
    DECLARE @TemporaryNewDisplayName NVARCHAR(250)    
    
    IF @HasTypeChange = 0    
    BEGIN    
        SET @TemporaryNewName = ISNULL(@AttributeNewName,@AttributeName_Current)    
        SET @TemporaryNewDisplayName = ISNULL(@DisplayName, @AttributeDisplayName_Current)    
        SET @Return_DeprecatedAttributeName = @AttributeName_Current    
    END    
    ELSE -- There is also a change in the type    
    BEGIN    
        DECLARE @RenamingCounter INT = 0    
        DECLARE @Suffix NVARCHAR(10) = N'_old';    
        SET @TemporaryNewName = CONCAT(SUBSTRING(@AttributeName_Current, 0, @MaxLength_Name - LEN(@Suffix)), @Suffix)    
        SET @TemporaryNewDisplayName = CONCAT(SUBSTRING(@AttributeDisplayName_Current, 0, @MaxLength_DisplayName - LEN(@Suffix)), @Suffix)    
        -- Get temporary attribute name    
        WHILE (EXISTS(SELECT 1 FROM mdm.tblAttribute WHERE Name=@TemporaryNewName))    
        BEGIN    
            SET @RenamingCounter += 1    
            SET @TemporaryNewName = CONCAT(SUBSTRING(@AttributeName_Current, 0, @MaxLength_Name - LEN(@Suffix) - 4), @Suffix, @RenamingCounter)    
        END    
        -- Get temporary display name    
        SET @RenamingCounter = 0    
        WHILE (EXISTS(SELECT 1 FROM mdm.tblAttribute WHERE DisplayName=@TemporaryNewDisplayName))    
        BEGIN    
            SET @RenamingCounter += 1    
            SET @TemporaryNewDisplayName = CONCAT(SUBSTRING(@AttributeDisplayName_Current, 0, @MaxLength_DisplayName - LEN(@Suffix) - 4), @Suffix, @RenamingCounter)    
        END    
        SET @Return_DeprecatedAttributeName = @TemporaryNewName    
    END    
    
    --Start transaction, being careful to check if we are nested    
    DECLARE @TranCounter INT;    
    SET @TranCounter = @@TRANCOUNT;    
    IF @TranCounter > 0 SAVE TRANSACTION TX;    
    ELSE BEGIN TRANSACTION;    
    
    BEGIN TRY    
        --If we're changing just the description, display width, display name, or change tracking group don't make a new attribute    
        IF (@HasDescriptionChange = 1 OR @HasDisplayWidthChange = 1 OR @HasDisplayNameChange = 1 OR @HasChangeTrackingChange = 1 OR @HasFilterChange = 1) AND @HasNameChange = 0 AND @HasTypeChange = 0    
        BEGIN    
            EXECUTE  [mdm].[udpAttributeSave]    
                     @User_ID = @User_ID    
                    ,@Model_ID = @Model_ID    
                    ,@Entity_ID = @Entity_ID    
                    ,@IsHierarchyEnabled = @IsHierarchyEnabled    
                    ,@IsCollectionEnabled = @IsCollectionEnabled    
                    ,@DataCompression = @DataCompression    
                    ,@TableName = @TableName    
                    ,@StagingTableName = @StagingTableName    
                    ,@MemberType_ID = @MemberType_ID    
                    ,@Attribute_MUID = @Attribute_MUID    
                    ,@AttributeName = @AttributeName_Current    
                    ,@Description = @Description    
                    ,@DisplayName = @DisplayName    
                    ,@AttributeType_ID = @AttributeType_ID    
                    ,@DisplayWidth = @DisplayWidth    
                    ,@DomainEntity_ID = @DomainEntity_ID_Current    
                    ,@FilterParentAttribute_ID = @FilterParentAttribute_ID    
                    ,@FilterHierarchyDetail_ID = @FilterHierarchyDetail_ID    
                    ,@DataType_ID = @DataType_ID_Current    
                    ,@DataTypeInformation = @DataTypeInformation_Current    
                    ,@InputMask_ID = @InputMask_ID_Current     
                    ,@ChangeTrackingGroup = @ChangeTrackingGroup    
                    ,@SortOrder = @OriginalSortOrder    
                    ,@EditMode = @EditMode_Update    
                    ,@Return_ID = @Return_NewAttribute_ID OUTPUT    
                    ,@Return_MUID = @Return_NewAttribute_MUID OUTPUT;    
        END    
    
        -- Change the name of the attribute, preserving the sortOrder    
        IF @HasNameChange = 1    
        BEGIN    
            DECLARE @OldAttributeID INT    
            EXECUTE  [mdm].[udpAttributeSave]    
                         @User_ID = @User_ID    
                        ,@Model_ID = @Model_ID    
                        ,@Entity_ID = @Entity_ID    
                        ,@IsHierarchyEnabled = @IsHierarchyEnabled    
                        ,@IsCollectionEnabled = @IsCollectionEnabled    
                        ,@DataCompression = @DataCompression    
                        ,@TableName = @TableName    
                        ,@StagingTableName = @StagingTableName    
                        ,@MemberType_ID = @MemberType_ID    
                        ,@Attribute_MUID = @Attribute_MUID    
                        ,@AttributeName = @TemporaryNewName    
                        ,@Description = @Description    
                        ,@DisplayName = @TemporaryNewDisplayName    
                        ,@AttributeType_ID = @AttributeType_ID_Current    
                        ,@DisplayWidth = @DisplayWidth_Current    
                        ,@DomainEntity_ID = @DomainEntity_ID_Current    
                        ,@FilterParentAttribute_ID = @FilterParentAttribute_ID    
                        ,@FilterHierarchyDetail_ID = @FilterHierarchyDetail_ID    
                        ,@DataType_ID = @DataType_ID_Current    
                        ,@DataTypeInformation = @DataTypeInformation_Current    
                        ,@InputMask_ID = @InputMask_ID_Current    
                        ,@ChangeTrackingGroup = @ChangeTrackingGroup    
                        ,@SortOrder = @OriginalSortOrder    
                        ,@EditMode = @EditMode_Update    
                        ,@Return_ID = @OldAttributeID OUTPUT    
        END    
    
        IF @HasTypeChange = 1    
        BEGIN    
            --Change the name of the attribute, because it is the first phase of an attribute type change    
            EXECUTE  [mdm].[udpAttributeSave]    
                         @User_ID = @User_ID    
                        ,@Model_ID = @Model_ID    
                        ,@Entity_ID = @Entity_ID    
                        ,@IsHierarchyEnabled = @IsHierarchyEnabled    
                        ,@IsCollectionEnabled = @IsCollectionEnabled    
                        ,@DataCompression = @DataCompression    
                        ,@TableName = @TableName    
                        ,@StagingTableName = @StagingTableName    
                        ,@MemberType_ID = @MemberType_ID    
                        ,@Attribute_MUID = @Attribute_MUID    
                        ,@AttributeName = @TemporaryNewName    
                        ,@Description = @Description    
                        ,@DisplayName = @TemporaryNewDisplayName    
                        ,@AttributeType_ID = @AttributeType_ID_Current    
                        ,@DisplayWidth = @DisplayWidth_Current    
                        ,@DomainEntity_ID = @DomainEntity_ID_Current    
                        ,@FilterParentAttribute_ID = @FilterParentAttribute_ID    
                        ,@FilterHierarchyDetail_ID = @FilterHierarchyDetail_ID    
                        ,@DataType_ID = @DataType_ID_Current    
                        ,@DataTypeInformation = @DataTypeInformation_Current    
                        ,@InputMask_ID = @InputMask_ID_Current    
                        ,@ChangeTrackingGroup = @ChangeTrackingGroup    
                        ,@EditMode = @EditMode_Update    
                        ,@Return_ID = @OldAttributeID OUTPUT    
    
            -- Create the new attribute using the original attribute name, but with the new type definition    
            EXECUTE  [mdm].[udpAttributeSave]    
                         @User_ID = @User_ID    
                        ,@Model_ID = @Model_ID    
                        ,@Entity_ID = @Entity_ID    
                        ,@IsHierarchyEnabled = @IsHierarchyEnabled    
                        ,@IsCollectionEnabled = @IsCollectionEnabled    
                        ,@DataCompression = @DataCompression    
                        ,@TableName = @TableName    
                        ,@StagingTableName = @StagingTableName    
                        ,@MemberType_ID = @MemberType_ID    
                        ,@Attribute_MUID = NULL    
                        ,@AttributeName = @AttributeNewName    
                        ,@Description = @Description    
                        ,@DisplayName = @DisplayName    
                        ,@AttributeType_ID = @AttributeType_ID    
                        ,@DisplayWidth = @DisplayWidth    
                        ,@DomainEntity_ID = @DomainEntity_ID    
                        ,@FilterParentAttribute_ID = @FilterParentAttribute_ID    
                        ,@FilterHierarchyDetail_ID = @FilterHierarchyDetail_ID    
                        ,@DataType_ID = @DataType_ID    
                        ,@DataTypeInformation = @DataTypeInformation    
                        ,@InputMask_ID = @InputMask_ID    
                        ,@ChangeTrackingGroup = @ChangeTrackingGroup    
                        ,@SortOrder = @OriginalSortOrder    
                        ,@EditMode = @EditMode_Create    
                        ,@Return_ID = @Return_NewAttribute_ID OUTPUT    
                        ,@Return_MUID = @Return_NewAttribute_MUID OUTPUT;    
  
            -- Attribute type change will occur security related view change and following logic will use these views directly. Truncate copy the related views here.   
            EXEC mdm.udpPerformanceTruncateCopy;  
    
            DECLARE @SQL NVARCHAR(MAX)    
            SET @SQL = N'    
                DECLARE @AttributeValues TABLE    
                (    
                     RowID         INT IDENTITY(1, 1)    
                    ,MemberCode     NVARCHAR(250)    
                    ,MemberMUID     UNIQUEIDENTIFIER    
                    ,AttributeValue NVARCHAR(MAX)    
                )    
                INSERT INTO @AttributeValues (MemberCode, MemberMUID, AttributeValue)    
                SELECT    
                     Code    
                     ,MUID    
                    '    
    
            -- We treat a previously date time attribute differently - as we don't want to take it as is to the new one,    
            -- we first convert it to string using the input mask    
            IF ((@DataType_ID_Current = @DataTypeDateTime) AND (@AttributeType_ID_Current = @AttributeTypeFreeform))    
            BEGIN    
                -- Get the name of the current input mask (i.e. mm/dd/yyyy)    
                DECLARE @InputMask_Name_Current NVARCHAR(250) = (    
                    SELECT ListOption    
                    FROM mdm.tblList    
                    WHERE ListCode = N'lstInputMask'    
                        AND OptionID = @InputMask_ID_Current    
                        AND Group_ID = @DataType_ID_Current)    
    
                -- Convert date to string using the input mask    
                SET @SQL +=    
                    N',mdq.DateToString(' + QUOTENAME(@Return_DeprecatedAttributeName) + N', ''' +  @InputMask_Name_Current + N''')'    
            END    
            ELSE    
            BEGIN    
                -- Just trim whitespace    
                SET @SQL +=    
                    N',LTRIM(RTRIM(CONVERT(NVARCHAR(MAX),' + QUOTENAME(@Return_DeprecatedAttributeName) + N')))'    
            END    
    
            DECLARE @ViewName SYSNAME = mdm.udfViewNameGet(@Model_ID, @Entity_ID, @MemberType_ID, 0, 0);    
            SET @SQL +=  N'    
                FROM mdm.' + CONVERT(NVARCHAR(MAX), @ViewName) + N' AS m    
                WHERE    
                    m.Version_ID = @LastVersion AND    
                    ' + QUOTENAME(@Return_DeprecatedAttributeName) + N' IS NOT NULL    
                DECLARE @Members mdm.MemberSaveList;    
                INSERT INTO @Members    
                (    
                     RowID    
                    ,MemberCode    
                )    
                SELECT    
                     RowID    
                    ,MemberCode    
                FROM @AttributeValues;    
    
                DECLARE @MemberAttributes mdm.MemberAttributeValues;    
                INSERT INTO @MemberAttributes    
                (    
                     MemberRowID    
                    ,AttributeID    
                    ,AttributeValue    
                )    
                SELECT    
                     RowID    
                    ,@NewAttribute_ID    
                    ,AttributeValue    
                FROM @AttributeValues;    
    
                IF (@MemberType_ID = 2)  --Consolidated Attribute values are updating in different sproc    
                BEGIN    
                    DECLARE @MyMemberAttributes mdm.MemberAttributes;    
                    INSERT INTO @MyMemberAttributes    
                    (    
                         MemberCode    
                        ,MemberMUID    
                        ,AttributeName    
                        ,AttributeValue    
                    )    
                    SELECT    
                         MemberCode    
                        ,MemberMUID    
                        ,@NewAttributeName    
                        ,AttributeValue    
                    FROM @AttributeValues;    
                    EXEC mdm.udpEntityMembersUpdate @User_ID = @User_ID , @Version_ID = @LastVersion, @Entity_ID = @Entity_ID, @MemberType_ID = @MemberType_ID, @MemberAttributes = @MyMemberAttributes, @IgnorePriorValues = 0, @ValidateDataTypes = 1, @ShouldReturnMembersWithErrorsAsXml = 1, @Return_MembersWithErrors = @MembersWithErrors OUTPUT;    
                END    
                ELSE    
                BEGIN    
                EXEC mdm.udpEntityMembersSave    
                      @User_ID = @User_ID    
                     ,@Model_ID = @Model_ID    
                     ,@Version_ID = @LastVersion    
                     ,@Entity_ID = @Entity_ID    
                     ,@MemberType_ID = @MemberType_ID    
                     ,@Members = @Members    
                     ,@MemberAttributes = @MemberAttributes    
                     ,@SaveMode = 3 -- Update    
                     ,@LogFlag = 1    
                     ,@ValidateDataTypes = 1    
                     ,@DoInheritanceRuleCheck = 0    
                     ,@ErrorReportingType = 2 -- Put errors in XML out param    
                     ,@Errors = @MembersWithErrors OUTPUT;    
                END    
            ';    
            -- Copy the old attribute values to the new attribute. This is a best effort insertion. NULLs will be placed where it fails.    
            DECLARE @MemberAttributes            mdm.MemberAttributes    
            EXEC sp_executesql @SQL,    
                N'@User_ID INT, @LastVersion INT, @Model_ID INT, @Entity_ID INT, @MemberType_ID INT, @NewAttribute_ID INT,    @NewAttributeName NVARCHAR(MAX), @MembersWithErrors XML OUTPUT',    
                  @User_ID,     @LastVersion,     @Model_ID,     @Entity_ID,     @MemberType_ID,     @Return_NewAttribute_ID, @AttributeNewName, @MembersWithErrors OUTPUT;    
    
            -- Get all the IDs of the attribute groups the old attribute belonged to    
            DECLARE @AttributeGroups AS TABLE (    
                     RowNumber INT IDENTITY(1,1) NOT NULL,    
                     AttributeGroup_ID INT NOT NULL    
                     );    
    
            INSERT INTO @AttributeGroups(AttributeGroup_ID) SELECT AttributeGroup_ID FROM mdm.tblAttributeGroupDetail WHERE Attribute_ID=@OldAttributeID    
    
            IF EXISTS(SELECT 1 FROM @AttributeGroups)    
            BEGIN    
                DECLARE    
                    @Counter INT,    
                    @MaxCounter INT,    
                    @AttributeGroup_ID INT    
    
                SELECT    
                    @Counter=1,    
                    @MaxCounter = MAX(RowNumber)    
                FROM @AttributeGroups    
    
                --Loop through each attribute group this attribute belongs to, and associate the new attribute to it.    
                WHILE @Counter <= @MaxCounter    
                BEGIN    
                    SELECT    
                        @AttributeGroup_ID = AttributeGroup_ID    
                    FROM @AttributeGroups WHERE [RowNumber] = @Counter ;    
    
                     exec mdm.udpAttributeGroupDetailSave    
                                 @User_ID=@User_ID    
                                ,@AttributeGroup_ID=@AttributeGroup_ID    
                                ,@Attribute_ID=@Return_NewAttribute_ID    
                    SET @Counter += 1    
                END    
    
            END    
    
            -- Decide if we should delete or not the old attribute    
            -- If there are no errors on this old attribute, delete it    
            IF (@MembersWithErrors IS NULL)    
            BEGIN    
                EXEC mdm.udpAttributeDelete @Attribute_ID = @Attribute_ID, @CreateViewsInd = 1    
            END    
    
    
            IF @MembersWithErrors IS NOT NULL    
            BEGIN    
                -- Return to user all the member codes that had an error converting.    
                SELECT    
                    node.value('MemberCode[1]', 'NVARCHAR(MAX)') AS MemberCodeWithError,    
                    node.value('MemberMUID[1]', 'UNIQUEIDENTIFIER') AS MemberMuidWithError    
                FROM    
                    @MembersWithErrors.nodes('//Error') T(node)    
            END    
    
        END;    
    
        --Commit only if we are not nested    
        IF @TranCounter = 0    
        BEGIN    
            COMMIT TRANSACTION;    
            SET @TranCommitted = 1;    
        END; -- IF    
    
    END TRY    
    --Compensate as necessary    
    BEGIN CATCH    
    
        -- Get error info.    
        DECLARE    
            @ErrorMessage NVARCHAR(4000),    
            @ErrorSeverity INT,    
            @ErrorState INT,    
            @ErrorNumber INT,    
            @ErrorLine INT,    
            @ErrorProcedure NVARCHAR(126);    
        EXEC mdm.udpGetErrorInfo    
            @ErrorMessage = @ErrorMessage OUTPUT,    
            @ErrorSeverity = @ErrorSeverity OUTPUT,    
            @ErrorState = @ErrorState OUTPUT,    
            @ErrorNumber = @ErrorNumber OUTPUT,    
            @ErrorLine = @ErrorLine OUTPUT,    
            @ErrorProcedure = @ErrorProcedure OUTPUT    
    
        SET @ErrorMessage = CONCAT(@ErrorMessage, N', @ErrorNumber = ', @ErrorNumber, N', @ErrorProcedure = "', @ErrorProcedure, N'", line ', @ErrorLine);    
    
        IF @TranCommitted = 0 -- Don't rollback when the transaction has been committed.    
        BEGIN    
            IF @TranCounter = 0 ROLLBACK TRANSACTION;    
            ELSE IF XACT_STATE() <> -1 ROLLBACK TRANSACTION TX;    
        END; -- IF    
    
        --Throw the error again so the calling procedure can use it    
        RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);    
    
        RETURN;    
    
    END CATCH;    
    
    SET NOCOUNT OFF;    
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpAttributeColumnListGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
    Procedure  : mdm.udpAttributeColumnListGet  
    Component  : Hierarchy Explorer; Security Administration  
    Description: mdm.udpAttributeColumnListGet returns a string containing column names that are accessible to a user (security is applied)  
    Parameters : User ID (required)             
                 Entity ID (required)            
                 Member Type ID (required)       
                 Display Type ID (required)      
                 Attribute Group ID (required)         
    Return     : String  
    Example    :   
                DECLARE @ColumnString AS NVARCHAR(MAX);  
                EXEC mdm.udpAttributeColumnListGet 1, 6, 1, NULL, @ColumnString OUT;  
                SELECT @ColumnString;  
*/  
CREATE PROCEDURE [mdm].[udpAttributeColumnListGet]  
(  
    @User_ID            INT,  
    @Entity_ID          INT,  
    @MemberType_ID      INT,  
    @AttributeGroup_ID  INT = NULL,  
    @ColumnString       NVARCHAR(MAX) OUTPUT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON;  
  
    --Get static set of columns  
    SET @ColumnString = CAST(N'T.[ID], T.[Version_ID], T.[ValidationStatus_ID]' AS NVARCHAR(MAX));  
  
    --Get variable set of colummns  
    SELECT @ColumnString += N', T.' + QUOTENAME(a.Name)   
    FROM mdm.tblAttribute a  
    INNER JOIN viw_SYSTEM_SECURITY_USER_ATTRIBUTE aSec  
    ON a.ID = aSec.ID  
        AND aSec.User_ID = @User_ID  
        AND (@Entity_ID IS NULL OR a.Entity_ID = @Entity_ID)  
        AND (@MemberType_ID IS NULL OR a.MemberType_ID = @MemberType_ID)  
    LEFT JOIN mdm.tblAttributeGroupDetail aGroup   
    ON      a.ID = aGroup.Attribute_ID  
        AND aGroup.AttributeGroup_ID = @AttributeGroup_ID  
    WHERE  @AttributeGroup_ID IS NULL  
        OR aGroup.AttributeGroup_ID IS NOT NULL  
        OR a.IsCode = 1 -- always include Name and Code (if the user has permission to see them)  
        OR a.IsName = 1  
    ORDER BY -- Ensure Name and Code come before the other attributes  
        CASE WHEN a.IsName = 1 THEN 0  
             WHEN a.IsCode = 1 THEN 1  
             ELSE 2 END;  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpAttributeDelete]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    DECLARE @Attribute_ID INT;  
    SET @Attribute_ID = 891;  
    EXEC mdm.udpAttributeDelete @Attribute_ID, 1;  
    SELECT * FROM mdm.tblAttribute WHERE ID = @Attribute_ID;  
  
MDM Errors that this proc may throw:  
100022 - when an attempt is made to delete a system attribute.  
*/  
CREATE PROCEDURE [mdm].[udpAttributeDelete]  
(  
    @Attribute_ID       INTEGER,  
    @CreateViewsInd     BIT = NULL, --1=Create, 0=DoNot Create  
    @IsSync             BIT = 0,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON  
  
    DECLARE @IsValidParam       INT = 1,  
            @SQL                NVARCHAR(MAX) = N'',  
  
            @MemberType_Leaf            TINYINT = 1,  
            @MemberType_Consolidated    TINYINT = 2,  
  
            @AttributeType_Freeform    TINYINT = 1,  
            @AttributeType_Domain      TINYINT = 2,  
            @AttributeType_System      TINYINT = 3,  
            @AttributeType_File        TINYINT = 4,  
  
            @TableName          SYSNAME,  
            @TransactionTableName       SYSNAME,  
            @AttributeName      NVARCHAR(250),  
            @TableColumn        SYSNAME,  
            @ForeignTableName   SYSNAME,  
            @Model_ID           INT,  
            @Entity_ID          INT,  
            @MemberType_ID      TINYINT,  
            @AttributeType_ID   INT,  
            @DomainEntity_ID    INT,  
            @IsSystem           BIT,  
            @AttributeMUID      UNIQUEIDENTIFIER,  
            @idx                SYSNAME,  
            @UniqueIndexPrefix  SYSNAME,  
            @NonUniqueIndexPrefix  SYSNAME,  
            @uniqueidx          SYSNAME,  
            @nonuniqueidx       SYSNAME,  
            @fk                 SYSNAME,  
            @StagingBase        NVARCHAR(60),  
            @StagingTableName   SYSNAME,  
            @TranCommitted      INT = 0; -- 0: Not committed, 1: Committed.  
  
    --Start transaction, being careful to check if we are nested  
    DECLARE @TranCounter INT;  
    SET @TranCounter = @@TRANCOUNT;  
    IF @TranCounter > 0 SAVE TRANSACTION TX;  
    ELSE BEGIN TRANSACTION;  
  
    BEGIN TRY  
  
        SET @CreateViewsInd = ISNULL(@CreateViewsInd, 1);  
  
        SELECT  
            @Model_ID = e.Model_ID,  
            @Entity_ID = e.ID,  
            @MemberType_ID = a.MemberType_ID,  
            @AttributeName = a.[Name],  
            @DomainEntity_ID = a.DomainEntity_ID,  
            @TableColumn = a.TableColumn,  
            @AttributeType_ID = a.AttributeType_ID,  
            @AttributeMUID = a.MUID,  
            @IsSystem = a.IsSystem  
        FROM mdm.tblEntity AS e  
        INNER JOIN mdm.tblAttribute AS a ON (e.ID = a.Entity_ID)  
        WHERE a.ID = @Attribute_ID;  
  
        IF @IsSystem = 1  
        BEGIN  
            RAISERROR('MDSERR100022|A system attribute cannot be deleted.', 16, 1);  
            RETURN;  
         END; --if  
  
        -- Verify the entity is not a sync target.  
        IF @IsSync = 0  
        BEGIN  
            IF EXISTS(SELECT 1 FROM mdm.tblSyncRelationship WHERE TargetEntity_ID = @Entity_ID)-- This query is in a nested IF statement, rather than in the parent IF statement, for efficiency because SQL does not guarantee Boolean short circuiting.  
            BEGIN  
                RAISERROR('MDSERR200216|The attribute cannot be deleted. The entity is the target of a sync relationship.', 16, 1);  
                RETURN;  
            END  
        END  
  
        --Get the Table Name.  
        SET @TableName = mdm.udfTableNameGetByID(@Entity_ID, @MemberType_ID);  
        SET @TransactionTableName = mdm.udfGetTransactionTableName(@Model_ID);  
  
        --Delete the transaction table. The transaction annotation table will be cascade deleted.  
        SET @SQL = CONCAT(N'  
            DELETE [mdm].', QUOTENAME(@TransactionTableName), N'  
            WHERE Attribute_ID = @Attribute_ID;');  
        EXEC sp_executesql @SQL, N'@Attribute_ID INT', @Attribute_ID;  
  
        --Get the Staging Table Name and Staging Base.  
        SELECT  
             @StagingTableName = CASE a.MemberType_ID  
                WHEN @MemberType_Leaf           THEN e.StagingLeafName  
                WHEN @MemberType_Consolidated   THEN e.StagingConsolidatedName  
                END  
            ,@StagingBase = e.StagingBase  
        FROM mdm.tblAttribute a  
        INNER JOIN mdm.tblEntity e  
        ON a.Entity_ID = e.ID  
        WHERE a.ID = @Attribute_ID  
  
        DECLARE @table_ID INT = OBJECT_ID(N'[mdm].' + QUOTENAME(@TableName));  
        IF EXISTS(SELECT 1 FROM sys.columns WHERE object_id = @table_ID AND [name] = @TableColumn)  
        BEGIN  
  
  
           -- Verify the attribute is not included in the composite keys indexing.IF there are only single indexing the attribute is good to be deleted after dropping the indexes.  
            SET @UniqueIndexPrefix = CONCAT(N'uixud_', @TableName, N'_Version_ID_');  
            SET @NonUniqueIndexPrefix = CONCAT(N'ixud_', @TableName, N'_Version_ID_');  
            DECLARE @cnt INT = 0;  
            SELECT @cnt = Count (*) FROM sys.indexes  WHERE object_id = @table_ID AND (name like @UniqueIndexPrefix + '%' + CAST(@Attribute_ID AS VARCHAR)  + '%') OR (name like @NonUniqueIndexPrefix + '%' + CAST(@Attribute_ID AS VARCHAR) + '%')  
            --IF there are more than 2 indexes on an attribute, it means that the attribute is included in at least  
            -- one composite type indexing and can not be deleted, if it's less or equal to 2, we need to check if these are single indexing or not.  
            IF @cnt IS NOT NULL AND ( @cnt > 0 AND @cnt <= 2)  
            BEGIN  
                DECLARE @UniqueExists BIT = 0;  
                DECLARE @NonUniqueExists BIT = 0;  
                --Check for unique single key user defined indexing  
                SET @uniqueidx = CONCAT(@UniqueIndexPrefix, @Attribute_ID);  
                DECLARE @uidx_ID INT;  
                --Drop index  
                IF @uniqueidx IS NOT NULL AND EXISTS(SELECT 1 FROM sys.indexes  WHERE object_id = @table_ID AND name = @uniqueidx) BEGIN  
                    SET @cnt = @cnt - 1;  
                    SET @UniqueExists = 1;  
  
                END; --if  
                --Check for non-unique single key user defined indexing  
                SET @nonuniqueidx = CONCAT(@NonUniqueIndexPrefix, @Attribute_ID);  
                --Drop index  
                IF @nonuniqueidx IS NOT NULL AND EXISTS(SELECT 1 FROM sys.indexes WHERE object_id = @table_ID AND name = @nonuniqueidx) BEGIN  
                    SET @cnt = @cnt - 1;  
                    SET @NonUniqueExists = 1;  
  
                END; --if  
                IF @cnt = 0 BEGIN  
                    IF @UniqueExists = 1 BEGIN  
                        SET @SQL = CONCAT( N'  
                        DROP INDEX ' , QUOTENAME(@uniqueidx) , N' ON mdm.' , QUOTENAME(@TableName) , N';');  
                        DELETE FROM mdm.tblIndex WHERE SysIndex_ID = (SELECT index_id from  sys.indexes  WHERE object_id = @table_ID AND name = @uniqueidx) and Entity_ID = @Entity_ID;  
                        EXEC sp_executesql @SQL;  
                    END  
                    IF @NonUniqueExists = 1 BEGIN  
                        SET @SQL = CONCAT( N'  
                        DROP INDEX ' , QUOTENAME(@nonuniqueidx) , N' ON mdm.' , QUOTENAME(@TableName) , N';');  
                        DELETE FROM mdm.tblIndex WHERE SysIndex_ID = (SELECT index_id from  sys.indexes  WHERE object_id = @table_ID AND name = @nonuniqueidx) and Entity_ID = @Entity_ID;  
                        EXEC sp_executesql @SQL;  
                    END  
                END  
            END  
             --when we're here all single indexing are excluded from the @cnt and if it's not zero means there are some composite indexing on the attribute  
            IF @cnt IS NOT NULL AND @cnt <> 0  
            BEGIN  
                RAISERROR('MDSERR200301|The attribute cannot be deleted because it is included in at least one composite index.', 16, 1);  
                RETURN;  
            END  
  
            SET @SQL = N'';  
            --Check for an attribute type of DBA  
            IF (@AttributeType_ID = @AttributeType_Domain)  
            BEGIN  
  
                --Get The Table Name of the table this attribute is a domain-based list for  
                SET @ForeignTableName = mdm.udfTableNameGetByID(@DomainEntity_ID, @MemberType_Leaf);  
  
                --Create the index and constraints for this attribute column  
                SET @idx = CONCAT(N'ix_', @TableName, N'_Version_ID_', @TableColumn);  
                SET @fk = CONCAT(N'fk_', @TableName, N'_' + @ForeignTableName, N'_Version_ID_', @TableColumn);  
  
            --Check for a file link  attribute  
            END ELSE IF (@AttributeType_ID = @AttributeType_File)  
            BEGIN  
  
                SET @ForeignTableName = N'tblFile';  
                SET @idx = CONCAT(N'ix_', @TableName, N'_Version_ID_', @TableColumn);  
                SET @fk = CONCAT(N'fk_', @TableName, N'_', @ForeignTableName, N'_', @TableColumn);  
  
                -- Get list of File IDs that are about to be orphaned.  
                CREATE TABLE #FileIDsToDelete  
                (  
                    ID  INT  
                );  
                DECLARE @GetFileIdsSQL NVARCHAR(MAX) = mdm.udfFileIDReferencesGetSQL(@Entity_ID, NULL, @Attribute_ID, 0)  
  
                IF LEN(@GetFileIdsSQL) > 0  
                BEGIN  
                    SET @GetFileIdsSQL = CONCAT(N'INSERT INTO #FileIDsToDelete(ID)  
', @GetFileIdsSQL);  
                    EXEC sp_executesql @GetFileIdsSQL;  
                END;  
            END; --if  
  
            --Drop FK index  
            IF @idx IS NOT NULL AND EXISTS(SELECT 1 FROM sys.indexes WHERE object_id = @table_ID AND name = @idx) BEGIN  
                --AZURE: Sql Azure does not support DROP INDEX with twp part name  
                --SET @SQL = @SQL + N'  
                --DROP INDEX [mdm].' + QUOTENAME(@TableName) + N'.' + QUOTENAME(@idx) + N';';  
                SET @SQL = @SQL + N'  
                DROP INDEX ' + QUOTENAME(@idx) + N' ON mdm.' + QUOTENAME(@TableName) + N';';  
            END; --if  
  
            --Drop FK constraint  
            IF @fk IS NOT NULL AND EXISTS(SELECT 1 FROM sys.foreign_keys WHERE object_id = OBJECT_ID(N'[mdm].' + @fk) AND parent_object_id = @table_ID)  
            BEGIN  
                SET @SQL = @SQL + N'  
                ALTER TABLE [mdm].' + QUOTENAME(@TableName) + N' DROP CONSTRAINT ' + QUOTENAME(@fk) + N';';  
            END; --if  
  
            --Drop column  
            SET @SQL = @SQL + N'  
                ALTER TABLE mdm.' + QUOTENAME(@TableName) + N' DROP COLUMN ' + QUOTENAME(@TableColumn) + N';';  
  
            --PRINT(@SQL);  
            EXEC sp_executesql @SQL;  
  
  
            IF @AttributeType_ID = @AttributeType_File  
            BEGIN  
                -- Delete orphaned files.  
                IF EXISTS(SELECT 1 FROM #FileIDsToDelete)  
                BEGIN  
                    DECLARE @File_ID mdm.IdList;  
                    INSERT INTO @File_ID  
                    SELECT ID  
                    FROM #FileIDsToDelete;  
  
                    EXEC mdm.udpFilesDelete @File_ID = @File_ID  
                END  
            END  
  
        END; --if  
  
        --Remove attribute group detail entry  
        DELETE FROM mdm.tblAttributeGroupDetail WHERE Attribute_ID = @Attribute_ID;  
  
        --Delete the security around the attribute  
        DECLARE    @Object_ID INT = mdm.udfSecurityObjectIDGetByCode(N'DIMATT');  
        EXEC mdm.udpSecurityPrivilegesDelete NULL, NULL, @Object_ID, @Attribute_ID;  
  
        -- Remove any sync source attribute mappings  
        UPDATE mdm.tblAttribute  
        SET  Source_ID = NULL  
            ,Source_LastChgTS = NULL  
        WHERE Source_ID = @Attribute_ID;  
  
        -- Remove any attribute filters that reference the attribute  
        IF @AttributeType_ID = @AttributeType_Domain -- Only DBAs can be filter parents  
        BEGIN  
            UPDATE mdm.tblAttribute  
            SET  FilterParentAttribute_ID = NULL  
                ,FilterHierarchyDetail_ID = NULL  
            WHERE FilterParentAttribute_ID = @Attribute_ID  
        END  
  
        --Delete the attribute record  
        DELETE FROM mdm.tblAttribute WHERE ID = @Attribute_ID;  
  
        --Recreate the views  
        IF @CreateViewsInd = 1  
        BEGIN  
            EXEC mdm.udpCreateViews @Model_ID, @Entity_ID;  
        END  
  
        --Recreate the subscription views of entity  
        EXEC mdm.udpCreateAllSubscriptionViews NULL, @Entity_ID;  
  
        --Delete the column from the staging table.  
        SET @table_ID = OBJECT_ID(N'stg.' + QUOTENAME(@StagingTableName));  
        IF LEN(COALESCE(@StagingTableName, N'')) > 0 AND EXISTS (SELECT * FROM sys.objects WHERE object_id = @table_ID AND type in (N'U'))  
        BEGIN  
            SET @SQL = N'ALTER TABLE stg.' + QUOTENAME(@StagingTableName) + N' DROP COLUMN ' + QUOTENAME(@AttributeName);  
            --Execute the dynamic SQL  
            EXEC sp_executesql @SQL;  
        END; -- IF  
  
        --Commit only if we are not nested  
        IF @TranCounter = 0  
        BEGIN  
            COMMIT TRANSACTION;  
            SET @TranCommitted = 1;  
        END; -- IF  
  
        -- Recreate the staging stored procedure.  
        IF @MemberType_ID = @MemberType_Leaf  
        BEGIN  
            EXEC mdm.udpEntityStagingCreateLeafStoredProcedure @Entity_ID  
        END -- IF  
        ELSE IF @MemberType_ID = @MemberType_Consolidated  
        BEGIN  
            EXEC mdm.udpEntityStagingCreateConsolidatedStoredProcedure @Entity_ID  
        END -- IF  
  
        -- Send the message  
	    EXEC mdm.udpPerformanceQueueSave;  
  
        RETURN(0);  
  
    END TRY  
    --Compensate as necessary  
    BEGIN CATCH  
  
        -- Get error info.  
        DECLARE  
            @ErrorMessage NVARCHAR(4000),  
            @ErrorSeverity INT,  
            @ErrorState INT,  
            @ErrorNumber INT,  
            @ErrorLine INT,  
            @ErrorProcedure NVARCHAR(126);  
        EXEC mdm.udpGetErrorInfo  
            @ErrorMessage = @ErrorMessage OUTPUT,  
            @ErrorSeverity = @ErrorSeverity OUTPUT,  
            @ErrorState = @ErrorState OUTPUT,  
            @ErrorNumber = @ErrorNumber OUTPUT,  
            @ErrorLine = @ErrorLine OUTPUT,  
            @ErrorProcedure = @ErrorProcedure OUTPUT  
  
        SET @ErrorMessage = CONCAT(@ErrorMessage, N', @ErrorNumber = ', @ErrorNumber, N', @ErrorProcedure = "', @ErrorProcedure, N'", line ', @ErrorLine);  
  
        IF @TranCommitted = 0 -- Don't rollback when the transaction has been committed.  
        BEGIN  
            IF @TranCounter = 0 ROLLBACK TRANSACTION;  
            ELSE IF XACT_STATE() <> -1 ROLLBACK TRANSACTION TX;  
        END; -- IF  
  
        RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);  
  
        --On error, return NULL results  
        --SELECT @Return_ID = NULL;  
        RETURN(1);  
  
    END CATCH;  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpAttributeGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpAttributeGet]  
(  
     @User_ID       INT  
  
    ,@Model_MUID    UNIQUEIDENTIFIER = NULL  
    ,@Model_Name    NVARCHAR(50) = NULL  
    ,@Model_ID      INT = NULL -- set internally only  
  
    ,@Entity_MUID   UNIQUEIDENTIFIER = NULL  
    ,@Entity_Name   NVARCHAR(50) = NULL  
    ,@Entity_ID     INT = NULL -- set internally only  
  
    ,@MemberType_ID TINYINT = NULL  
  
    ,@AttributeGroup_MUID   UNIQUEIDENTIFIER = NULL  
    ,@AttributeGroup_Name   NVARCHAR(50) = NULL  
    ,@AttributeGroup_ID     INT = NULL -- set internally only  
  
    ,@Attribute_MUID    UNIQUEIDENTIFIER = NULL  
    ,@Attribute_Name    NVARCHAR(100) = NULL  
  
    ,@IncludeParentIdentifiers BIT = 1 -- Return results sets for parent Model and Entity identifiers. Set to 0 when getting attributes as part of a parent object (because the parent identifiers will already have been looked up).  
  
    ,@AttributeIds      mdm.IdList READONLY  
  
    ,@Debug                     BIT = 0  
    ,@CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
  
    SET NOCOUNT ON  
  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), ': begin udpAttributeGet, @Model_ID = ', @Model_ID, N', @Entity_ID = ', @Entity_ID, N', @MemberType_ID = ', @MemberType_ID, N', @AttributeGroup_ID = ', @AttributeGroup_ID, N', @Attribute_Name = ', @Attribute_Name)  
    -- Get model ID  
    IF @Model_ID IS NULL -- If the ID was already provided, don't bother looking it up again  
        AND (@Model_Name IS NOT NULL OR @Model_MUID IS NOT NULL)  
    BEGIN  
        IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), ': lookup @Model_ID')  
        SELECT   
             @Model_ID = ID  
            ,@Model_MUID = MUID  
            ,@Model_Name = Name  
        FROM mdm.tblModel  
        WHERE   MUID = ISNULL(@Model_MUID, MUID)  
            AND Name = ISNULL(@Model_Name, Name)  
  
        SET @Model_ID = COALESCE(@Model_ID, 0)  
    END  
  
    -- Get entity ID  
    IF @Entity_ID IS NULL -- If the ID was already provided, don't bother looking it up again  
        AND (@Entity_Name IS NOT NULL OR @Entity_MUID IS NOT NULL)  
    BEGIN  
        IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), ': lookup @Entity_ID')  
        SELECT  
             @Model_ID = Model_ID  
            ,@Entity_ID = ID  
            ,@Entity_MUID = MUID  
            ,@Entity_Name = Name  
        FROM mdm.tblEntity  
        WHERE   MUID = ISNULL(@Entity_MUID, MUID)  
            AND Name = ISNULL(@Entity_Name, Name)  
            AND Model_ID = ISNULL(@Model_ID, Model_ID) -- If a model filter is specified, use it  
  
        SET @Entity_ID = COALESCE(@Entity_ID, 0)  
    END  
  
    -- Get attribute group ID  
    IF @AttributeGroup_ID IS NULL -- If the ID was already provided, don't bother looking it up again  
        AND (@AttributeGroup_Name IS NOT NULL OR @AttributeGroup_MUID IS NOT NULL)  
    BEGIN  
        IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), ': lookup @AttributeGroup_ID')  
        SELECT @AttributeGroup_ID = ID  
        FROM mdm.tblAttributeGroup  
        WHERE   MUID = ISNULL(@AttributeGroup_MUID, MUID)  
            AND Name = ISNULL(@AttributeGroup_Name, Name)  
            AND MemberType_ID = ISNULL(@MemberType_ID, MemberType_ID)  
            AND Entity_ID = ISNULL(@Entity_ID, Entity_ID) -- If an entity filter is specified, use it  
  
        SET @AttributeGroup_ID = COALESCE(@AttributeGroup_ID, 0)  
    END  
  
    -- Get attribute ID  
    DECLARE @Attribute_ID INT = NULL;  
    IF @Attribute_Name IS NOT NULL OR @Attribute_MUID IS NOT NULL  
    BEGIN  
        IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), ': lookup @Attribute_ID')  
        SELECT @Attribute_ID = ID  
        FROM mdm.tblAttribute  
        WHERE   MUID = ISNULL(@Attribute_MUID, MUID)  
            AND Name = ISNULL(@Attribute_Name, Name)              
            AND MemberType_ID = ISNULL(@MemberType_ID, MemberType_ID)  
            AND Entity_ID = ISNULL(@Entity_ID, Entity_ID) -- If an entity filter is specified, use it  
  
        SET @Attribute_ID = COALESCE(@Attribute_ID, 0)  
    END  
  
    DECLARE @SelectedAttribute TABLE   
    (  
         ID                 INT PRIMARY KEY  
        ,Entity_ID          INT  
        ,Privilege_ID       TINYINT  
        ,AccessPermission   TINYINT  
    )  
  
    IF @AttributeGroup_ID IS NOT NULL  
    BEGIN  
        IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), ': caller has specified an AttributeGroup, using it to get selected attributes')  
        -- Get all attributes under the specified attribute group  
        INSERT INTO @SelectedAttribute  
        SELECT  
             a.ID  
            ,a.Entity_ID  
            ,acl.Privilege_ID  
            ,acl.AccessPermission  
        FROM mdm.tblAttribute a  
        INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_ATTRIBUTE acl  
        ON a.ID = acl.ID  
        INNER JOIN mdm.tblAttributeGroupDetail agd  
        ON      a.ID = agd.Attribute_ID  
        WHERE   acl.User_ID = @User_ID  
            AND a.AttributeType_ID <> 3 -- System (except Name and Code)  
            AND agd.AttributeGroup_ID = @AttributeGroup_ID  
            AND a.ID = ISNULL(@Attribute_ID, a.ID)  
    END ELSE  
    BEGIN  
        IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), ': getting selected attributes from criteria')  
        INSERT INTO @SelectedAttribute  
        SELECT  
             a.Attribute_ID AS ID  
            ,a.Entity_ID  
            ,acl.Privilege_ID  
            ,acl.AccessPermission  
        FROM mdm.viw_SYSTEM_SCHEMA_ATTRIBUTES a  
        INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_ATTRIBUTE acl  
        ON a.Attribute_ID = acl.ID  
        WHERE   acl.User_ID = @User_ID  
            AND a.Attribute_Type_ID <> 3 -- System (except Name and Code)  
            AND a.Model_ID = ISNULL(@Model_ID, a.Model_ID)  
            AND a.Entity_ID = ISNULL(@Entity_ID, a.Entity_ID)  
            AND a.Attribute_MemberType_ID = ISNULL(@MemberType_ID, a.Attribute_MemberType_ID)  
            AND a.Attribute_ID = ISNULL(@Attribute_ID, a.Attribute_ID)  
    END  
  
    IF EXISTS (SELECT 1 FROM @AttributeIds)  
    BEGIN  
        -- The caller has specified which attributes to return in a temp table  
        IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), ': caller has defined #Attribute, using it to further filter selected attributes')  
  
        DELETE sa  
        FROM @SelectedAttribute sa  
        LEFT JOIN @AttributeIds a  
        ON sa.ID = a.ID  
        WHERE a.ID IS NULL  
    END  
  
    IF @IncludeParentIdentifiers = 1  
    BEGIN  
        IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), ': returning parent identifiers')  
        -- Return model Identifier(s)  
        IF @Model_ID IS NOT NULL  
        BEGIN  
            IF @Model_Name IS NULL OR @Model_MUID IS NULL  
            BEGIN  
                SELECT   
                     @Model_MUID = MUID  
                    ,@Model_Name = Name  
                FROM mdm.tblModel  
                WHERE ID = @Model_ID  
            END  
  
            -- A single model was specified, and its info has already been looked up, so simply return it  
            SELECT   
                 @Model_MUID    AS Model_MUID  
                ,@Model_Name    AS Model_Name  
                ,@Model_ID      AS Model_ID  
        END ELSE  
        BEGIN  
            SELECT DISTINCT  
                 m.MUID AS Model_MUID  
                ,m.Name AS Model_Name  
                ,m.ID   AS Model_ID  
            FROM @SelectedAttribute a  
            INNER JOIN mdm.tblEntity e  
            ON a.Entity_ID = e.ID  
            INNER JOIN mdm.tblModel m  
            ON e.Model_ID = m.ID  
        END  
  
        -- Return entity Identifier(s)  
        IF @Entity_ID IS NOT NULL  
        BEGIN  
            -- A single entity was specified, and its info has already been looked up, so simply return it  
            SELECT   
                 @Model_ID      AS Model_ID  
                ,@Entity_MUID   AS Entity_MUID  
                ,@Entity_Name   AS Entity_Name  
                ,@Entity_ID     AS Entity_ID  
        END ELSE  
        BEGIN  
            SELECT DISTINCT  
                 e.Model_ID AS Model_ID  
                ,e.MUID AS Entity_MUID  
                ,e.Name AS Entity_Name  
                ,e.ID   AS Entity_ID  
            FROM @SelectedAttribute a  
            INNER JOIN mdm.tblEntity e  
            ON a.Entity_ID = e.ID  
        END  
    END  
  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), ': returning attribute info')  
    SELECT  
         a.Attribute_MUID  
        ,a.Attribute_Name  
        ,a.Attribute_ID  
        ,sa.Privilege_ID  
        ,sa.AccessPermission  
  
        ,a.Attribute_MemberType_ID AS MemberType_ID  
  
        ,a.Entity_ID  
  
        ,a.Attribute_Type_ID                AS AttributeType_ID  
        ,a.Attribute_ChangeTrackingGroup    AS ChangeTrackingGroup  
        ,a.Attribute_DataType_ID            AS DataType_ID  
        ,a.Attribute_DataType_Information   AS DataTypeInformation  
        ,a.Attribute_Description            AS Description  
        ,a.Attribute_DisplayName            AS DisplayName  
        ,a.Attribute_DisplayWidth           AS DisplayWidth  
  
        ,NULLIF(a.Attribute_DBAEntity_MUID, 0x0)    AS DomainEntity_MUID  
        ,NULLIF(a.Attribute_DBAEntity_Name, N'')    AS DomainEntity_Name  
        ,NULLIF(a.Attribute_DBAEntity_ID, 0)        AS DomainEntity_ID  
        ,CONVERT(BIT, a.Attribute_DBAEntity_IsHierarchyEnabled)         AS DomainEntity_IsHierarchyEnabled  
        ,CONVERT(TINYINT, COALESCE(DBAMemberTypeSec.Privilege_ID, 0))   AS DomainEntity_Privilege_ID  
        ,CONVERT(TINYINT, DBAMemberTypeSec.AccessPermission)            AS DomainEntity_AccessPermission -- We use memberType leaf effective permission instead of entity effective permission  
  
        ,NULLIF(a.FilterParentHierarchy_MUID, 0x0)  AS FilterParentHierarchy_MUID  
        ,NULLIF(a.FilterParentHierarchy_Name, N'')  AS FilterParentHierarchy_Name  
        ,NULLIF(a.FilterParentHierarchy_ID, 0)      AS FilterParentHierarchy_ID  
        ,NULLIF(a.FilterParentHierarchy_LevelNumber, -1)    AS FilterParentHierarchy_LevelNumber  
        ,NULLIF(a.FilterParentAttribute_MUID, 0x0)  AS FilterParentAttribute_MUID  
        ,NULLIF(a.FilterParentAttribute_Name, N'')  AS FilterParentAttribute_Name  
        ,NULLIF(a.FilterParentAttribute_ID, 0)      AS FilterParentAttribute_ID  
  
        ,a.Attribute_DataMask_Name      AS InputMask_Name  
        ,a.Attribute_DataMask_ID        AS InputMask_ID  
        ,a.Attribute_IsReadOnly         AS IsReadOnly -- Always 0? Except for LevelNumber (MemberType 4)  
        ,a.Attribute_IsSystem           AS IsSystem  
        ,a.Attribute_SortOrder          AS SortOrder  
  
        ,a.EnteredUser_DTM  
        ,a.EnteredUser_MUID  
        ,a.EnteredUser_UserName  
        ,a.EnteredUser_ID  
        ,a.LastChgUser_DTM  
        ,a.LastChgUser_MUID  
        ,a.LastChgUser_UserName  
        ,a.LastChgUser_ID  
    FROM @SelectedAttribute sa  
    INNER JOIN mdm.viw_SYSTEM_SCHEMA_ATTRIBUTES a  
    ON sa.ID = a.Attribute_ID  
    LEFT JOIN mdm.viw_SYSTEM_SECURITY_USER_MEMBERTYPE DBAMemberTypeSec  
    ON      a.Attribute_DBAEntity_ID = DBAMemberTypeSec.Entity_ID   
        AND DBAMemberTypeSec.ID = 1 -- DBA always reference leaf  
        AND DBAMemberTypeSec.User_ID = @User_ID  
    ORDER BY   
         a.Model_ID  
        ,a.Entity_ID  
        ,a.Attribute_MemberType_ID  
        ,a.Attribute_SortOrder  
        ,a.Attribute_ID  
  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), ': end udpAttributeGet')  
  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpAttributeGroupDelete]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    EXEC mdm.udpAttributeGroupDelete null,1;  
    SELECT * FROM mdm.tblAttributeGroup;  
*/  
CREATE PROCEDURE [mdm].[udpAttributeGroupDelete]  
(  
    @ID		    INT = NULL,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON;  
  
    --Start transaction, being careful to check if we are nested  
    DECLARE @TranCounter INT;   
    DECLARE	@Object_ID	INT;  
    DECLARE @AttributeGroupMUID UNIQUEIDENTIFIER;  
      
    IF @ID IS NULL RETURN;  
    SELECT  @AttributeGroupMUID = MUID FROM mdm.tblAttributeGroup WHERE ID = @ID;  
    IF @AttributeGroupMUID IS NULL RETURN;  
  
    SET @TranCounter = @@TRANCOUNT;  
    IF @TranCounter > 0 SAVE TRANSACTION TX;  
    ELSE BEGIN TRANSACTION;  
  
    BEGIN TRY  
  
        SELECT @Object_ID = ID FROM mdm.tblSecurityObject WHERE Code = N'ATTGRP'  
  
        DELETE FROM mdm.tblAttributeGroupDetail WHERE AttributeGroup_ID = @ID;  
  
        EXEC mdm.udpSecurityPrivilegesDelete NULL, NULL, @Object_ID, @ID;  
  
        DELETE FROM mdm.tblAttributeGroup WHERE ID = @ID;  
  
        --Commit only if we are not nested  
        IF @TranCounter = 0 COMMIT TRANSACTION;  
        RETURN(0);  
  
    END TRY  
    --Compensate as necessary  
    BEGIN CATCH  
  
        -- Get error info.  
        DECLARE  
            @ErrorMessage NVARCHAR(4000),  
            @ErrorSeverity INT,  
            @ErrorState INT,  
            @ErrorNumber INT,  
            @ErrorLine INT,  
            @ErrorProcedure NVARCHAR(126);  
        EXEC mdm.udpGetErrorInfo  
            @ErrorMessage = @ErrorMessage OUTPUT,  
            @ErrorSeverity = @ErrorSeverity OUTPUT,  
            @ErrorState = @ErrorState OUTPUT,  
            @ErrorNumber = @ErrorNumber OUTPUT,  
            @ErrorLine = @ErrorLine OUTPUT,  
            @ErrorProcedure = @ErrorProcedure OUTPUT  
  
        SET @ErrorMessage = CONCAT(@ErrorMessage, N', @ErrorNumber = ', @ErrorNumber, N', @ErrorProcedure = "', @ErrorProcedure, N'", line ', @ErrorLine);  
  
        IF @TranCounter = 0 ROLLBACK TRANSACTION;  
        ELSE IF XACT_STATE() <> -1 ROLLBACK TRANSACTION TX;  
  
        RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);		  
  
        --On error, return NULL results  
        --SELECT @Return_ID = NULL;  
        RETURN(1);  
  
    END CATCH;  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpAttributeGroupDetailDelete]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    EXEC mdm.udpAttributeGroupDetailDelete 1,1,1;  
    SELECT * FROM mdm.tblAttributeGroupDetail;  
*/  
CREATE PROCEDURE [mdm].[udpAttributeGroupDetailDelete]  
(  
   @User_ID                INT,  
   @AttributeGroup_ID      INT,  
   @Type_ID                INT, --Attributes = 1,Users = 2,UserGroups = 3  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE @TempModel_ID        INT,  
            @TempEntity_ID        INT,  
            @TempMemberType_ID    TINYINT,  
            @TempVersion_ID        INT;  
  
    --Get Entity  
    SELECT @TempEntity_ID = Entity_ID, @TempMemberType_ID = MemberType_ID   
    FROM mdm.tblAttributeGroup   
    WHERE ID = @AttributeGroup_ID;  
  
    --Get MemberType_ID and latest Version  
    SELECT   
        @TempModel_ID = e.Model_ID,  
        @TempVersion_ID = MAX(mv.ID)   
    FROM mdm.tblModelVersion AS mv  
    INNER JOIN mdm.tblEntity AS e ON (mv.Model_ID = e.Model_ID)  
    WHERE e.ID = @TempEntity_ID  
    GROUP BY e.Model_ID;  
  
    IF @Type_ID = 1 BEGIN --Attributes  
  
        DELETE FROM mdm.tblAttributeGroupDetail   
        WHERE AttributeGroup_ID = @AttributeGroup_ID;  
  
    END ELSE IF @Type_ID = 2 BEGIN --Users  
  
        EXEC mdm.udpSecurityPrivilegesDelete NULL, 1, 5, @AttributeGroup_ID;  
  
    END ELSE IF @Type_ID = 3 BEGIN --User Groups  
  
        EXEC mdm.udpSecurityPrivilegesDelete NULL, 2, 5, @AttributeGroup_ID;  
  
    END; --if  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpAttributeGroupDetailSave]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
    EXEC mdm.udpAttributeGroupDetailSave @User_ID = 1, @ModelName = N'Product', @EntityName = N'Product', @MemberType_ID = 1, @AttributeGroupName = N'System', @Name = N'SourceKey';  
    SELECT * FROM mdm.tblAttributeGroupDetail;  
*/  
CREATE PROCEDURE [mdm].[udpAttributeGroupDetailSave]  
(  
    @User_ID            INT,  
    @Version_ID         INT = NULL, -- used for audit info. When NULL, the highest value for the model will be used  
    @AttributeGroup_ID  INT, -- Caller should validate  
    @Attribute_ID       INT, -- Caller should validate  
    @Return_ID          INT = NULL OUTPUT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON;  
  
    --Raise an error if we are missing the attribute group ID  
    IF @AttributeGroup_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR110007|The ID is not valid.', 16, 1);  
        RETURN;  
    END;  
  
    --Raise an error if we are missing the attribute ID  
    IF @Attribute_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR110007|The ID is not valid.', 16, 1);  
        RETURN;  
    END;      
  
    IF @Version_ID IS NULL  
    BEGIN  
        SELECT @Version_ID = MAX(mv.ID)   
        FROM mdm.tblModelVersion mv  
        INNER JOIN mdm.tblEntity e  
        ON mv.Model_ID = e.Model_ID  
        INNER JOIN mdm.tblAttributeGroup ag  
        ON e.ID = ag.Entity_ID  
        WHERE ag.ID = @AttributeGroup_ID  
    END  
  
    INSERT INTO mdm.tblAttributeGroupDetail  
    (  
        AttributeGroup_ID,  
        Attribute_ID,  
        SortOrder,  
        EnterDTM,  
        EnterUserID,  
        EnterVersionID,  
        LastChgDTM,  
        LastChgUserID,  
        LastChgVersionID  
    )  
    SELECT  
        @AttributeGroup_ID,  
        @Attribute_ID,  
        ISNULL(MAX(SortOrder),0) + 1,  
        GETUTCDATE(),  
        @User_ID,  
        @Version_ID,  
        GETUTCDATE(),  
        @User_ID,  
        @Version_ID  
    FROM mdm.tblAttributeGroupDetail  
    WHERE AttributeGroup_ID = @AttributeGroup_ID;  
  
    SET @Return_ID = SCOPE_IDENTITY();  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpAttributeGroupGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpAttributeGroupGet]  
(  
     @User_ID       INT  
  
    ,@Model_MUID    UNIQUEIDENTIFIER = NULL  
    ,@Model_Name    NVARCHAR(50) = NULL  
    ,@Model_ID      INT = NULL -- set internally only  
  
    ,@Entity_MUID   UNIQUEIDENTIFIER = NULL  
    ,@Entity_Name   NVARCHAR(50) = NULL  
    ,@Entity_ID     INT = NULL -- set internally only  
  
    ,@MemberType_ID TINYINT = NULL  
  
    ,@AttributeGroup_MUID   UNIQUEIDENTIFIER = NULL  
    ,@AttributeGroup_Name   NVARCHAR(50) = NULL  
  
    -- Only used when getting details  
    ,@Attribute_MUID   UNIQUEIDENTIFIER = NULL  
    ,@Attribute_Name   NVARCHAR(100) = NULL  
  
    ,@ResultOption TINYINT -- None = 0, Identifiers = 1, Details = 2.   
  
    ,@IncludeParentIdentifiers  BIT = 1 -- Return results sets for parent Model and Entity identifiers. Set to 0 when getting explicit hierarchies as part of a parent object (because the parent identifiers will already have been looked up).  
    ,@OmitAttributes            BIT = 0 -- When 1, a result set is not returned for attributes. This should be set to 1 when the caller will return Attributes. Ignored when @ResultOption is not Details.  
    ,@Debug                     BIT = 0  
    ,@CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
  
    SET NOCOUNT ON  
  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), ': begin udpAttributeGroupGet')  
  
    DECLARE   
         @ResultOption_Identifiers  TINYINT = 1  
        ,@ResultOption_Details      TINYINT = 2  
  
    -- Get model ID  
    IF @Model_ID IS NULL -- If the ID was already provided, don't bother looking it up again  
        AND (@Model_Name IS NOT NULL OR @Model_MUID IS NOT NULL)  
    BEGIN  
        SELECT   
             @Model_ID = ID  
            ,@Model_MUID = MUID  
            ,@Model_Name = Name  
        FROM mdm.tblModel  
        WHERE   MUID = ISNULL(@Model_MUID, MUID)  
            AND Name = ISNULL(@Model_Name, Name)  
  
        SET @Model_ID = COALESCE(@Model_ID, 0)  
    END  
  
    -- Get entity ID  
    IF @Entity_ID IS NULL -- If the ID was already provided, don't bother looking it up again  
        AND (@Entity_Name IS NOT NULL OR @Entity_MUID IS NOT NULL)  
    BEGIN  
        SELECT  
             @Model_ID = Model_ID  
            ,@Entity_ID = ID  
            ,@Entity_MUID = MUID  
            ,@Entity_Name = Name  
        FROM mdm.tblEntity  
        WHERE   MUID = ISNULL(@Entity_MUID, MUID)  
            AND Name = ISNULL(@Entity_Name, Name)  
            AND Model_ID = ISNULL(@Model_ID, Model_ID) -- If a model filter is specified, use it  
  
        SET @Entity_ID = COALESCE(@Entity_ID, 0)  
    END  
  
    -- Get index ID  
    DECLARE @AttributeGroup_ID INT = NULL;  
    IF @AttributeGroup_Name IS NOT NULL OR @AttributeGroup_MUID IS NOT NULL  
    BEGIN  
        SELECT @AttributeGroup_ID = ID  
        FROM mdm.tblAttributeGroup  
        WHERE   MUID = ISNULL(@AttributeGroup_MUID, MUID)  
            AND Name = ISNULL(@AttributeGroup_Name, Name)  
            AND MemberType_ID = ISNULL(@MemberType_ID, MemberType_ID)  
            AND Entity_ID = ISNULL(@Entity_ID, Entity_ID) -- If an entity filter is specified, use it  
  
        SET @AttributeGroup_ID = COALESCE(@AttributeGroup_ID, 0)  
    END  
  
    DECLARE @SelectedAttributeGroup TABLE   
    (  
         ID                 INT PRIMARY KEY  
        ,Entity_ID          INT  
        ,Model_ID           INT  
        ,Privilege_ID       TINYINT  
        ,AccessPermission   TINYINT  
    )  
  
    INSERT INTO @SelectedAttributeGroup  
    SELECT  
         ag.ID  
        ,ag.Entity_ID  
        ,ag.Model_ID  
        ,acl.Privilege_ID  
        ,acl.AccessPermission  
    FROM mdm.viw_SYSTEM_SCHEMA_ATTRIBUTEGROUPS ag  
    INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_ATTRIBUTEGROUP acl  
    ON acl.ID = ag.ID   
    WHERE   acl.User_ID = @User_ID  
        AND ag.Model_ID = ISNULL(@Model_ID, ag.Model_ID)  
        AND ag.Entity_ID = ISNULL(@Entity_ID, ag.Entity_ID)  
        AND ag.MemberType_ID = ISNULL(@MemberType_ID, ag.MemberType_ID)  
        AND ag.ID = ISNULL(@AttributeGroup_ID, ag.ID)  
  
    IF @IncludeParentIdentifiers = 1  
    BEGIN  
        -- Return model Identifier(s)  
        IF @Model_ID IS NOT NULL  
        BEGIN  
            IF @Model_Name IS NULL OR @Model_MUID IS NULL  
            BEGIN  
                SELECT   
                     @Model_MUID = MUID  
                    ,@Model_Name = Name  
                FROM mdm.tblModel  
                WHERE ID = @Model_ID  
            END  
  
            -- A single model was specified, and its info has already been looked up, so simply return it  
            SELECT   
                 @Model_MUID    AS Model_MUID  
                ,@Model_Name    AS Model_Name  
                ,@Model_ID      AS Model_ID  
        END ELSE  
        BEGIN  
            SELECT DISTINCT  
                 m.MUID AS Model_MUID  
                ,m.Name AS Model_Name  
                ,m.ID   AS Model_ID  
            FROM @SelectedAttributeGroup ag  
            INNER JOIN mdm.tblEntity e  
            ON ag.Entity_ID = e.ID  
            INNER JOIN mdm.tblModel m  
            ON e.Model_ID = m.ID  
        END  
  
        -- Return entity Identifier(s)  
        IF @Entity_ID IS NOT NULL  
        BEGIN  
            -- A single entity was specified, and its info has already been looked up, so simply return it  
            SELECT   
                 @Model_ID      AS Model_ID  
                ,@Entity_MUID   AS Entity_MUID  
                ,@Entity_Name   AS Entity_Name  
                ,@Entity_ID     AS Entity_ID  
        END ELSE  
        BEGIN  
            SELECT DISTINCT  
                 e.Model_ID AS Model_ID  
                ,e.MUID AS Entity_MUID  
                ,e.Name AS Entity_Name  
                ,e.ID   AS Entity_ID  
            FROM @SelectedAttributeGroup ag  
            INNER JOIN mdm.tblEntity e  
            ON ag.Entity_ID = e.ID  
        END  
    END  
  
  
    SELECT  
         ag.MUID    AS AttributeGroup_MUID  
        ,ag.Name    AS AttributeGroup_Name  
        ,ag.ID      AS AttributeGroup_ID  
        ,sag.Privilege_ID  
        ,sag.AccessPermission  
  
        ,ag.Entity_ID  
        ,ag.MemberType_ID  
  
        ,ag.IsNameCodeFrozen   
        ,ag.SortOrder  
  
        ,ag.EnteredUser_DTM  
        ,ag.EnteredUser_MUID  
        ,ag.EnteredUser_UserName  
        ,ag.EnteredUser_ID  
        ,ag.LastChgUser_DTM  
        ,ag.LastChgUser_MUID  
        ,ag.LastChgUser_UserName  
        ,ag.LastChgUser_ID  
    FROM @SelectedAttributeGroup sag  
    INNER JOIN mdm.viw_SYSTEM_SCHEMA_ATTRIBUTEGROUPS ag  
    ON sag.ID = ag.ID  
    ORDER BY ag.Model_ID, sag.Entity_ID, ag.MemberType_ID, ag.SortOrder  
  
    IF @ResultOption = @ResultOption_Details  
    BEGIN  
  
        -- return index-to-attribute mapping  
        DECLARE @AttributeGroupToAttribute TABLE  
        (   
             AttributeGroup_ID  INT NOT NULL  
            ,Attribute_ID       INT NOT NULL  
            ,SortOrder          INT NOT NULL  
        );  
  
        INSERT INTO @AttributeGroupToAttribute  
        SELECT  
             ag.ID AS AttributeGroup_ID  
            ,agd.Attribute_ID  
            ,agd.SortOrder  
        FROM @SelectedAttributeGroup ag  
        INNER JOIN mdm.tblAttributeGroupDetail agd  
        ON ag.ID = agd.AttributeGroup_ID  
  
        -- Note: this many include attributes to which the user does not have permission, because we don't want to repeat  
        -- the expensive attribute permission check here. Caller must ignore any rows that don't have a match in the   
        -- permission-checked Attributes result set  
        SELECT  
             AttributeGroup_ID  
            ,Attribute_ID  
        FROM @AttributeGroupToAttribute  
        ORDER BY AttributeGroup_ID, SortOrder  
  
  
        -- Return attributes (unless omitted)  
        IF COALESCE(@OmitAttributes, 1) = 0  
        BEGIN  
            DECLARE @AttributeIds mdm.IdList;  
            INSERT INTO @AttributeIds (ID)  
            SELECT DISTINCT Attribute_ID  
            FROM @AttributeGroupToAttribute  
  
            EXEC mdm.udpAttributeGet  
                 @User_ID = @User_ID  
                ,@Model_ID = @Model_ID  
                ,@Entity_ID = @Entity_ID  
                ,@MemberType_ID = @MemberType_ID  
                ,@AttributeGroup_ID = @AttributeGroup_ID  
                ,@Attribute_MUID = @Attribute_MUID  
                ,@Attribute_Name = @Attribute_Name  
                ,@IncludeParentIdentifiers = 0 -- parent Ids already returned  
                ,@AttributeIds = @AttributeIds  
                ,@Debug = @Debug  
                ,@CorrelationID = @CorrelationID  
        END  
  
    END   
  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), ': end udpAttributeGroupGet')  
  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpAttributeGroupSave]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
Saves (creates or updates) an AttributeGroup  
  
*/  
CREATE PROCEDURE [mdm].[udpAttributeGroupSave]  
(  
    @User_ID            INT,  
    @Version_ID         INT, -- Caller should validate. Used for audit info.  
    @Model_ID           INT, -- Caller should validate  
    @Entity_ID          INT, -- Caller should validate  
    @IsHierarchyEnabled     BIT,  
    @IsCollectionEnabled    BIT,  
    @DataCompression        TINYINT,  
    @MemberType_ID      TINYINT = NULL,  
    @MUID               UNIQUEIDENTIFIER = NULL,  
    @Name               NVARCHAR(50),  
    @SortOrder          INT = NULL,  
    @FreezeNameCode     BIT = 0,  
    @IsSystem           BIT = 0,  
    @EditMode           TINYINT = 0, --0: Create, 1: Update, 4: Clone, defaults to Create  
    @Return_ID          INT = NULL OUTPUT,  
    @Return_MUID        UNIQUEIDENTIFIER = NULL OUTPUT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON;  
  
    SET @Return_ID = NULL;  
    SET @Return_MUID = NULL;  
  
  
    DECLARE @CurrentDTM             AS DATETIME2(3),  
            @GuidEmpty              UNIQUEIDENTIFIER = CAST(0x0 AS UNIQUEIDENTIFIER),  
            @EditMode_Create        TINYINT = 0,  
            @EditMode_Update        TINYINT = 1,  
            @EditMode_Clone         TINYINT = 4,  
            @ExistingAttributeGroup_MUID UNIQUEIDENTIFIER = NULL,  
            @ExistingAttributeGroup_ID   INT = NULL,  
            @ExistingAttributeGroupName  NVARCHAR(MAX),  
  
            @MemberType_Leaf           TINYINT = 1,  
            @MemberType_Consolidated   TINYINT = 2,  
            @MemberType_Collection     TINYINT = 3,  
  
            @TableOptions           NVARCHAR(MAX) = N'',  
            @IndexOptions           NVARCHAR(MAX) = N'';  
  
    --Initialize output parameters and local variables  
    SELECT  
        @Name = NULLIF(LTRIM(RTRIM(@Name)), N''), --Convert empty @Name to NULL  
        @FreezeNameCode = ISNULL(@FreezeNameCode, 0), --Convert NULL @FreezeNameCode to 0  
        @IsSystem = ISNULL(@IsSystem, 0), --Convert NULL @IsSystem to 0  
        @Return_ID = NULL,  
        @CurrentDTM = GETUTCDATE(),  
        @Entity_ID = NULLIF(@Entity_ID, 0),  
        @MUID = NULLIF(@MUID, @GuidEmpty),  
        @Name = NULLIF(LTRIM(RTRIM(@Name)), N'');  
  
    BEGIN TRY  
  
        -- When creating collection member attributes, ensure the collection tables have been created.  
        IF @MemberType_ID = @MemberType_Collection AND @IsCollectionEnabled = 0  
        BEGIN  
            DECLARE @TableName SYSNAME;  
            SET @TableOptions = mdm.udfGetTableOptions(@DataCompression, @Model_ID);  
            SET @IndexOptions = mdm.udfGetIndexOptions(@DataCompression, @Model_ID);  
  
            EXEC mdm.udpCollectionTablesCreate @User_ID, @Model_ID, @Version_ID, @Entity_ID, @IsHierarchyEnabled, @TableOptions, @IndexOptions, @TableName OUTPUT;  
            SET @IsCollectionEnabled = 1;  
        END; --if  
  
        --If we are in the Update or Clone mode get the missing pieces of the identifier  
        IF @EditMode IN (@EditMode_Update, @EditMode_Clone)  
        BEGIN  
            --Only use the name if the MUID is not available. This is important because we don't want  
            --to look up by name if the name is what the user is trying to update.  
            IF @MUID IS NULL  
            BEGIN  
                SELECT TOP 1  
                    @ExistingAttributeGroup_ID =  ID,  
                    @ExistingAttributeGroup_MUID = MUID,  
                    @ExistingAttributeGroupName = Name  
                FROM mdm.tblAttributeGroup  
                WHERE  
                    --Filter by member type too  
                    MemberType_ID = @MemberType_ID AND  
                    [Name] = @Name AND  
                    Entity_ID = @Entity_ID;  
            END  
            --Use the Attribute group MUID to look up the full identifier  
            ELSE  
            BEGIN  
                SELECT  
                    @ExistingAttributeGroup_ID =  ID,  
                    @ExistingAttributeGroup_MUID = MUID,  
                    @ExistingAttributeGroupName = Name  
                FROM mdm.tblAttributeGroup  
                WHERE  
                    MemberType_ID = @MemberType_ID AND  
                    MUID = @MUID AND  
                    Entity_ID = @Entity_ID;  
            END  
  
            --If we are in the Clone mode we need to figure out whether we are creating or updating an attribute group  
            IF @EditMode = @EditMode_Clone  
            BEGIN  
                --If there is no existing attribute group then set the edit mode to Create  
                IF @ExistingAttributeGroup_MUID IS NULL AND @ExistingAttributeGroup_ID IS NULL  
                BEGIN  
                    SET @EditMode = @EditMode_Create;  
                END  
                --If there is an existing attribute group then set the edit mode to Update  
                ELSE  
                BEGIN  
                    SET @EditMode = @EditMode_Update;  
                    SET @MUID = @ExistingAttributeGroup_MUID;  
                END  
            END  
            --If we are in Update mode and could not find a matching existing attribute group we need to raise an error and quit now  
            ELSE IF @EditMode = @EditMode_Update  
            BEGIN  
                IF @ExistingAttributeGroup_ID IS NULL OR @ExistingAttributeGroup_MUID IS NULL  
                BEGIN  
                    --On error, return NULL results  
                    SELECT @Return_ID = NULL, @Return_MUID = NULL;  
                    RAISERROR('MDSERR110007|The ID is not valid.', 16, 1);  
                    RETURN;  
                END  
                ELSE  
                BEGIN  
                    SET @MUID = @ExistingAttributeGroup_MUID;  
                END  
            END  
        END  
  
        --If the edit mode is Create. This code also needs to execute if the user sent in EditMode clone which ended up becoming Create (hence the IF instead of ELSE IF)  
        IF @EditMode = @EditMode_Create  
        BEGIN  
  
            --If @MUID is not null then we need to ensure it does not already exist (since this is a create)  
            IF @MUID IS NOT NULL AND EXISTS(SELECT * FROM mdm.tblAttributeGroup WHERE MUID = @MUID)  
            BEGIN  
                --On error, return NULL results  
                SELECT @Return_ID = NULL, @Return_MUID = NULL;  
                RAISERROR('MDSERR110007|The ID is not valid.', 16, 1);  
                RETURN;  
            END  
        END  
  
        --Test for invalid parameters  
        IF (@Entity_ID IS NULL OR @User_ID IS NULL)  
            OR (@ExistingAttributeGroup_ID IS NULL AND (@MemberType_ID IS NULL OR @Name IS NULL OR @MemberType_ID NOT IN (@MemberType_Leaf, @MemberType_Consolidated, @MemberType_Collection))) --INSERT: Requires these params to be populated  
            OR (@ExistingAttributeGroup_ID IS NOT NULL AND @MemberType_ID IS NOT NULL AND @MemberType_ID NOT IN (@MemberType_Leaf, @MemberType_Consolidated, @MemberType_Collection)) --UPDATE: Invalid @MemberType_ID  
            OR (@SortOrder IS NOT NULL AND @SortOrder < 0) --Invalid @SortOrder  
        BEGIN  
            RAISERROR('MDSERR100010|The Parameters are not valid.', 16, 1);  
            RETURN;  
        END; --if  
  
        --Check the name of the attribute group for duplicates  
        IF EXISTS  
        (  
            SELECT 1 FROM  
            mdm.tblAttributeGroup  
            WHERE  
                @Name = Name AND  
                (@MUID IS NULL OR MUID <> @MUID) AND  
                Entity_ID = @Entity_ID AND  
                MemberType_ID = @MemberType_ID  
        )  
        BEGIN  
            --On error, return NULL resultsudpSecurityPrivilegesSave  
            SELECT @Return_ID = NULL, @Return_MUID = NULL;  
            RAISERROR('MDSERR110003|The name already exists. Type a different name.', 16, 1);  
            RETURN;  
        END  
  
        --Update/Insert Attribute Group details  
        IF @EditMode = @EditMode_Update  
        --Update Attribute Group  
        BEGIN  
            UPDATE mdm.tblAttributeGroup   
            SET  
                [Name] = ISNULL(@Name, [Name]),  
                SortOrder = ISNULL(@SortOrder, SortOrder),  
                FreezeNameCode = ISNULL(@FreezeNameCode, FreezeNameCode),  
                LastChgDTM = @CurrentDTM,  
                LastChgUserID = @User_ID  
            WHERE  
                ID = @ExistingAttributeGroup_ID;  
  
            --Populate output parameters  
            SELECT @Return_MUID = @ExistingAttributeGroup_MUID  
  
        END  
        ELSE  
        --New Attribute Group  
        BEGIN  
            --Accept an explicit MUID (for clone operations) or generate a new one  
            SET @Return_MUID = ISNULL(@MUID, NEWID());  
  
            INSERT INTO mdm.tblAttributeGroup  
            (  
                 [Entity_ID]  
                ,[MemberType_ID]  
                ,[Name]  
                ,[SortOrder]  
                ,FreezeNameCode  
                ,[IsSystem]  
                ,[MUID]  
                ,[EnterDTM]  
                ,[EnterUserID]  
                ,[EnterVersionID]  
                ,[LastChgDTM]  
                ,[LastChgUserID]  
                ,[LastChgVersionID]  
            )  
            SELECT  
                @Entity_ID,  
                @MemberType_ID,  
                @Name,  
                ISNULL(MAX(SortOrder), 0) + 1,  
                @FreezeNameCode,  
                @IsSystem,  
                @Return_MUID,  
                @CurrentDTM,  
                @User_ID,  
                @Version_ID,  
                @CurrentDTM,  
                @User_ID,  
                @Version_ID  
            FROM  
                mdm.tblAttributeGroup  
            WHERE  
                    Entity_ID = @Entity_ID  
                AND MemberType_ID = @MemberType_ID;  
  
            --Save the identity value  
            SET @ExistingAttributeGroup_ID = SCOPE_IDENTITY();  
  
            -- Allow the creating user to see the new Attribute Group  
            EXEC mdm.udpSecurityPrivilegesSave  
                @SystemUser_ID = @User_ID,  
                @Principal_ID = @User_ID,  
                @PrincipalType_ID = 1, -- User  
                @RoleAccess_ID = NULL,  
                @Object_ID = 5, --AttributeGroup,  
                @Privilege_ID = 4, -- Access  
                @AccessPermission = 7, -- all  
                @Model_ID = @Model_ID,  
                @Securable_ID = @ExistingAttributeGroup_ID,  
                @Securable_Name = @Name;  
  
        END; --if  
  
        --Return values  
        SET @Return_ID = @ExistingAttributeGroup_ID;  
        RETURN;  
  
    END TRY  
    --Compensate as necessary  
    BEGIN CATCH  
  
        -- Get error info.  
        DECLARE  
            @ErrorMessage NVARCHAR(4000),  
            @ErrorSeverity INT,  
            @ErrorState INT,  
            @ErrorNumber INT,  
            @ErrorLine INT,  
            @ErrorProcedure NVARCHAR(126);  
        EXEC mdm.udpGetErrorInfo  
            @ErrorMessage = @ErrorMessage OUTPUT,  
            @ErrorSeverity = @ErrorSeverity OUTPUT,  
            @ErrorState = @ErrorState OUTPUT,  
            @ErrorNumber = @ErrorNumber OUTPUT,  
            @ErrorLine = @ErrorLine OUTPUT,  
            @ErrorProcedure = @ErrorProcedure OUTPUT  
  
        SET @ErrorMessage = CONCAT(@ErrorMessage, N', @ErrorNumber = ', @ErrorNumber, N', @ErrorProcedure = "', @ErrorProcedure, N'", line ', @ErrorLine);  
  
        RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);  
  
        --On error, return NULL results  
        SELECT @Return_ID = NULL, @Return_MUID = NULL;  
        RETURN;  
  
    END CATCH;  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpAttributeSave]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
Creates an attribute. For efficiency, this sproc does not verify that the user is a model  
admin. This check should be done before calling the sproc.  
  
    --Create free form attribute  
    DECLARE @Return_ID INT, @Return_MUID UNIQUEIDENTIFIER, @Type INT;  
    SET @Type = 1; --SET NVARCHAR=1, DECIMAL=2, DATETIME=3  
    EXEC mdm.udpAttributeSave  
    @User_ID = 1,  
    @Entity_ID = 15,  
    @MemberType_ID = 1, --Leaf  
    @AttributeName = N'Comments 10',  
    @AttributeType_ID = 1,  
    @Description = N'Comments 10',  
    @DisplayName = N'Comments 10',  
    @DisplayWidth = 100,  
    @DataType_ID = @Type,  
    @DataTypeInformation = 0,  
    @EditMode = 0,  
    @Return_ID = @Return_ID OUTPUT,  
    @Return_MUID = @Return_MUID OUTPUT;  
    SELECT @Return_ID, @Return_MUID;  
    SELECT * FROM mdm.tblAttribute WHERE ID = @Return_ID;  
  
    --Create DBA attribute  
    DECLARE @Return_ID INT, @Return_MUID UNIQUEIDENTIFIER, @DomainEntity_ID INT;  
    SET @DomainEntity_ID = 4;  
    EXEC mdm.udpAttributeSave  
    @User_ID = 1,  
    @Entity_ID = 15,  
    @MemberType_ID = 1, --Leaf  
    @AttributeName = N'Color Attribute',  
    @AttributeType_ID = 2, --Domain  
    @Description = N'Color Attribute',  
    @DisplayName = N'Color Attribute',  
    @DisplayWidth = 100,  
    @DomainEntity_ID = @DomainEntity_ID  
    @DataTypeInformation = 0,  
    @EditMode = 0,  
    @Return_ID = @Return_ID OUTPUT,  
    @Return_MUID = @Return_MUID OUTPUT;  
    SELECT @Return_ID, @Return_MUID;  
    SELECT * FROM mdm.tblAttribute WHERE ID = @Return_ID;  
  
    --Create FILE attribute  
    DECLARE @Return_ID INT, @Return_MUID UNIQUEIDENTIFIER;  
    --SET @Return_MUID = NEWID(); SELECT @Return_MUID; --Uncomment to test clone operation  
    EXEC mdm.udpAttributeSave  
    @User_ID = 1,  
    @Entity_ID = 15,  
    @MemberType_ID = 1, --Leaf  
    @AttributeName = N'Picture',  
    @AttributeType_ID = 4, --File  
    @Description = N'Picture',  
    @DisplayName = N'Picture',  
    @DisplayWidth = 100,  
    @EditMode = 0,  
    @Return_ID = @Return_ID OUTPUT,  
    @Return_MUID = @Return_MUID OUTPUT;  
    SELECT @Return_ID, @Return_MUID;  
    SELECT * FROM mdm.tblAttribute WHERE ID = @Return_ID;  
  
    --Update name of free form attribute  
    DECLARE @Return_ID INT, @Return_MUID UNIQUEIDENTIFIER;  
    EXEC mdm.udpAttributeSave  
    @User_ID = 1,  
    @Entity_ID = 15,  
    @MemberType_ID = 1, --Leaf  
    @Attribute_ID = 10,  
    @AttributeName = N'NewName',  
    @AttributeType_ID = 1,  
    @Description = N'Comments 10',  
    @DisplayName = N'Comments 10',  
    @DisplayWidth = 100,  
    @DataType_ID = 1,  
    @DataTypeInformation = 0,  
    @EditMode = 1, --Update  
    @Return_ID = @Return_ID OUTPUT,  
    @Return_MUID = @Return_MUID OUTPUT;  
    SELECT @Return_ID, @Return_MUID;  
    SELECT * FROM mdm.tblAttribute WHERE ID = @Return_ID;  
*/  
CREATE PROCEDURE [mdm].[udpAttributeSave]  
(  
    @User_ID                INT,  
    @Model_ID               INT,-- Caller should validate  
    @Version_ID             INT = NULL,-- used for audit info. When NULL, the highest value for the model will be used  
  
    -- Entity info  
    @Entity_ID              INT, -- Caller should validate  
    @IsHierarchyEnabled     BIT,  
    @IsCollectionEnabled    BIT,  
    @DataCompression        TINYINT,  
    @TableName              SYSNAME OUTPUT,-- OUTPUT param because creating a collection attribute causes the entity to support collections  
    @StagingTableName       SYSNAME,  
  
    @MemberType_ID          TINYINT,  
    @Attribute_ID           INT = NULL,  
    @Attribute_MUID         UNIQUEIDENTIFIER = NULL,  
    @AttributeName          NVARCHAR(100),  
    @AttributeType_ID       TINYINT, --1: Freeform, 2: Domain, 3: System, 4: File  
    @Description	        NVARCHAR(500) = NULL,  
    @DisplayName            NVARCHAR(250) = NULL,  
    @DisplayWidth           INT,  
    @DomainEntity_ID        INT = NULL,  
    @FilterParentAttribute_ID INT = NULL,-- Caller should validate  
    @FilterHierarchyDetail_ID INT = NULL,-- Caller should validate  
    @DataType_ID            TINYINT = NULL,  
    @DataTypeInformation    INT = NULL,  
    @InputMask_ID           INT = NULL,-- Caller should validate  
    @ChangeTrackingGroup    INT = 0,  
    @SortOrder              INT = NULL OUTPUT,  
    @EditMode               TINYINT = 0, --0: Create, 1: Update, 4: Clone, defaults to Create  
    @IsSync                 BIT = 0,  
    @RecreateStagingProc    BIT = 1, -- In can be useful, for efficiency, to turn this off for batch metadata changes   
    @Return_DidNameChange   BIT = NULL OUTPUT,  
    @Return_ID              INT = NULL OUTPUT,  
    @Return_MUID            UNIQUEIDENTIFIER = NULL OUTPUT, --Also an input parameter for clone operations  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE   
            @SQL                    NVARCHAR(MAX),  
            @AddColumnSQL           NVARCHAR(MAX),  
            @CurrentDTM             DATETIME2(3),  
            @TableColumn            SYSNAME,  
            @IsCloneMode            BIT,  
            @ExistingSysAttr_MUID   UNIQUEIDENTIFIER,  
            @CurrentDataType_ID     INT,  
            @CurrentDataTypeInfo    INT,  
            @CurrentSortOrder       INT,  
            @HistoryTableName       SYSNAME,  
            @VersionColumnName      SYSNAME,  
            @PendingTableName       SYSNAME,  
  
            -- MemberType constants  
            @MemberTypeLeaf         TINYINT = 1,  
            @MemberTypeConsolidated TINYINT = 2,  
            @MemberTypeCollection   TINYINT = 3,  
  
            -- AttributeType constants  
            @AttributeTypeFreeform  TINYINT = 1,  
            @AttributeTypeDomain    TINYINT = 2,  
            @AttributeTypeSystem    TINYINT = 3,  
            @AttributeTypeFile      TINYINT = 4,  
  
            -- AttributeDataType constants  
            @DataTypeText           TINYINT = 1,  
            @DataTypeNumber         TINYINT = 2,  
            @DataTypeDateTime       TINYINT = 3,  
            @DataTypeLink           TINYINT = 6,  
  
            @TranCommitted          INT = 0, -- 0: Not committed, 1: Committed.  
            @PreviousAttributeName  NVARCHAR(100),  
            @IsSystem               BIT = 0,  
            @TableOptions           NVARCHAR(MAX) = N'',  
            @IndexOptions           NVARCHAR(MAX) = N'',  
  
            @GuidEmpty              UNIQUEIDENTIFIER = CAST(0x0 AS UNIQUEIDENTIFIER),  
            @EditMode_Create        TINYINT = 0,  
            @EditMode_Update        TINYINT = 1,  
            @EditMode_Clone         TINYINT = 4,  
            @ExistingAttribute_MUID UNIQUEIDENTIFIER = NULL,  
            @ExistingAttribute_ID   INT = NULL,  
            @ExistingAttributeType  TINYINT = NULL,  
            @ExistingAttributeName  NVARCHAR(MAX),  
            @ExistingFilterParentAttribute_ID INT,  
            @ExistingFilterHierarchyDetail_ID INT,  
            @Found_DomainEntity_ID  INT = NULL;  
  
    --Initialize output parameters and local variables  
    SELECT  
        @Description = NULLIF(LTRIM(RTRIM(@Description)), N''),  
        @DisplayName = NULLIF(LTRIM(RTRIM(@DisplayName)), N''),  
        @Return_ID = NULL,  
        @CurrentDTM = GETUTCDATE(),  
        @IsCloneMode = CASE WHEN @Return_MUID IS NULL THEN 0 ELSE 1 END,  
        @Entity_ID = NULLIF(@Entity_ID, 0),  
        @Attribute_ID = NULLIF(@Attribute_ID, 0),  
        @Attribute_MUID = NULLIF(@Attribute_MUID, @GuidEmpty),  
        @AttributeName = NULLIF(LTRIM(RTRIM(@AttributeName)), N''),  
        @DomainEntity_ID = NULLIF(@DomainEntity_ID, 0),  
        @FilterParentAttribute_ID = NULLIF(@FilterParentAttribute_ID, 0),  
        @FilterHierarchyDetail_ID = NULLIF(@FilterHierarchyDetail_ID, 0),  
        @AttributeType_ID = NULLIF(@AttributeType_ID, 0),  
        @Return_DidNameChange = 0,  
        @MemberType_ID = COALESCE(@MemberType_ID, 0),  
        @TableName = @TableName,  
        @SortOrder = @SortOrder  
        ;  
  
  
  
    --Invalid @MemberType_ID  
    IF @MemberType_ID NOT IN (@MemberTypeLeaf, @MemberTypeConsolidated, @MemberTypeCollection) --Invalid MemberType  
    BEGIN  
        RAISERROR('MDSERR200015|The attribute cannot be saved. The member type is not valid.', 16, 1);  
        RETURN;  
    END; --if  
  
    --Test for invalid AttributeType  
    IF @AttributeType_ID NOT IN (@AttributeTypeFreeform, @AttributeTypeDomain, @AttributeTypeSystem, @AttributeTypeFile)  
    BEGIN  
        --On error, return NULL results  
        SELECT @Return_ID = NULL, @Return_MUID = NULL;  
        RAISERROR('MDSERR100010|The Parameters are not valid.', 16, 1);  
        RETURN;  
    END; --if  
  
    --Raise an error if we are missing the entity ID  
    IF @Model_ID IS NULL OR @Entity_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR200014|The attribute cannot be saved. The entity ID is not valid.', 16, 1);  
        RETURN;  
    END;  
  
    --Get the latest Model version  
    IF @Version_ID IS NULL  
    BEGIN  
        SELECT @Version_ID = MAX(ID)  
        FROM mdm.tblModelVersion  
        WHERE Model_ID = @Model_ID  
    END  
  
    IF @AttributeType_ID = @AttributeTypeDomain  
    BEGIN  
        SET @DataType_ID = @DataTypeText;  
        IF COALESCE(@DomainEntity_ID, 0) <= 0  
        BEGIN  
            RAISERROR('MDSERR200068|The attribute cannot be saved. The DomainEntity ID is not valid.', 16, 1);  
            RETURN;  
        END  
    END ELSE  
    BEGIN  
        IF @FilterParentAttribute_ID IS NOT NULL OR @FilterHierarchyDetail_ID IS NOT NULL  
        BEGIN  
            RAISERROR(N'MDSERR200115|The attribute cannot be saved. An attribute filter can only be added to a domain-based attribute.', 16, 1);  
            RETURN;  
        END  
    END  
  
    -- Either both or neither filter params must be specified  
    IF @FilterParentAttribute_ID > 0 AND COALESCE(@FilterHierarchyDetail_ID, 0) <= 0   
    BEGIN  
        RAISERROR(N'MDSERR200119|The attribute cannot be saved. The attribute filter hierarchy is not valid.', 16, 1);  
        RETURN;  
    END  
    IF @FilterHierarchyDetail_ID > 0 AND COALESCE(@FilterParentAttribute_ID, 0) <= 0   
    BEGIN  
        RAISERROR(N'MDSERR200116|The attribute cannot be saved. The attribute filter parent is not valid.', 16, 1);  
        RETURN;  
    END  
  
  
    IF @MemberType_ID <> @MemberTypeLeaf AND @FilterParentAttribute_ID IS NOT NULL  
    BEGIN  
        RAISERROR(N'MDSERR200114|The attribute cannot be saved. An attribute filter can only be added to a leaf attribute.', 16, 1);  
        RETURN;  
    END  
  
    --Test for invalid parameters:  
    --Invalid @ChangeTrackingGroup  
    IF @ChangeTrackingGroup NOT BETWEEN 0 AND 31  
    BEGIN  
        RAISERROR('MDSERR100108|Change Tracking Group must be an INT between 0 and 31.', 16, 1);  
        RETURN;  
    END --IF  
  
    --Invalid @MemberType_ID for THIS entity  
    IF @MemberType_ID = @MemberTypeConsolidated AND @IsHierarchyEnabled = 0  
    BEGIN  
        RAISERROR('MDSERR200072|The attribute cannot be saved. The member type is not valid for this entity.', 16, 1);  
        RETURN;  
    END; --if  EXE  
  
    SET @TableOptions = mdm.udfGetTableOptions(@DataCompression, @Model_ID);  
    SET @IndexOptions = mdm.udfGetIndexOptions(@DataCompression, @Model_ID);  
  
    -- When creating collection member attributes, ensure the collection tables have been created.  
    IF @MemberType_ID = @MemberTypeCollection AND @IsCollectionEnabled = 0  
    BEGIN  
        EXEC mdm.udpCollectionTablesCreate @User_ID, @Model_ID, @Version_ID, @Entity_ID, @IsHierarchyEnabled, @TableOptions, @IndexOptions, @TableName OUTPUT;  
        SET @IsCollectionEnabled = 1;  
    END; --if  
  
    --Figure out whether the attribute is a system attribute  
    IF @EditMode IN (@EditMode_Update, @EditMode_Clone)  
        AND EXISTS(  
                SELECT 1  
                FROM mdm.tblAttribute  
                WHERE Entity_ID = @Entity_ID  
                AND MemberType_ID = @MemberType_ID  
                AND IsSystem = 1  
                AND [Name] = @AttributeName  
             )  
    BEGIN  
        SET @IsSystem = 1;  
    END  
  
    --Invalid @DataType_ID  
    IF @DataType_ID NOT IN (@DataTypeText, @DataTypeNumber, @DataTypeDateTime, @DataTypeLink) --Invalid @DataType_ID  
    BEGIN  
        RAISERROR('MDSERR200073|The attribute cannot be saved. The data type is not valid.', 16, 1);  
        RETURN;  
    END; --if  
  
    --Invalid @DisplayWidth  
    IF @DisplayWidth NOT BETWEEN 0 AND 500 --Invalid @DisplayWidth  
    BEGIN  
        RAISERROR('MDSERR200067|The attribute cannot be saved. The display width is not valid.', 16, 1);  
        RETURN;  
    END; --if  
  
    -- Validate @AttributeName  
    IF ISNULL(@AttributeName, '') = ''  
    BEGIN  
        RAISERROR('MDSERR100003|The Name is not valid.', 16, 1);  
        RETURN;  
    END; --if  
  
    --If we are in the Update or Clone mode get the missing pieces of the identifier  
    IF @EditMode IN (@EditMode_Update, @EditMode_Clone)  
    BEGIN  
        --Use the name to look up the attribute identifier if:  
        --  * the attribute is a system attribute. In this case name updates are not allowed  
        --    and we don't care what IDs the user sent in  
        -- OR  
        --  * use the name if neither MUID nor ID are available. This is important because we don't  
        --    want to look up by name if the name is what the user is trying to update.  
        IF @IsSystem = 1 OR (@Attribute_ID IS NULL AND @Attribute_MUID IS NULL)  
        BEGIN  
            SELECT TOP 1  
                @ExistingAttribute_ID =  ID,  
                @ExistingAttribute_MUID = MUID,  
                @ExistingAttributeType = AttributeType_ID,  
                @ExistingAttributeName = Name,  
                @ExistingFilterParentAttribute_ID = FilterParentAttribute_ID,  
                @ExistingFilterHierarchyDetail_ID = FilterHierarchyDetail_ID,  
                @TableColumn = TableColumn,  
                @CurrentDataType_ID = DataType_ID,  
                @CurrentDataTypeInfo = DataTypeInformation,  
                @PreviousAttributeName = [Name],  
                @CurrentSortOrder = SortOrder  
            FROM mdm.tblAttribute  
            WHERE  
                --Filter by member type too  
                MemberType_ID = @MemberType_ID AND  
                [Name] = @AttributeName AND  
                Entity_ID = @Entity_ID;  
        END  
        --Use the Attribute ID and MUID to look up the full identifier  
        ELSE  
        BEGIN  
            SELECT  
                @ExistingAttribute_ID =  ID,  
                @ExistingAttribute_MUID = MUID,  
                @ExistingAttributeType = AttributeType_ID,  
                @ExistingAttributeName = Name,  
                @ExistingFilterParentAttribute_ID = FilterParentAttribute_ID,  
                @ExistingFilterHierarchyDetail_ID = FilterHierarchyDetail_ID,  
                @TableColumn = TableColumn,  
                @CurrentDataType_ID = DataType_ID,  
                @CurrentDataTypeInfo = DataTypeInformation,  
                @PreviousAttributeName = [Name],  
                @CurrentSortOrder = SortOrder  
            FROM mdm.tblAttribute  
            WHERE  
                MemberType_ID = @MemberType_ID AND  
                (@Attribute_ID IS NOT NULL OR @Attribute_MUID IS NOT NULL) AND  
                (@Attribute_ID IS NULL OR ID = @Attribute_ID) AND  
                (@Attribute_MUID IS NULL OR MUID = @Attribute_MUID) AND  
                Entity_ID = @Entity_ID;  
        END  
  
        --If we are in the Clone mode we need to figure out whether we are creating or updating an attribute  
        IF @EditMode = @EditMode_Clone  
        BEGIN  
            --If there is no existing attribute then set the edit mode to Create  
            IF @ExistingAttribute_MUID IS NULL AND @ExistingAttribute_ID IS NULL  
            BEGIN  
                SET @EditMode = @EditMode_Create;  
                SET @Attribute_ID = NULL;  
            END  
            --If there is an existing attribute then set the edit mode to Update  
            ELSE  
            BEGIN  
                SET @EditMode = @EditMode_Update;  
                SET @Attribute_ID = @ExistingAttribute_ID;  
            END  
        END  
        --If we are in Update mode and could not find a matching existing attribute we need to raise an error and quit now  
        ELSE IF @EditMode = @EditMode_Update  
        BEGIN  
            IF @ExistingAttribute_ID IS NULL OR @ExistingAttribute_MUID IS NULL  
            BEGIN  
                --On error, return NULL results  
                SELECT @Return_ID = NULL, @Return_MUID = NULL;  
                RAISERROR('MDSERR110007|The ID is not valid.', 16, 1);  
                RETURN;  
            END  
            ELSE  
            BEGIN  
                SET @Attribute_ID = @ExistingAttribute_ID;  
                SET @Attribute_MUID = @ExistingAttribute_MUID;  
            END  
        END  
  
        --Can not update attribute type of an existing attribute  
        IF @EditMode = @EditMode_Update AND @AttributeType_ID <> @ExistingAttributeType  
        BEGIN  
            SELECT @Return_ID = NULL, @Return_MUID = NULL;  
            RAISERROR('MDSERR100010|The Parameters are not valid.', 16, 1);  
            RETURN;  
        END  
    END  
  
    --If the edit mode is Create. This code also needs to execute if the user sent in EditMode clone which ended up becoming Create (hence the IF instead of ELSE IF)  
    IF @EditMode = @EditMode_Create  
    BEGIN  
        --Set Entity ID to null. We don't care what came in.  
        SET @Attribute_ID = NULL;  
  
        --If @Attribute_MUID is not null then we need to ensure it does not already exist (since this is a create)  
        IF @Attribute_MUID IS NOT NULL AND EXISTS(SELECT 1 FROM mdm.tblAttribute WHERE MUID = @Attribute_MUID)  
        BEGIN  
            --On error, return NULL results  
            SELECT @Return_ID = NULL, @Return_MUID = NULL;  
            RAISERROR('MDSERR110007|The ID is not valid.', 16, 1);  
        RETURN;  
        END  
    END  
  
    --Invalid @Attribute_ID (or not in same Entity)  
    IF @Attribute_ID IS NOT NULL AND NOT EXISTS(SELECT 1 FROM mdm.tblAttribute WHERE ID = @Attribute_ID AND Entity_ID = @Entity_ID AND MemberType_ID = @MemberType_ID)  
    BEGIN  
        RAISERROR('MDSERR200016|The attribute cannot be saved. The attribute ID is not valid.', 16, 1);  
        RETURN;  
    END; --if  
  
    --Do not allow the creation of system attributes  
    IF @EditMode = @EditMode_Create AND @IsSystem = 1 --System attribute  
    BEGIN  
        RAISERROR('MDSERR200074|Creating system attributes is not supported.', 16, 1);  
        RETURN;  
    END  
  
    --Check the name of the attribute for duplicates  
    IF @IsSystem = 0  
    BEGIN  
        IF EXISTS  
        (  
            SELECT 1   
            FROM mdm.tblAttribute  
            WHERE  
                @AttributeName = Name AND  
                (@Attribute_MUID IS NULL OR MUID <> @Attribute_MUID) AND  
                Entity_ID = @Entity_ID AND  
                MemberType_ID = @MemberType_ID  
        )  
        BEGIN  
            --On error, return NULL results  
            SELECT @Return_ID = NULL, @Return_MUID = NULL;  
            RAISERROR('MDSERR110003|The name already exists. Type a different name.', 16, 1);  
            RETURN;  
        END  
    END  
  
    -- If an Attribute filter is specified ensure it is valid  
   -- If an existing attribute is being updated with a new filter, do additional validity checks  
    IF      @EditMode = @EditMode_Update   
        AND @FilterParentAttribute_ID IS NOT NULL   
    BEGIN  
  
        -- If the parent attribute is new, verify that it does not cause a circular dependency. Note: this does not need to be checked in Create mode, because no existing attribute can reference an attribute that hasn't yet been created.  
        IF (@FilterParentAttribute_ID <> COALESCE(@ExistingFilterParentAttribute_ID, 0))  
        BEGIN  
            DECLARE @IsCircularReference BIT = 0;  
  
            ;WITH attributesCte AS  
            (  
                SELECT  
                     ID Child_ID  
                    ,CASE WHEN ID = @Attribute_ID   
                        THEN @FilterParentAttribute_ID -- Use the new value for the attribute being updated  
                        ELSE FilterParentAttribute_ID -- Use the current value  
                        END Parent_ID  
                FROM mdm.tblAttribute  
                WHERE   Entity_ID = @Entity_ID  
                    AND MemberType_ID = @MemberType_ID  
            )  
            ,parentChildCte AS  
            (  
                -- The recursive base case is the attribute being updated.  
                SELECT  
                     @Attribute_ID Child_ID  
                    ,@FilterParentAttribute_ID Parent_ID  
                    ,0 RecursionLevel  
  
                UNION ALL  
  
                SELECT  
                     child.Child_ID  
                    ,CASE WHEN child.Child_ID = ancestor.Parent_ID THEN NULL ELSE ancestor.Parent_ID END Parent_ID  
                    ,child.RecursionLevel + 1  
                FROM parentChildCte child  
                INNER JOIN attributesCte ancestor  
                ON      child.Parent_ID = ancestor.Child_ID  
                    AND child.RecursionLevel < 99 -- Protects against "The statement terminated. The maximum recursion 100 has been exhausted before statement completion" error.  
                WHERE ancestor.Parent_ID IS NOT NULL-- ignore rows without a parent, they cannot be part of a circular relationship  
            )  
            SELECT TOP 1  
                @IsCircularReference = 1  
            FROM parentChildCte  
            WHERE Parent_ID IS NULL  
  
            If @IsCircularReference = 0  
            BEGIN  
                -- Check for circular references across entities (it would cause problems for Model Deployment)  
                ;WITH filteredAttributesCte AS  
                (  
                    SELECT  
                         a.ID               Child_ID  
                        ,a.Entity_ID        ChildEntity_ID  
                        ,a.DomainEntity_ID  ChildDomainEntity_ID  
                    FROM mdm.tblAttribute a  
                    WHERE (a.ID = @Attribute_ID OR FilterParentAttribute_ID IS NOT NULL)  
                        AND a.DomainEntity_ID <> a.Entity_ID -- ignore recursive filtered attributes  
                )  
                ,parentChildCte AS  
                (  
                    -- The recursive base case is the attribute being updated.  
                    SELECT   
                         Child_ID  
                        ,ChildEntity_ID  
                        ,ChildDomainEntity_ID  
                        ,0 RecursionLevel  
                    FROM filteredAttributesCte  
                    WHERE Child_ID = @Attribute_ID  
  
                    UNION ALL  
  
                    SELECT  
                         child.Child_ID  
                        ,child.ChildEntity_ID  
                        ,CASE WHEN child.ChildEntity_ID = ancestor.ChildEntity_ID THEN NULL ELSE ancestor.ChildDomainEntity_ID END ChildDomainEntity_ID  
                        ,child.RecursionLevel + 1  
                    FROM parentChildCte child  
                    INNER JOIN filteredAttributesCte ancestor  
                    ON      child.ChildDomainEntity_ID = ancestor.ChildEntity_ID  
                        AND child.RecursionLevel < 99 -- Protects against "The statement terminated. The maximum recursion 100 has been exhausted before statement completion" error.  
                )  
                SELECT TOP 1  
                    @IsCircularReference = 1  
                FROM parentChildCte  
                WHERE ChildDomainEntity_ID IS NULL  
            END  
  
            IF @IsCircularReference = 1  
            BEGIN  
                RAISERROR('MDSERR200124|The attribute cannot be saved. The attribute filter forms a circular dependency, which is not allowed.', 16, 1);  
                RETURN;  
            END  
        END  
  
        -- If an existing attribute is being updated with a new filter, check for conflicts with existing attribute values. Note: this does not need to be checked in Create mode, because a new attribute's values are null.  
        IF    (@FilterParentAttribute_ID <> COALESCE(@ExistingFilterParentAttribute_ID, 0)   
            OR @FilterHierarchyDetail_ID <> COALESCE(@ExistingFilterHierarchyDetail_ID, 0))  
        BEGIN  
            DECLARE   
                 @MemberCodeWithInconpatibleValue   NVARCHAR(250)  
                ,@MemberVersionName                 NVARCHAR(50)  
                ,@FilterParentColumnName            SYSNAME = (SELECT TableColumn FROM mdm.tblAttribute WHERE ID = @FilterParentAttribute_ID)  
                ,@FilterHierarchyEntityTableName    SYSNAME  
                ,@FilterHierarchyParentColumnName   SYSNAME  
                ,@FilterHierarchyM2MChildColumnName SYSNAME  
  
            SELECT   
                 @FilterHierarchyEntityTableName = parentEntity.EntityTable  
                ,@FilterHierarchyParentColumnName = parentAttribute.TableColumn   
                ,@FilterHierarchyM2MChildColumnName = m2mChildAttribute.TableColumn  
            FROM mdm.tblDerivedHierarchyDetail dhd  
            INNER JOIN mdm.tblAttribute parentAttribute  
            ON dhd.Foreign_ID = parentAttribute.ID   
            INNER JOIN mdm.tblEntity parentEntity  
            ON parentAttribute.Entity_ID = parentEntity.ID  
            LEFT JOIN mdm.tblAttribute m2mChildAttribute  
            ON dhd.ManyToManyChildAttribute_ID = m2mChildAttribute.ID  
            WHERE dhd.ID = @FilterHierarchyDetail_ID;  
  
            SET @SQL = CONCAT(N'  
        SELECT TOP 1   
             @MemberCodeWithInconpatibleValue = en.Code  
            ,@MemberVersionName = v.Name  
        FROM mdm.', QUOTENAME(@TableName), N' en  
        INNER JOIN mdm.tblModelVersion v  
        ON en.Version_ID = v.ID  
        LEFT JOIN mdm.', QUOTENAME(@FilterHierarchyEntityTableName), N' fen  
        ON      en.Version_ID = fen.Version_ID  
            AND en.', QUOTENAME(@TableColumn), N' = fen.', QUOTENAME(COALESCE(@FilterHierarchyM2MChildColumnName, N'ID')), N' -- If DBA level, this should always have exactly one match. If M2M level, it could have zero to many matches.  
            AND ISNULL(en.', QUOTENAME(@FilterParentColumnName), N', 0) = ISNULL(fen.', QUOTENAME(@FilterHierarchyParentColumnName), N', 0)  
        WHERE   en.', QUOTENAME(@TableColumn), N' IS NOT NULL -- a null child value is always valid  
            AND fen.ID IS NULL -- could not find a matching row in the domain/mapping entity  
        ORDER BY en.Version_ID DESC');  
  
            --Execute the dynamic SQL  
            EXEC sp_executesql @SQL, N'@MemberCodeWithInconpatibleValue NVARCHAR(250) OUTPUT, @MemberVersionName NVARCHAR(50) OUTPUT', @MemberCodeWithInconpatibleValue OUTPUT, @MemberVersionName OUTPUT;  
  
            IF @MemberCodeWithInconpatibleValue IS NOT NULL  
            BEGIN  
                DECLARE @Message NVARCHAR(MAX) = CONCAT('MDSERR200117|The attribute cannot be updated. The attribute filter is not compatible with one or more current attribute values. First member code: {0}, version: {1}.|', REPLACE(@MemberCodeWithInconpatibleValue, N'|', N''), N'|', REPLACE(@MemberVersionName, N'|', N''))  
                RAISERROR(@Message, 16, 1);  
                RETURN;  
            END  
        END  
    END -- If updating with a filter  
  
  
    --Start transaction, being careful to check if we are nested  
    DECLARE @TranCounter INT;  
    SET @TranCounter = @@TRANCOUNT;  
    IF @TranCounter > 0 SAVE TRANSACTION TX;  
    ELSE BEGIN TRANSACTION;  
  
    BEGIN TRY  
  
        DECLARE @SortOrderProvided BIT = 1;  
  
        IF (@SortOrder IS NULL OR @SortOrder = 0)  
        BEGIN  
            SET @SortOrderProvided = 0;  
            SELECT @SortOrder = MAX(SortOrder) + 1  
            FROM mdm.tblAttribute  
            WHERE   Entity_ID = @Entity_ID  
                AND MemberType_ID = @MemberType_ID  
  
            -- If we still couldn't find  a sort order, default to 1  
            IF (@SortOrder IS NULL)  
            BEGIN  
                SET @SortOrder = 1  
            END  
        END  
  
        --Update/Insert Attribute details  
        IF @EditMode = @EditMode_Update  
        --Update Attribute  
        BEGIN  
  
            IF @IsSystem = 1  
            --System Attribute  
            BEGIN  
  
                --The only change we allow on system attributes is the DisplayWidth, DisplayName, Description and MUID (clone scenario).  
                UPDATE mdm.tblAttribute   
                SET  
                    MUID = ISNULL(@Attribute_MUID, MUID),  
                    DisplayWidth = ISNULL(@DisplayWidth, DisplayWidth),  
                    DisplayName = COALESCE(@DisplayName,DisplayName,Name),  
                    [Description] = COALESCE(@Description, [Description]),  
                    LastChgDTM = @CurrentDTM,  
                    LastChgUserID = @User_ID,  
                    LastChgVersionID = @Version_ID,  
                    ChangeTrackingGroup  = @ChangeTrackingGroup  
                WHERE ID = @Attribute_ID;  
  
                SELECT @AttributeName = @PreviousAttributeName;  
  
            END ELSE  
            --Non-system Attribute  
            BEGIN  
                IF (@SortOrderProvided = 1)  
                BEGIN  
                    DECLARE @NextExistingOrder int;  
                    DECLARE @NextExistingID int;  
                    IF @CurrentSortOrder > @SortOrder  
                    BEGIN  
                        SELECT TOP 1  
                           @NextExistingID = ID,  
                           @NextExistingOrder = SortOrder  
                        FROM tblAttribute  
                        WHERE  
                            Entity_ID = @Entity_ID AND  
                            MemberType_ID = @MemberType_ID AND -- Only take into accounts attributes on the same entity of the same member type  
                            SortOrder < @CurrentSortOrder  
                        ORDER BY SortOrder DESC;  
  
                        UPDATE tblAttribute SET SortOrder = @NextExistingOrder WHERE ID = @Attribute_ID;  
                        UPDATE tblAttribute SET SortOrder = @CurrentSortOrder WHERE ID = @NextExistingID;  
                    END  
  
                    ELSE IF @CurrentSortOrder < @SortOrder  
                    BEGIN  
                        SELECT TOP 1  
                            @NextExistingID = ID,  
                            @NextExistingOrder = SortOrder  
                        FROM tblAttribute  
                        WHERE  
                            Entity_ID = @Entity_ID AND  
                            MemberType_ID = @MemberType_ID AND -- Only take into accounts attributes on the same entity of the same member type  
                            SortOrder > @CurrentSortOrder  
                        ORDER BY SortOrder ASC;  
  
                        IF (@NextExistingOrder IS NULL)  
                        BEGIN  
                            UPDATE tblAttribute SET SortOrder = @SortOrder WHERE ID = @Attribute_ID;  
                        END ELSE  
                        BEGIN  
                            UPDATE tblAttribute SET SortOrder = @NextExistingOrder WHERE ID = @Attribute_ID;  
                            UPDATE tblAttribute SET SortOrder = @CurrentSortOrder WHERE ID = @NextExistingID;  
                       END  
                    END  
                END  
                ELSE  
                --if SortOrderProvided = 0. This is for the case when we are updating an attribute type and therefor the old attribute is created and we don't want to swap it with anything else  
                BEGIN  
                    UPDATE tblAttribute SET SortOrder = @SortOrder WHERE ID = @Attribute_ID;  
                END  
  
                --Update details in the Attribute table  
                UPDATE mdm.tblAttribute   
                SET  
                    [Name] = ISNULL(@AttributeName, [Name]),  
                    [Description] =  COALESCE(@Description, [Description]),  
                    DisplayName = ISNULL(@DisplayName, DisplayName),  
                    DisplayWidth = @DisplayWidth,  
                    InputMask_ID = ISNULL(@InputMask_ID, InputMask_ID),  
                    FilterParentAttribute_ID = @FilterParentAttribute_ID,  
                    FilterHierarchyDetail_ID = @FilterHierarchyDetail_ID,  
                    LastChgDTM = @CurrentDTM,  
                    LastChgUserID = @User_ID,  
                    LastChgVersionID = @Version_ID,  
                    ChangeTrackingGroup = @ChangeTrackingGroup  
                WHERE   
                    ID = @Attribute_ID;  
  
                --Update column name of the staging table when @StagingTableName is specified.  
                IF @AttributeName IS NOT NULL AND @PreviousAttributeName <> @AttributeName AND COALESCE(@StagingTableName, N'') <> N''   
                BEGIN  
                    SET @SQL = N'EXEC sp_rename N' + QUOTENAME(N'stg.' + QUOTENAME(@StagingTableName) + N'.' + QUOTENAME(@PreviousAttributeName), N'''') + N', N' + QUOTENAME(@AttributeName, N'''') + N', ''COLUMN'';';  
                    --Execute the dynamic SQL  
                    EXEC sp_executesql @SQL;  
                END; --IF  
            END; --if  
  
            --Populate output parameters  
            SELECT @Return_MUID = MUID FROM mdm.tblAttribute WHERE ID = @Attribute_ID;  
  
        END  
        ELSE  
        --New Attribute  
        BEGIN  
            --Coalesce defaults for specific parameters  
            SELECT  
                --Accept an explicit MUID (for clone operations) or generate a new one  
                @Return_MUID = ISNULL(@Attribute_MUID, NEWID()),  
                @DataType_ID = ISNULL(@DataType_ID, @DataTypeText),  
                @DataTypeInformation = ISNULL(@DataTypeInformation, 0),  
                @InputMask_ID = ISNULL(@InputMask_ID, 1),  
                @DisplayName = ISNULL(@DisplayName,@AttributeName);  
  
            -- Always use Link data type for file attributes.  
            IF (@AttributeType_ID = @AttributeTypeFile)   
            BEGIN  
                SET @DataType_ID = @DataTypeLink;  
            END;  
  
            --Insert details into Attribute table  
            INSERT INTO mdm.tblAttribute  
            (  
                Entity_ID,  
                SortOrder,  
                DomainEntity_ID,  
                FilterParentAttribute_ID,  
                FilterHierarchyDetail_ID,  
                AttributeType_ID,  
                MemberType_ID,  
                IsSystem,  
                IsReadOnly,  
                [Name],  
                [Description],  
                DisplayName,  
                TableColumn,  
                DisplayWidth,  
                DataType_ID,  
                DataTypeInformation,  
                InputMask_ID,  
                MUID,  
                EnterUserID,  
                EnterVersionID,  
                LastChgUserID,  
                LastChgVersionID,  
                ChangeTrackingGroup  
            )  
            SELECT  
                @Entity_ID,  
                @SortOrder,  
                CASE  
                    WHEN @DomainEntity_ID > 0 THEN @DomainEntity_ID  
                    ELSE NULL --Distinguish between FILE and F/F using AttributeType_ID  
                END, --case  
                @FilterParentAttribute_ID,  
                @FilterHierarchyDetail_ID,  
                @AttributeType_ID,  
                @MemberType_ID,  
                0, --IsSystem = False  
                0, --IsReadOnly = False  
                @AttributeName,  
                @Description,  
                @DisplayName,  
                N'', --Temporary value since this is a required column  
                @DisplayWidth,  
                @DataType_ID,  
                @DataTypeInformation,  
                @InputMask_ID,  
                @Return_MUID,  
                @User_ID,  
                @Version_ID,  
                @User_ID,  
                @Version_ID,  
                @ChangeTrackingGroup  
  
            --Save the identity value  
            SET @Attribute_ID = SCOPE_IDENTITY();  
  
            --Generate the physical column name and replace the default generated value.  
            --Note that a random value would work fine, but a reproducible value makes debugging simpler.  
            --Note that @Attribute_ID required to maintain uniqueness. For example user creates attribute 'Color'  
            --which instantiates as column [A]. They rename 'Color' to 'Size' but the column stays as [A].  
            --They then create a new attribute called 'Color' which - if @Attribute_ID was not used to uniqify  
            --the generated name it would try to instantiate the column as [A] again --> Error.  
            SET @TableColumn = CONCAT(N'uda_', @Entity_ID, N'_', @Attribute_ID);  
            SET @VersionColumnName = N'Version_ID'  
  
            UPDATE mdm.tblAttribute SET TableColumn = @TableColumn WHERE ID = @Attribute_ID;  
  
            --Add the column to the Entity table.  
            SET @AddColumnSQL = N' ADD ' + QUOTENAME(@TableColumn) + N' ';  
            IF @AttributeType_ID = @AttributeTypeFreeform   
            BEGIN  
                IF @DataType_ID = @DataTypeText OR @DataType_ID = @DataTypeLink   
                BEGIN  
                    IF @DataTypeInformation < 1  
                    BEGIN  
                        SET @AddColumnSQL += N'NVARCHAR(MAX) NULL;';  
                    END  
                    ELSE  
                    BEGIN  
                    SET @AddColumnSQL += N'NVARCHAR(' + CONVERT(NVARCHAR(30), @DataTypeInformation) + N') NULL;';  
                    END  
                END ELSE IF @DataType_ID = @DataTypeNumber   
                BEGIN  
                    IF @DataTypeInformation < 0   
                    BEGIN  
                        SET @DataTypeInformation = 0; --DECIMAL(38, 0) is minimum precision allowed by SQL  
                    END ELSE   
                    IF @DataTypeInformation > 38   
                    BEGIN  
                        SET @DataTypeInformation = 38; --DECIMAL(38, 38) is maximum precision allowed by SQL  
                    END  
                    SET @AddColumnSQL += N'DECIMAL(38, ' + CONVERT(NVARCHAR(2), @DataTypeInformation) + N') NULL;';  
                END ELSE IF @DataType_ID = @DataTypeDateTime   
                BEGIN  
                    SET @AddColumnSQL += N'DATETIME2(3) NULL;';  
                END; --if  
            END ELSE   
            BEGIN --DBA/FILE  
                SET @AddColumnSQL += N'INT NULL;';  
            END --if  
  
            SET @SQL = N'ALTER TABLE mdm.' + QUOTENAME(@TableName) + @AddColumnSQL;  
            --Execute the dynamic SQL  
            EXEC sp_executesql @SQL;  
  
            SET @HistoryTableName = CONCAT(@TableName, N'_HS');  
            SET @SQL = N'ALTER TABLE mdm.' + QUOTENAME(@HistoryTableName) + @AddColumnSQL;  
            --Execute the dynamic SQL  
            EXEC sp_executesql @SQL;  
  
            IF @MemberType_ID = @MemberTypeLeaf  
            BEGIN  
                SET @PendingTableName = CONCAT(@TableName, N'_PD');  
                SET @SQL = N'ALTER TABLE mdm.' + QUOTENAME(@PendingTableName) + @AddColumnSQL;  
                --Execute the dynamic SQL  
                EXEC sp_executesql @SQL;  
            END  
  
            --Create the FK & FK index for DBA & FIL attributes.  
            IF @AttributeType_ID = @AttributeTypeDomain   
            BEGIN  
  
                --Foreign key constraint definition  
                SELECT @SQL = CONCAT(N'  
                    ALTER TABLE mdm.', QUOTENAME(@TableName), N' ADD CONSTRAINT  
                        ', QUOTENAME(CONCAT(N'fk_', @TableName, N'_', EntityTable, N'_Version_ID_', @TableColumn)), N'  
                        FOREIGN KEY (', QUOTENAME(@VersionColumnName), N', ', QUOTENAME(@TableColumn), N')  
                        REFERENCES mdm.', QUOTENAME(EntityTable), N'(Version_ID, ID);')  
                FROM mdm.tblEntity   
                WHERE ID = @DomainEntity_ID;  
  
                --Foreign key index definition  
                SET @SQL += CONCAT(N'  
                    -- For udpVersionCopy  
                    CREATE NONCLUSTERED INDEX ', QUOTENAME(CONCAT(N'ix_', @TableName, N'_Version_ID_', @TableColumn)), N'  
                        ON mdm.', QUOTENAME(@TableName), N'(', QUOTENAME(@VersionColumnName), N', ', QUOTENAME(@TableColumn), N')  
                        INCLUDE(ID)  
                        ', @IndexOptions, N';');  
  
                IF @MemberType_ID = @MemberTypeLeaf  
                BEGIN  
                    --Foreign key index definition  
                    SET @SQL += CONCAT(N'  
                        -- For udpVersionCopy  
                        CREATE NONCLUSTERED INDEX ', QUOTENAME(CONCAT(N'ix_', @PendingTableName, N'_Version_ID_', @TableColumn)), N'  
                            ON mdm.', QUOTENAME(@PendingTableName), N'(', QUOTENAME(@VersionColumnName), N', ', QUOTENAME(@TableColumn), N')  
                            INCLUDE(ID)  
                            ', @IndexOptions, N';');  
                END  
  
                EXEC sp_executesql @SQL;  
  
            END ELSE IF @AttributeType_ID = @AttributeTypeFile   
            BEGIN  
  
                --Foreign key constraint definition  
                SET @SQL = N'  
                    ALTER TABLE mdm.' + QUOTENAME(@TableName) + N' ADD CONSTRAINT  
                        ' + QUOTENAME(N'fk_' + @TableName + N'_tblFile_' + @TableColumn) + N'  
                        FOREIGN KEY (' + QUOTENAME(@TableColumn) + N')  
                        REFERENCES mdm.tblFile(ID);';  
  
                --Foreign key index definition  
                SET @SQL += N'  
                    CREATE NONCLUSTERED INDEX ' + QUOTENAME(N'ix_' + @TableName + N'_Version_ID_' + @TableColumn ) + N'  
                        ON mdm.' + QUOTENAME(@TableName) + N'(' + QUOTENAME(@VersionColumnName) + N', ' + QUOTENAME(@TableColumn) + N')  
                        INCLUDE(ID)  
                        ' + @IndexOptions + N';';  
  
                IF @MemberType_ID = @MemberTypeLeaf  
                BEGIN  
                    --Foreign key index definition  
                    SET @SQL += N'  
                        CREATE NONCLUSTERED INDEX ' + QUOTENAME(N'ix_' + @PendingTableName + N'_Version_ID_' + @TableColumn ) + N'  
                            ON mdm.' + QUOTENAME(@PendingTableName) + N'(' + QUOTENAME(@VersionColumnName) + N', ' + QUOTENAME(@TableColumn) + N')  
                            INCLUDE(ID)  
                            ' + @IndexOptions + N';';  
                END  
  
                EXEC sp_executesql @SQL;  
  
            END; --if  
  
            --Add the column to the Staging table.  
            IF LEN(COALESCE(@StagingTableName, N'')) > 0  
            BEGIN  
                SET @SQL = N'ALTER TABLE stg.' + QUOTENAME(@StagingTableName) + N' ADD ' + QUOTENAME(@AttributeName) + N' ';  
                IF @AttributeType_ID = @AttributeTypeFreeform   
                BEGIN  
                    IF @DataType_ID = @DataTypeText OR @DataType_ID = @DataTypeLink   
                    BEGIN  
                        IF @DataTypeInformation < 1  
                        BEGIN  
                            SET @SQL += N'NVARCHAR(MAX) NULL;';  
                        END  
                        ELSE  
                        BEGIN  
                            SET @SQL += CONCAT(N'NVARCHAR(', @DataTypeInformation, N') NULL;');  
                        END  
                    END ELSE   
                    IF @DataType_ID = @DataTypeNumber   
                    BEGIN  
                        IF @DataTypeInformation < 0   
                        BEGIN  
                            SET @DataTypeInformation = 0; --DECIMAL(38, 0) is minimum precision allowed by SQL  
                        END ELSE   
                        IF @DataTypeInformation > 38  
                        BEGIN  
                            SET @DataTypeInformation = 38; --DECIMAL(38, 38) is maximum precision allowed by SQL  
                        END  
                        SET @SQL += CONCAT(N'DECIMAL(38, ', @DataTypeInformation, N') NULL;');  
                    END ELSE   
                    IF @DataType_ID = @DataTypeDateTime   
                    BEGIN  
                        SET @SQL += N'DATETIME2(3) NULL;';  
                    END; --if  
                END ELSE   
                BEGIN --DBA/FILE  
                    SET @SQL += N'NVARCHAR(250) NULL;';  
                END --if  
  
                --Execute the dynamic SQL  
                EXEC sp_executesql @SQL;  
  
            END; --IF  
  
            --Populate output parameters  
            SELECT @CurrentDataType_ID = @DataType_ID;  
  
        END; --if new attribute  
  
        --Recreate the views  
        EXEC mdm.udpCreateViews @Model_ID, @Entity_ID;  
  
        --Recreate the subscription views of entity  
        EXEC mdm.udpCreateAllSubscriptionViews NULL, @Entity_ID;  
  
        --Return values  
        SET @Return_ID = @Attribute_ID;  
  
        IF @RecreateStagingProc = 1  
        BEGIN  
            -- Recreate the staging stored procedure.  
            IF @MemberType_ID = @MemberTypeLeaf  
            BEGIN  
                EXEC mdm.udpEntityStagingCreateLeafStoredProcedure @Entity_ID  
            END -- IF  
            ELSE IF @MemberType_ID = @MemberTypeConsolidated  
            BEGIN  
                EXEC mdm.udpEntityStagingCreateConsolidatedStoredProcedure @Entity_ID  
            END -- IF  
        END  
  
        --Commit only if we are not nested  
        IF @TranCounter = 0  
        BEGIN  
            COMMIT TRANSACTION;  
            SET @TranCommitted = 1;  
        END; -- IF  
  
        IF @EditMode = @EditMode_Update AND @AttributeName <> @ExistingAttributeName  
        BEGIN  
            SET @Return_DidNameChange = 1;  
        END  
  
        -- Send the message  
		EXEC mdm.udpPerformanceQueueSave;  
  
        RETURN;  
  
    END TRY  
    --Compensate as necessary  
    BEGIN CATCH  
        -- Get error info.  
        DECLARE  
            @ErrorMessage NVARCHAR(4000),  
            @ErrorSeverity INT,  
            @ErrorState INT,  
            @ErrorNumber INT,  
            @ErrorLine INT,  
            @ErrorProcedure NVARCHAR(126);  
        EXEC mdm.udpGetErrorInfo  
            @ErrorMessage = @ErrorMessage OUTPUT,  
            @ErrorSeverity = @ErrorSeverity OUTPUT,  
            @ErrorState = @ErrorState OUTPUT,  
            @ErrorNumber = @ErrorNumber OUTPUT,  
            @ErrorLine = @ErrorLine OUTPUT,  
            @ErrorProcedure = @ErrorProcedure OUTPUT  
  
        SET @ErrorMessage = CONCAT(@ErrorMessage, N', @ErrorNumber = ', @ErrorNumber, N', @ErrorProcedure = "', @ErrorProcedure, N'", line ', @ErrorLine);  
  
        IF @TranCommitted = 0 -- Don't rollback when the transaction has been committed.  
        BEGIN  
            IF @TranCounter = 0 ROLLBACK TRANSACTION;  
            ELSE IF XACT_STATE() <> -1 ROLLBACK TRANSACTION TX;  
        END; -- IF  
  
        --On error, return NULL results  
        SELECT @Attribute_ID = NULL, @Return_MUID = NULL, @TableColumn = NULL, @AttributeName = NULL, @CurrentDataType_ID = NULL, @CurrentDataTypeInfo = NULL, @Model_ID = NULL;  
  
        --Throw the error again so the calling procedure can use it  
        RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);  
  
        RETURN;  
  
    END CATCH;  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpBusinessRule_AttributeMemberController]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
EXEC mdm.udpBusinessRule_AttributeMemberController 1,2,3,'9876',10000,1,7  
*/  
CREATE PROCEDURE [mdm].[udpBusinessRule_AttributeMemberController]  
    (  
    @User_ID INT,   
    @Version_ID INT,   
    @Entity_ID INT,   
    @MemberIdList mdm.IdList READONLY,   
    @MemberType_ID TINYINT,   
    @ProcessOptions INT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
    )  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON  
  
    DECLARE @BRControllerName           sysname,  
            @ValidationStatus_Succeeded INT = 3;  
  
    SELECT @BRControllerName = mdm.udfBusinessRuleAttributeMemberControllerNameGetByID(@Entity_ID, @MemberType_ID)  
  
    --Check to see if the Business Rule Controller exists for this entity/member type.  
    IF mdm.udfDBObjectExist(@BRControllerName, N'P') = 1   
    BEGIN  
  
        --Call the Business Rule Controller to validate the members  
        DECLARE @SQLString NVARCHAR(MAX);  
  
        SELECT @SQLString = N'EXEC mdm.' + @BRControllerName +   
            N' @User_ID, @Version_ID, @Entity_ID, @MemberIdList,@MemberType_ID,@ProcessOptions;'  
  
        EXEC sp_executesql @SQLString,   
            N'@User_ID INT, @Version_ID INT, @Entity_ID INT, @MemberIdList mdm.IdList READONLY, @MemberType_ID TINYINT, @ProcessOptions INT',   
            @User_ID, @Version_ID, @Entity_ID, @MemberIdList, @MemberType_ID, @ProcessOptions;  
    END   
    ELSE   
    BEGIN  
        IF EXISTS (SELECT * from mdm.tblBRBusinessRule WHERE Status_ID = 1 AND Entity_ID = @Entity_ID AND MemberType_ID = @MemberType_ID)   
        BEGIN  
            --We have a problem because the ProcessRules sproc doesn't exists.  Return error stating the  
            --user needs to publish business rules to generate the sproc.  
            RAISERROR('MDSERR400038|Unpublished business rules exist. Apply the business rules before running Business Rules or Validation again.', 16, 1);  
            RETURN;  
        END   
        ELSE   
        BEGIN  
                --No rules exists.  Update members validation status to 3 - succeeded  
            EXEC mdm.udpMembersValidationStatusUpdate @Entity_ID, @MemberType_ID, @ValidationStatus_Succeeded, @Version_ID, @MemberIdList;  
        END  
    END  
  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpBusinessRuleAttributeMemberControllerNameGetByID]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
declare @res NVARCHAR(200)  
exec mdm.udpBusinessRuleAttributeMemberControllerNameGetByID 1,1,@res output  
select @res  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpBusinessRuleAttributeMemberControllerNameGetByID]  
(  
	@Entity_ID			INT,  
	@MemberType_ID		TINYINT,  
	@BRControllerName	NVARCHAR(200) OUTPUT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
	SET NOCOUNT ON  
  
	SELECT @BRControllerName = mdm.udfBusinessRuleAttributeMemberControllerNameGetByID(@Entity_ID, @MemberType_ID)   
  
	SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpBusinessRuleGetTableMetadata]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    EXEC mdm.udpBusinessRuleGetTableMetadata 1,1,31  
    EXEC mdm.udpBusinessRuleGetTableMetadata 1,2,31  
*/  
CREATE PROCEDURE [mdm].[udpBusinessRuleGetTableMetadata]  
(  
     @Entity_ID      INT  
    ,@MemberType_ID  TINYINT  
    ,@CorrelationID  UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON  
  
    DECLARE  
        @FactTableName              SYSNAME,  
        @ParentFactTableName        SYSNAME,  
        @PublishableStatus          mdm.IdList,  
        @ChangeValueActions         mdm.IdList,  
        @RecursiveInheritanceAttributes mdm.IdList,  
        @AttributeProperty          INT = 2,  
        @DbaAttributeProperty       INT = 4,  
        @ParentAttributeProperty    INT = 3,  
        @ValuePropertyName_ID       INT = 1,  
  
        @MemberType_Leaf           TINYINT = 1,  
        @MemberType_Consolidated   TINYINT = 2,  
  
        @Model_ID                   INT,  
        @ValidationLogTableName     SYSNAME,  
        @ValidationLogViewName      SYSNAME;  
  
    SET @FactTableName = mdm.udfViewNameGetByID(@Entity_ID, @MemberType_ID, 0, 0)  
    SET @ParentFactTableName = mdm.udfViewNameGetByID(@Entity_ID, @MemberType_Consolidated, 0, 0)  
  
    INSERT INTO @PublishableStatus (ID)  
        SELECT OptionID FROM mdm.tblList  
        WHERE ListCode = CAST(N'lstBRStatus' AS NVARCHAR(50)) AND Group_ID = 1  -- Group_ID = 1 indicates publishable.  
  
  
    INSERT INTO @ChangeValueActions (ID)  
        SELECT AppliesTo_ID FROM mdm.viw_SYSTEM_SCHEMA_BUSINESSRULE_ITEMTYPES WHERE ApplyToCategoryID = 2/*BRItemTypeCategory*/ AND BRTypeID = 2/*Actions*/ AND (BRSubTypeID = 2/*Default value*/ OR BRSubTypeID = 3/*Change value*/)  
  
    INSERT INTO @RecursiveInheritanceAttributes  
        SELECT DISTINCT Attribute_ID FROM (  
            SELECT BusinessRule_ID, Attribute_ID  
            FROM mdm.viw_SYSTEM_SCHEMA_BUSINESSRULE_PROPERTIES_ATTRIBUTES a  
            INNER JOIN @PublishableStatus ps ON a.BusinessRule_Status = ps.ID  
            INNER JOIN @ChangeValueActions cva ON a.Item_AppliesTo_ID = cva.ID  
            WHERE   a.Attribute_Entity_ID = @Entity_ID  
                AND a.Attribute_MemberType_ID = @MemberType_Consolidated  
                AND a.Property_IsLeftHandSide = 1  
            INTERSECT  
            SELECT BusinessRule_ID, Attribute_ID  
            FROM mdm.viw_SYSTEM_SCHEMA_BUSINESSRULE_PROPERTIES_ATTRIBUTES a  
            INNER JOIN @PublishableStatus ps ON a.BusinessRule_Status = ps.ID  
            INNER JOIN @ChangeValueActions cva ON a.Item_AppliesTo_ID = cva.ID  
            WHERE   a.Attribute_Entity_ID = @Entity_ID  
                AND a.Attribute_MemberType_ID = @MemberType_Consolidated  
                AND a.Property_IsLeftHandSide = 0  
                AND a.Property_Parent_PropertyType_ID = @ParentAttributeProperty  
        ) r  
  
    --Get the model ID  
    SELECT @Model_ID = Model_ID  
    FROM mdm.tblEntity  
    WHERE ID = @Entity_ID;  
  
    --Get validation log table and view names  
    SET @ValidationLogTableName = mdm.udfGetValidationLogTableName(@Model_ID);  
    SET @ValidationLogViewName = mdm.udfGetValidationLogViewName(@Model_ID);  
  
    /* FACT TABLE */ -- This will only ever return one row, for the specified entity member type  
    SELECT  
         @Entity_ID AS ID  
        ,@FactTableName AS [Name]  
        ,N'' AS ColumnPrefix  
        ,@MemberType_ID AS MemberTypeID  
        ,N'Fact' AS Type  
        ,N'fact' AS Alias  
        ,N'' AS JoinTableName  
        ,N'' AS JoinTableColumn  
        ,N'' AS JoinTableAlias  
        ,CASE @MemberType_ID  
            WHEN @MemberType_Leaf THEN EntityTable  
            WHEN @MemberType_Consolidated THEN HierarchyParentTable  
         END AS PhysicalTableName  
        ,CASE @MemberType_ID  
            WHEN @MemberType_Leaf THEN StagingLeafName  
            WHEN @MemberType_Consolidated THEN StagingConsolidatedName  
         END AS StagingName  
        ,@ValidationLogTableName AS ValidationLogTableName  
        ,@ValidationLogViewName AS ValidationLogViewName  
        ,CASE @MemberType_ID  
            WHEN @MemberType_Leaf THEN EntityTable + N'_AN'  
            WHEN @MemberType_Consolidated THEN HierarchyParentTable + N'_AN'  
         END AS AnnotationTableName  
    FROM mdm.tblEntity  
    WHERE ID = @Entity_ID;  
  
    /* FACT TABLE ATTRIBUTES */  
    SELECT DISTINCT  
        @Entity_ID AS ParentFactID,  
        col.COLUMN_NAME As [Name],  
        a.DisplayName,  
        a.ID AS TableColumnID,  
        a.AttributeType_ID AS AttributeTypeID,  
        a.DomainEntity_ID AS DomainEntityID,  
        CASE WHEN dbaRefresh.Attribute_ID IS NULL THEN 0 ELSE 1 END AS IsDomainEntityRefreshRequired,  
        CASE WHEN recur.ID IS NULL THEN 0 ELSE 1 END AS IsRecursiveInheritance,  
        a.SortOrder AS Ordinal,  
        col.DATA_TYPE AS SQLType,  
        CASE col.CHARACTER_MAXIMUM_LENGTH WHEN -1 THEN N'MAX' ELSE CONVERT(NVARCHAR(MAX), col.CHARACTER_MAXIMUM_LENGTH) END AS MaxLength,  
        col.NUMERIC_PRECISION AS NumericPrecision,  
        col.NUMERIC_SCALE AS NumericScale  
    FROM mdm.tblBRItemProperties p  
    LEFT JOIN mdm.tblBRItemProperties pp ON  
        p.Parent_ID =  pp.ID  
    INNER JOIN mdm.tblBRItem i ON  
        p.BRItem_ID = i.ID  
    INNER JOIN mdm.tblBRLogicalOperatorGroup g ON  
        i.BRLogicalOperatorGroup_ID = g.ID  
    INNER JOIN mdm.tblBRBusinessRule br ON  
        g.BusinessRule_ID = br.ID  
    INNER JOIN @PublishableStatus ps  
        ON br.Status_ID = ps.ID  
    INNER JOIN mdm.tblAttribute a ON  
        a.ID = cast(p.[Value] AS INT) and  
        p.PropertyType_ID IN (@AttributeProperty, @DbaAttributeProperty) and  
        (p.Parent_ID is null  OR pp.PropertyType_ID = 8)  
    INNER JOIN INFORMATION_SCHEMA.COLUMNS col ON  
        col.TABLE_NAME = @FactTableName AND col.TABLE_SCHEMA = 'mdm' AND col.COLUMN_NAME = a.Name COLLATE database_default  
    LEFT JOIN (  
        -- Find any DBAs that are getting set (left-hand side) and their attributes are referenced in the right-hand side of other rules  
        -- These DBA attribute values will need to be refreshed during business rule processing.  
        -- Find the DBAs getting set  
        SELECT Attribute_ID  
        FROM mdm.viw_SYSTEM_SCHEMA_BUSINESSRULE_PROPERTIES_ATTRIBUTES a  
        INNER JOIN @PublishableStatus ps ON a.BusinessRule_Status = ps.ID  
        INNER JOIN @ChangeValueActions cva ON a.Item_AppliesTo_ID = cva.ID  
        WHERE  
            a.Attribute_Entity_ID = @Entity_ID  
        AND a.Attribute_MemberType_ID = @MemberType_ID  
        AND a.Attribute_DBAEntity_ID IS NOT NULL  
        AND a.Property_IsLeftHandSide = 1  
        INTERSECT  
        -- Find the DBA attribute values being referenced.  
        SELECT Attribute_ID  
        FROM mdm.viw_SYSTEM_SCHEMA_BUSINESSRULE_PROPERTIES_ATTRIBUTES a  
        INNER JOIN @PublishableStatus ps ON a.BusinessRule_Status = ps.ID  
        INNER JOIN @ChangeValueActions cva ON a.Item_AppliesTo_ID = cva.ID  
        WHERE  
            a.Attribute_Entity_ID = @Entity_ID  
        AND a.Attribute_MemberType_ID = @MemberType_ID  
        AND a.Attribute_DBAEntity_ID IS NOT NULL  
        AND a.Property_IsLeftHandSide = 0  
        AND a.Property_Parent_ID IS NULL  
        AND a.PropertyType_ID = @DbaAttributeProperty  
    ) dbaRefresh  
    ON a.ID = dbaRefresh.Attribute_ID  
    LEFT JOIN @RecursiveInheritanceAttributes recur  
        ON a.ID = recur.ID  
    WHERE   br.Entity_ID = @Entity_ID  
        AND br.MemberType_ID = @MemberType_ID  
  
    UNION -- not UNION ALL because deduplication is needed  
    --Ensure the Code attribute is returned  
    SELECT DISTINCT  
        @Entity_ID AS ParentFactID,  
        col.COLUMN_NAME AS [Name],  
        a.DisplayName,  
        a.ID AS TableColumnID,  
        a.AttributeType_ID AS AttributeTypeID,  
        a.DomainEntity_ID AS DomainEntityID,  
        0 AS IsDomainEntityRefreshRequired,  
        0 AS IsRecursiveInheritance,  
        a.SortOrder AS Ordinal,  
        col.DATA_TYPE AS SQLType,  
        CASE col.CHARACTER_MAXIMUM_LENGTH WHEN -1 THEN N'MAX' ELSE CONVERT(NVARCHAR(MAX), col.CHARACTER_MAXIMUM_LENGTH) END AS MaxLength,  
        col.NUMERIC_PRECISION AS NumericPrecision,  
        col.NUMERIC_SCALE AS NumericScale  
    FROM mdm.tblAttribute a  
    INNER JOIN INFORMATION_SCHEMA.COLUMNS col  
    ON      a.Entity_ID = @Entity_ID  
        AND a.MemberType_ID = @MemberType_ID  
        AND a.Name = 'Code'  
        AND col.TABLE_NAME = @FactTableName  
        AND col.TABLE_SCHEMA = 'mdm'  
        AND col.COLUMN_NAME = a.Name COLLATE database_default  
    ORDER BY  
        a.SortOrder;  
  
    /* DBA SUPPORTING FACT TABLES */  
    SELECT DISTINCT  
         e.ID  
        ,mdm.udfViewNameGetByID(DomainEntity_ID, @MemberType_Leaf, 0, 0) AS [Name]  
        ,N'DBA.' + a.Name AS ColumnPrefix  
        ,@MemberType_Leaf AS MemberTypeID  
        ,N'SupportingFactDBA' AS Type  
        ,N'[dba' + a.Name + N']' AS Alias  
        ,@FactTableName AS JoinTableName  
        ,a.Name AS JoinTableColumn  
        ,N'fact' AS JoinTableAlias  
        ,mdm.udfTableNameGetByID(DomainEntity_ID, @MemberType_Leaf) AS PhysicalTableName  
    FROM mdm.tblBRItemProperties p  
    LEFT JOIN mdm.tblBRItemProperties pp ON  
        p.Parent_ID =  pp.ID  
    INNER JOIN mdm.tblBRItem i  
    ON p.BRItem_ID = i.ID  
    INNER JOIN mdm.tblBRLogicalOperatorGroup g  
    ON i.BRLogicalOperatorGroup_ID = g.ID  
    INNER JOIN mdm.tblBRBusinessRule br  
    ON g.BusinessRule_ID = br.ID  
    INNER JOIN @PublishableStatus ps  
    ON br.Status_ID = ps.ID  
    INNER JOIN mdm.tblAttribute a  
    ON      p.[Value] = CONVERT(NVARCHAR, a.ID)  
        AND p.PropertyType_ID = @DbaAttributeProperty  
        AND (p.Parent_ID is null  OR pp.PropertyType_ID = 8) --No parent or the parent is UserDefinedScript  
    INNER JOIN mdm.tblEntity e  
    ON a.DomainEntity_ID = e.ID  
    WHERE   br.Entity_ID = @Entity_ID  
        AND br.MemberType_ID = @MemberType_ID  
    ORDER BY [Type];  
  
    /* DBA SUPPORTING FACT TABLE ATTRIBUTES */  
    SELECT DISTINCT  
        a.Entity_ID AS ParentFactID,  
        col.COLUMN_NAME As [Name],  
        a.DisplayName,  
        a.ID AS TableColumnID,  
        a.AttributeType_ID AS AttributeTypeID,  
        a.DomainEntity_ID AS DomainEntityID,  
        0 AS IsDomainEntityRefreshRequired,  
        0 AS IsRecursiveInheritance,  
        a.SortOrder AS Ordinal,  
        col.DATA_TYPE AS SQLType,  
        col.CHARACTER_MAXIMUM_LENGTH AS MaxLength,  
        col.NUMERIC_PRECISION AS NumericPrecision,  
        col.NUMERIC_SCALE AS NumericScale  
    FROM mdm.tblBRItemProperties p  
    INNER JOIN mdm.tblBRItem i  
    ON p.BRItem_ID = i.ID  
    INNER JOIN mdm.tblBRLogicalOperatorGroup g  
    ON i.BRLogicalOperatorGroup_ID = g.ID  
    INNER JOIN mdm.tblBRBusinessRule br  
    ON g.BusinessRule_ID = br.ID  
    INNER JOIN @PublishableStatus ps  
    ON br.Status_ID = ps.ID  
    INNER JOIN mdm.tblAttribute a  
    ON      p.[Value] = CONVERT(NVARCHAR, a.ID)  
        AND p.PropertyType_ID = @AttributeProperty  
        AND p.Parent_ID IS NOT NULL  
    INNER JOIN mdm.tblBRItemProperties p_dba  
    ON      p.Parent_ID = p_dba.ID  
        AND p_dba.PropertyType_ID = @DbaAttributeProperty  
    INNER JOIN INFORMATION_SCHEMA.COLUMNS col  
    ON      col.TABLE_NAME = mdm.udfViewNameGetByID(a.Entity_ID, @MemberType_Leaf, 0, 0)  
        AND col.TABLE_SCHEMA = 'mdm'  
        AND col.COLUMN_NAME = a.Name COLLATE database_default  
    WHERE   br.Entity_ID = @Entity_ID  
        AND br.MemberType_ID = @MemberType_ID  
    ORDER BY  
        ParentFactID, a.SortOrder;  
  
    /* PARENT (HIERARCHY) SUPPORTING FACT TABLES */  
    SELECT DISTINCT  
         h.ID  
        ,@ParentFactTableName AS [Name]  
        ,N'Parent.' + h.Name AS ColumnPrefix  
        ,@MemberType_Consolidated AS MemberTypeID  
        ,N'SupportingFactParent' AS Type  
        ,N'[hp' + h.Name + N']' AS Alias  
        ,mdm.udfTableNameGetByID(@Entity_ID, 4) AS JoinTableName  
        ,N'' AS JoinTableColumn  
        ,N'hr' AS JoinTableAlias  
        ,mdm.udfTableNameGetByID(@Entity_ID, 4) AS PhysicalTableName  
    FROM mdm.tblBRItemProperties p  
    INNER JOIN mdm.tblBRItem i  
    ON p.BRItem_ID = i.ID  
    INNER JOIN mdm.tblBRLogicalOperatorGroup g  
    ON i.BRLogicalOperatorGroup_ID = g.ID  
    INNER JOIN mdm.tblBRBusinessRule br  
    ON g.BusinessRule_ID = br.ID  
    INNER JOIN @PublishableStatus ps  
    ON br.Status_ID = ps.ID  
    INNER JOIN mdm.tblHierarchy h  
    ON      p.[Value] = CONVERT(NVARCHAR, h.ID)  
        AND p.PropertyType_ID = @ParentAttributeProperty  
        AND p.Parent_ID is null  
    WHERE   br.Entity_ID = @Entity_ID  
        AND br.MemberType_ID = @MemberType_ID  
  
    ORDER BY  
        h.ID;  
  
    /* PARENT (HIERARCHY) SUPPORTING FACT TABLE ATTRIBUTES */  
    SELECT DISTINCT  
        cast(p_parent.[Value] AS INT) AS ParentFactID,  
        col.COLUMN_NAME As [Name],  
        a.DisplayName,  
        a.ID AS TableColumnID,  
        a.AttributeType_ID AS AttributeTypeID,  
        a.DomainEntity_ID AS DomainEntityID,  
        0 AS IsDomainEntityRefreshRequired,  
        CASE WHEN recur.ID IS NULL THEN 0 ELSE 1 END AS IsRecursiveInheritance,  
        a.SortOrder AS Ordinal,  
        col.DATA_TYPE AS SQLType,  
        col.CHARACTER_MAXIMUM_LENGTH AS MaxLength,  
        col.NUMERIC_PRECISION AS NumericPrecision,  
        col.NUMERIC_SCALE AS NumericScale  
    FROM mdm.tblBRItemProperties p  
    INNER JOIN mdm.tblBRItem i  
    ON p.BRItem_ID = i.ID  
    INNER JOIN mdm.tblBRLogicalOperatorGroup g  
    ON i.BRLogicalOperatorGroup_ID = g.ID  
    INNER JOIN mdm.tblBRBusinessRule br  
    ON g.BusinessRule_ID = br.ID  
    INNER JOIN @PublishableStatus ps  
    ON br.Status_ID = ps.ID  
    INNER JOIN mdm.tblAttribute a  
    ON      p.[Value] = CONVERT(NVARCHAR, a.ID)  
        AND p.PropertyType_ID = @AttributeProperty  
        AND p.Parent_ID IS NOT NULL  
    INNER JOIN mdm.tblBRItemProperties p_parent  
    ON      p.Parent_ID = p_parent.ID  
        AND p_parent.PropertyType_ID = @ParentAttributeProperty  
    INNER JOIN INFORMATION_SCHEMA.COLUMNS col  
    ON      col.TABLE_NAME = @ParentFactTableName  
        AND col.TABLE_SCHEMA = 'mdm'  
        AND col.COLUMN_NAME = a.Name COLLATE database_default  
    LEFT JOIN @RecursiveInheritanceAttributes recur  
    ON a.ID = recur.ID  
    WHERE   br.Entity_ID = @Entity_ID  
        AND br.MemberType_ID = @MemberType_ID  
    ORDER BY  
        a.SortOrder;  
  
    -- Business rule attribute value properties  
    SELECT  
         bri.ID AS RuleItemID  
        ,attributes.Name AS AttributeName  
    FROM mdm.tblBRBusinessRule br  
    INNER JOIN @PublishableStatus ps  
    ON br.Status_ID = ps.ID  
    INNER JOIN mdm.tblBRLogicalOperatorGroup grp  
    ON br.ID = grp.BusinessRule_ID  
    INNER JOIN mdm.tblBRItem bri  
    ON grp.ID = bri.BRLogicalOperatorGroup_ID  
    INNER JOIN mdm.tblBRItemProperties brip  
    ON bri.ID = brip.BRItem_ID  
    INNER JOIN mdm.tblAttribute attributes  
    ON      br.Entity_ID = attributes.Entity_ID  
        AND brip.Value = CONVERT(NVARCHAR, attributes.ID)  
        AND br.MemberType_ID = attributes.MemberType_ID  
    WHERE   brip.PropertyType_ID = @AttributeProperty  
        AND brip.PropertyName_ID = @ValuePropertyName_ID  
        AND br.Entity_ID = @Entity_ID  
        AND br.MemberType_ID = @MemberType_ID  
    ORDER BY attributes.ID  
  
  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpBusinessRuleItemDelete]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpBusinessRuleItemDelete]  
(  
    @User_ID        INT,  
    @MUID           UNIQUEIDENTIFIER,  
    @RuleMUID       UNIQUEIDENTIFIER = NULL OUTPUT,  
    @CorrelationID  UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON  
  
    DECLARE  
        @GuidEmpty                  UNIQUEIDENTIFIER = CAST(0x0 AS UNIQUEIDENTIFIER),  
        @ID                         INT,  
        @LogicalOperatorGroupId     INT,  
        @LogicalOperatorGroupMUID   UNIQUEIDENTIFIER,  
        @ItemType                   INT, -- condition or action  
  
        @ActionTypeId               INT = 2,  
        @Permission_Admin           TINYINT = 5;  
  
    SET @RuleMUID = NULL;  
    SET @MUID = NULLIF(@MUID, @GuidEmpty);  
  
    SELECT  
        @ID = it.ID,  
        @RuleMUID = br.MUID,  
        @LogicalOperatorGroupId = lg.ID,  
        @LogicalOperatorGroupMUID = lg.MUID,  
        @ItemType = lr.Parent_ID  
    FROM mdm.tblBRItem it  
    INNER JOIN mdm.tblBRLogicalOperatorGroup lg  
    ON it.BRLogicalOperatorGroup_ID = lg.ID  
    INNER JOIN mdm.tblBRBusinessRule br  
    ON lg.BusinessRule_ID = br.ID  
    INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_ENTITY se  
    ON br.Entity_ID = se.ID AND se.User_ID = @User_ID  
    LEFT JOIN mdm.tblBRItemTypeAppliesTo itat  
    ON it.BRItemAppliesTo_ID = itat.ID  
    LEFT JOIN mdm.tblListRelationship lr  
    ON itat.ApplyTo_ID = lr.ID  
    WHERE @MUID IS NOT NULL  
        AND it.MUID = @MUID  
        AND se.Privilege_ID = @Permission_Admin;  
  
    IF @ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR400027|The rule item MUID is not valid.', 16, 1);  
        RETURN;  
    END  
  
    -- delete all item properties  
    DELETE FROM mdm.tblBRItemProperties WHERE BRItem_ID = @ID  
          
    -- delete the item  
    DELETE FROM mdm.tblBRItem WHERE ID = @ID  
  
    -- delete the owning logical operator group *if* the deleted BRItem was the rule's last Action item  
    IF @ItemType = @ActionTypeId AND NOT EXISTS (SELECT 1 FROM mdm.tblBRItem WHERE BRLogicalOperatorGroup_ID = @LogicalOperatorGroupId)  
    BEGIN  
        EXEC mdm.udpBusinessRuleLogicalOperatorGroupDelete @User_ID, @LogicalOperatorGroupMUID  
    END  
  
    SET NOCOUNT OFF  
END
GO
/****** Object:  StoredProcedure [mdm].[udpBusinessRuleItemPropertySave]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
No need check user permission.  
The permission should be checked on BusinessRuleItem level  
*/  
CREATE PROCEDURE [mdm].[udpBusinessRuleItemPropertySave]  
(  
    @SaveMode               TINYINT = 0, -- 0 = Create, 1 = Clone, 2 = Update    
    @BRItem_ID              INT = NULL,    
    @PropertyType_ID        INT = NULL,    
    @PropertyName_ID        INT = NULL,    
    @Value                  NVARCHAR(999) = NULL, -- possible values: freeform/blank string, Attribute muid, Hierarchy muid, or AttributeValue code    
    @AttributeName          NVARCHAR(128) = NULL, -- optional    
    @Sequence               INT = NULL,    
    @IsLeftHandSide         BIT = NULL,    
    @Parent_ID              INT = NULL,    
    @SuppressText           BIT = NULL,    
    @MUID                   UNIQUEIDENTIFIER = NULL OUTPUT, /*Input and output*/    
    @ID                     INT = NULL OUTPUT, /*Output only*/    
    @BypassUdsValidation     BIT = 0,  
    @CorrelationID          UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability    
)    
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN    
    SET NOCOUNT ON    
    
    DECLARE    
        @ValueMuid                          UNIQUEIDENTIFIER,    
    
        @SaveMode_Create                    TINYINT = 0,    
        @SaveMode_Clone                     TINYINT = 1,    
        @SaveMode_Update                    TINYINT = 2,    
    
        @PropertyType_Constant              INT = 1,    
        @PropertyType_Attribute             INT = 2,    
        @PropertyType_ParentAttribute       INT = 3,    
        @PropertyType_DBAAttribute          INT = 4,    
        @PropertyType_AttributeValue        INT = 5,    
        @PropertyType_Blank                 INT = 6,    
        @PropertyType_ChangeTrackingGroup   INT = 7,    
        @PropertyType_UserScriptParameter   INT = 8,    
    
        @GuidEmpty                          UNIQUEIDENTIFIER = CAST(0x0 AS UNIQUEIDENTIFIER);    
    
    SELECT    
        @Parent_ID = NULLIF(@Parent_ID, 0),    
        @BRItem_ID = NULLIF(@BRItem_ID, 0),    
        @MUID = NULLIF(@MUID, @GuidEmpty),    
        @ID = NULL;    
    
    IF @SaveMode = @SaveMode_Clone    
    BEGIN    
        IF @MUID IS NOT NULL AND EXISTS (SELECT 1 FROM mdm.tblBRItemProperties WHERE MUID = @MUID)    
        BEGIN    
            SET @SaveMode = @SaveMode_Update;    
        END    
        ELSE    
        BEGIN    
            SET @SaveMode = @SaveMode_Create;    
        END    
    END    
    
    IF @SaveMode = @SaveMode_Create    
    BEGIN    
        SET @MUID = COALESCE(@MUID, NEWID());    
    END    
    
    IF @SaveMode = @SaveMode_Update    
    BEGIN    
        -- made sure a MUID of an existing row was given    
        IF @MUID IS NULL OR NOT EXISTS (SELECT 1 FROM mdm.tblBRItemProperties WHERE MUID = @MUID)    
        BEGIN    
            RAISERROR('MDSERR400001|The Update operation failed. The MUID was not found.', 16, 1);    
            RETURN;    
        END    
    END    
    
    /*    
        The meaning of @Value's input value depends on @PropertyType_ID,    
        as given in the below table:    
    
           @PropertyType_ID         @Value (input)      @Value (output)    
          ******************       ****************    *****************    
            1 (Constant)            freeform string        unchanged    
            2 (Attribute)           Attribute MUID         int ID    
            3 (ParentAttribute)     Hierarchy MUID         int ID    
            4 (DBAAttribute)        Attribute MUID         int ID    
            5 (AttributeValue)      Code (i.e. 'Blue')     unchanged    
            6 (Blank)               doesn't matter         'Blank'    
            8 (UserScriptParameter) string(parameter name)    unchanged    
    
        @Value's output value will contain the correct value for writing to    
        tblBRItemProperties.Value.    
        For @PropertyType_ID values 2 and 4, if @Value's input value is null or invalid,    
        then the Attribute's int ID will be looked up from the given @AttributeName.    
        In all other cases, @AttributeName is ignored.    
    */    
    
    -- TODO EMMAYIN CHECK DATE TYPE COMPATIBILITY    
    IF @PropertyType_ID IN (@PropertyType_Attribute, @PropertyType_ParentAttribute, @PropertyType_DBAAttribute)    
    BEGIN    
        -- try to convert @Value to a GUID    
        BEGIN TRY    
            SET @ValueMuid = CONVERT(UNIQUEIDENTIFIER, @Value)    
        END TRY    
        BEGIN CATCH    
            SET @ValueMuid = NULL    
        END CATCH    
    END    
    
    IF @PropertyType_ID IN (@PropertyType_Attribute, @PropertyType_DBAAttribute)    
    BEGIN    
        IF @ValueMuid IS NOT NULL    
        BEGIN    
            -- lookup the Attribute's ID from its MUID    
            SET @Value = CONVERT(NVARCHAR(999), (SELECT ID FROM mdm.tblAttribute WHERE MUID = @ValueMuid));    
        END    
    
        IF @Value IS NULL AND @AttributeName IS NOT NULL    
        BEGIN    
            -- lookup the Attribute ID from the given @AttributeName    
            SET @Value = CONVERT(NVARCHAR(999),(    
                SELECT a.Attribute_ID    
                FROM mdm.tblBRItem it    
                 INNER JOIN mdm.tblBRLogicalOperatorGroup lg    
                 ON it.ID = @BRItem_ID    
                    AND it.BRLogicalOperatorGroup_ID = lg.ID    
                 INNER JOIN mdm.viw_SYSTEM_SCHEMA_BUSINESSRULES b    
                 ON lg.BusinessRule_ID = b.BusinessRule_ID    
                 INNER JOIN mdm.viw_SYSTEM_SCHEMA_ATTRIBUTES a    
                 ON a.Attribute_Name = @AttributeName    
                    AND b.Entity_ID = a.Entity_ID));    
        END    
    
        IF @Value IS NULL    
        BEGIN    
            RAISERROR('MDSERR400003|The attribute reference is not valid. The attribute was not found.', 16, 1);    
            RETURN;    
        END    
    END ELSE IF @PropertyType_ID = @PropertyType_ParentAttribute    
    BEGIN    
        -- lookup the Hierarchy's ID from its MUID    
        SET @Value = CONVERT(NVARCHAR(999), (SELECT ID FROM mdm.tblHierarchy WHERE MUID = @ValueMuid));    
    
        IF @Value IS NULL    
        BEGIN    
            RAISERROR('MDSERR400021|The hierarchy identifier is not valid. The MUID was not found.', 16, 1);    
            RETURN;    
        END    
    END    
    ELSE IF @PropertyType_ID = @PropertyType_AttributeValue    
    BEGIN    
        -- @Value is a member code, so trim its whitespace. Note that the member code should not be validated (i.e. checked to make sure    
        -- there exists a member with the specified code) here, so that it is possible for Model Deployment to deploy business rules with metadata, but    
        -- without master data.    
        SET @Value = LTRIM(RTRIM(@Value));    
    END    
    ELSE    
    IF @PropertyType_ID = @PropertyType_Blank    
    BEGIN    
        SET @Value = CONVERT(NVARCHAR(999), N'Blank')    
    END    
    ELSE IF @PropertyType_ID = 8 AND @BypassUdsValidation = 0   
    BEGIN -- User defined script name    
        DECLARE @BRItemAnchorName NVARCHAR(256),    
                @ErrorMsg NVARCHAR(MAX),    
                @AppliesToAction BIT;    
    
        -- Verify if corresponding BRItem's BRItemType is UserDefinedScript (ID:34)    
        SET @Value = LTRIM(RTRIM(@Value));    
    
        SELECT @BRItemAnchorName = AnchorName, @AppliesToAction = via.BRTypeID-1    
        FROM mdm.tblBRItem item    
        INNER JOIN mdm.viw_SYSTEM_SCHEMA_BUSINESSRULE_ITEMTYPES via    
        ON item.BRItemAppliesTo_ID = via.AppliesTo_ID    
        WHERE item.ID = @BRItem_ID AND via.BRItemType_ID = 34    
    
        IF @BRItemAnchorName = NULL    
        BEGIN    
            RAISERROR('MDSERR400063|Cannot assign a script parameter to a non user script business rule item.', 16, 1);    
            RETURN    
        END    
    
        SET @Sequence = NULL    
    
        SELECT @Sequence = P.parameter_id    
        FROM sys.objects AS SO    
        INNER JOIN sys.parameters AS P    
        ON SO.object_id = P.object_id    
        WHERE P.name = @Value    
            AND SO.object_id IN (    
                SELECT object_id    
                FROM sys.objects    
                WHERE type = (CASE WHEN @AppliesToAction = 1 THEN N'P' ELSE N'FN' END)    
                    AND schema_id = SCHEMA_ID(N'usr')    
                    AND name = @BRItemAnchorName)    
    
        IF @Sequence IS NULL    
        BEGIN    
            SET @ErrorMsg = 'MDSERR400064|The parameter {0} is not defined in {1}.|'+ @Value+'|'+ @BRItemAnchorName    
            SET @ErrorMsg = REPLACE(@ErrorMsg, '%', '%%')-- escape out format specifier    
            RAISERROR(@ErrorMsg, 16, 1);    
            RETURN    
        END    
    END    
    
    IF @SaveMode = @SaveMode_Create    
    BEGIN    
        -- add row    
        INSERT INTO mdm.tblBRItemProperties (    
            MUID,    
            BRItem_ID,    
            PropertyType_ID,    
            PropertyName_ID,    
            [Value],    
            [Sequence],    
            IsLeftHandSide,    
            Parent_ID,    
            SuppressText    
        )    
        VALUES (    
            @MUID,    
            @BRItem_ID,    
            @PropertyType_ID,    
            @PropertyName_ID,    
            @Value,    
            @Sequence,    
            @IsLeftHandSide,    
            @Parent_ID,    
            @SuppressText    
        );    
    
        -- set output params    
        IF @@ERROR = 0    
        BEGIN    
            SET @ID = SCOPE_IDENTITY();    
        END    
    END    
    ELSE    
    BEGIN    
        -- update row    
        UPDATE mdm.tblBRItemProperties    
        SET BRItem_ID = @BRItem_ID,    
            PropertyType_ID = @PropertyType_ID,    
            PropertyName_ID = @PropertyName_ID,    
            [Value] = @Value,    
            [Sequence] = @Sequence,    
            IsLeftHandSide = @IsLeftHandSide,    
            Parent_ID = @Parent_ID,    
            SuppressText = @SuppressText    
        WHERE MUID = @MUID    
    
        -- set output params    
        IF @@ERROR = 0    
        BEGIN    
            SELECT @ID = ID FROM mdm.tblBRItemProperties WHERE MUID = @MUID;    
        END    
    END    
    
    SET NOCOUNT OFF    
END
GO
/****** Object:  StoredProcedure [mdm].[udpBusinessRuleItemSave]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpBusinessRuleItemSave]  
(  
    @User_ID                        INT = NULL,    
    @SaveMode                       TINYINT = 0, -- 0 = Create, 1 = Clone, 2 = Update    
    @BRLogicalOperatorGroup_MUID    UNIQUEIDENTIFIER = NULL OUTPUT,    -- required for Conditions, optional for Actions (will be found/created if not provided)    
    @Rule_MUID                      UNIQUEIDENTIFIER = NULL,    
    @MemberType_ID                  TINYINT = NULL,    
    @ItemType_ID                    INT = NULL,    
    @ItemCategory                   TINYINT  = NULL, -- 1 Condition 2 ThenAction 3 ElseActioin    
    @AnchorName                     NVARCHAR(250),    
    @AnchorAttribute_MUID           UNIQUEIDENTIFIER = NULL,    -- required    
    @Sequence                       INT = NULL,    
    @ItemText                       NVARCHAR(MAX) = NULL,    
    @ArgumentMuids                  XML = NULL, -- must contain Muids of all tblBRItemProperties rows belonging to the BRItem    
    @MUID                           UNIQUEIDENTIFIER = NULL OUTPUT, -- Input (Clone or Update) and output    
    @ID                             INT = NULL OUTPUT, -- Output only    
    @BypassUdsValidation            BIT = 0,  
    @CorrelationID                  UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability    
)    
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN    
    SET NOCOUNT ON    
    
    DECLARE    
        @Rule_ID                        INT,    
        @BRLogicalOperatorGroup_ID      INT,    
        @BRItemAppliesTo_ID             INT,    
        @AnchorDataTypeID               INT,    
        @AnchorID                       INT,    
        @AnchorAttributeType            INT,    
        @Entity_ID                      INT,    
    
        @ItemType_Workflow              INT = 32, -- From tblBRItemType.ID    
    
        @Model_Permission               INT,    
    
        @Permission_Admin               INT = 5,    
    
        @SaveMode_Create                TINYINT = 0,    
        @SaveMode_Clone                 TINYINT = 1,    
        @SaveMode_Update                TINYINT = 2,    
    
        @MemberType_Leaf                TINYINT = 1,    
        @MemberType_Consolidated        TINYINT = 2,    
    
        @GuidEmpty                      UNIQUEIDENTIFIER = CAST(0x0 AS UNIQUEIDENTIFIER);    
    
    SELECT    
        @BRLogicalOperatorGroup_MUID = NULLIF(@BRLogicalOperatorGroup_MUID, @GuidEmpty),    
        @Rule_MUID = NULLIF(@Rule_MUID, @GuidEmpty),    
        @AnchorName = NULLIF(LTRIM(RTRIM(@AnchorName)), N''),    
        @AnchorAttribute_MUID = NULLIF(@AnchorAttribute_MUID, @GuidEmpty),    
        @ItemText = NULLIF(LTRIM(RTRIM(@ItemText)), N''),    
        @MUID = NULLIF(@MUID, @GuidEmpty),    
        @ID = NULL;    
    
    IF @SaveMode = @SaveMode_Clone    
    BEGIN    
        IF @MUID IS NOT NULL AND EXISTS (SELECT 1 FROM mdm.tblBRItem WHERE MUID = @MUID)    
        BEGIN    
            SET @SaveMode = @SaveMode_Update;    
        END    
        ELSE    
        BEGIN    
            SET @SaveMode = @SaveMode_Create;    
        END    
    END    
    
    IF @SaveMode = @SaveMode_Create    
    BEGIN    
        SET @MUID = COALESCE(@MUID, NEWID());    
    END    
    
    IF @SaveMode = @SaveMode_Update    
    BEGIN    
        -- made sure a MUID of an existing row was given    
        IF @MUID IS NULL OR NOT EXISTS (SELECT 1 FROM mdm.tblBRItem WHERE MUID = @MUID)    
        BEGIN    
            RAISERROR('MDSERR400001|The Update operation failed. The MUID was not found.', 16, 1);    
            RETURN;    
        END    
    END    
    
    SELECT    
        @Rule_ID = ID,    
        @Entity_ID = [Entity_ID]    
    FROM mdm.tblBRBusinessRule    
    WHERE MUID = @Rule_MUID    
    
    IF @Rule_ID IS NULL    
    BEGIN    
        RAISERROR('MDSERR400005|The business rule MUID is not valid.', 16, 1);    
        RETURN    
    END    
    
    SELECT @Model_Permission = m.Privilege_ID    
    FROM mdm.viw_SYSTEM_SECURITY_USER_MODEL m    
    INNER JOIN mdm.tblEntity en ON m.ID = en.Model_ID    
    WHERE [User_ID] = @User_ID AND en.ID = @Entity_ID;    
    
    IF @Model_Permission <> @Permission_Admin    
    BEGIN    
        RAISERROR('MDSERR120003|The user does not have permission or the object ID is not valid.', 16, 1);    
        RETURN;    
    END    
    
    -- Getanchorattribute    
    IF @ItemType_ID = 34 -- User defined script    
    BEGIN    
        IF @BypassUdsValidation = 0 And mdm.udfScriptExists(@AnchorName, (CASE WHEN @ItemCategory = 1 THEN 1 ELSE 2 END) , 'usr') = 0    
        BEGIN    
            IF @ItemCategory = 1    
            RAISERROR('MDSERR400060|Could not find SQL Function |%s| with return type BIT in usr schema.', 16, 1, @AnchorName);    
            ELSE    
            RAISERROR('MDSERR400061|Could not find SQL Stored Procedure |%s| with the first parameter type as mdm.MemberId and the second parameter type as string in usr schema.', 16, 1, @AnchorName);    
        END    
    END    
    ELSE    
    BEGIN    
        -- get AnchorAttribute properties    
        SELECT    
            @AnchorID = Attribute_ID,    
            @AnchorDataTypeID = Attribute_DataType_ID,    
            @AnchorAttributeType = Attribute_Type_ID    
        FROM mdm.viw_SYSTEM_SCHEMA_ATTRIBUTES vAtt    
        WHERE vAtt.Attribute_MUID = @AnchorAttribute_MUID    
            OR (vAtt.Attribute_Name = @AnchorName AND  vAtt.[Entity_ID] = @Entity_ID)    
    
        IF (@AnchorID IS NULL)    
        BEGIN    
            RAISERROR('MDSERR400003|The attribute reference is not valid. The attribute was not found.', 16, 1);    
            RETURN    
        END    
    
        -- check compatibility between operation and anchor    
        IF mdm.udfBusinessRuleIsItemTypeCompatible(@AnchorAttributeType, @AnchorDataTypeID, @ItemType_ID) <> 1    
        BEGIN    
            RAISERROR('MDSERR400004|The operation is not supported for the attribute type.', 16, 1);    
            RETURN    
        END    
    END    
    
    -- get @BRLogicalOperatorGroup_ID    
    IF (@BRLogicalOperatorGroup_MUID IS NOT NULL)    
    BEGIN    
        SELECT @BRLogicalOperatorGroup_ID = ID FROM mdm.tblBRLogicalOperatorGroup WHERE MUID = @BRLogicalOperatorGroup_MUID;    
    END    
    IF (@BRLogicalOperatorGroup_ID IS NULL AND @ItemCategory <> 1)    
    BEGIN    
        -- search for existing Action operator group row    
        SELECT    
            @BRLogicalOperatorGroup_ID = logp.ID,    
            @BRLogicalOperatorGroup_MUID = logp.MUID    
        FROM mdm.tblBRLogicalOperatorGroup logp    
        INNER JOIN mdm.tblBRItem it ON logp.ID = it.BRLogicalOperatorGroup_ID    
            AND logp.BusinessRule_ID = @Rule_ID    
            AND logp.Parent_ID IS NULL -- no parent    
            AND logp.LogicalOperator_ID = 1 --AND operator    
        INNER JOIN mdm.tblBRItemTypeAppliesTo itat ON it.BRItemAppliesTo_ID = itat.ID    
        INNER JOIN mdm.tblListRelationship lr ON itat.ApplyTo_ID = lr.ID    
            AND lr.Parent_ID = 2 -- Action    
        ORDER BY logp.ID    
    
        IF (@BRLogicalOperatorGroup_ID IS NULL)    
        BEGIN    
        SET @BRLogicalOperatorGroup_MUID = NEWID()    
            -- couldn't find existing row, so add one    
            INSERT INTO mdm.tblBRLogicalOperatorGroup (    
                LogicalOperator_ID,    
                BusinessRule_ID,    
                [Sequence],    
                MUID    
            )    
            VALUES (    
                1,-- 1 = AND Operator    
                @Rule_ID,    
                1,    
                @BRLogicalOperatorGroup_MUID    
            )    
            SET @BRLogicalOperatorGroup_ID = SCOPE_IDENTITY();    
        END    
    END    
    
    IF @BRLogicalOperatorGroup_ID IS NULL    
    BEGIN    
        RAISERROR('MDSERR400006|The logical operator group MUID is not valid.', 16, 1);    
        RETURN    
    END    
    
    SET @BRItemAppliesTo_ID = mdm.udfBusinessRuleGetBRItemAppliesToID(@ItemType_ID, @ItemCategory, @MemberType_ID)    
    IF (@BRItemAppliesTo_ID IS NULL) BEGIN    
        RAISERROR('MDSERR400007|The operation is not valid for the condition or action.', 16, 1);    
        RETURN    
    END    
    
    -- If the rule item is Workflow, ensure that no other items within the same rule are Workflow.    
    
    IF @ItemType_ID = @ItemType_Workflow    
        AND EXISTS(    
            SELECT 1    
            FROM mdm.tblBRItem i    
            LEFT JOIN mdm.tblBRItemTypeAppliesTo itat ON i.BRItemAppliesTo_ID = itat.ID    
            WHERE  i.BRLogicalOperatorGroup_ID = @BRLogicalOperatorGroup_ID -- All actions within the same rule will share the same logical operator group.    
                AND itat.BRItemType_ID = @ItemType_Workflow    
                AND (@MUID IS NULL OR i.MUID <> @MUID))    
    BEGIN    
        RAISERROR('MDSERR400041|A rule cannot contain more than one Workflow action.', 16, 1);    
        RETURN;    
    END;    
    
    IF @SaveMode = @SaveMode_Create    
    BEGIN    
        -- add row    
        INSERT INTO mdm.tblBRItem (    
            MUID,    
            BRLogicalOperatorGroup_ID,    
            BRItemAppliesTo_ID,    
            [Sequence],    
            ItemText,    
            AnchorName,    
            AnchorAttributeType    
        )    
        VALUES (    
            @MUID,    
            @BRLogicalOperatorGroup_ID,    
            @BRItemAppliesTo_ID,    
            @Sequence,    
            @ItemText,    
            @AnchorName,    
            @AnchorAttributeType    
        );    
    
        -- set output params    
        IF @@ERROR = 0    
        BEGIN    
            SET @ID = SCOPE_IDENTITY();    
        END    
    END    
    ELSE    
        BEGIN    
        -- delete unused arguments    
        DELETE FROM mdm.tblBRItemProperties    
        WHERE BRItem_ID = @ID    
            AND MUID NOT IN (    
                SELECT    
                DISTINCT am.MUID.value(N'.',N'UNIQUEIDENTIFIER') MUID    
                FROM @ArgumentMuids.nodes(N'//guid') am(MUID))    
    
        -- update row    
        UPDATE mdm.tblBRItem    
        SET BRLogicalOperatorGroup_ID = @BRLogicalOperatorGroup_ID,    
            BRItemAppliesTo_ID = @BRItemAppliesTo_ID,    
            [Sequence] = @Sequence,    
            ItemText = @ItemText,    
            AnchorName = @AnchorName,    
            AnchorAttributeType = @AnchorAttributeType    
        WHERE MUID = @MUID    
    
        -- set output params    
        IF @@ERROR = 0    
        BEGIN    
            SELECT @ID = ID FROM mdm.tblBRItem WHERE MUID = @MUID;    
        END    
    END    
    SET NOCOUNT OFF    
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpBusinessRuleLogicalOperatorGroupDelete]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpBusinessRuleLogicalOperatorGroupDelete]  
(  
    @User_ID        INT,  
    @MUID           UNIQUEIDENTIFIER,  
    @RuleMUID       UNIQUEIDENTIFIER = NULL OUTPUT,  
    @CorrelationID  UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON  
      
    DECLARE  
        @GuidEmpty          UNIQUEIDENTIFIER = CAST(0x0 AS UNIQUEIDENTIFIER),  
        @ID                 INT,  
  
        @Permission_Admin   TINYINT = 5;  
  
    SET @RuleMUID = NULL;  
    SET @MUID = NULLIF(@MUID, @GuidEmpty);  
  
    -- find the item ID  
    DECLARE @RuleID INT;  
  
    SELECT   
        @ID = lg.ID,  
        @RuleMUID = br.MUID  
    FROM mdm.tblBRLogicalOperatorGroup lg  
    INNER JOIN mdm.tblBRBusinessRule br  
    ON lg.BusinessRule_ID = br.ID  
    INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_ENTITY se  
    ON br.Entity_ID = se.ID AND se.User_ID = @User_ID  
    WHERE @MUID IS NOT NULL  
        AND lg.MUID = @MUID  
        AND se.Privilege_ID = @Permission_Admin;  
  
    IF @ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR400006|The logical operator group MUID is not valid.', 16, 1);  
        RETURN;  
    END  
          
    -- delete all child rule items and their properties  
    DECLARE @ChildMuids TABLE (MUID UNIQUEIDENTIFIER PRIMARY KEY)  
    INSERT INTO @ChildMuids  
        SELECT MUID FROM mdm.tblBRItem WHERE BRLogicalOperatorGroup_ID = @ID;  
    DECLARE @ChildMuid UNIQUEIDENTIFIER SET @ChildMuid = (SELECT TOP 1 MUID FROM @ChildMuids);  
    WHILE @ChildMuid IS NOT NULL BEGIN  
        EXEC mdm.udpBusinessRuleItemDelete @User_ID, @ChildMuid  
        DELETE FROM @ChildMuids WHERE MUID = @ChildMuid  
        SET @ChildMuid = (SELECT TOP 1 MUID FROM @ChildMuids);  
    END  
  
    -- delete all child logical operator groups  
    INSERT INTO @ChildMuids  
        SELECT MUID FROM mdm.tblBRLogicalOperatorGroup WHERE ISNULL(Parent_ID, 0) = @ID;  
    SET @ChildMuid = (SELECT TOP 1 MUID FROM @ChildMuids);  
    WHILE @ChildMuid IS NOT NULL BEGIN  
        EXEC mdm.udpBusinessRuleLogicalOperatorGroupDelete @User_ID, @ChildMuid  
        DELETE FROM @ChildMuids WHERE MUID = @ChildMuid  
        SET @ChildMuid = (SELECT TOP 1 MUID FROM @ChildMuids);  
    END  
  
    -- delete the logical operator group  
    DELETE FROM mdm.tblBRLogicalOperatorGroup WHERE ID = @ID  
  
    SET NOCOUNT OFF  
END
GO
/****** Object:  StoredProcedure [mdm].[udpBusinessRuleLogicalOperatorGroupSave]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpBusinessRuleLogicalOperatorGroupSave]  
(  
    @User_ID                INT = NULL,  
    @SaveMode               TINYINT = 0, -- 0 = Create, 1 = Clone, 2 = Update  
    @Rule_MUID              UNIQUEIDENTIFIER = NULL,  
    @LogicalOperator_ID     INT = NULL, /* 1= AND, 2 = OR */  
    @Parent_MUID            UNIQUEIDENTIFIER = NULL,  
    @Sequence               INT = NULL,  
    @MUID                   UNIQUEIDENTIFIER = NULL OUTPUT, /*Input (Clone only) and output*/  
    @ID                     INT = NULL OUTPUT, /*Output only*/  
    @CorrelationID          UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON  
  
    DECLARE @Rule_ID                        INT,  
            @Parent_ID                      INT,  
            @Entity_ID                      INT,  
  
            @Model_Permission               INT,  
  
            @Permission_Deny                INT = 1,  
            @Permission_Admin               INT = 5,  
  
            @GuidEmpty                      UNIQUEIDENTIFIER = CAST(0x0 AS UNIQUEIDENTIFIER),  
  
            @SaveMode_Create                TINYINT = 0,  
            @SaveMode_Clone                 TINYINT = 1,  
            @SaveMode_Update                TINYINT = 2;  
  
    SELECT  
        @Rule_MUID = NULLIF(@Rule_MUID, @GuidEmpty),  
        @Parent_MUID = NULLIF(@Parent_MUID, @GuidEmpty),  
        @MUID = NULLIF(@MUID, @GuidEmpty),  
        @ID = NULL;  
  
    IF @SaveMode = @SaveMode_Clone  
    BEGIN  
        IF @MUID IS NOT NULL AND EXISTS (SELECT 1 FROM mdm.tblBRLogicalOperatorGroup WHERE MUID = @MUID)  
        BEGIN  
            SET @SaveMode = @SaveMode_Update;  
        END  
        ELSE  
        BEGIN  
            SET @SaveMode = @SaveMode_Create;  
        END  
    END  
  
    IF @SaveMode = @SaveMode_Create  
    BEGIN  
        SET @MUID = COALESCE(@MUID, NEWID());  
    END  
  
    IF @SaveMode = @SaveMode_Update  
    BEGIN  
        -- made sure a MUID of an existing row was given  
        IF @MUID IS NULL OR NOT EXISTS (SELECT 1 FROM mdm.tblBRLogicalOperatorGroup WHERE MUID = @MUID)  
        BEGIN  
            RAISERROR('MDSERR400001|The Update operation failed. The MUID was not found.', 16, 1);  
            RETURN;  
        END  
    END  
  
    SELECT  
        @Rule_ID = ID,  
        @Entity_ID = [Entity_ID]  
    FROM mdm.tblBRBusinessRule  
    WHERE MUID = @Rule_MUID;  
  
    IF @Rule_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR400005|The business rule MUID is not valid.', 16, 1);  
        RETURN  
    END  
  
    SELECT @Model_Permission = m.Privilege_ID  
    FROM mdm.viw_SYSTEM_SECURITY_USER_MODEL m  
    INNER JOIN mdm.tblEntity en ON m.ID = en.Model_ID  
    WHERE [User_ID] = @User_ID AND en.ID = @Entity_ID;  
  
    IF @Model_Permission <> @Permission_Admin  
    BEGIN  
        RAISERROR('MDSERR120003|The user does not have permission or the object ID is not valid.', 16, 1);  
        RETURN;  
    END  
  
    -- get parent ID  
    IF @Parent_MUID IS NOT NULL  
    BEGIN  
        SELECT @Parent_ID = ID FROM mdm.tblBRLogicalOperatorGroup WHERE MUID = @Parent_MUID;  
  
        IF @Parent_ID IS NULL  
        BEGIN  
            RAISERROR('MDSERR400020|The MUID for the parent tree node is not valid.', 16, 1);  
            RETURN;  
        END  
    END  
  
    IF @SaveMode = @SaveMode_Create  
    BEGIN  
     -- add row  
        INSERT INTO mdm.tblBRLogicalOperatorGroup (  
            MUID,  
            LogicalOperator_ID,  
            Parent_ID,  
            BusinessRule_ID,  
            [Sequence]  
        )  
        VALUES (  
            @MUID,  
            @LogicalOperator_ID,  
            @Parent_ID,  
            @Rule_ID,  
            @Sequence  
        );  
  
        IF @@ERROR = 0  
        BEGIN  
            SET @ID = SCOPE_IDENTITY();  
        END  
    END  
    ELSE  
    BEGIN  
        -- update row  
        UPDATE mdm.tblBRLogicalOperatorGroup  
        SET LogicalOperator_ID = @LogicalOperator_ID,  
            Parent_ID = @Parent_ID,  
            BusinessRule_ID = @Rule_ID,  
            [Sequence] = @Sequence  
        WHERE MUID = @MUID  
  
        IF @@ERROR = 0  
        BEGIN  
            SELECT @ID = ID FROM mdm.tblBRLogicalOperatorGroup WHERE MUID = @MUID;  
        END  
    END  
  
    SET NOCOUNT OFF  
END
GO
/****** Object:  StoredProcedure [mdm].[udpBusinessRuleLogicalOperatorGroupsDelete]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
exec mdm.udpBusinessRuleLogicalOperatorGroupsDelete 1  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpBusinessRuleLogicalOperatorGroupsDelete]  
(  
    @RuleIDs mdm.IdList READONLY,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON  
  
    BEGIN TRANSACTION  
  
    -- Delete associated business rule item properties  
    DELETE  
    FROM    mdm.tblBRItemProperties  
    WHERE    BRItem_ID IN  
        (  
        SELECT    i.ID  
        FROM     mdm.tblBRItem i INNER JOIN  
            mdm.tblBRLogicalOperatorGroup l ON   
                i.BRLogicalOperatorGroup_ID = l.ID AND  
                l.BusinessRule_ID IN (SELECT ID FROM @RuleIDs)  
        )  
  
    -- Delete associated business rule items  
    DELETE  
    FROM    mdm.tblBRItem  
    WHERE    BRLogicalOperatorGroup_ID IN  
        (  
        SELECT    ID  
        FROM     mdm.tblBRLogicalOperatorGroup  
        WHERE    BusinessRule_ID IN (SELECT ID FROM @RuleIDs)  
        )  
  
    -- Delete logical operator groups  
    DELETE      
    FROM     mdm.tblBRLogicalOperatorGroup  
    WHERE    BusinessRule_ID IN (SELECT ID FROM @RuleIDs);  
  
    -- Clear RuleText and change status to unpublished  
    UPDATE    mdm.tblBRBusinessRule  
    SET    RuleConditionText = CAST(N''  AS NVARCHAR(1000)),  
        RuleActionText = CAST(N'' AS NVARCHAR(1000)),  
        RuleElseActionText = CAST(N'' AS NVARCHAR(1000)),  
        Status_ID = mdm.udfBusinessRuleGetNewStatusID(3, br.Status_ID)  
    FROM    mdm.tblBRBusinessRule br  
    WHERE    br.ID IN (SELECT ID FROM @RuleIDs);  
  
    COMMIT TRANSACTION  
  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpBusinessRuleMarkAsDeletePending]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
exec mdm.udpBusinessRuleMarkAsDeletePending @MUID  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpBusinessRuleMarkAsDeletePending]  
(  
    @User_ID       INT,  
    @MUID          UNIQUEIDENTIFIER,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON  
  
    DECLARE  
        @GuidEmpty              UNIQUEIDENTIFIER = CAST(0x0 AS UNIQUEIDENTIFIER),  
        @ID                     INT,  
  
        @Permission_Admin       TINYINT = 5,  
  
        @Status_DeletePending   INT = 6;  
  
    SET @MUID = NULLIF(@MUID, @GuidEmpty);  
  
    SELECT @ID = br.ID  
    FROM mdm.tblBRBusinessRule br  
    INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_ENTITY se  
    ON br.Entity_ID = se.ID AND se.User_ID = @User_ID  
    WHERE @MUID IS NOT NULL  
        AND MUID = @MUID  
        AND se.Privilege_ID = @Permission_Admin  
  
    IF @ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR400005|The business rule MUID is not valid.', 16, 1);  
        RETURN;  
    END  
  
    -- Mark as Delete Pending  
    UPDATE tblBRBusinessRule  
    SET Status_ID = @Status_DeletePending   
    WHERE ID = @ID  
  
    SET NOCOUNT OFF  
END
GO
/****** Object:  StoredProcedure [mdm].[udpBusinessRuleMarkAsPublished]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
exec mdm.udpBusinessRuleMarkAsPublished 1,1,31  
*/  
CREATE PROCEDURE [mdm].[udpBusinessRuleMarkAsPublished]  
(  
    @Entity_ID      INT,    
    @MemberType_ID  TINYINT,    
    @CorrelationID  UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability    
)    
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN    
    SET NOCOUNT ON    
    
    DECLARE @UpdatedBRs TABLE    
    (    
         ID INT PRIMARY KEY    
        ,NewStatusID INT NOT NULL DEFAULT -1    
    );    
    DECLARE @DeleteBRs mdm.IdList;    
        
    -- Update status of business rules    
    UPDATE tblBRBusinessRule     
    SET Status_ID = mdm.udfBusinessRuleGetNewStatusID(6, br.Status_ID)     
    OUTPUT inserted.ID, inserted.Status_ID INTO @UpdatedBRs    
    FROM    
        mdm.tblBRBusinessRule br     
    WHERE br.Entity_ID = @Entity_ID    
        AND br.MemberType_ID = @MemberType_ID    
    
    -- Delete any business rules that have a status of 'Delete Pending'    
    INSERT INTO @DeleteBRs (ID) SELECT ID FROM @UpdatedBRs WHERE NewStatusID = 6    
    EXEC mdm.udpBusinessRulesDelete @DeleteBRs    
    
    --If there are any business rules that have NO actions then update their status to Undefined.    
    UPDATE	tblBRBusinessRule     
    SET	Status_ID = 0 -- Undefined    
    WHERE ID IN (     
        SELECT BusinessRule_ID     
        FROM mdm.viw_SYSTEM_SCHEMA_BUSINESSRULES     
        WHERE BusinessRule_ID IN (SELECT ID FROM @UpdatedBRs EXCEPT SELECT ID FROM @DeleteBRs) -- Exclude deleted BRs.  No need to update them.    
        EXCEPT -- exclude rules that have actions     
        SELECT DISTINCT br.ID     
        FROM mdm.tblBRItem item    
        INNER JOIN mdm.tblBRLogicalOperatorGroup lg ON item.BRLogicalOperatorGroup_ID = lg.ID  
        INNER JOIN mdm.tblBRBusinessRule br ON lg.BusinessRule_ID = br.ID  
        INNER JOIN mdm.viw_SYSTEM_SCHEMA_BUSINESSRULE_ITEMTYPES i    
        ON item.BRItemAppliesTo_ID = i.AppliesTo_ID AND (i.BRTypeID = 2 OR i.BRTypeID = 3) --Action   
    )    
        
    SET NOCOUNT OFF    
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpBusinessRuleSave]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpBusinessRuleSave]  
(  
    @User_ID                INT = NULL,  
    @SaveMode               TINYINT = 0, -- 0 = Create, 1 = Clone, 2 = Update  
    @Name                   NVARCHAR(50) = NULL,  
    @Description            NVARCHAR(255) = NULL,  
    @RuleConditionText      NVARCHAR(MAX) = NULL,  
    @RuleActionText         NVARCHAR(MAX) = NULL,  
    @RuleElseActionText     NVARCHAR(MAX) = NULL,  
    @Priority               INT = NULL,  
    @NotificationGroupMuid  UNIQUEIDENTIFIER = NULL,  
    @NotificationUserMuid   UNIQUEIDENTIFIER = NULL,  
    @RevisionID             BIGINT = NULL,  
    @Status_ID              INT = NULL,  
    @MemberType_ID          TINYINT,  
    @ClearDefinition        BIT = 0,  
    @Entity_MUID            UNIQUEIDENTIFIER = NULL OUTPUT,  
    @Entity_Name            NVARCHAR(MAX) = NULL OUTPUT,  
    @Model_MUID             UNIQUEIDENTIFIER = NULL OUTPUT,  
    @Model_Name             NVARCHAR(50) = NULL OUTPUT,  
    @MUID                   UNIQUEIDENTIFIER = NULL OUTPUT, /*Input (Clone or Update only) and output*/  
    @ID                     INT = NULL OUTPUT, /*Output only*/  
    @CorrelationID          UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON  
  
    DECLARE @Model_ID                       INT,  
            @Entity_ID                      INT,  
            @NotificationGroup_ID           INT,  
            @NotificationUser_ID            INT,  
  
            @Model_Permission               INT,  
  
            @Permission_Deny                INT = 1,  
            @Permission_Admin               INT = 5,  
  
            @GuidEmpty                      UNIQUEIDENTIFIER = CAST(0x0 AS UNIQUEIDENTIFIER),  
  
            @FunctionalPrivilege_Explorer   TINYINT = 1,  
  
            @SaveMode_Create                TINYINT = 0,  
            @SaveMode_Clone                 TINYINT = 1,  
            @SaveMode_Update                TINYINT = 2,  
  
            @MemberType_Leaf                TINYINT = 1,  
            @MemberType_Consolidated        TINYINT = 2;  
  
  
    SELECT  
        @RevisionID = NULLIF(@RevisionID, 0),  
        @Name = NULLIF(LTRIM(RTRIM(@Name)), N''),  
        @Description = NULLIF(LTRIM(RTRIM(@Description)), N''),  
        @RuleConditionText = NULLIF(LTRIM(RTRIM(@RuleConditionText)), N''),  
        @RuleActionText = NULLIF(LTRIM(RTRIM(@RuleActionText)), N''),  
        @RuleElseActionText = NULLIF(LTRIM(RTRIM(@RuleElseActionText)), N''),  
        @Entity_MUID = NULLIF(@Entity_MUID, @GuidEmpty),  
        @Entity_Name = NULLIF(LTRIM(RTRIM(@Entity_Name)), N''),  
        @Model_MUID = NULLIF(@Model_MUID, @GuidEmpty),  
        @Model_Name = NULLIF(LTRIM(RTRIM(@Model_Name)), N''),  
        @NotificationGroupMuid = NULLIF(@NotificationGroupMuid, @GuidEmpty),  
        @NotificationUserMuid = NULLIF(@NotificationUserMuid, @GuidEmpty),  
        @MUID = NULLIF(@MUID, @GuidEmpty),  
        @ID = NULL;  
  
    IF @SaveMode = @SaveMode_Clone  
    BEGIN  
        IF @MUID IS NOT NULL AND EXISTS (SELECT 1 FROM mdm.tblBRBusinessRule WHERE MUID = @MUID)  
        BEGIN  
            SET @SaveMode = @SaveMode_Update;  
        END  
        ELSE  
        BEGIN  
            SET @SaveMode = @SaveMode_Create;  
        END  
    END  
  
    IF @SaveMode = @SaveMode_Create  
    BEGIN  
        SET @MUID = COALESCE(@MUID, NEWID());  
    END  
  
    IF @SaveMode = @SaveMode_Update  
    BEGIN  
        -- made sure a MUID of an existing row was given  
        IF @MUID IS NULL OR NOT EXISTS (SELECT 1 FROM mdm.tblBRBusinessRule WHERE MUID = @MUID)  
        BEGIN  
            RAISERROR('MDSERR400001|The Update operation failed. The MUID was not found.', 16, 1);  
            RETURN;  
        END  
  
        -- make sure the rule has not changed since the LastChanged date (if given)  
        IF (@RevisionID IS NOT NULL AND @RevisionID <> (SELECT LastChgTS FROM mdm.tblBRBusinessRule WHERE MUID = @MUID))  
        BEGIN  
            RAISERROR('MDSERR400014|The business rule cannot be updated. It has been changed by another user.', 16, 1);  
            RETURN;  
        END  
  
        SELECT @Entity_ID = [Entity_ID] FROM mdm.tblBRBusinessRule WHERE MUID = @MUID;  
  
        SELECT @Model_Permission = m.Privilege_ID  
        FROM mdm.viw_SYSTEM_SECURITY_USER_MODEL m  
        INNER JOIN mdm.tblEntity en ON m.ID = en.Model_ID  
        WHERE [User_ID] = @User_ID AND en.ID = @Entity_ID;  
    END  
    ELSE  
    BEGIN  
        IF @MemberType_ID NOT IN (@MemberType_Leaf, @MemberType_Consolidated)  
        BEGIN  
            RAISERROR('MDSERR400008|The MemberType is not valid for the rule.', 16, 1);  
            RETURN;  
        END  
  
        EXEC mdm.udpInformationLookupModel  
            @User_ID = @User_ID,  
            @Model_MUID = @Model_MUID,  
            @Model_Name = @Model_Name,  
            @ID = @Model_ID OUTPUT,  
            @Name = @Model_Name OUTPUT,  
            @MUID = @Model_MUID OUTPUT,  
            @Privilege_ID = @Model_Permission OUTPUT;  
  
        IF @Model_ID IS NULL  
        BEGIN  
            RAISERROR('MDSERR300005|The supplied model is not valid.', 16, 1);  
            RETURN;  
        END;  
  
        EXEC mdm.udpInformationLookupEntity  
            @User_ID = @User_ID,  
            @Model_ID = @Model_ID,  
            @Entity_MUID = @Entity_MUID,  
            @Entity_Name = @Entity_Name,  
            @ID = @Entity_ID OUTPUT,  
            @Name = @Entity_Name OUTPUT,  
            @MUID = @Entity_MUID OUTPUT;  
  
        IF @Entity_ID IS NULL  
        BEGIN  
            RAISERROR('MDSERR300008|The supplied entity is not valid.', 16, 1);  
            RETURN;  
        END;  
    END  
  
    IF @Model_Permission <> @Permission_Admin  
    BEGIN  
        RAISERROR('MDSERR120003|The user does not have permission or the object ID is not valid.', 16, 1);  
        RETURN;  
    END  
  
    -- Verify the entity is not a sync target.  
    IF EXISTS(SELECT 1 FROM mdm.tblSyncRelationship WHERE TargetEntity_ID = @Entity_ID)  
    BEGIN  
        RAISERROR('MDSERR200217|The business rule cannot be saved. The entity is the target of a sync relationship.', 16, 1);  
        RETURN;  
    END  
  
    IF @Name IS NULL  
    BEGIN  
        RAISERROR('MDSERR400010|Business rule name is required.', 16, 1);  
        RETURN;  
    END  
  
    IF EXISTS(  
        SELECT 1  
        FROM mdm.tblBRBusinessRule  
        WHERE [Name] = @Name  
            AND MUID <> @MUID  
            AND [Entity_ID] = @Entity_ID  
            and MemberType_ID = @MemberType_ID)  
    BEGIN  
        RAISERROR('MDSERR400011|A business rule with that name already exists for the entity and member type.', 16, 1);  
        RETURN;  
    END  
  
    -- get notification id  
    IF @NotificationGroupMuid IS NOT NULL AND @NotificationUserMuid IS NOT NULL  
    BEGIN  
        RAISERROR('MDSERR400036|Specify either a user, a group, or neither, but not both', 16, 1);  
        RETURN;  
    END  
  
    IF @NotificationGroupMuid IS NOT NULL  
    BEGIN  
        SELECT @NotificationGroup_ID = ID  
        FROM mdm.tblUserGroup  
        WHERE MUID = @NotificationGroupMuid  
  
        IF @NotificationGroup_ID IS NULL  
        BEGIN  
            RAISERROR('MDSERR500025|The principal ID for the user or group is not valid.', 16, 1);  
            RETURN;  
        END  
    END  
  
    IF @NotificationUserMuid IS NOT NULL  
    BEGIN  
        SELECT @NotificationUser_ID = ID  
        FROM mdm.tblUser  
        WHERE MUID = @NotificationUserMuid  
  
        IF @NotificationUser_ID IS NULL                                                                        -- Ensure the user exists and can see members subject to the business rule by checking:  
            OR NOT EXISTS (  
                SELECT ID  
                FROM mdm.viw_SYSTEM_SECURITY_USER_MEMBERTYPE  
                WHERE User_ID = @NotificationUser_ID  
                    AND ID = @MemberType_ID  
                    AND @Entity_ID = @Entity_ID  
                    AND Privilege_ID <> @Permission_Deny)                                                       -- Entity Member Type permission, and  
            OR mdm.udfSecurityUserFunctionIsAllowed(@NotificationUser_ID, @FunctionalPrivilege_Explorer) = 0    -- Explorer function  
        BEGIN  
            RAISERROR('MDSERR120000|The user is not valid or has insufficient permissions.', 16, 1);  
            RETURN;  
        END  
    END  
  
    IF @SaveMode = @SaveMode_Create  
    BEGIN  
        -- add row  
        INSERT INTO mdm.tblBRBusinessRule (  
            MUID,  
            [Name],  
            [Description],  
            RuleConditionText,  
            RuleActionText,  
            RuleElseActionText,  
            Entity_ID,  
            MemberType_ID,  
            Status_ID,  
            Priority,  
            NotificationGroupID,  
            NotificationUserID,  
            EnterDTM,  
            EnterUserID,  
            LastChgDTM,  
            LastChgUserID  
        )  
        VALUES (  
            @MUID,  
            @Name,  
            @Description,  
            @RuleConditionText,  
            @RuleActionText,  
            @RuleElseActionText,  
            @Entity_ID,  
            @MemberType_ID,  
            COALESCE(@Status_ID, mdm.udfBusinessRuleGetNewStatusID(1, 0)), -- 1 = enum ActionType.Create  
            @Priority,  
            @NotificationGroup_ID,  
            @NotificationUser_ID,  
            GETUTCDATE(),  
            @User_ID,  
            GETUTCDATE(),  
            @User_ID  
        );  
  
        IF @@ERROR = 0  
        BEGIN  
            SET @ID = SCOPE_IDENTITY();  
        END  
    END  
    ELSE  
    BEGIN  
        -- find Action_ID  
        DECLARE @Action_ID INT SET @Action_ID = 3 -- 3 = Change  
        IF @Status_ID IS NOT NULL  
        BEGIN  
            DECLARE @CurrentStatus_ID INT = (SELECT Status_ID FROM mdm.tblBRBusinessRule WHERE MUID = @MUID)  
            IF (@CurrentStatus_ID NOT IN (2,5) AND @Status_ID IN (2,5)) SET @Action_ID = 5 -- 5 = Exclude  
            ELSE IF (@CurrentStatus_ID IN (2,5) AND @Status_ID IN (1,3)) SET @Action_ID = 2 -- 2 = Activate  
        END  
  
        -- update row  
        UPDATE mdm.tblBRBusinessRule  
        SET [Name] = @Name,  
            [Description] = @Description,  
            RuleConditionText = @RuleConditionText,  
            RuleActionText = @RuleActionText,  
            RuleElseActionText = @RuleElseActionText,  
            Status_ID = mdm.udfBusinessRuleGetNewStatusID(@Action_ID, Status_ID),  
            Priority = @Priority,  
            NotificationGroupID = @NotificationGroup_ID,  
            NotificationUserID = @NotificationUser_ID,  
            LastChgDTM = GETUTCDATE(),  
            LastChgUserID = @User_ID  
        WHERE MUID = @MUID  
  
        IF @@ERROR = 0  
        BEGIN  
            SELECT @ID = ID FROM mdm.tblBRBusinessRule WHERE MUID = @MUID;  
  
            IF @ClearDefinition = 1  
            BEGIN  
                DELETE brip  
                FROM mdm.tblBRItemProperties brip  
                INNER JOIN mdm.tblBRItem bri ON bri.ID = brip.BRItem_ID  
                INNER JOIN mdm.tblBRLogicalOperatorGroup brlog ON brlog.ID = bri.BRLogicalOperatorGroup_ID  
                WHERE brlog.BusinessRule_ID = @ID;  
  
                DELETE bri  
                FROM mdm.tblBRItem bri  
                INNER JOIN mdm.tblBRLogicalOperatorGroup brlog ON brlog.ID = bri.BRLogicalOperatorGroup_ID  
                WHERE brlog.BusinessRule_ID = @ID  
  
                DELETE brlog  
                FROM mdm.tblBRLogicalOperatorGroup brlog  
                WHERE brlog.BusinessRule_ID = @ID  
            END  
        END  
    END  
  
    SET NOCOUNT OFF  
END
GO
/****** Object:  StoredProcedure [mdm].[udpBusinessRulesDelete]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
exec mdm.udpBusinessRulesDelete 1  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpBusinessRulesDelete]  
(  
    @RuleIDs        mdm.IdList READONLY,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON  
  
    BEGIN TRANSACTION  
  
    -- Delete logical operator groups  
    EXEC mdm.udpBusinessRuleLogicalOperatorGroupsDelete @RuleIDs  
  
    -- Delete business rules  
    DELETE	  
    FROM 	mdm.tblBRBusinessRule  
    WHERE	ID IN (SELECT ID FROM @RuleIDs);  
  
    COMMIT TRANSACTION  
  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpBusinessRulesGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
Returns business rule information using the given criteria. If no  
criteria is specified, then info for all rules is returned. For example:  
  
    DECLARE @BusinessRuleTable mdm.Identifier  
    exec mdm.udpBusinessRulesAPIGet  
        @UserId=1,  
        @AttributeMuid=NULL,  
        @AttributeName=NULL,  
        @MemberType_ID=NULL,  
        @EntityMuid=NULL,  
        @EntityName=NULL,  
        @ModelMuid=NULL,  
        @ModelName=NULL,  
        @BusinessRuleTable=@BusinessRuleTable,  
        @ActionResultType=0,  
        @ConditionResultType=0,  
        @ConditionTreeNodeResultType=0,  
        @BusinessRulesResultType=2  
  
Returned tables:  
    BR_IDs  
    AuditInfo  
    Actions  
    Conditions  
    ConditionTreeNodes  
    BusinessRules  
    Arguments  
*/  
CREATE PROCEDURE [mdm].[udpBusinessRulesGet]  
(  
    @UserId INT,    
    @AttributeMuid UNIQUEIDENTIFIER = NULL,    
    @AttributeName NVARCHAR(128) = NULL,    
    @MemberType_ID TINYINT = NULL, /*1 = Leaf, 2 = Consolidated */    
    @EntityMuid UNIQUEIDENTIFIER = NULL,    
    @EntityName NVARCHAR(MAX) = NULL,    
    @ModelMuid UNIQUEIDENTIFIER = NULL,    
    @ModelName NVARCHAR(50) = NULL,    
    @BusinessRuleTable mdm.Identifier READONLY,-- caller should ensure table does not include rows where both MUID and Name are blank    
    
    @ActionResultType INT = 0, /*0 = None, 1 = Identifiers, 2 = Details */    
    @ConditionResultType INT = 0,    
    @ConditionTreeNodeResultType INT = 0,    
    @BusinessRulesResultType INT = 0,    
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability    
)    
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN    
    SET NOCOUNT ON    
    
    DECLARE @PermissionType_Deny TINYINT = 1;    
    DECLARE @Model_ID            INT = NULL;    
    DECLARE @Entity_ID           INT = NULL;    
    DECLARE @Attribute_ID        INT = NULL;    
    DECLARE @EmptyMuid           UNIQUEIDENTIFIER = CAST(0x0 AS UNIQUEIDENTIFIER);    
    
    SET @ModelName  = NULLIF(@ModelName, N'');    
    SET @ModelMuid = NULLIF(@ModelMuid, @EmptyMuid);    
    SET @EntityName = NULLIF(@EntityName, N'');    
    SET @EntityMuid = NULLIF(@EntityMuid, @EmptyMuid);    
    SET @AttributeName = NULLIF(@AttributeName, N'');    
    SET @AttributeMuid = NULLIF(@AttributeMuid, @EmptyMuid);    
    
    -- lookup Model identifiers, if necessary    
    IF @ModelName IS NOT NULL OR @ModelMuid IS NOT NULL    
    BEGIN    
        SELECT @Model_ID  = m.ID    
        FROM mdm.tblModel m    
        INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_MODEL acl    
        ON m.ID = acl.ID    
            AND acl.User_ID = @UserId    
            AND acl.Privilege_ID <> 1 /*Deny*/    
        WHERE    
                (@ModelMuid IS NULL OR @ModelMuid = m.MUID)    
            AND (@ModelName IS NULL OR @ModelName = m.Name)    
    
        SET @Model_ID = COALESCE(@Model_ID, 0);    
    END    
    
    -- lookup Entity identifiers, if necessary    
    IF @EntityName IS NOT NULL OR @EntityMuid IS NOT NULL    
    BEGIN    
        SELECT    
             @Entity_ID  = e.ID    
            ,@Model_ID = COALESCE(@Model_ID, e.Model_ID) -- Ensure that the model ID param is set, if an entity is specified    
        FROM mdm.tblEntity e    
        INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_ENTITY acl    
        ON      e.ID = acl.ID    
        WHERE   acl.User_ID = @UserId    
            AND acl.Privilege_ID <> @PermissionType_Deny    
            AND (@Model_ID IS NULL OR @Model_ID = e.Model_ID)    
            AND (@EntityMuid IS NULL OR @EntityMuid = e.MUID)    
            AND (@EntityName IS NULL OR @EntityName = e.Name);    
    
        SET @Entity_ID = COALESCE(@Entity_ID, 0);    
    END    
    
    -- lookup Attribute identifiers, if necessary    
    IF @AttributeName IS NOT NULL OR @AttributeMuid IS NOT NULL    
    BEGIN    
        SELECT TOP 1    
             @Attribute_ID  = a.ID    
            ,@AttributeName = a.Name    
            ,@AttributeMuid = a.MUID    
        FROM mdm.tblAttribute a    
        INNER JOIN mdm.tblEntity e    
        ON a.Entity_ID = e.ID    
        INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_ATTRIBUTE acl    
        ON a.ID = acl.ID    
        WHERE acl.User_ID = @UserId    
            AND (@Entity_ID IS NULL OR @Entity_ID = a.Entity_ID)    
            AND (@MemberType_ID IS NULL OR @MemberType_ID = a.MemberType_ID)    
            AND (@Model_ID IS NULL OR @Model_ID = e.Model_ID)    
            AND (@AttributeMuid IS NULL OR @AttributeMuid = a.MUID)    
            AND (@AttributeName IS NULL OR @AttributeName = a.Name)    
        ORDER BY a.MemberType_ID;    
    
        SET @Attribute_ID = COALESCE(@Attribute_ID, 0);    
    END    
    
    DECLARE @ConditionId INT SET @ConditionId = 1;    
    DECLARE @ThenActionId INT SET @ThenActionId = 2;    
    DECLARE @ElseActionId INT SET @ElseActionId = 3;    
    
    -- result type values    
    DECLARE @Details INT SET @Details = 2;    
    DECLARE @IdentifiersOnly INT SET @IdentifiersOnly = 1;    
    DECLARE @None INT SET @None = 0;    
    
    -- Use the criteria vars to find the Ids of matching business rule(s).    
    -- Place these Ids in a table var for use in subsequent queries.    
    DECLARE @BR_Ids TABLE (    
        Id INT PRIMARY KEY CLUSTERED,    
        Muid UNIQUEIDENTIFIER UNIQUE NOT NULL,    
        [Name] NVARCHAR(100),    
        ModelId INT,    
        ModelMuid UNIQUEIDENTIFIER,    
        ModelName NVARCHAR(50),    
        EntityId INT,    
        EntityMuid UNIQUEIDENTIFIER,    
        EntityName NVARCHAR(MAX),    
        MemberType INT,    
        IsCorrupted BIT    
        );    
    
    INSERT INTO @BR_Ids    
    SELECT    
        DISTINCT    
        b.BusinessRule_ID Id,    
        b.BusinessRule_MUID Muid,    
        b.BusinessRule_Name [Name],    
        COALESCE(b.Model_ID, 0) ModelId,    
        b.Model_MUID ModelMuid,    
        b.Model_Name ModelName,    
        COALESCE(b.Entity_ID, 0) EntityId,    
        b.Entity_MUID EntityMuid,    
        b.Entity_Name EntityName,    
        COALESCE(b.MemberType_ID, 0) MemberType,    
        0    
    FROM    
        mdm.viw_SYSTEM_SECURITY_USER_MODEL acl    
    INNER JOIN    
        mdm.viw_SYSTEM_SCHEMA_BUSINESSRULES b    
        ON acl.ID = b.Model_ID    
        AND acl.User_ID = @UserId    
        AND acl.Privilege_ID <> 1 /*Deny*/    
        AND (@Entity_ID IS NULL OR b.Entity_ID = @Entity_ID)    
        AND (@Model_ID IS NULL OR b.Model_ID = @Model_ID)    
        AND (@MemberType_ID IS NULL OR b.MemberType_ID = @MemberType_ID)    
        AND acl.Privilege_ID <> @PermissionType_Deny -- read only users can view BRs    
    
    IF @Attribute_ID IS NOT NULL    
    BEGIN    
        -- remove rules that don't have arguments referencing the given attribute ID    
        DELETE FROM    
            @BR_Ids    
        WHERE    
            Id NOT IN    
                (SELECT DISTINCT BusinessRule_ID    
                 FROM mdm.viw_SYSTEM_SCHEMA_BUSINESSRULE_PROPERTIES_ATTRIBUTES    
                 WHERE Attribute_ID = @Attribute_ID)    
    END    
    
    IF EXISTS(SELECT 1 FROM @BusinessRuleTable)     
    BEGIN    
        -- remove rules that were not in the given list of rule MUIDs    
        DELETE FROM    
            @BR_Ids    
        WHERE    
            Muid NOT IN    
            (SELECT br.Muid    
             FROM @BR_Ids br    
            INNER JOIN @BusinessRuleTable crit    
            ON     
                ISNULL(crit.MUID, br.Muid) = br.Muid AND    
                ISNULL(crit.Name, br.Name) = br.Name)    
    END    
    
    -- get the BR IDs containing attributes that the user does not have privileges for    
    -- and remove them    
    -- Combining the select statement into delete statement will cause worse performance!!!  
    DECLARE @cteBRWithAttributeDeny TABLE(ID INT);  
    INSERT INTO @cteBRWithAttributeDeny   
        SELECT DISTINCT    
            a.BusinessRule_ID AS ID    
        FROM mdm.viw_SYSTEM_SCHEMA_BUSINESSRULE_PROPERTIES_ATTRIBUTES a    
        LEFT JOIN mdm.viw_SYSTEM_SECURITY_USER_ATTRIBUTE acl -- All attributes referenced by the rule must be in the same model, but they might have a different entity (in the case of DBAs) or member type (in the case of a hierarchy parent).    
        ON a.Attribute_ID = acl.ID    
            AND acl.User_ID = @UserId    
        WHERE acl.ID IS NULL    
  
    DELETE    
        br_id    
    FROM    
        @BR_Ids AS br_id    
    INNER JOIN    
        @cteBRWithAttributeDeny acl    
    ON br_id.Id = acl.ID;    
    
    -- Load BRItems (Actions and Conditions) into a table var    
    DECLARE @BR_Items TABLE    
    (    
        Id INT,    
        Muid UNIQUEIDENTIFIER,    
        [Text] NVARCHAR(MAX),    
        RuleId INT,    
        ItemTypeId INT,    
        Sequence INT,    
        [Type] INT NOT NULL,    
        LogicalOperatorGroupId INT,    
        LogicalOperatorGroupMuid UNIQUEIDENTIFIER,    
        UserScriptName NVARCHAR(128),    
        UserScriptParameterCount INT,    
        IsCorrupted BIT,    
        IsUDS BIT    
    );    
    IF  @None <> @BusinessRulesResultType OR    
        @None <> @ActionResultType OR    
        @None <> @ConditionResultType OR    
        @None <> @ConditionTreeNodeResultType    
    BEGIN    
        INSERT INTO @BR_Items    
        SELECT    
            DISTINCT    
            it.ID Id,    
            it.MUID Muid,    
            it.ItemText [Text],    
            lo.BusinessRule_ID RuleId,    
            itat.BRItemType_ID ItemTypeId, -- operator    
            it.Sequence Sequence,    
            lr.Parent_ID [Type], -- 1 = Condition, 2 = ThenAction, 3 = ElseAction    
            lo.ID LogicalOperatorGroupId,    
            lo.MUID LogicalOperatorGroupMuid,    
            (CASE WHEN itat.BRItemType_ID = 34 THEN AnchorName ELSE NULL END) AS UserScriptName,    
            (CASE WHEN itat.BRItemType_ID = 34 AND AnchorName IS NOT NULL AND  mdm.udfScriptExists(AnchorName, CASE WHEN lr.Parent_ID = 1 THEN 1 ELSE 2 END,'usr') = 1 THEN (SELECT COUNT(*)    
            FROM sys.objects AS SO    
            INNER JOIN sys.parameters AS P    
            ON SO.object_id = P.object_id    
            WHERE P.is_output = 0    
            AND SO.object_id = ( SELECT object_id    
            FROM sys.objects    
            WHERE type = (CASE WHEN lr.Parent_ID = 1 THEN 'FN'ELSE 'P'END) AND SCHEMA_ID('usr') IS NOT NULL AND schema_id = SCHEMA_ID('usr') AND name = AnchorName)) ELSE -1 END),    
            0 AS IsCorrupted,    
            (CASE itat.BRItemType_ID WHEN 34 THEN 1 ELSE 0 END ) AS IsUDS    
        FROM    
            @BR_Ids i    
            INNER JOIN mdm.tblBRLogicalOperatorGroup lo    
                ON i.Id = lo.BusinessRule_ID    
            INNER JOIN mdm.tblBRItem it    
                ON lo.ID = it.BRLogicalOperatorGroup_ID    
            INNER JOIN mdm.tblBRItemTypeAppliesTo itat    
                ON it.BRItemAppliesTo_ID = itat.ID    
            INNER JOIN mdm.tblListRelationship lr    
                ON itat.ApplyTo_ID = lr.ID AND    
                   lr.Parent_ID IN (@ThenActionId, @ElseActionId, @ConditionId)    
            LEFT JOIN mdm.tblBRItemProperties anchorArg    
                ON anchorArg.BRItem_ID = it.ID AND    
                   anchorArg.IsLeftHandSide = 1 AND    
                   anchorArg.PropertyType_ID = 2 -- 2 = Attribute    
    
        ORDER BY lo.ID, it.Sequence    
    END    
    
    -- Validate BRItems    
    DECLARE @ScriptArgument NVARCHAR(MAX),    
            @ScriptName NVARCHAR(128),    
            @UDSBRItemId INT,    
            @IsUDSBRItemValid BIT,    
            @UDSBRItemType INT,    
            @IsSproc BIT,    
            @UDSBRId INT,    
            @Arguments mdm.ScriptArgument   
    DECLARE brItemCursor CURSOR FOR    
    SELECT  Id, UserScriptName, [Type], RuleId FROM @BR_Items WHERE IsUDS = 1;    
    OPEN brItemCursor;    
    FETCH NEXT FROM brItemCursor INTO @UDSBRItemId, @ScriptName , @UDSBRItemType, @UDSBRId    
    WHILE (@@FETCH_STATUS = 0)    
    BEGIN    
       DELETE FROM @Arguments  
       SET @IsSproc = (CASE  @UDSBRItemType WHEN @ConditionId THEN 0 ELSE 1 END)    
       INSERT INTO @Arguments    
       SELECT CONVERT(NVARCHAR(128),l.Value),    
        CASE WHEN r2.Value IS NULL THEN    
            ( CASE r1.PropertyType_ID    
            WHEN 6 THEN 3 -- BLANK    
            WHEN 2 THEN 2 -- ATTRIBUTE    
            WHEN 1 THEN 1 -- VALUE    
            ELSE 0 END)    
            ELSE    
            ( CASE r2.PropertyType_ID    
            WHEN 6 THEN 3 -- BLANK    
            WHEN 2 THEN 2 -- ATTRIBUTE    
            WHEN 1 THEN 1 -- VALUE    
            ELSE 0 END) END,    
       CASE WHEN r2.Value IS NULL THEN r1.Value ELSE r2.Value END,    
       ''    
       FROM mdm.tblBRItemProperties l    
       INNER JOIN mdm.tblBRItemProperties r1 ON r1.Parent_ID = l.ID    
       LEFT JOIN mdm.tblBRItemProperties r2 ON r2.Parent_ID = r1.ID    
       WHERE l.BRItem_ID = @UDSBRItemId AND l.PropertyType_ID = 8 --User Defined Script Parameter    
         
       EXEC [mdm].[udpValidateFunctionArguments] @ScriptName = @ScriptName, @IsSproc = @IsSproc, @Arguments = @Arguments,@ThrowException = 0, @BRID = @UDSBRItemId, @IsValid = @IsUDSBRItemValid OUT , @ScriptArguments = @ScriptArgument OUT    
       IF @IsUDSBRItemValid = 0    
       BEGIN    
             UPDATE @BR_Items    
             SET IsCorrupted = 1    
             WHERE Id = @UDSBRItemId    
    
             UPDATE @BR_Ids    
             SET IsCorrupted = 1    
             WHERE Id = @UDSBRId    
       END    
       FETCH NEXT FROM brItemCursor INTO @UDSBRItemId, @ScriptName , @UDSBRItemType, @UDSBRId    
    END -- END WHILE(@@FETCH_STATUS = 0)    
    CLOSE brItemCursor;    
    DEALLOCATE brItemCursor;    
    
    -- Load Arguments into a table var    
    DECLARE @BR_ItemArguments TABLE    
    (    
        Id INT PRIMARY KEY,    
        Muid UNIQUEIDENTIFIER UNIQUE,    
        ItemId INT,    
        ParentId INT,    
        [Value] NVARCHAR(999),    
        ValueMuid UNIQUEIDENTIFIER,    
        ValueName NVARCHAR(128),    
        PropertyType INT,    
        PropertyName INT,    
        IsLeftHandSide BIT,    
        [Sequence] INT,    
        AnchorAttributeDataType INT    
    );    
    IF  @None <> @BusinessRulesResultType OR    
        @None <> @ActionResultType OR    
        @None <> @ConditionResultType OR    
        @None <> @ConditionTreeNodeResultType    
    BEGIN    
        DECLARE @GetActions BIT SET @GetActions = 0    
        DECLARE @GetConditions BIT SET @GetConditions = 0    
        IF @ActionResultType <> @None OR @BusinessRulesResultType <> @None BEGIN    
            SET @GetActions = 1    
        END    
        IF @ConditionResultType <> @None OR @ConditionTreeNodeResultType <> @None OR @BusinessRulesResultType <> @None BEGIN    
            SET @GetConditions = 1    
        END    
        INSERT INTO @BR_ItemArguments    
        SELECT    
            ip.ID Id,    
            ip.MUID Muid,    
            ip.BRItem_ID ItemId,    
            COALESCE(ip.Parent_ID, 0) ParentId,    
            ip.Value [Value], -- freeform string, attributeId, hierarchyId, or member code (for attribute value arguments)    
            COALESCE(a.MUID, h.MUID) ValueMuid, -- attribute muid or hierarchy muid    
            COALESCE(a.Name, h.Name) ValueName, -- attribute name or hierarchy name    
            ip.PropertyType_ID PropertyType,    
            ip.PropertyName_ID PropertyName,    
            ip.IsLeftHandSide IsLeftHandSide,    
            ip.[Sequence] [Sequence],    
            anchorAttribute.DataType_ID AnchorAttributeDataType    
       FROM    
            mdm.tblBRItemProperties ip    
            INNER JOIN @BR_Items i    
                ON ip.BRItem_ID = i.Id AND    
                   ip.ID > 0 AND    
                    ((@GetActions    = 1 AND (i.Type = @ThenActionId OR i.Type = @ElseActionId)) OR    
                     (@GetConditions = 1 AND i.Type = @ConditionId))    
            LEFT JOIN mdm.tblAttribute a    
                ON ip.PropertyType_ID IN (2,4) AND -- Attribute = 2, DBAAttribute = 4    
                   ip.Value = CONVERT(nvarchar(50), a.ID)    
            LEFT JOIN mdm.tblHierarchy h    
                ON ip.PropertyType_ID = 3 AND -- ParentAttribute = 3    
                   ip.Value = CONVERT(nvarchar(50), h.ID)    
            LEFT JOIN mdm.tblBRItemProperties anchorArg    
                ON anchorArg.BRItem_ID = ip.BRItem_ID AND    
                   anchorArg.IsLeftHandSide = 1 AND    
                   anchorArg.PropertyType_ID = 2 -- 2 = Attribute    
            LEFT JOIN mdm.tblAttribute anchorAttribute    
                ON TRY_PARSE(anchorArg.Value AS INT) = anchorAttribute.ID    
       ORDER BY ip.BRItem_ID, ip.Sequence    
    END    
    
    -- Output 1, BR Id info    
    SELECT Id ,    
        Muid ,    
        [Name] ,    
        ModelId ,    
        ModelMuid ,    
        ModelName ,    
        EntityId ,    
        EntityMuid ,    
        EntityName ,    
        MemberType    
    FROM @BR_Ids    
    
    -- Output 2, BR Audit Info    
    IF @Details IN (@BusinessRulesResultType, @ActionResultType, @ConditionTreeNodeResultType, @ConditionResultType)    
    BEGIN    
        -- Details    
        SELECT    
            DISTINCT    
            b.BusinessRule_ID RuleId,    
            CONVERT(BIGINT, b.BusinessRule_LastChgTS) LastChgTS,    
            COALESCE(b.BusinessRule_CreatedUserID, 0) CreatedUserId,    
            b.BusinessRule_CreatedUserMUID CreatedUserMuid,    
            b.BusinessRule_CreatedUserName CreatedUserName,    
            b.BusinessRule_DateCreated CreatedDateTime,    
            COALESCE(b.BusinessRule_UpdatedUserID, 0) UpdatedUserId,    
            b.BusinessRule_UpdatedUserMUID UpdatedUserMuid,    
            b.BusinessRule_UpdatedUserName UpdatedUserName,    
            b.BusinessRule_DateUpdated UpdatedDateTime    
        FROM    
            @BR_Ids i    
            INNER JOIN    
            mdm.viw_SYSTEM_SCHEMA_BUSINESSRULES b    
                ON i.Id = b.BusinessRule_ID    
    END    
    ELSE    
    BEGIN    
        -- IDs Only or None    
        SELECT NULL WHERE 1=0;    
    END    
    
    -- Output 3, BusinessRules    
    IF @BusinessRulesResultType = @Details BEGIN    
        -- Details    
        SELECT    
            DISTINCT    
            b.BusinessRule_ID Id,    
            b.BusinessRule_Description [Description],    
            b.BusinessRule_RuleActionText RuleActionText,    
            b.BusinessRule_RuleElseActionText RuleElseActionText,    
            b.BusinessRule_RuleConditionText RuleConditionText,    
            COALESCE(b.BusinessRule_StatusID, 0) [Status],    
            COALESCE(b.BusinessRule_Priority, 0) Priority,    
            b.BusinessRule_NotificationGroupMUID NotificationGroup,    
            b.BusinessRule_NotificationUserMUID NotificationUser,    
            i.IsCorrupted    
        FROM    
            @BR_Ids i    
            INNER JOIN    
            mdm.viw_SYSTEM_SCHEMA_BUSINESSRULES b    
                ON i.Id = b.BusinessRule_ID    
    END ELSE IF @BusinessRulesResultType = @IdentifiersOnly BEGIN    
        -- IDs only    
        SELECT i.Id    
        FROM @BR_Ids i    
    END ELSE BEGIN    
        -- Nothing    
        SELECT NULL WHERE 1=0;    
    END    
    
    -- Output 4,Condition Tree Nodes    
    IF  @None <> @BusinessRulesResultType OR    
        @None <> @ConditionTreeNodeResultType    
    BEGIN    
         -- Details or IDs only    
        SELECT    
            DISTINCT    
            lo.ID Id,    
            lo.MUID Muid,    
            lo.BusinessRule_ID RuleId,    
            lop.ID ParentId,    
            lop.MUID ParentMuid,    
            lo.LogicalOperator_ID OperatorId,    
            lo.Sequence Sequence    
        FROM    
            mdm.tblBRLogicalOperatorGroup lo    
            INNER JOIN @BR_Ids br    
                ON lo.BusinessRule_ID = br.Id    
            LEFT JOIN mdm.tblBRItem it  -- left (not inner) join, because a condition operator group can be empty    
                ON lo.ID = it.BRLogicalOperatorGroup_ID    
            LEFT JOIN mdm.tblBRItemTypeAppliesTo itat    
                ON it.BRItemAppliesTo_ID = itat.ID    
            LEFT JOIN mdm.tblListRelationship lr    
                ON itat.ApplyTo_ID = lr.ID    
            LEFT JOIN mdm.tblBRLogicalOperatorGroup lop -- self join to get the parent group's MUID    
                ON lo.Parent_ID IS NOT NULL AND    
                   lo.Parent_ID = lop.ID    
            WHERE ISNULL(lr.Parent_ID, @ConditionId) = @ConditionId -- exclude action logical operator group    
        ORDER BY RuleId, ParentId, Sequence    
    END ELSE BEGIN    
        -- None    
        SELECT NULL WHERE 1=0;    
    END    
    
    -- Output 5, Actions    
    IF @Details IN (@BusinessRulesResultType, @ActionResultType) BEGIN    
        -- Details    
        SELECT    
            Id,    
            Muid,    
            RuleId,    
            [Type],    
            [Text],    
            ItemTypeId, -- operator    
            Sequence,    
            UserScriptName,    
            UserScriptParameterCount,    
            IsCorrupted    
        FROM @BR_Items    
        WHERE [Type] <> @ConditionId    
    END ELSE IF @IdentifiersOnly IN (@BusinessRulesResultType, @ActionResultType) BEGIN    
        -- IDs only    
        SELECT    
            Id,    
            Muid,    
            RuleId,    
            [Type]    
        FROM @BR_Items    
        WHERE [Type] <> @ConditionId    
    END ELSE BEGIN    
        -- None    
        SELECT NULL WHERE 1=0;    
    END    
    
    -- Output 6, Conditions    
    IF @Details IN (@BusinessRulesResultType, @ConditionResultType, @ConditionTreeNodeResultType) BEGIN    
        -- Details    
        SELECT    
            Id,    
            Muid,    
            RuleId,    
            LogicalOperatorGroupId,    
            LogicalOperatorGroupMuid,    
            [Text],    
            ItemTypeId, -- operator    
            Sequence,    
            UserScriptName,    
            UserScriptParameterCount,    
            IsCorrupted    
        FROM @BR_Items    
        WHERE [Type] = @ConditionId    
    END ELSE IF @IdentifiersOnly IN (@BusinessRulesResultType, @ConditionResultType, @ConditionTreeNodeResultType) BEGIN    
        -- IDs only    
        SELECT    
            Id,    
            Muid,    
            RuleId,    
            LogicalOperatorGroupId,    
            LogicalOperatorGroupMuid    
        FROM @BR_Items    
        WHERE [Type] = @ConditionId    
    END ELSE BEGIN    
        -- None    
        SELECT NULL WHERE 1=0;    
    END    
    
    -- Output 7, Arguments    
    IF @Details IN (@BusinessRulesResultType, @ActionResultType, @ConditionResultType, @ConditionTreeNodeResultType) BEGIN    
        -- Details    
        SELECT    
            Id,    
            Muid,    
            ItemId,    
            ParentId,    
            PropertyType,    
            PropertyName,    
            IsLeftHandSide,    
            [Value],    
            ValueMuid,    
            ValueName,    
            [Sequence],    
            AnchorAttributeDataType    
         FROM @BR_ItemArguments; -- Note: Ignore the "Microsoft.Design#SR0001" Code Analysis warning.    
    END    
    ELSE    
    IF @IdentifiersOnly IN (@BusinessRulesResultType, @ActionResultType, @ConditionResultType, @ConditionTreeNodeResultType) BEGIN    
        -- IDs only    
        SELECT    
            Id,    
            Muid,    
            ItemId,    
            ParentId,    
            PropertyType,    
            PropertyName ,    
            IsLeftHandSide    
        FROM @BR_ItemArguments;    
    END    
    ELSE    
    BEGIN    
        -- None    
        SELECT NULL WHERE 1=0;    
    END    
    
    SET NOCOUNT OFF    
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpBusinessRulesGetPublishInfo]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
Returns a table with two columns: EntityId and MemberType, with one row  
for each distinct Entity-MemberType combination that should be published  
as per the given critieria. The UserId is required and must pertain to a user  
with admin permission on the given model. The model and entity parameters  
must collectively allow for the model to be uniquely identified. Other than that, the  
criteria parameters are optional. Any that are given will be AND'ed together. If Entity and  
MemberType are null, then the Entity-MemberType pairs for all rules within the model will be returned.  
  
    exec mdm.udpBusinessRulesAPIGet  
        @UserId INT=1,  
        @ModelMuid=NULL,  
        @ModelName="Product",  
        @EntityMuid=NULL,  
        @EntityName=NULL,  
        @MemberType=NULL  
  
*/  
CREATE PROCEDURE [mdm].[udpBusinessRulesGetPublishInfo]  
(  
    @UserId INT = NULL,  
    @ModelMuid UNIQUEIDENTIFIER = NULL,  
    @ModelName NVARCHAR(50) = NULL,  
    @EntityMuid UNIQUEIDENTIFIER = NULL,  
    @EntityName NVARCHAR(MAX) = NULL,  
    @MemberType INT = NULL, /*1 = Leaf, 2 = Consolidated, 3 = Collection. If null, all MemberTypes will be included*/  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON  
  
    -- change empty strings to null  
    IF LEN(@ModelName) = 0 BEGIN  
        SET @ModelName = NULL  
    END  
    IF LEN(@EntityName) = 0 BEGIN  
        SET @EntityName = NULL  
    END  
  
     -- Validate user model permission.  
    DECLARE @ModelId INT = NULL;  
    IF (@ModelMuid IS NOT NULL OR @ModelName IS NOT NULL OR @EntityMuid IS NOT NULL) BEGIN -- If no model info is provided, then entity MUID is required to determine the model.  
            SELECT  
                @ModelId = Model_ID  
            FROM  
                mdm.viw_SYSTEM_SCHEMA_ENTITY en  
            INNER JOIN  
                mdm.viw_SYSTEM_SECURITY_USER_MODEL acl  
            ON  
                acl.ID = en.Model_ID AND  
                acl.User_ID = @UserId AND  
                acl.Privilege_ID = 5 /*Admin*/ AND  
                (@ModelMuid IS NULL OR @ModelMuid = en.Model_MUID) AND  
                (@ModelName IS NULL OR @ModelName = en.Model_Name) AND  
                (@EntityMuid IS NULL OR @EntityMuid = en.MUID) AND  
                (@EntityName IS NULL OR @EntityName = en.Name);  
    END  
    IF (@ModelId IS NULL) BEGIN  
        RAISERROR('MDSERR120003|The user does not have permission or the object ID is not valid.', 16, 1);  
        RETURN;  
    END  
  
    SELECT  
        DISTINCT  
        br.Entity_ID EntityId,  
        br.Entity_MUID EntityMuid,  
        br.MemberType_ID MemberType  
    FROM  
        mdm.viw_SYSTEM_SCHEMA_BUSINESSRULES br  
        INNER JOIN  
        mdm.tblList ls  
        ON  
            (@MemberType IS NULL OR @MemberType = br.MemberType_ID) AND  
            @ModelId = br.Model_ID AND  
            ((@EntityMuid IS NULL AND @EntityName IS NULL) OR @EntityMuid = br.Entity_MUID OR @EntityName = br.Entity_Name) AND  
            br.BusinessRule_StatusID = ls.OptionID AND  
            ls.Group_ID > 0 AND -- Publishable and delete/exclude pending statuses  
            ls.ListCode = CAST(N'lstBRStatus' AS NVARCHAR(50))  
  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpBusinessRulesPaletteGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
Returns the data for the business rules palette  
  
exec mdm.udpBusinessRulesPaletteGet 1  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpBusinessRulesPaletteGet]  
(  
    @MemberType_ID TINYINT = NULL,    
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability    
)    
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN    
    SET NOCOUNT ON    
    
    -- create vars corresponding to tblListRelationshipType.ID values    
    DECLARE @BRType INT = 1    
            ,@BRItemTypeCategory INT = 2    
            ,@DataType INT = 3   
            ,@BRActionTypeID INT = 2;  
             
  
    -- Level 2 nodes, i.e. "Value Comparison", "Default value", "Change value", "Validation"    
    SELECT        
        c.OptionID AS Id,    
        CONVERT(BIT, p.OptionID - 1) AS IsAction,    
        c.ListOption AS [Name]    
    FROM        
        mdm.tblListRelationship lr     
        INNER JOIN    
        mdm.tblList c     
            ON     
                lr.ListRelationshipType_ID = @BRItemTypeCategory AND    
                lr.Child_ID = c.OptionID AND     
                lr.ChildListCode = c.ListCode AND     
                c.IsVisible = 1     
        INNER JOIN    
        mdm.tblList p     
            ON     
                lr.Parent_ID = p.OptionID AND    
                p.OptionID <>3 AND    -- Ignore Else actions which are duplicated.  
                lr.ParentListCode = p.ListCode     
    ORDER BY p.Seq, c.Seq    
    
    -- Rule item types (level 3 nodes)    
    SELECT         
        ssbi.BRItemType_ID  Id,    
        ssbi.BRSubTypeID    ParentId,  
        (CASE ssbi.BRTypeID WHEN @BRActionTypeID THEN 1 ELSE 0 END) IsAction               
    FROM    mdm.viw_SYSTEM_SCHEMA_BUSINESSRULE_ITEMTYPES ssbi    
    WHERE        
        ssbi.ApplyToCategoryID = @BRItemTypeCategory AND    
        ssbi.BRSubTypeIsVisible = 1 AND    
        EXISTS     
        (    
            SELECT    BRItemType_ID     
            FROM    mdm.viw_SYSTEM_SCHEMA_BUSINESSRULE_ITEMTYPES     
            WHERE        
                ApplyToCategoryID = @BRType AND    
                BRSubTypeID = @MemberType_ID AND    
                BRItemType_ID = ssbi.BRItemType_ID    
        )    
    ORDER BY     
        DisplaySequence,     
        DisplaySubSequence,  
        Id   
    
    -- Compatible attribute types    
    SELECT     
        itat.BRItemType_ID  BRItemType,    
        lr.Parent_ID        AttributeType,    
        lr.Child_ID         AttributeDataType    
    FROM        
        mdm.tblBRItemTypeAppliesTo itat     
        INNER JOIN    
        mdm.tblListRelationship lr     
        ON     
            lr.ListRelationshipType_ID = @DataType AND    
            itat.ApplyTo_ID = lr.ID    
    ORDER BY     
        itat.BRItemType_ID,     
        lr.Parent_ID,     
        lr.Child_ID    
    
    IF( @MemberType_ID = 1)  
    BEGIN   
         
        -- Condition scripts    
        SELECT     
            SO.name AS ScriptName    
            , P.name AS ParameterName    
            , P.parameter_id AS [Index]    
            , P.is_output IsOutput          
            , TYPE_NAME(P.system_type_id) AS TypeName    
            , P.scale AS Scale    
            , P.precision AS [Precision]    
            , P.max_length AS [MaxLength]    
        FROM sys.objects AS SO    
        INNER JOIN sys.parameters AS P     
        ON SO.object_id = P.object_id    
        WHERE  type ='FN' AND schema_id = SCHEMA_ID('usr')     
        AND mdm.udfScriptExists(SO.name, 1, 'usr') = 1      
    
        -- Action scripts    
        Select name As ScriptName    
        FROM sys.objects    
        WHERE  schema_id = SCHEMA_ID('usr')     
        AND type ='P'    
        AND mdm.udfScriptExists(name,2,'usr') = 1       
    END  
      
        
    SET NOCOUNT OFF    
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpBusinessRuleTextSQLSave]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
Updates the text and sql columns of the business rule with the given Muid.   
*/  
CREATE PROCEDURE [mdm].[udpBusinessRuleTextSQLSave]  
(  
    @User_ID            INT, --Person performing save  
    @RuleMuid           UNIQUEIDENTIFIER = NULL,  
    @RuleConditionText  NVARCHAR(MAX) = NULL,   
    @RuleActionText     NVARCHAR(MAX) = NULL,   
    @RuleElseActionText NVARCHAR(MAX) = NULL,  
    @RuleConditionSQL   NVARCHAR(MAX) = NULL ,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON  
  
    DECLARE @ActionType AS INT  
    IF ( @RuleActionText IS NULL OR LEN(@RuleActionText) = 0 OR @RuleActionText = N'None' ) AND (@RuleElseActionText IS NULL OR LEN(@RuleElseActionText) = 0 OR @RuleElseActionText = N'None')    
    BEGIN  
        -- treat rules without actions as newly-created   
        SET @ActionType = 1 -- 1 = enum ActionType.Create  
    END   
    ELSE   
    BEGIN  
        SET @ActionType = 3 -- 3 = enum ActionType.Change  
    END  
  
    UPDATE tblBRBusinessRule  
    SET  
        RuleConditionText = @RuleConditionText,  
        RuleActionText = @RuleActionText,  
        RuleElseActionText = @RuleElseActionText,  
        Status_ID = mdm.udfBusinessRuleGetNewStatusID(@ActionType, Status_ID),   
        LastChgUserID = @User_ID,  
        LastChgDTM = GETUTCDATE()  
    FROM mdm.tblBRBusinessRule  
    WHERE MUID = @RuleMuid  
  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpChangeTableDataCompressionType]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpChangeTableDataCompressionType]  
    @tableName       NVARCHAR(128),  
    @dataCompression TINYINT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
AS  
BEGIN  
    DECLARE @sql NVARCHAR(MAX),  
            @tableId INT = NULL,  
            @index NVARCHAR(128),  
            @options NVARCHAR(MAX);  
    -- Only enterprise version supports data compression  
    -- http://msdn.microsoft.com/en-us/library/ms174396.aspx  
    IF mdm.udfIsEnterpriseEdition() = 1  
    BEGIN  
        SET @tableId = OBJECT_ID(@tableName);  
        IF @tableId IS NOT NULL AND EXISTS (SELECT 1 FROM sys.tables WHERE [object_id] = @tableId)  
        BEGIN  
            -- Rebuild Tabble  
            SET @options = mdm.udfGetTableOptions(@dataCompression, NULL);  
            SET @sql = N'ALTER TABLE ' + @tableName + N' REBUILD ' + @options;  
            -- PRINT @sql  
            EXEC (@sql);  
  
            -- Rebuild Indexes  
            SET @options = mdm.udfGetIndexOptions(@dataCompression, NULL);  
  
            DECLARE tableIndexes CURSOR FOR  
            SELECT name FROM sys.indexes WHERE [object_id] = @tableId  
  
            OPEN tableIndexes;  
            FETCH NEXT FROM tableIndexes INTO @index;  
  
            WHILE @@FETCH_STATUS = 0  
            BEGIN  
                SET @sql = N'ALTER INDEX ' + QUOTENAME(@index) + N' ON ' + @tableName + N' REBUILD ' + @options;  
                -- PRINT @sql  
                EXEC (@sql);  
                FETCH NEXT FROM tableIndexes INTO @index;  
            END  
            CLOSE tableIndexes;  
            DEALLOCATE tableIndexes;  
       END;  
    END;  
END
GO
/****** Object:  StoredProcedure [mdm].[udpCircularReferenceMemberCodesGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    We call the [udpCircularReferenceMemberCodesGet] SPROC to figure out whether the provided member codes being updated are  
    part of a circular reference. The member codes to check for are provided in the @MemberAttributes param and the view  
    that defines the hierarchy (derived only) to check is provided in the @RecursiveDerivedView param.  
  
    It is also possible to use this SPROC to check the whole hierarchy for circular/cyclical references. To do that, do  
    not pass in anything for @MemberAttributes  
  
    DECLARE @MemberAttributes mdm.MemberAttributes;  
    INSERT INTO @MemberAttributes (MemberCode, AttributeName, AttributeValue)  
    VALUES  
         (N'A', N'ModelName', N'DEF')  
        ,(N'B', N'ModelName', N'DEF')  
    ;  
    --Validate the supplied member codes for circular references  
    EXEC mdm.udpCircularReferenceMemberCodesGet N'viw_SYSTEM_10_12_PARENTCHILD_DERIVED', @MemberAttributes;  
      
    OR  
  
    --Validate the whole entity/hierarchy for circular references  
    EXEC mdm.udpCircularReferenceMemberCodesGet N'viw_SYSTEM_10_12_PARENTCHILD_DERIVED';  
  
*/  
CREATE PROCEDURE [mdm].[udpCircularReferenceMemberCodesGet]  
(  
    @Model_ID               INT,  
    @RecursiveHierarchy_ID  INT,  
    @MemberAttributes       mdm.MemberAttributes READONLY,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)   
AS   
BEGIN  
    DECLARE @RecursiveDerivedView SYSNAME = CONCAT(N'viw_SYSTEM_', @Model_ID, N'_', @RecursiveHierarchy_ID, N'_PARENTCHILD_DERIVED');  
  
    CREATE TABLE #CircularReferenceCodes  
    (            
         MemberCode            NVARCHAR(MAX) COLLATE DATABASE_DEFAULT NULL  
    );  
    DECLARE @SQL    NVARCHAR(MAX) = N'';  
    DECLARE @CircularReferencedMemberCodes INT;  
    DECLARE @MemberJoinSQL NVARCHAR(MAX) = N'';  
      
    --To check for circular references, we run a recursive CTE. Here's the algorithm of that describes what is going on below:  
    --1. Retrieve the immediate child of every member code in scope (this is all of them if the user does not supply a value for @MemberAttributes)  
    --2. Recurse down the list also retrieving the children of every child found in 1, i.e., find all the descendants of every member in scope  
    --3. Stop (that is what the CASE that sets the MemberCode to NULL is about) the moment you find a member in its own list of descendants. This  
    --     means we have located a circular reference  
    --4. Put a list of all the members that are part of circular references in #CircularReferenceCodes  
  
    IF EXISTS(SELECT 1 FROM @MemberAttributes)  
    BEGIN  
        -- Load the provided member codes into an indexed temp table. Joining against this table is much faster   
        -- than joining directly against the @MemberAttributes parameter (e.g. 4 seconds versus 117 seconds on a test db   
        -- where the derived view contained 67K members and @MemberAttributes contained 2 rows).  
        CREATE TABLE #MemberCodes   
        (  
            MemberCode NVARCHAR(250) COLLATE DATABASE_DEFAULT PRIMARY KEY  
        )  
        INSERT INTO #MemberCodes  
        SELECT   
            DISTINCT CONVERT(NVARCHAR(250), MemberCode)  
        FROM @MemberAttributes  
        SET @MemberJoinSQL = N'  
        INNER JOIN #MemberCodes m  
            ON member.ParentCode = m.MemberCode';  
    END;  
  
    SET @SQL = N'  
CREATE TABLE #ParentChildWorkingSet  
(  
     Parent_ID          INT   
    ,ParentCode         NVARCHAR(250) COLLATE DATABASE_DEFAULT  
    ,ParentEntity_ID    INT  
    ,Child_ID           INT  
    ,ChildEntity_ID     INT  
);  
CREATE CLUSTERED INDEX #ix_ParentChildWorkingSet_ParentCode ON #ParentChildWorkingSet(ParentCode);  
CREATE INDEX #ix_ParentChildWorkingSet_ParentEntity_ID_Parent_ID ON #ParentChildWorkingSet(ParentEntity_ID, Parent_ID);  
CREATE INDEX #ix_ParentChildWorkingSet_ChildEntity_ID_Child_ID ON #ParentChildWorkingSet(ChildEntity_ID, Child_ID);  
  
INSERT INTO #ParentChildWorkingSet  
SELECT  
     Parent_ID  
    ,ParentCode  
    ,ParentEntity_ID  
    ,Child_ID  
    ,Entity_ID  
FROM mdm.' + @RecursiveDerivedView + N' viw  
WHERE viw.Parent_ID > 0; -- Exclude ROOT parent  
  
;WITH cteMemberChildren AS  
(  
    SELECT   member.Parent_ID       AS Member_ID  
            ,member.ParentCode      AS MemberCode   
            ,member.ParentEntity_ID AS MemberEntity_ID    
            ,member.Parent_ID   
            ,member.ParentEntity_ID  
            ,member.Child_ID  
            ,member.ChildEntity_ID  
            ,0 Recursion_Level  
        FROM #ParentChildWorkingSet member' +  
        @MemberJoinSQL + N'  
                   
    UNION ALL  
  
    SELECT   cte.Member_ID  
            ,cte.MemberCode  
            ,cte.MemberEntity_ID  
            ,child.Parent_ID     
            ,child.ParentEntity_ID  
            ,CASE WHEN child.Child_ID = cte.Member_ID AND child.ChildEntity_ID = cte.MemberEntity_ID THEN NULL ELSE child.Child_ID END AS Child_ID  
            ,child.ChildEntity_ID  
            ,cte.Recursion_Level + 1  
        FROM #ParentChildWorkingSet child  
        INNER JOIN cteMemberChildren cte  
            ON   
                child.Parent_ID         = cte.Child_ID  
            AND child.ParentEntity_ID   = cte.ChildEntity_ID   
            AND cte.Recursion_Level < 99 -- Protects against "The statement terminated. The maximum recursion 100 has been exhausted before statement completion" error.  
)  
INSERT INTO #CircularReferenceCodes  
SELECT MemberCode FROM cteMemberChildren WHERE Child_ID IS NULL';  
  
    --PRINT @SQL;  
    EXEC sp_executesql @SQL;  
  
    --Put out the set of member codes that are part of circular references  
    SELECT MemberCode FROM #CircularReferenceCodes;  
  
    --Return the total number of members with problems  
    SET @CircularReferencedMemberCodes=(SELECT COUNT(MemberCode) FROM #CircularReferenceCodes);  
    RETURN @CircularReferencedMemberCodes;  
END;
GO
/****** Object:  StoredProcedure [mdm].[udpCollectionMemberSave]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    --it will either insert the record or if the Remove param is specified it will remove the record..  
  
    --Entity  
    EXEC mdm.udpCollectionMemberSave @User_ID=1, @Version_ID = '1', @Entity_ID = '9', @Collection_ID = '41', @Child_ID = '3784', @ChildType_ID = '1', @SortOrder=0, @Weight=1;  
    --Parent  
    EXEC mdm.udpCollectionMemberSave 1,1,9,1,959,2;  
*/  
CREATE PROCEDURE [mdm].[udpCollectionMemberSave]  
(  
    @User_ID        INT,  
    @Version_ID     INT,  
    @Entity_ID      INT,  
    @Collection_ID  INT,  
    @Child_ID       INT,  
    @ChildType_ID   TINYINT,  
    @SortOrder      INT = 0,  
    @Weight         DECIMAL(10,3) = 1.0,  
    @Remove         TINYINT = 0,  
    @CorrelationID  UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    --Start transaction, being careful to check if we are nested  
    DECLARE @TranCounter INT;  
  
  
    SET @TranCounter = @@TRANCOUNT;  
    IF @TranCounter > 0 SAVE TRANSACTION TX;  
    ELSE BEGIN TRANSACTION;  
  
    BEGIN TRY  
  
        DECLARE @SQL                            NVARCHAR(MAX),  
                @HistoryOutputQuery             NVARCHAR(MAX),  
  
                @EntityTableName                SYSNAME,  
                @CollectionMemberTableName      SYSNAME,  
                @CollectionTableName            SYSNAME,  
                @HierarchyParentTableName       SYSNAME,  
                @RecordExists                   BIT,  
  
                @MemberType_Leaf                TINYINT = 1,  
                @MemberType_Consolidated        TINYINT = 2,  
                @MemberType_Collection          TINYINT = 3,  
                @MemberType_CollectionMember    TINYINT = 5,  
  
                @Status_Active                  TINYINT = 1,  
                @Status_Deactivated             TINYINT = 2,  
  
                @TransactionLogType             TINYINT,  
                @TransactionLogType_Member      TINYINT = 2,  
  
                -- This pseudo-constant is for use in string concatenation operations to prevent string truncation. When concatenating two or more strings,  
                -- if none of the strings is an NVARCHAR(MAX) or an NVARCHAR constant that is longer than 4,000 characters, then the resulting string  
                -- will be silently truncated to 4,000 characters. Concatenating with this empty NVARCHAR(MAX), is sufficient to prevent truncation.  
                -- See http://connect.microsoft.com/SQLServer/feedback/details/283368/nvarchar-max-concatenation-yields-silent-truncation.  
                @TruncationGuard            NVARCHAR(MAX) = N'';  
  
        SELECT  
             @EntityTableName           = EntityTable  
            ,@CollectionMemberTableName = CollectionMemberTable  
            ,@CollectionTableName       = CollectionTable  
            ,@HierarchyParentTableName  = HierarchyParentTable  
            ,@TransactionLogType        = TransactionLogType  
        FROM mdm.tblEntity  
        WHERE ID = @Entity_ID;  
  
        IF @TransactionLogType = @TransactionLogType_Member  
        BEGIN  
            SET @HistoryOutputQuery = mdm.udfGetHistoryOutputQuery(@Entity_ID, @MemberType_CollectionMember, NULL, NULL);  
        END  
  
        IF      @HierarchyParentTableName IS NULL  
            AND @ChildType_ID = @MemberType_Consolidated  
        BEGIN  
            RAISERROR('MDSERR300035|The member type is not supported by the entity.', 16, 1);  
            RETURN;  
        END;  
  
        --If asked to remove the record then remove it, otherwise create it.  
        IF @Remove = 1 BEGIN--Delete the existing record  
  
            SET @SQL = CONCAT(N'  
                UPDATE mdm.', QUOTENAME(@CollectionMemberTableName), N'  
                SET Status_ID = ', @Status_Deactivated, N',  
                    LastChgDTM = GETUTCDATE(),  
                    LastChgUserID =  @User_ID,  
                    LastChgVersionID =  @Version_ID', CASE @TransactionLogType WHEN @TransactionLogType_Member THEN @HistoryOutputQuery END, N'  
                WHERE Version_ID = @Version_ID  
                    AND ',  
                    CASE @ChildType_ID  
                        WHEN @MemberType_Leaf THEN N'Child_EN_ID'  
                        WHEN @MemberType_Consolidated THEN N'Child_HP_ID'  
                        WHEN @MemberType_Collection THEN N'Child_CN_ID'  
                    END, N' = @Child_ID  
                    AND ChildType_ID = @ChildType_ID  
                    AND Parent_CN_ID = @Collection_ID  
                    AND Status_ID = ', @Status_Active, N';');  
            EXEC sp_executesql @SQL,  
                N'@Version_ID INT, @Child_ID INT, @ChildType_ID TINYINT, @Collection_ID INT, @User_ID INT',  
                  @Version_ID,     @Child_ID,     @ChildType_ID,         @Collection_ID,     @User_ID;  
  
        END ELSE  BEGIN --Create the record  
  
            --Validate @Collection_ID  
            IF @Collection_ID IS NULL  
            BEGIN  
                RAISERROR('MDSERR100039|The Collection ID is not valid.', 16, 1);  
                RETURN;  
            END;--if  
  
            --Check to see if a record with the Collection_ID exists  
            SET @RecordExists = 0;  
            SET @SQL = N'  
                IF EXISTS (  
                    SELECT 1 FROM mdm.' + QUOTENAME(@CollectionTableName) + N'  
                    WHERE ID = @Collection_ID  
                    AND Version_ID = @Version_ID  
                ) SET @RecordExists = 1;';  
  
            EXEC sp_executesql @SQL,  
                N'@Version_ID INT, @Collection_ID INT, @RecordExists BIT OUTPUT',  
                @Version_ID, @Collection_ID, @RecordExists OUTPUT;  
  
            IF @RecordExists = 0  
            BEGIN  
                RAISERROR('MDSERR100010|The Parameters are not valid.', 16, 1);  
                RETURN;  
            END; --if  
  
            --Validate @ChildType_ID  
  
            IF (@ChildType_ID IS NULL) OR (@ChildType_ID < @MemberType_Leaf OR @ChildType_ID > @MemberType_Collection)  
            BEGIN  
                RAISERROR('MDSERR100010|The Parameters are not valid.', 16, 1);  
                RETURN;  
            END; --if  
  
            --Validate @Child_ID  
            --Check to see if a record with the Child_ID exists  
            SET @RecordExists = 0;  
  
            IF @Child_ID IS NOT NULL  
            BEGIN  
                SET @SQL = N'  
                    IF EXISTS (  
                        SELECT 1 FROM mdm.' + QUOTENAME(CASE @ChildType_ID  
                                                            WHEN @MemberType_Leaf           THEN @EntityTableName  
                                                            WHEN @MemberType_Consolidated   THEN @HierarchyParentTableName  
                                                            WHEN @MemberType_Collection     THEN @CollectionTableName  
                                                            END  
                                                            ) + N'  
                        WHERE ID = @Child_ID  
                        AND Version_ID = @Version_ID  
                    ) SET @RecordExists = 1;';  
  
                EXEC sp_executesql @SQL,  
                    N'@Version_ID INT, @Child_ID INT, @RecordExists BIT OUTPUT',  
                    @Version_ID, @Child_ID, @RecordExists OUTPUT;  
            END; -- IF  
  
            IF @RecordExists = 0  
            BEGIN  
                RAISERROR('MDSERR100010|The Parameters are not valid.', 16, 1);  
                RETURN;  
            END; --if  
  
            --IF the user supplied a sort order, we need to update all the collection members that follow this one  
            --to have SortOrder = SortOrder + 1  
            IF COALESCE(@SortOrder, 0) != 0  
                BEGIN  
                    SET @SQL = N'WITH cteCollectionMembersToUpdate AS  
                                    (  
                                        SELECT  tCM1.SortOrder,  
                                                tCM1.ID  
                                        FROM mdm.' + QUOTENAME(@CollectionMemberTableName) + N' AS tCM1  
                                        WHERE  
                                            tCM1.SortOrder = @SortOrder AND  
                                            tCM1.Version_ID = @Version_ID AND  
                                            tCM1.Parent_CN_ID = NULLIF(@Collection_ID, 0)  
  
                                        UNION ALL  
  
                                        SELECT  tCM2.SortOrder,  
                                                tCM2.ID  
                                        FROM mdm.' + QUOTENAME(@CollectionMemberTableName) + N' AS tCM2  
                                        INNER JOIN cteCollectionMembersToUpdate ON tCM2.SortOrder = cteCollectionMembersToUpdate.SortOrder + 1  
                                        WHERE  
                                            tCM2.Version_ID = @Version_ID AND  
                                            tCM2.Parent_CN_ID = NULLIF(@Collection_ID, 0)  
                                    )';  
  
                    SET @SQL += CONCAT(N' UPDATE tCM  
                                    SET tCM.SortOrder += 1,  
                                        LastChgDTM = GETUTCDATE(),  
                                        LastChgUserID =  @User_ID,  
                                        LastChgVersionID =  @Version_ID',  CASE @TransactionLogType WHEN @TransactionLogType_Member THEN @HistoryOutputQuery END, N'  
                                   FROM mdm.', QUOTENAME(@CollectionMemberTableName), N' AS tCM  
                                   INNER JOIN cteCollectionMembersToUpdate  
                                   ON tCM.ID = cteCollectionMembersToUpdate.ID  
  
                                   WHERE tCM.Version_ID = @Version_ID AND  
                                         tCM.Parent_CN_ID = NULLIF(@Collection_ID, 0)');  
  
                    EXEC sp_executesql @SQL,  
                        N'@User_ID INT, @Version_ID INT, @Collection_ID INT, @SortOrder INT',  
                        @User_ID, @Version_ID, @Collection_ID, @SortOrder;  
                END  
  
            --Insert into the Correct Collection Member Table  
            SET @SQL = CONCAT(N'  
                DECLARE  
                    @Child_EN_ID    INT = CASE @ChildType_ID WHEN 1 /*Leaf*/            THEN @Child_ID ELSE NULL END,',  
                        CASE WHEN @HierarchyParentTableName IS NOT NULL THEN '  
                    @Child_HP_ID    INT = CASE @ChildType_ID WHEN 2 /*Consolidated*/    THEN @Child_ID ELSE NULL END,' END, N'  
                    @Child_CN_ID    INT = CASE @ChildType_ID WHEN 3 /*Collection*/      THEN @Child_ID ELSE NULL END,  
                    @Parent_CN_ID   INT = NULLIF(@Collection_ID, 0);  
                DECLARE @CM_ID INT;  
  
                SELECT @CM_ID = ID  
                FROM mdm.', QUOTENAME(@CollectionMemberTableName), N'  
                WHERE  
                    Version_ID = @Version_ID AND  
                    ISNULL(Parent_CN_ID, 0) = ISNULL(@Parent_CN_ID, 0) AND  
                    ChildType_ID = @ChildType_ID AND  
                    ISNULL(Child_EN_ID, 0) = ISNULL(@Child_EN_ID, 0) AND',  
                    CASE WHEN @HierarchyParentTableName IS NOT NULL THEN '  
                    ISNULL(Child_HP_ID, 0) = ISNULL(@Child_HP_ID, 0) AND' ELSE N'' END, N'  
                    ISNULL(Child_CN_ID, 0) = ISNULL(@Child_CN_ID, 0);  
  
                -- Add the member to the collection if it is not already in the collection.  
                IF @CM_ID IS NULL  
                BEGIN  
                    INSERT INTO mdm.', QUOTENAME(@CollectionMemberTableName), N'  
                    (  
                        Version_ID,  
                        Status_ID,  
                        Parent_CN_ID,  
                        ChildType_ID,  
                        Child_EN_ID,',  
                        CASE WHEN @HierarchyParentTableName IS NOT NULL THEN '  
                        Child_HP_ID,' ELSE N'' END, N'  
                        Child_CN_ID,  
                        SortOrder,  
                        Weight,  
                        EnterDTM,  
                        EnterUserID,  
                        EnterVersionID,  
                        LastChgDTM,  
                        LastChgUserID,  
                        LastChgVersionID  
                    )  
                    SELECT  
                        @Version_ID,  
                        1, --Status  
                        @Parent_CN_ID,  
                        @ChildType_ID,  
                        @Child_EN_ID,',  
                        CASE WHEN @HierarchyParentTableName IS NOT NULL THEN '  
                        @Child_HP_ID,' ELSE N'' END, N'  
                        @Child_CN_ID,  
                        CASE WHEN COALESCE(@SortOrder, 0) = 0 THEN COALESCE(MAX(ID), 0) + 1 ELSE @SortOrder END, --Sort order  
                        @Weight, --Weight  
                        GETUTCDATE(),  
                        @User_ID,  
                        @Version_ID,  
                        GETUTCDATE(),  
                        @User_ID,  
                        @Version_ID  
                    FROM  
                        mdm.', QUOTENAME(@CollectionMemberTableName), N';  
                END  
                ELSE  
                BEGIN  
                    UPDATE mdm.', QUOTENAME(@CollectionMemberTableName), N'  
                    SET  
                        Status_ID = ', @Status_Active, ',  
                        Weight = COALESCE(@Weight, Weight),  
                        SortOrder = COALESCE(@SortOrder, SortOrder), --Sort order  
                        LastChgDTM = GETUTCDATE(),  
                        LastChgUserID =  @User_ID,  
                        LastChgVersionID =  @Version_ID',  CASE @TransactionLogType WHEN @TransactionLogType_Member THEN @HistoryOutputQuery END, N'  
                    WHERE ID = @CM_ID;  
                END;');  
  
            EXEC sp_executesql @SQL,  
                N'@User_ID INT, @Version_ID INT, @Collection_ID INT, @ChildType_ID TINYINT, @Child_ID INT, @SortOrder INT, @Weight DECIMAL(10,3)',  
                @User_ID, @Version_ID, @Collection_ID, @ChildType_ID, @Child_ID, @SortOrder, @Weight;  
  
        END; --if  
  
        --Commit only if we are not nested  
        IF @TranCounter = 0 COMMIT TRANSACTION;  
        RETURN(0);  
  
    END TRY  
    --Compensate as necessary  
    BEGIN CATCH  
  
        -- Get error info.  
        DECLARE  
            @ErrorMessage NVARCHAR(4000),  
            @ErrorSeverity INT,  
            @ErrorState INT,  
            @ErrorNumber INT,  
            @ErrorLine INT,  
            @ErrorProcedure NVARCHAR(126);  
        EXEC mdm.udpGetErrorInfo  
            @ErrorMessage = @ErrorMessage OUTPUT,  
            @ErrorSeverity = @ErrorSeverity OUTPUT,  
            @ErrorState = @ErrorState OUTPUT,  
            @ErrorNumber = @ErrorNumber OUTPUT,  
            @ErrorLine = @ErrorLine OUTPUT,  
            @ErrorProcedure = @ErrorProcedure OUTPUT  
  
        SET @ErrorMessage = CONCAT(@ErrorMessage, N', @ErrorNumber = ', @ErrorNumber, N', @ErrorProcedure = "', @ErrorProcedure, N'", line ', @ErrorLine);  
  
        IF @TranCounter = 0 ROLLBACK TRANSACTION;  
        ELSE IF XACT_STATE() <> -1 ROLLBACK TRANSACTION TX;  
  
        RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);  
  
        --On error, return NULL results  
        --SELECT @Return_ID = NULL;  
        RETURN(1);  
  
    END CATCH;  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpCollectionTablesCreate]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
Creates the collection member tables  (e.g. tbl_{@Model_ID}_{@Entity_ID}_CN and tbl_{@Model_ID}_{@Entity_ID}_CM  and system views for the given entity.  
  
*/  
CREATE PROCEDURE [mdm].[udpCollectionTablesCreate]  
(  
     @User_ID               INT  
    ,@Model_ID              INT -- Note that this value could be looked up from the provided entity ID, but it is being passed to save an extra lookup  
    ,@Version_ID            INT  
    ,@Entity_ID             INT  
    ,@IsHierarchyEnabled    BIT -- If 1, adds to the collection membership (CM) table a column with a FK reference to the HP table (since collections can contain consolidated members)  
    ,@TableOptions          NVARCHAR(MAX) = N''  
    ,@IndexOptions          NVARCHAR(MAX) = N''  
    ,@CollectionTable       NVARCHAR(128) OUTPUT  
    ,@CorrelationID         UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
AS BEGIN  
  
    DECLARE  
         @SQL                       NVARCHAR(MAX)  
        ,@TableNamePrefix           NVARCHAR(120) = CONCAT(N'tbl_', @Model_ID, N'_', @Entity_ID)  
        ,@Status_Active             TINYINT = 1  
  
        -- This pseudo-constant is for use in string concatenation operations to prevent string truncation. When concatenating two or more strings,  
        -- if none of the strings is an NVARCHAR(MAX) or an NVARCHAR constant that is longer than 4,000 characters, then the resulting string  
        -- will be silently truncated to 4,000 characters. Concatenating with this empty NVARCHAR(MAX) is sufficient to prevent truncation.  
        -- See http://connect.microsoft.com/SQLServer/feedback/details/283368/nvarchar-max-concatenation-yields-silent-truncation.  
        ,@TruncationGuard        NVARCHAR(MAX) = N'';  
  
    SET @CollectionTable = @TableNamePrefix + N'_CN';  
    DECLARE  
         @EntityTable               NVARCHAR(128) = @TableNamePrefix + N'_EN'  
        ,@CollectionMemberTable     NVARCHAR(128) = @TableNamePrefix + N'_CM'  
        ,@HierarchyParentTable      NVARCHAR(128) = @TableNamePrefix + N'_HP'  
        ,@CollectionHistoryTable    NVARCHAR(128) = @TableNamePrefix + N'_CN_HS'  
        ,@CollectionAnnotationTable NVARCHAR(128) = @TableNamePrefix + N'_CN_AN'  
        ,@CollectionMemberHistoryTable      NVARCHAR(128) = @TableNamePrefix + N'_CM_HS'  
        ,@CollectionMemberAnnotationTable   NVARCHAR(128) = @TableNamePrefix + N'_CM_AN';  
    -- Create the Collection table (CN)  
    SET @SQL = @TruncationGuard + N'  
        CREATE TABLE mdm.' + QUOTENAME(@CollectionTable) + N'  
        (  
            --Identity  
             Version_ID          INT NOT NULL  
            ,ID                  INT IDENTITY(1, 1) NOT NULL  
            --Status  
            ,Status_ID           TINYINT NOT NULL CONSTRAINT ' + QUOTENAME(N'df_' + @CollectionTable  + N'_Status_ID') + N' DEFAULT ' + CONVERT(NVARCHAR, @Status_Active) + N'  
            ,ValidationStatus_ID TINYINT NOT NULL CONSTRAINT ' + QUOTENAME(N'df_' + @CollectionTable  + N'_ValidationStatus_ID') + N' DEFAULT 0  
  
            --Data  
            ,[Name]              NVARCHAR(250) NULL  
            ,Code                NVARCHAR(250) NOT NULL  
            ,[Description]       NVARCHAR(500) NULL  
            ,[Owner_ID]          INT NOT NULL  
  
            --Auditing  
            ,EnterDTM            DATETIME2(3) NOT NULL CONSTRAINT ' + QUOTENAME(N'df_' + @CollectionTable  + N'_EnterDTM') + N' DEFAULT GETUTCDATE()  
            ,EnterUserID         INT NOT NULL  
            ,EnterVersionID      INT NOT NULL  
            ,LastChgDTM          DATETIME2(3) NOT NULL CONSTRAINT ' + QUOTENAME(N'df_' + @CollectionTable  + N'_LastChgDTM') + N' DEFAULT GETUTCDATE()  
            ,LastChgUserID       INT NOT NULL  
            ,LastChgVersionID    INT NOT NULL  
            ,LastChgTS           ROWVERSION NOT NULL  
            ,AsOf_ID             INT NULL  
            ,MUID                UNIQUEIDENTIFIER NOT NULL CONSTRAINT ' + QUOTENAME(N'df_' + @CollectionTable + N'_MUID') + N' DEFAULT NEWID()  
  
            --Create PRIMARY KEY constraint  
            ,CONSTRAINT ' + QUOTENAME(N'pk_' + @CollectionTable + N'') + N'  
                PRIMARY KEY CLUSTERED (Version_ID, ID)  
  
            --Create FOREIGN KEY constraints  
            ,CONSTRAINT ' + QUOTENAME(N'fk_' + @CollectionTable  + N'_tblUser_Owner_ID') + N'  
                FOREIGN KEY ([Owner_ID]) REFERENCES mdm.tblUser(ID)  
                ON UPDATE NO ACTION  
                ON DELETE NO ACTION  
  
            -- Note: the values of the Status_ID column should fall between 1 and 2. The ValidationStatus_ID column should be between 0 and 5. However,  
            -- we do not enforce this via db constraint because it would slow down table writes and only trusted MDS sproc code should be writing to those columns.  
        )  
        ' + @TableOptions + N';  
  
        --Ensure uniqueness of [Code] for active members.  
        CREATE UNIQUE NONCLUSTERED INDEX ' + QUOTENAME(N'ux_' + @CollectionTable + N'_Version_ID_Code_Active') + N'  
            ON mdm.' + QUOTENAME(@CollectionTable) + N'(Version_ID, Code)  
            WHERE Status_ID = ' + CONVERT(NVARCHAR, @Status_Active) + N'  
        ' + @IndexOptions + N';  
  
        --Index [Name] for performance  
        CREATE NONCLUSTERED INDEX ' + QUOTENAME(N'ix_' + @CollectionTable + N'_Version_ID_Name') + N'  
            ON mdm.' + QUOTENAME(@CollectionTable) + N'(Version_ID, Name)  
        ' + @IndexOptions + N';  
  
        --Ensure uniqueness of [MUID]  
        CREATE UNIQUE NONCLUSTERED INDEX ' + QUOTENAME(N'ux_' + @CollectionTable + N'_Version_ID_MUID') + N'  
            ON mdm.' + QUOTENAME(@CollectionTable) + N'(Version_ID, MUID)  
        ' + @IndexOptions + N';  
  
        CREATE NONCLUSTERED INDEX ' + QUOTENAME(N'ux_' + @CollectionTable + N'_Version_ID_Owner_ID') + N'  
            ON mdm.' + QUOTENAME(@CollectionTable) + N'(Version_ID, Owner_ID)  
        ' + @IndexOptions + N';  
  
        --Required for VersionCopy operations  
        CREATE NONCLUSTERED INDEX ' + QUOTENAME(N'ix_' + @CollectionTable  + N'_Version_ID_AsOf_ID_Status_ID') + N'  
            ON mdm.' + QUOTENAME(@CollectionTable) + N'(Version_ID, AsOf_ID, Status_ID)  
            INCLUDE ([ID])  
            WHERE [AsOf_ID] IS NOT NULL  
        ' + @IndexOptions + N';  
  
        --Create the History (_CN_HS) table  
        CREATE TABLE mdm.' + QUOTENAME(@CollectionHistoryTable) + N'  
        (  
            --Identity  
            Version_ID          INT NOT NULL,  
            ID                  BIGINT NOT NULL,  
  
            CN_ID               INT NOT NULL,  
  
            --Status  
            Status_ID           TINYINT NOT NULL,  
  
            --Data  
            [Name]              NVARCHAR(250) NULL,  
            Code                NVARCHAR(250) NOT NULL,  
            [Description]       NVARCHAR(500) NULL,  
            [Owner_ID]          INT NOT NULL,  
  
            --Auditing  
            EnterDTM            DATETIME2(3) NOT NULL,  
            EnterUserID         INT NOT NULL,  
            LastChgDTM          DATETIME2(3) NOT NULL,  
            LastChgUserID       INT NOT NULL,  
            MUID                UNIQUEIDENTIFIER NOT NULL,  
  
            --Create PRIMARY KEY constraint  
            CONSTRAINT ' + QUOTENAME(N'pk_' + @CollectionHistoryTable + N'') + N'  
                PRIMARY KEY CLUSTERED (Version_ID, ID)  
  
            --Cannot have foreign key (Version_ID, CN_ID) on CN table, because HS table is used in OUTPUT clause  
        )  
        ' + @TableOptions + N';  
  
        -- Required by udpEntityMemberHistoriesGet and type2 view  
        CREATE NONCLUSTERED INDEX ' + QUOTENAME(N'ix_' + @CollectionHistoryTable + N'_Version_ID_CN_ID') + N'  
            ON mdm.' + QUOTENAME(@CollectionHistoryTable) + N'(Version_ID, CN_ID, EnterDTM, LastChgDTM)  
            ' + @IndexOptions + N';  
  
        --Create the Annotation (_CN_AN) table  
        CREATE TABLE mdm.' + QUOTENAME(@CollectionAnnotationTable) + N'  
        (  
            Version_ID          INT NOT NULL,  
            ID                  INT IDENTITY(1, 1) NOT NULL,  
  
            Revision_ID         BIGINT NOT NULL,  
  
            [Comment]           [NVARCHAR](500) NULL,  
  
            --Auditing  
            EnterDTM            DATETIME2(3) NOT NULL CONSTRAINT ' + QUOTENAME(N'df_' + @CollectionAnnotationTable  + N'_EnterDTM') + N' DEFAULT GETUTCDATE(),  
            EnterUserID         INT NOT NULL,  
            LastChgDTM          DATETIME2(3) NOT NULL CONSTRAINT ' + QUOTENAME(N'df_' + @CollectionAnnotationTable  + N'_LastChgDTM') + N' DEFAULT GETUTCDATE(),  
            LastChgUserID       INT NOT NULL,  
            LastChgTS           ROWVERSION NOT NULL,  
  
            --Create PRIMARY KEY constraint  
            CONSTRAINT ' + QUOTENAME(N'pk_' + @CollectionAnnotationTable) + N'  
                PRIMARY KEY CLUSTERED (Version_ID, ID)  
        )  
        ' + @TableOptions + N';  
  
        -- Required for udpEntityMemberAnnotationsGet operations  
        CREATE NONCLUSTERED INDEX ' + QUOTENAME(N'ix_' + @CollectionAnnotationTable + N'_Version_ID_Revision_ID') + N'  
            ON mdm.' + QUOTENAME(@CollectionAnnotationTable) + N'(Version_ID, Revision_ID)  
            ' + @IndexOptions + N';  
        ';  
  
    --Execute the dynamic SQL  
    --PRINT(@SQL);  
    EXEC sp_executesql @SQL;  
  
  
    -- Create the Collection Member Table (CM)  
    SET @SQL = @TruncationGuard + N'  
        CREATE TABLE mdm.' + QUOTENAME(@CollectionMemberTable) + N'  
        (  
            --Identity  
             Version_ID          INT NOT NULL  
            ,ID                  INT IDENTITY(1, 1) NOT NULL  
  
            --Status  
            ,Status_ID           TINYINT NOT NULL CONSTRAINT ' + QUOTENAME(N'df_' + @CollectionMemberTable  + N'_Status_ID') + N' DEFAULT ' + CONVERT(NVARCHAR, @Status_Active) + N'  
  
            --Pointers  
            ,Parent_CN_ID        INT NOT NULL --Always points to CN  
            ,ChildType_ID        TINYINT NOT NULL  
            ,Child_EN_ID         INT NULL --Used when the child is of type EN (ChildType_ID = 1)' +  
            CASE WHEN @IsHierarchyEnabled = 1 THEN N'  
            ,Child_HP_ID         INT NULL --Used when the child is of type HP (ChildType_ID = 2)' ELSE N'' END + N'  
            ,Child_CN_ID         INT NULL --Used when the child is of type CN (ChildType_ID = 3)  
  
            --Data  
            ,SortOrder           INT NOT NULL  
            ,Weight              DECIMAL(10,3) NOT NULL CONSTRAINT ' + QUOTENAME(N'df_' + @CollectionMemberTable  + N'_Weight') + N' DEFAULT 1.0  
  
            --Auditing  
            ,EnterDTM            DATETIME2(3) NOT NULL CONSTRAINT ' + QUOTENAME(N'df_' + @CollectionMemberTable  + N'_EnterDTM') + N' DEFAULT GETUTCDATE()  
            ,EnterUserID         INT NOT NULL  
            ,EnterVersionID      INT NOT NULL  
            ,LastChgDTM          DATETIME2(3) NOT NULL CONSTRAINT ' + QUOTENAME(N'df_' + @CollectionMemberTable  + N'_LastChgDTM') + N' DEFAULT GETUTCDATE()  
            ,LastChgUserID       INT NOT NULL  
            ,LastChgVersionID    INT NOT NULL  
            ,LastChgTS           ROWVERSION NOT NULL  
            ,AsOf_ID             INT NULL  
            ,MUID                UNIQUEIDENTIFIER NOT NULL CONSTRAINT ' + QUOTENAME(N'df_' + @CollectionMemberTable + N'_MUID') + N' DEFAULT NEWID()  
  
            --Create PRIMARY KEY constraint  
            CONSTRAINT ' + QUOTENAME(N'pk_' + @CollectionMemberTable + N'') + N'  
                PRIMARY KEY (Version_ID, ID)  
  
            --Create FOREIGN KEY constraints  
            ,CONSTRAINT ' + QUOTENAME(N'fk_' + @CollectionMemberTable + N'_' + @CollectionTable + N'_Parent_CN_ID') + N'  
                FOREIGN KEY (Version_ID, Parent_CN_ID) REFERENCES mdm.' + QUOTENAME(@CollectionTable) + N'(Version_ID, ID)  
                ON UPDATE NO ACTION  
                ON DELETE CASCADE  
            ,CONSTRAINT ' + QUOTENAME(N'fk_' + @CollectionMemberTable + N'_' + @EntityTable + N'_Child_EN_ID') + N'  
                FOREIGN KEY (Version_ID, Child_EN_ID) REFERENCES mdm.' + QUOTENAME(@EntityTable) + N'(Version_ID, ID)  
                ON UPDATE NO ACTION  
                ON DELETE CASCADE' +  
            CASE WHEN @IsHierarchyEnabled = 1 THEN N'  
            ,CONSTRAINT ' + QUOTENAME(N'fk_' + @CollectionMemberTable + N'_' + @HierarchyParentTable + N'_Child_HP_ID') + N'  
                FOREIGN KEY (Version_ID, Child_HP_ID) REFERENCES mdm.' + QUOTENAME(@HierarchyParentTable) + N'(Version_ID, ID)  
                ON UPDATE NO ACTION  
                ON DELETE CASCADE' ELSE N'' END + N'  
            ,CONSTRAINT ' + QUOTENAME(N'fk_' + @CollectionMemberTable + N'_' + @CollectionTable + N'_Child_CN_ID') + N'  
                FOREIGN KEY (Version_ID, Child_CN_ID) REFERENCES mdm.' + QUOTENAME(@CollectionTable) + N'(Version_ID, ID)  
                ON UPDATE NO ACTION  
                ON DELETE NO ACTION --Cannot use CASCADE due to chance of cycles  
  
            --Create CHECK constraints  
            ,CONSTRAINT ' + QUOTENAME(N'ck_' + @CollectionMemberTable + N'_ChildType_ID') + N'  
                CHECK (    (ChildType_ID = 1 AND Child_EN_ID IS NOT NULL' +  
            CASE WHEN @IsHierarchyEnabled = 1 THEN N' AND Child_HP_ID IS NULL' ELSE N'' END + N' AND Child_CN_ID IS NULL)' +  
            CASE WHEN @IsHierarchyEnabled = 1 THEN N'  
                        OR (ChildType_ID = 2 AND Child_HP_ID IS NOT NULL AND Child_EN_ID IS NULL AND Child_CN_ID IS NULL)' ELSE N'' END + N'  
                        OR (ChildType_ID = 3 AND Child_CN_ID IS NOT NULL AND Child_EN_ID IS NULL' +  
            CASE WHEN @IsHierarchyEnabled = 1 THEN N' AND Child_HP_ID IS NULL' ELSE N'' END + N'))  
            ,CONSTRAINT ' + QUOTENAME(N'ck_' + @CollectionMemberTable + N'_Parent_CN_ID_Child_CN_ID') + N'  
                CHECK (NOT (ChildType_ID = 3 AND Parent_CN_ID = Child_CN_ID)) --Prevent self-reference  
        )  
        ' + @TableOptions + N';  
  
        --Required for foreign key join performance  
        CREATE NONCLUSTERED INDEX ' + QUOTENAME(N'ix_' + @CollectionMemberTable + N'_Version_ID_Parent_CN_ID') + N'  
            ON mdm.' + QUOTENAME(@CollectionMemberTable) + N'(Version_ID, Parent_CN_ID)  
            ' + @IndexOptions + N';  
            --No filter on this index since Parent_CN_ID is NOT NULL' +  
            CASE WHEN @IsHierarchyEnabled = 1 THEN N'  
        CREATE NONCLUSTERED INDEX ' + QUOTENAME(N'ix_' + @CollectionMemberTable + N'_Version_ID_Child_HP_ID') + N'  
            ON mdm.' + QUOTENAME(@CollectionMemberTable) + N'(Version_ID, Child_HP_ID)  
            WHERE [Child_HP_ID] IS NOT NULL  
            ' + @IndexOptions + N';' ELSE N'' END + N'  
        CREATE NONCLUSTERED INDEX ' + QUOTENAME(N'ix_' + @CollectionMemberTable + N'_Version_ID_Child_CN_ID') + N'  
            ON mdm.' + QUOTENAME(@CollectionMemberTable) + N'(Version_ID, Child_CN_ID)  
            WHERE [Child_CN_ID] IS NOT NULL  
            ' + @IndexOptions + N';  
        CREATE NONCLUSTERED INDEX ' + QUOTENAME(N'ix_' + @CollectionMemberTable + N'_Version_ID_Child_EN_ID') + N'  
            ON mdm.' + QUOTENAME(@CollectionMemberTable) + N'(Version_ID, Child_EN_ID)  
            WHERE [Child_EN_ID] IS NOT NULL  
            ' + @IndexOptions + N';  
  
        --Create the HISTORY (_CM_HS) table  
        CREATE TABLE mdm.' + QUOTENAME(@CollectionMemberHistoryTable) + N'  
        (  
            --Identity  
            Version_ID          INT NOT NULL,  
            ID                  BIGINT NOT NULL,  
  
            CM_ID               INT NOT NULL,  
  
            --Status  
            Status_ID           TINYINT NOT NULL,  
  
            --Pointers  
            Parent_CN_ID        INT NOT NULL, --Always points to CN  
            ChildType_ID        TINYINT NOT NULL,  
            Child_EN_ID         INT NULL, --Used when the child is of type EN (ChildType_ID = 1)' +  
            CASE WHEN @IsHierarchyEnabled = 1 THEN N'  
            Child_HP_ID         INT NULL, --Used when the child is of type HP (ChildType_ID = 2)' ELSE N'' END + N'  
            Child_CN_ID         INT NULL, --Used when the child is of type CN (ChildType_ID = 3)  
  
            --Data  
            SortOrder           INT NOT NULL,  
            Weight              DECIMAL(10,3) NOT NULL,  
  
            --Auditing  
            EnterDTM            DATETIME2(3) NOT NULL,  
            EnterUserID         INT NOT NULL,  
            LastChgDTM          DATETIME2(3) NOT NULL,  
            LastChgUserID       INT NOT NULL,  
            MUID                UNIQUEIDENTIFIER NOT NULL,  
  
            --Create PRIMARY KEY constraint  
            CONSTRAINT ' + QUOTENAME(N'pk_' + @CollectionMemberHistoryTable + N'') + N'  
                PRIMARY KEY CLUSTERED (Version_ID, ID)  
  
            --Cannot have foreign key (Version_ID, CM_ID) on CM table, because HS table is used in OUTPUT clause  
        )  
        ' + @TableOptions + N';  
  
        --Required for udpEntityMemberHistoriesGet operations  
        CREATE NONCLUSTERED INDEX ' + QUOTENAME(N'ix_' + @CollectionMemberHistoryTable + N'_Version_ID_CM_ID') + N'  
            ON mdm.' + QUOTENAME(@CollectionMemberHistoryTable) + N'(Version_ID, CM_ID)  
            ' + @IndexOptions + N';  
  
        --Create the Annotation (_CM_AN) table  
        CREATE TABLE mdm.' + QUOTENAME(@CollectionMemberAnnotationTable) + N'  
        (  
            Version_ID          INT NOT NULL,  
            ID                  INT IDENTITY(1, 1) NOT NULL,  
  
            Revision_ID         BIGINT NOT NULL,  
  
            [Comment]           [NVARCHAR](500) NULL,  
  
            --Auditing  
            EnterDTM            DATETIME2(3) NOT NULL CONSTRAINT ' + QUOTENAME(N'df_' + @CollectionMemberAnnotationTable  + N'_EnterDTM') + N' DEFAULT GETUTCDATE(),  
            EnterUserID         INT NOT NULL,  
            LastChgDTM          DATETIME2(3) NOT NULL CONSTRAINT ' + QUOTENAME(N'df_' + @CollectionMemberAnnotationTable  + N'_LastChgDTM') + N' DEFAULT GETUTCDATE(),  
            LastChgUserID       INT NOT NULL,  
            LastChgTS           ROWVERSION NOT NULL,  
  
            --Create PRIMARY KEY constraint  
            CONSTRAINT ' + QUOTENAME(N'pk_' + @CollectionMemberAnnotationTable) + N'  
                PRIMARY KEY CLUSTERED (Version_ID, ID)  
        )  
        ' + @TableOptions + N';  
  
        --Required for udpEntityMemberAnnotationsGet operations  
        CREATE NONCLUSTERED INDEX ' + QUOTENAME(N'ix_' + @CollectionMemberAnnotationTable + N'_Version_ID_Revision_ID') + N'  
            ON mdm.' + QUOTENAME(@CollectionMemberAnnotationTable) + N'(Version_ID, Revision_ID)  
            ' + @IndexOptions + N';  
        ';  
  
    --Execute the dynamic SQL  
    --PRINT(@SQL);  
    EXEC sp_executesql @SQL;  
  
    -- Update the entity table with the new collection table names  
    UPDATE mdm.tblEntity  
    SET  CollectionTable = @CollectionTable  
        ,CollectionMemberTable = @CollectionMemberTable  
        ,LastChgDTM = GETUTCDATE()  
        ,LastChgUserID = @User_ID  
    WHERE ID = @Entity_ID;  
  
    -- Add system attributes for collection tables.  
  
    --Collection (CN)  
    INSERT INTO mdm.tblAttribute (Entity_ID,SortOrder,DomainEntity_ID,AttributeType_ID,MemberType_ID,IsSystem,IsReadOnly,IsCode,IsName,[Name],DisplayName,TableColumn,DisplayWidth,DataType_ID,DataTypeInformation,InputMask_ID,EnterUserID,EnterVersionID,LastChgUserID,LastChgVersionID)  
    VALUES  
     (@Entity_ID,1,NULL,3,3,1,1,0,0,N'ID',N'ID',N'ID',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
    ,(@Entity_ID,2,NULL,3,3,1,1,0,0,N'Version_ID',N'Version_ID',N'Version_ID',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
    ,(@Entity_ID,4,NULL,3,3,1,1,0,0,N'Status_ID',N'Status_ID',N'Status_ID',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
    ,(@Entity_ID,5,NULL,3,3,1,1,0,0,N'ValidationStatus_ID',N'ValidationStatus_ID',N'ValidationStatus_ID',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
    ,(@Entity_ID,6,NULL,3,3,1,1,0,0,N'EnterDTM',N'EnterDTM',N'EnterDTM',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
    ,(@Entity_ID,7,NULL,3,3,1,1,0,0,N'EnterUserID',N'EnterUserID',N'EnterUserID',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
    ,(@Entity_ID,8,NULL,3,3,1,1,0,0,N'EnterVersionID',N'EnterVersionID',N'EnterVersionID',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
    ,(@Entity_ID,9,NULL,3,3,1,1,0,0,N'LastChgDTM',N'LastChgDTM',N'LastChgDTM',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
    ,(@Entity_ID,10,NULL,3,3,1,1,0,0,N'LastChgUserID',N'LastChgUserID',N'LastChgUserID',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
    ,(@Entity_ID,11,NULL,3,3,1,1,0,0,N'LastChgVersionID',N'LastChgVersionID',N'LastChgVersionID',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
    ,(@Entity_ID,12,NULL,3,3,1,1,0,0,N'LastChgTS',N'LastChgTS',N'LastChgTS',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
    ,(@Entity_ID,13,NULL,1,3,1,0,0,1,N'Name',N'Name',N'Name',250,1,250,1,@User_ID,@Version_ID,@User_ID,@Version_ID)  
    ,(@Entity_ID,14,NULL,1,3,1,0,1,0,N'Code',N'Code',N'Code',250,1,250,1,@User_ID,@Version_ID,@User_ID,@Version_ID)  
    ,(@Entity_ID,15,NULL,1,3,1,0,0,0,N'Description',N'Description',N'Description',225,1,100,1,@User_ID,@Version_ID,@User_ID,@Version_ID)  
    ,(@Entity_ID,16,NULL,1,3,1,0,0,0,N'Owner_ID',N'Owner_ID',N'Owner_ID',100,1,100,1,@User_ID,@Version_ID,@User_ID,@Version_ID)  
    ,(@Entity_ID,17,NULL,3,3,1,1,0,0,N'MUID',N'MUID',N'MUID',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
    ,(@Entity_ID,18,NULL,3,3,1,1,0,0,N'AsOf_ID',N'AsOf_ID',N'AsOf_ID',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
    ;  
  
    --CollectionMember (CM)  
    INSERT INTO mdm.tblAttribute (Entity_ID,SortOrder,DomainEntity_ID,AttributeType_ID,MemberType_ID,IsSystem,IsReadOnly,[Name],DisplayName,TableColumn,DisplayWidth,DataType_ID,DataTypeInformation,InputMask_ID,EnterUserID,EnterVersionID,LastChgUserID,LastChgVersionID)  
    VALUES  
     (@Entity_ID, 1,NULL,3,5,1,1,N'ID',N'ID',N'ID',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
    ,(@Entity_ID, 2,NULL,3,5,1,1,N'Version_ID',N'Version_ID',N'Version_ID',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
    ,(@Entity_ID, 3,NULL,3,5,1,1,N'Status_ID',N'Status_ID',N'Status_ID',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
    ,(@Entity_ID, 5,NULL,3,5,1,1,N'EnterDTM',N'EnterDTM',N'EnterDTM',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
    ,(@Entity_ID, 6,NULL,3,5,1,1,N'EnterUserID',N'EnterUserID',N'EnterUserID',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
    ,(@Entity_ID, 7,NULL,3,5,1,1,N'EnterVersionID',N'EnterVersionID',N'EnterVersionID',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
    ,(@Entity_ID, 8,NULL,3,5,1,1,N'LastChgDTM',N'LastChgDTM',N'LastChgDTM',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
    ,(@Entity_ID, 9,NULL,3,5,1,1,N'LastChgUserID',N'LastChgUserID',N'LastChgUserID',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
    ,(@Entity_ID, 10,NULL,3,5,1,1,N'LastChgVersionID',N'LastChgVersionID',N'LastChgVersionID',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
    ,(@Entity_ID, 11,NULL,3,5,1,1,N'LastChgTS',N'LastChgTS',N'LastChgTS',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
    ,(@Entity_ID, 13, NULL,3,5,1,1,N'Parent_CN_ID',N'Parent_CN_ID',N'Parent_CN_ID',0,1,100,1,@User_ID,@Version_ID,@User_ID,@Version_ID)  
    ,(@Entity_ID, 14, NULL,3,5,1,1,N'Child_EN_ID',N'Child_EN_ID',N'Child_EN_ID',0,1,100,1,@User_ID,@Version_ID,@User_ID,@Version_ID)  
    ,(@Entity_ID, 15, NULL,3,5,1,1,N'Child_HP_ID',N'Child_HP_ID',N'Child_HP_ID',0,1,100,1,@User_ID,@Version_ID,@User_ID,@Version_ID)  
    ,(@Entity_ID, 16, NULL,3,5,1,1,N'Child_CN_ID',N'Child_CN_ID',N'Child_CN_ID',0,1,100,1,@User_ID,@Version_ID,@User_ID,@Version_ID)  
    ,(@Entity_ID, 17, NULL,3,5,1,1,N'ChildType_ID',N'ChildType_ID',N'ChildType_ID',0,1,100,1,@User_ID,@Version_ID,@User_ID,@Version_ID)  
    ,(@Entity_ID, 18, NULL,3,5,1,1,N'SortOrder',N'SortOrder',N'SortOrder',0,1,100,1,@User_ID,@Version_ID,@User_ID,@Version_ID)  
    ,(@Entity_ID, 19, NULL,1,5,1,0,N'Weight',N'Weight',N'Weight',50,1,100,1,@User_ID,@Version_ID,@User_ID,@Version_ID)  
    ,(@Entity_ID, 20,NULL,3,5,1,1,N'MUID',N'MUID',N'MUID',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
    ,(@Entity_ID, 21,NULL,3,5,1,1,N'AsOf_ID',N'AsOf_ID',N'AsOf_ID',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
    ;  
  
    EXEC mdm.udpCreateSystemViews @Model_ID, @Entity_ID  
  
    -- Recreate the staging sprocs, because they reference the collection table to check for code uniqueness.  
    EXEC mdm.udpEntityStagingCreateLeafStoredProcedure @Entity_ID;  
    IF @IsHierarchyEnabled = 1  
    BEGIN  
        EXEC mdm.udpEntityStagingCreateConsolidatedStoredProcedure @Entity_ID;  
    END;  
  
    -- Send the message  
	EXEC mdm.udpPerformanceQueueSave;  
END;
GO
/****** Object:  StoredProcedure [mdm].[udpCollectionTablesDrop]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    Removes all collection-related tables from the given entities.  
*/  
CREATE PROCEDURE [mdm].[udpCollectionTablesDrop]  
(  
    @Entities       mdm.IdList READONLY,  
    @CorrelationID  UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE   
         @SQL                               NVARCHAR(MAX) = ''  
        ,@SQLDeleteViews                    NVARCHAR(MAX) = ''  
        ,@MemberType_Collection             TINYINT = 3  
        ,@MemberType_CollectionParentChild  TINYINT = 5  
  
    -- This pseudo-constant is for use in string concatenation operations to prevent string truncation. When concatenating two or more strings,  
    -- if none of the strings is an NVARCHAR(MAX) or an NVARCHAR constant that is longer than 4,000 characters, then the resulting string   
    -- will be silently truncated to 4,000 characters. Concatenating with this empty NVARCHAR(MAX), is sufficient to prevent truncation.  
    -- See http://connect.microsoft.com/SQLServer/feedback/details/283368/nvarchar-max-concatenation-yields-silent-truncation.  
        ,@TruncationGuard NVARCHAR(MAX) = N'';  
  
    DECLARE @EntityInfo TABLE  
    (  
         ID                     INT PRIMARY KEY  
        ,Model_ID               INT  
        ,IsHierarchyEnabled     BIT  
        ,CollectionMemberTable  SYSNAME  
        ,CollectionTable        SYSNAME  
    );  
    --Start transaction, being careful to check if we are nested  
    DECLARE @TranCounter INT;   
  
    SET @TranCounter = @@TRANCOUNT;  
    IF @TranCounter > 0 SAVE TRANSACTION TX;  
    ELSE BEGIN TRANSACTION;  
  
    BEGIN TRY  
  
        INSERT INTO @EntityInfo  
        SELECT DISTINCT   
             ei.ID  
            ,e.Model_ID  
            ,CASE WHEN e.HierarchyTable IS NULL THEN 0 ELSE 1 END IsHierarchyEnabled  
            ,e.CollectionMemberTable  
            ,e.CollectionTable  
        FROM @Entities ei  
        INNER JOIN mdm.tblEntity e  
        ON ei.ID = e.ID  
        WHERE e.CollectionTable IS NOT NULL;  
  
        IF EXISTS (SELECT 1 FROM @EntityInfo)  
        BEGIN  
            SELECT   
                @SQLDeleteViews += CONCAT(@TruncationGuard, N'  
EXEC mdm.udpDeleteViews ', Model_ID, N',', ID, N', NULL, 2 -- Collection views  
                '),  
  
                @SQL += CONCAT(@TruncationGuard, N'  
DROP TABLE mdm.', QUOTENAME(CollectionMemberTable + N'_AN'), N'  
DROP TABLE mdm.', QUOTENAME(CollectionMemberTable + N'_HS'), N'  
DROP TABLE mdm.', QUOTENAME(CollectionMemberTable), N'  
DROP TABLE mdm.', QUOTENAME(CollectionTable + N'_AN'), N'  
DROP TABLE mdm.', QUOTENAME(CollectionTable + N'_HS'), N'  
DROP TABLE mdm.', QUOTENAME(CollectionTable), N'  
  
-- Recreate the staging sprocs, because they reference the collection table to check for code uniqueness.  
EXEC mdm.udpEntityStagingCreateLeafStoredProcedure ', ID, N';',   
            CASE WHEN IsHierarchyEnabled = 1 THEN CONCAT(N'  
EXEC mdm.udpEntityStagingCreateConsolidatedStoredProcedure ', ID, N';') END)  
            FROM @EntityInfo;  
  
PRINT CONCAT(SYSDATETIME(), N': Deleting collection system views'); -- Note that this must be done before clearing the tlbEntity columns  
            --PRINT @@SQLDeleteViews;  
            EXEC sp_executesql @SQLDeleteViews;  
  
PRINT CONCAT(SYSDATETIME(), N': Clearing collection member table info from tblEntity');  
            UPDATE e  
            SET   
                 CollectionTable = NULL  
                ,CollectionMemberTable = NULL  
            FROM @EntityInfo ei  
            INNER JOIN mdm.tblEntity e  
            ON ei.ID = e.ID;  
  
PRINT CONCAT(SYSDATETIME(), N': Removing collection-related attributes from tblAttribute');  
            DELETE a  
            FROM mdm.tblAttribute a  
            INNER JOIN @EntityInfo ei  
            ON a.Entity_ID = ei.ID  
            WHERE a.MemberType_ID IN (@MemberType_Collection, @MemberType_CollectionParentChild)  
  
PRINT CONCAT(SYSDATETIME(), N': Deleting collection tables');  
            --PRINT @SQL;  
            EXEC sp_executesql @SQL;  
        END  
  
        --Commit only if we are not nested  
        IF @TranCounter = 0 COMMIT TRANSACTION;  
  
        -- Send the message  
	    EXEC mdm.udpPerformanceQueueSave;  
  
        RETURN(0);  
  
    END TRY  
    --Compensate as necessary  
    BEGIN CATCH  
  
        -- Get error info.  
        DECLARE  
            @ErrorMessage NVARCHAR(4000),  
            @ErrorSeverity INT,  
            @ErrorState INT,  
            @ErrorNumber INT,  
            @ErrorLine INT,  
            @ErrorProcedure NVARCHAR(126);  
        EXEC mdm.udpGetErrorInfo  
            @ErrorMessage = @ErrorMessage OUTPUT,  
            @ErrorSeverity = @ErrorSeverity OUTPUT,  
            @ErrorState = @ErrorState OUTPUT,  
            @ErrorNumber = @ErrorNumber OUTPUT,  
            @ErrorLine = @ErrorLine OUTPUT,  
            @ErrorProcedure = @ErrorProcedure OUTPUT  
  
        SET @ErrorMessage = CONCAT(@ErrorMessage, N', @ErrorNumber = ', @ErrorNumber, N', @ErrorProcedure = "', @ErrorProcedure, N'", line ', @ErrorLine);  
  
        IF @TranCounter = 0 ROLLBACK TRANSACTION;  
        ELSE IF XACT_STATE() <> -1 ROLLBACK TRANSACTION TX;  
  
        RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);		  
  
        --On error, return NULL results  
        --SELECT @Return_ID = NULL;  
        RETURN(1);  
  
    END CATCH;  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpConvertCollectionAndConsolidatedMembersToLeaf]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
Converts deprecated collection members and consolidated members to leaf members. Also converts their corresponding deprecated explicit hierarchies (EH)   
to recursive derived hierarchies (RDH).  
  
Conversion process:  
  
Converting Consolidated members and EHs  
----------------------------------------  
Suppose there is an entity named Product that contains the following EHs:  
   EH Name          Mandatory EH?  
  *********        ***************  
   Bundle               Yes  
   NonMandatory         No  
  
- Create one new entity per EH. The name of the new entity is "<Leaf entity name>_<EH name>". In the above example, two new entities will be created, "Product_Bundle" and "Product_NonMandatory".  
    -- Copy consolidated attributes from original EH's entity to leaf attributes on each new entity.  
    -- Copy all consolidated members of the EH to leaf members on the corresponding new entity. For mandatory hierarchies that have leaf members directly under ROOT, add a "Pseudo Root" member. For  
       non-mandatory EHs that have unassigned leaf members, leave them as-is.  
    -- Add a new self-referencing DBA, named "Parent", to the new entity and set its value to reflect the original consolidated member's parent in the EH.  
- Create new DBAs on the original entity, one per EH on the entity. The name of each DBA will be the EH name. In the above example, two DBAs will be added to the Product entity: Bundle (which   
  references Product_Bundle as its domain entity) and NonMandatory (which references Product_NonMandatory). The value of these DBAs is set to reflect each leaf member's parent  
  in the EH being copied.  
- Copy transactions. EH parent/sibling move transactions are converted to attribute value change transactions. If the @DeleteOriginals flag is set, the original  
  transaction rows will be updated, rather than copied, for efficiency. Otherwise, transaction annotations are also copied.  
- Create one new RDH per EH. Each RDH will have a single non-recursive level beneath the recursive levels. The name of the RDH will be the same as the EH, if that name is  
  not already being used by another DH in the same model. Otherwise, it will follow the same pattern as the new entity names, i.e. "<Leaf entity name>_<EH name>", or   
  "Product_Bundle" and "Product_NonMandatory" in the above example.  
- For each existing DH with an EH cap, create a new RDH with (potentially) multiple levels below. The name of the new hierarchy will be "<EH cap DH name>_NoCap".  
- Copy business rules (BR), both rules that applied to the consolidated members being copied and leaf rules that were referencing consolidated parent attributes. In both cases, the consolidated parent  
  attribute references are converted to instead apply to the attributes of the new entities.  
  
Converting Collections.   
For each entity with collection member(s):  
----------------------------------------  
- Create a new entity "<entity name>_Col". This corresponds to the deprecated "%_CN" table.  
    -- Copy collection attributes from original entity to leaf attributes on the new entity  
    -- Copy collection members from original entity to leaf members on then new entity  
- Create new entity "<entity name>_ColMem" to track collection membership info. This corresponds to the deprecated "%_CM" table.  
    -- Add parent DBA, "Parent_<entity name>_Col", that will reference the parent "collection"  
    -- Add child DBAs, that correspond to collection members (exactly one will have a non-null value, per member):  
        -- "Child_<entity name>" for leaf members of the collection. References the original entity.  
        -- "Child_<entity name>_Col" for collection members of the collection  
        -- "Child_<EH name>", one per EH on the original entity, for consolidated members of the collection  
    -- Add attributes for "%_CM" table columns Weight and SortOrder  
    -- Create new members, one for each "%_CM" table row  
- Copy collection member transactions. If the @DeleteOriginals flag is set, the original transaction rows will be updated,   
  rather than copied, for efficiency. Otherwise, transaction annotations are also copied.  
- Create one DH per child type (Leaf, Collection, and one per EH). Each DH has two levels. The bottom level is the child entity. The top is a   
  Many-To-Many level that maps collection parents to children. There has to be one DH per child type because each child type is copied to its   
  own entity.  
  
Additional steps  
----------------------------------------  
- Copy consolidated and collection attribute groups to leaf attribute groups on their corresponding new entities.  
- Copy consolidated and collection subscription views (SV)  
        Old ViewFormat_ID            Deprecated?    New ViewFormat_ID  
       *******************          *************  *******************  
        1 (Leaf members)                No          unchanged  
        2 (Consolidated members)       Yes          1 (Leaf members)   
        3 (Collection members)         Yes          1 (Leaf members)  
        4 (Collection membership)      Yes          1 (Leaf members, on the mapping entity)  
        5 (Explicit Parent-Child)      Yes          7 (Derived Parent-Child)  
        6 (Explicit levels)            Yes          8 (Derived levels)  
        7 (Derived Parent-Child)        No          unchanged  
        8 (Derived levels)              No          unchanged  
        9 (Leaf history)                No          unchanged  
       10 (Consolidated history)       Yes          9 (Leaf history)  
       11 (Collection history)         Yes          9 (Leaf history)  
       12 (Leaf Type2)                  No          unchanged  
       13 (Consolidated Type2)         Yes          12 (Leaf Type2)  
       14 (Collection Type2)           Yes          12 (Leaf Type2)  
    For the consolidated-related SVs (ViewFormat_ID 2, 5, and 6) there is a one-to-many mapping. One new SV is created per EH. To disambiguate them, the EH   
    name is appended to the SV name.  
- Security permissions  
    -- Copy model object permissions from old entity and its consolidated and collection member types, attributes, and attribute groups, to their corresponding new entity objects.  
    -- Copy member permissions from old EHs to new RDHs (collections and DHs with an EH cap cannot be used for member security, so they will have no permissions to copy).  
- If the @DeleteOriginals flag is set, delete the originals of the copied items.  
- Kick off the service broker to process member security.  
  
Additional notes:  
1. EH child sort order info, as stored in the "%_HR" table's SortOrder column, is lost. Derived Hierarchies do not support child sort order.  
2. All copied/converted BRs are left in an unpublished state. The user must manually publish these rules, if desired, after running this script (the publish process can only be executed from the web service API, not from SQL)  
3. Validation issues (as stored in tables tbl_{MID}_VL, tbl_{MID}_VLH)) are not copied. They can be regenerated after BRs are published.  
4. The copy process checks for and handles any naming conflicts that would violate uniqueness constraints. For example, if the script tries to create a new entity named "Product_Bundle", but that   
   name is already used by another entity within the model, then it will try to use "Product_Bundle1" for the new entity name. If that name is already taken, then it will try   
   "Product_Bundle2", and so on.  
5. The copy process preserves original audit info (i.e. created/lastChanged userID/dateTime, etc) for copied items (i.e. master data, DH levels, security permissions, transactions, business rules, etc).  
*/  
CREATE PROCEDURE [mdm].[udpConvertCollectionAndConsolidatedMembersToLeaf]  
(  
     @Model_ID          INT = NULL -- Optional filter. When provided, only EHs and Collections within the specified model will be operated on.  
    ,@Entity_ID         INT = NULL -- Optional filter. When provided, only EHs and Collections within the specified entity will be operated on.  
    ,@DeleteOriginals   BIT = 1 -- When 0, the sproc is non-destructive. When 1, the sproc deletes the original collections, consolidated members, EHs, etc that are converted.  
    ,@CorrelationID     UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
AS BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE   
         @User_ID               INT  
  
        ,@EntityTableName_EN                SYSNAME  
        ,@EntityTableName_EN_HS             SYSNAME  
        ,@EntityTableName_EN_AN             SYSNAME  
        ,@EntityTableName_HP                SYSNAME  
        ,@EntityTableName_HP_HS             SYSNAME  
        ,@EntityTableName_HP_AN             SYSNAME  
        ,@EntityTableName_HR                SYSNAME  
        ,@EntityTableName_HR_HS             SYSNAME  
        ,@EntityTableName_HR_AN             SYSNAME  
        ,@NewEntityTableName_EN_HS          SYSNAME  
        ,@NewEntityTableName_EN_AN          SYSNAME  
        ,@EntityTableName_CN                SYSNAME  
        ,@EntityTableName_CN_HS             SYSNAME  
        ,@EntityTableName_CN_AN             SYSNAME  
        ,@EntityTableName_CM                SYSNAME  
        ,@EntityTableName_CM_HS             SYSNAME  
        ,@EntityTableName_CM_AN             SYSNAME  
        ,@TransactionTableName              SYSNAME  
        ,@TransactionAnnotationTableName    SYSNAME  
  
        ,@EntityName            NVARCHAR(50)  
        ,@DataCompression       TINYINT  
        ,@TransactionLogType    TINYINT  
          
        ,@TransactionLogType_Attribute  TINYINT = 1  
        ,@TransactionLogType_Member     TINYINT = 2  
        ,@TransactionLogType_None       TINYINT = 3  
  
        ,@StagingLeafName       SYSNAME  
        ,@ExplicitHierarchy_ID  INT  
        ,@ExplicitHierarchyName NVARCHAR(50)  
        ,@IsMandatory           BIT  
  
        ,@Attribute_ID          INT  
        ,@DisplayName           NVARCHAR(250)  
        ,@Name                  NVARCHAR(100)  
        ,@Description           NVARCHAR(500)  
        ,@AttributeType_ID      TINYINT  
        ,@DataType_ID           TINYINT  
        ,@DataTypeInformation   INT  
        ,@InputMask_ID          INT  
        ,@DisplayWidth          INT  
        ,@SortOrder             INT  
        ,@DomainEntity_ID       INT  
        ,@ChangeTrackingGroup   INT  
  
        ,@EnterDTM              DATETIME2(3)  
        ,@EnterUserID           INT  
        ,@EnterVersionID        INT  
        ,@LastChgDTM            DATETIME2(3)  
        ,@LastChgUserID         INT  
        ,@LastChgVersionID      INT  
  
        ,@NewEntity_ID                  INT  
        ,@NewEntityName                 NVARCHAR(50)  
        ,@NewEntityTableName_EN         SYSNAME  
        ,@NewEntityStagingLeafName      SYSNAME  
        ,@NewEntityDescription          NVARCHAR(500)  
        ,@NewDerivedHierarchy_ID        INT  
        ,@NewDerivedHierarchyName       NVARCHAR(50)  
        ,@NewLevel_ID                   INT  
        ,@counter                       INT  
        ,@suffix                        NVARCHAR(MAX)  
        ,@NewAttribute_ID               INT  
  
        ,@MaxMetadataObjectNameLength   INT = 50 -- except for attributes and DH levels  
        ,@MaxAttributeNameLength        INT = 100  
        ,@MaxHierarchyLevelNameLength   INT = 100  
  
        ,@NewRecursiveAttribute_ID          INT  
        ,@NewRecursiveAttributeName         NVARCHAR(100)  
        ,@NewRecursiveAttribute_ColumnName  SYSNAME  
        ,@NewLeafDba_ID                     INT  
        ,@NewLeafDbaName                    NVARCHAR(100)  
        ,@NewLeafDba_ColumnName             SYSNAME  
        ,@NewLevelName                      NVARCHAR(100)  
        ,@NewAttributeColumnNames           NVARCHAR(MAX) = N''  
        ,@OldAttributeColumnNames           NVARCHAR(MAX) = N''  
  
        ,@FunctionalPrivilege_SuperUser   TINYINT = 6  
  
        ,@HierarchyType_Explicit    TINYINT = 0   
        ,@HierarchyType_Derived     TINYINT = 1  
  
        ,@HierarchyItemType_Entity            TINYINT = 0  
        ,@HierarchyItemType_DBA               TINYINT = 1  
        ,@HierarchyItemType_ExplicitHierarchy TINYINT = 2  
        --,@HierarchyItemType_ConsolidatedDBA   INT = 3 -- Unused.  
        ,@HierarchyItemType_ManyToMany        TINYINT = 5  
  
        ,@MemberType_Leaf                   TINYINT = 1  
        ,@MemberType_Consolidated           TINYINT = 2  
        ,@MemberType_Collection             TINYINT = 3  
        ,@MemberType_ParentChild            TINYINT = 4  
        ,@MemberType_CollectionParentChild  TINYINT = 5  
  
        ,@DataType_Text           TINYINT = 1  
        ,@DataType_Number         TINYINT = 2  
        ,@DataType_DateTime       TINYINT = 3  
        ,@DataType_Link           TINYINT = 6  
  
        ,@AttributeType_Freeform  TINYINT = 1  
        ,@AttributeType_Domain    TINYINT = 2  
        ,@AttributeType_System    TINYINT = 3  
        ,@AttributeType_File      TINYINT = 4  
  
        ,@BRStatus_New                  INT = 0  
        ,@BRStatus_Active               INT = 1  
        ,@BRStatus_Excluded             INT = 2  
        ,@BRStatus_ActivationPending    INT = 3  
        ,@BRStatus_ChangesPending       INT = 4  
        ,@BRStatus_ExcludePending       INT = 5  
        ,@BRStatus_DeletePending        INT = 6  
  
        ,@BRPropertyType_Constant           TINYINT = 1  
        ,@BRPropertyType_Attribute          TINYINT = 2  
        ,@BRPropertyType_ParentAttribute    TINYINT = 3  
        ,@BRPropertyType_DBA                TINYINT = 4  
        ,@BRPropertyType_AttributeValue     TINYINT = 5  
        ,@BRPropertyType_Blank              TINYINT = 6  
  
        ,@ObjectType_Entity             INT = 3  
        ,@ObjectType_Attribute          INT = 4  
        ,@ObjectType_AttributeGroup     INT = 5  
        ,@ObjectType_LeafType           INT = 8  
        ,@ObjectType_ConsolidatedType   INT = 9  
        ,@ObjectType_CollectionType     INT = 10  
  
        ,@TransactionType_CreateMember          TINYINT = 1  
        ,@TransactionType_ChangeMemberStatus    TINYINT = 2  
        ,@TransactionType_SetAttributeValue     TINYINT = 3  
        ,@TransactionType_MoveMemberToParent    TINYINT = 4  
        ,@TransactionType_MoveMemberToSibling   TINYINT = 5  
        ,@TransactionType_AnnotateMember        TINYINT = 6  
  
        ,@ViewFormat_Leaf                   TINYINT = 1  
        ,@ViewFormat_Consolidated           TINYINT = 2  
        ,@ViewFormat_Collection             TINYINT = 3  
        ,@ViewFormat_CollectionMembership   TINYINT = 4  
        ,@ViewFormat_ExplicitParentChild    TINYINT = 5  
        ,@ViewFormat_ExplicitLevels         TINYINT = 6  
        ,@ViewFormat_DerivedParentChild     TINYINT = 7  
        ,@ViewFormat_DerivedLevels          TINYINT = 8  
        ,@ViewFormat_LeafHistory            TINYINT = 9  
        ,@ViewFormat_ConsolidatedHistory    TINYINT = 10  
        ,@ViewFormat_CollectionHistory      TINYINT = 11  
        ,@ViewFormat_LeafType2              TINYINT = 12  
        ,@ViewFormat_ConsolidatedType2      TINYINT = 13  
        ,@ViewFormat_CollectionType2        TINYINT = 14  
  
  
        ,@SQL                           NVARCHAR(MAX)  
  
        -- This pseudo-constant is for use in string concatenation operations to prevent string truncation. When concatenating two or more strings,  
        -- if none of the strings is an NVARCHAR(MAX) or an NVARCHAR constant that is longer than 4,000 characters, then the resulting string   
        -- will be silently truncated to 4,000 characters. Concatenating with this empty NVARCHAR(MAX), is sufficient to prevent truncation.  
        -- See http://connect.microsoft.com/SQLServer/feedback/details/283368/nvarchar-max-concatenation-yields-silent-truncation.  
        ,@TruncationGuard        NVARCHAR(MAX) = N''  
        ;  
  
    DECLARE @HalfMaxLen INT = @MaxMetadataObjectNameLength / 2 - 2;  
  
    -- Get the ID of the first user with super user functional permission. This may seem arbitrary, but that is okay because the resulting audit info  
    -- will be overwritten to match that of the EH being converted.  
    SELECT TOP 1  
        @User_ID = ID  
    FROM mdm.udfSecurityGetUsersByFunction(@FunctionalPrivilege_SuperUser)  
    ORDER BY ID;  
  
  
    BEGIN TRY  
  
        --Start transaction, being careful to check if we are nested.  
        DECLARE @TranCounter INT = @@TRANCOUNT;  
        IF @TranCounter > 0  
        BEGIN  
            SAVE TRANSACTION TX;  
        END ELSE  
        BEGIN  
            BEGIN TRANSACTION;  
        END;  
  
PRINT CONCAT(SYSDATETIME(), N': Getting filtered list of entities to convert.');  
        DECLARE @EntityInfo TABLE  
        (  
             Entity_ID                  INT PRIMARY KEY  
            ,EntityName                 NVARCHAR(50) COLLATE DATABASE_DEFAULT NOT NULL  
            ,Model_ID                   INT NOT NULL  
            ,DataCompression            TINYINT  
            ,TransactionLogType         TINYINT  
            --,RequireApproval            BIT -- Not needed. Only supported for Leaf members  
            ,StagingLeafName            SYSNAME COLLATE DATABASE_DEFAULT  
            ,EntityTableName_EN         SYSNAME COLLATE DATABASE_DEFAULT  
            ,EntityTableName_CN         SYSNAME COLLATE DATABASE_DEFAULT NULL  
            ,EntityTableName_CM         SYSNAME COLLATE DATABASE_DEFAULT NULL   
            ,EntityTableName_HP         SYSNAME COLLATE DATABASE_DEFAULT NULL  
            ,EntityTableName_HR         SYSNAME COLLATE DATABASE_DEFAULT NULL  
            ,New_CN_Entity_ID           INT NULL  
            ,New_CM_Entity_ID           INT NULL  
            ,HasCustomCollectionMetadata BIT NOT NULL DEFAULT 0 -- Zero when there no other user-defined collection metadata (attributes, subscription views).   
            ,HasExplicitHierarchy        BIT NOT NULL DEFAULT 0  
        )  
        INSERT INTO @EntityInfo  
        (  
             Entity_ID  
            ,EntityName  
            ,Model_ID  
            ,DataCompression  
            ,TransactionLogType  
            ,StagingLeafName  
            ,EntityTableName_EN  
            ,EntityTableName_CN  
            ,EntityTableName_CM  
            ,EntityTableName_HP  
            ,EntityTableName_HR  
        )  
        SELECT   
             ID  
            ,Name  
            ,Model_ID  
            ,DataCompression  
            ,TransactionLogType  
            ,StagingLeafName  
            ,EntityTable  
            ,CollectionTable  
            ,CollectionMemberTable  
            ,HierarchyParentTable  
            ,HierarchyTable  
        FROM mdm.tblEntity  
        WHERE   (@Model_ID  IS NULL OR @Model_ID  = Model_ID)  
            AND (@Entity_ID IS NULL OR @Entity_ID = ID)  
        DECLARE @EntityCount INT = COALESCE((SELECT COUNT(1) FROM @EntityInfo), 0);  
PRINT CONCAT(SYSDATETIME(), N': ', @EntityCount, ' entities found.');  
  
  
PRINT CONCAT(SYSDATETIME(), N': Determining whether entities with collection tables have user-defined collection metadata.');  
        UPDATE ei  
        SET HasCustomCollectionMetadata = CASE WHEN COALESCE(a.ID, sv.ID) IS NOT NULL THEN 1 ELSE ei.HasCustomCollectionMetadata END  
        FROM @EntityInfo ei  
        LEFT JOIN mdm.tblAttribute a  
        ON      ei.Entity_ID = a.Entity_ID  
            AND a.IsSystem = 0  
            AND a.MemberType_ID = @MemberType_Collection -- Note: ignoring @MemberType_CollectionParentChild because it cannot have user-defined attributes  
        LEFT JOIN mdm.tblSubscriptionView sv  
        ON      ei.Entity_ID = sv.Entity_ID  
            AND sv.ViewFormat_ID IN (@ViewFormat_Collection, @ViewFormat_CollectionMembership, @ViewFormat_CollectionHistory, @ViewFormat_CollectionType2)  
        WHERE ei.EntityTableName_CN IS NOT NULL  
  
        -- Contains info about the consolidated and collection attributes that will be copied.  
        DECLARE @AttributeInfo TABLE  
        (  
             Attribute_ID           INT PRIMARY KEY  
            ,DisplayName            NVARCHAR(250) COLLATE DATABASE_DEFAULT  
            ,Name                   NVARCHAR(100) COLLATE DATABASE_DEFAULT  
            ,Description            NVARCHAR(500) COLLATE DATABASE_DEFAULT  
            ,ColumnName             SYSNAME COLLATE DATABASE_DEFAULT  
            ,AttributeType_ID       TINYINT  
            ,DataType_ID            TINYINT  
            ,DataTypeInformation    INT  
            ,InputMask_ID           INT  
            ,DisplayWidth           INT  
            ,SortOrder              INT  
            ,DomainEntity_ID        INT  
            ,ChangeTrackingGroup    INT  
        );  
  
        -- Contains a list of derived hierarchies with an explicit cap.  
        DECLARE @ExplicitCapHierarchies TABLE  
        (     
             DerivedHierarchy_ID     INT PRIMARY KEY  
            ,DerivedHierarchyName    NVARCHAR(50) COLLATE DATABASE_DEFAULT  
        );  
  
        CREATE TABLE #EH_ConversionLog  
        (  
             ExplicitHierarchy_ID       INT PRIMARY KEY  
            ,ExplicitHierarchyName      NVARCHAR(50) COLLATE DATABASE_DEFAULT  
            ,Entity_ID                  INT NOT NULL DEFAULT 0  
            ,LeafParentDba_ID           INT -- The ID of the new DBA in the old leaf entity that references the new entity.  
            ,LeafParentDbaName          NVARCHAR(100) COLLATE DATABASE_DEFAULT  
            ,NewEntity_ID               INT -- The ID of the new Entity created to take the place of the EH's consolidated members  
            ,NewDerivedHierarchy_ID     INT -- The ID of the new Derived Hierarchy created to take the place of the EH  
            ,NewEntityRecursiveDba_ID   INT -- The ID of the self-referencing DBA in the new Entity.  
            ,NewEntityRecursiveDbaName  NVARCHAR(100) COLLATE DATABASE_DEFAULT  
        );  
        CREATE INDEX #ix_EH_ConversionLog_Entity_ID ON #EH_ConversionLog(Entity_ID);  
  
        CREATE TABLE #AttributeMapping  
        (  
             OldAttribute_ID    INT --PRIMARY KEY -- Consolidated attribute could be copied to multiple entities, so may not be unique.  
            ,OldMemberType      TINYINT   
            ,OldEntity_ID       INT  
  
            ,NewAttribute_ID    INT  
            ,NewEntity_ID       INT  
        );  
        CREATE CLUSTERED INDEX #ix_AttributeMapping_OldAttribute_ID ON #AttributeMapping(OldAttribute_ID);  
  
        CREATE TABLE #AttributeGroupMapping  
        (  
             OldAttributeGroup_ID   INT --PRIMARY KEY -- Attribute Group could be copied to multiple entities, so may not be unique.  
            ,Entity_ID              INT  
            ,NewAttributeGroup_ID   INT  
            ,NewEntity_ID           INT  
        );  
        CREATE CLUSTERED INDEX #ix_AttributeGroupMapping_OldAttributeGroup_ID ON #AttributeGroupMapping(OldAttributeGroup_ID);  
  
        DECLARE @CollectionMembershipAttributes TABLE  
        (  
             RowID                  INT IDENTITY(1, 1) PRIMARY KEY   
            ,Name                   NVARCHAR(100) COLLATE DATABASE_DEFAULT  
            ,DomainEntity_ID        INT     NULL  
            ,DomainEntityName       NVARCHAR(50) COLLATE DATABASE_DEFAULT  
            ,DomainEntityTableName  SYSNAME COLLATE DATABASE_DEFAULT NULL  
            ,DataTypeInformation    TINYINT NULL  
            ,OldColumnName          SYSNAME COLLATE DATABASE_DEFAULT NULL  
            ,NewAttribute_ID        INT     NULL  
            ,NewColumnName          SYSNAME COLLATE DATABASE_DEFAULT NULL  
        );  
  
  
PRINT CONCAT(SYSDATETIME(), N': Getting Explicit Hierarchies.');  
        -- Get a list of explicit hierarchies that match the given criteria.  
        DECLARE @ExplicitHierarchies TABLE  
        (  
             ExplicitHierarchy_ID   INT PRIMARY KEY  
            ,ExplicitHierarchyName  NVARCHAR(50) COLLATE DATABASE_DEFAULT  
            ,IsMandatory            BIT  
            ,Entity_ID              INT  
            ,EnterDTM               DATETIME2(3)  
            ,EnterUserID            INT  
            ,EnterVersionID         INT  
            ,LastChgDTM             DATETIME2(3)  
            ,LastChgUserID          INT  
            ,LastChgVersionID       INT  
        );  
        INSERT INTO @ExplicitHierarchies  
        SELECT   
             h.ID  
            ,h.Name  
            ,h.IsMandatory  
            ,e.Entity_ID  
            ,h.EnterDTM  
            ,h.EnterUserID  
            ,h.EnterVersionID  
            ,h.LastChgDTM  
            ,h.LastChgUserID  
            ,h.LastChgVersionID  
        FROM mdm.tblHierarchy h  
        INNER JOIN @EntityInfo e  
        ON h.Entity_ID = e.Entity_ID  
  
        UPDATE e  
        SET HasExplicitHierarchy = CASE WHEN eh.ExplicitHierarchy_ID IS NULL THEN 0 ELSE 1 END  
        FROM @EntityInfo e  
        LEFT JOIN @ExplicitHierarchies eh  
        ON e.Entity_ID = eh.Entity_ID  
  
        -- Loop through each entity, and copy its hierarchies  
        DECLARE @TempTimestampColumnName NVARCHAR(50) = N'LastChgTS_Old';  
  
        SET @Entity_ID = 0  
        WHILE EXISTS (SELECT 1 FROM @EntityInfo WHERE Entity_ID > @Entity_ID AND HasExplicitHierarchy = 1)  
        BEGIN  
            SELECT TOP 1  
                 @Entity_ID  = Entity_ID  
                ,@Model_ID = Model_ID  
                ,@DataCompression = DataCompression  
                ,@TransactionLogType = TransactionLogType  
                ,@StagingLeafName = StagingLeafName  
                ,@EntityName = EntityName  
                ,@EntityTableName_EN = EntityTableName_EN  
                ,@EntityTableName_EN_HS = CONCAT(EntityTableName_EN, N'_HS')  
                ,@EntityTableName_EN_AN = CONCAT(EntityTableName_EN, N'_AN')  
                ,@EntityTableName_HP = EntityTableName_HP  
                ,@EntityTableName_HP_HS = CONCAT(EntityTableName_HP, N'_HS')  
                ,@EntityTableName_HP_AN = CONCAT(EntityTableName_HP, N'_AN')  
                ,@EntityTableName_HR = EntityTableName_HR  
                ,@EntityTableName_HR_HS = CONCAT(EntityTableName_HR, N'_HS')  
                ,@EntityTableName_HR_AN = CONCAT(EntityTableName_HR, N'_AN')  
            FROM @EntityInfo  
            WHERE   Entity_ID > @Entity_ID  
                AND HasExplicitHierarchy = 1  
            ORDER BY Entity_ID  
  
            IF @TransactionLogType = @TransactionLogType_Member  
            BEGIN  
                PRINT CONCAT(SYSDATETIME(), N': Adding temporary LastChgTS column to table ', @EntityTableName_EN);  
                -- Before modifying the original EN table, add a column to track the current LastChgDTM. Needed for copying member history from TR_HS to EN_HS table.  
                SET @SQL = CONCAT(N'ALTER TABLE mdm.', QUOTENAME(@EntityTableName_EN), N' ADD ', QUOTENAME(@TempTimestampColumnName), N' BIGINT;');  
                --PRINT @SQL  
                EXEC sp_executesql @SQL;  
                SET @SQL = CONCAT(N'CREATE INDEX ', QUOTENAME(CONCAT(N'ix_', @EntityTableName_EN, N'_Version_ID_', @TempTimestampColumnName)), N' ON mdm.', QUOTENAME(@EntityTableName_EN), N' (Version_ID, ', QUOTENAME(@TempTimestampColumnName), N');');  
                --PRINT @SQL  
                EXEC sp_executesql @SQL;  
            END  
      
            -- Loop through each explicit hierarchy and copy it.  
            SET @ExplicitHierarchy_ID = 0;  
            WHILE EXISTS (SELECT 1 FROM @ExplicitHierarchies WHERE ExplicitHierarchy_ID > @ExplicitHierarchy_ID AND Entity_ID = @Entity_ID)  
            BEGIN  
                -- Get the next EH in the list.  
                SELECT TOP 1  
                     @ExplicitHierarchy_ID = ExplicitHierarchy_ID  
                    ,@ExplicitHierarchyName = ExplicitHierarchyName  
                    ,@IsMandatory = IsMandatory  
                    ,@EnterDTM = EnterDTM  
                    ,@EnterUserID = EnterUserID  
                    ,@EnterVersionID = EnterVersionID  
                    ,@LastChgDTM = LastChgDTM  
                    ,@LastChgUserID = LastChgUserID  
                    ,@LastChgVersionID = LastChgVersionID  
                FROM @ExplicitHierarchies  
                WHERE   ExplicitHierarchy_ID > @ExplicitHierarchy_ID  
                    AND Entity_ID = @Entity_ID  
                ORDER BY ExplicitHierarchy_ID;  
  
    PRINT ''  
    PRINT CONCAT(SYSDATETIME(), N': Begin converting EH: "', @ExplicitHierarchyName, N'" (ID = ', @ExplicitHierarchy_ID, N') in entity "', @EntityName, N'"');  
                DECLARE @EntityNameLength INT = LEN(@EntityName);  
                DECLARE @HierarchyNameLength INT = LEN(@ExplicitHierarchyName);  
   
    PRINT CONCAT(SYSDATETIME(), N': Get a name for the new entity');  
                -- Get a name for the new entity. It must be unique within the model.  
                SET @counter = 0;  
                WHILE (1=1) -- TSQL doesn't support a DO-WHILE loop, so use a tautology as this WHILE condition to simulate a post-test loop.  
                BEGIN  
                    -- Ideally, the new entity name should reference both the leaf entity name and the explicit hierarchy name. However, there is a risk  
                    -- that this could exceed the max name length, in which case we need to be smart about where to do the truncation.  
  
                    IF (@EntityNameLength + @HierarchyNameLength + 4/*allow room for the underscore and the counter*/ <= @MaxMetadataObjectNameLength)  
                    BEGIN  
                        -- The entity and hierarchy names are short enough that they can be concatenated together without exceeding the max length  
                        SET @NewEntityName = CONCAT(@EntityName, N'_', @ExplicitHierarchyName, CASE @counter WHEN 0 THEN N'' ELSE CONVERT(NVARCHAR, @counter) END);  
                    END  
                    ELSE  
                    BEGIN  
                        -- The entity and hierarchy names are together too long, so use truncation. Each name is limited to slightly less than half of the max length. Note  
                        -- that this approach may not be the most sophisticated way of doing it (it could result in overly-aggressive truncation in the case where one name  
                        -- is significantly longer than the other), but it is cheap to implement and should be sufficient since this is an edge case, anyways.  
                        SET @NewEntityName = CONCAT(SUBSTRING(@EntityName, 0, @HalfMaxLen), N'_', SUBSTRING(@ExplicitHierarchyName, 0, @HalfMaxLen), CASE @counter WHEN 0 THEN N'' ELSE CONVERT(NVARCHAR, @counter) END);  
                    END;  
  
                    -- If the new entity name is unique within the model, then exit the loop.  
                    IF NOT EXISTS (SELECT 1 FROM mdm.tblEntity WHERE Model_ID = @Model_ID AND Name = @NewEntityName)  
                    BEGIN  
                        BREAK;  
                    END;  
  
                    -- The name wasn't unique, so increment the counter for the next loop iteration.  
                    SET @counter += 1;  
                END; -- WHILE (get unique entity name)  
  
                SET @NewEntityDescription = CONCAT(N'Replaces consolidated members in the "', @EntityName, N'" entity''s "', @ExplicitHierarchyName, N'" explicit hierarchy');  
  
                -- Create a pseudo-consolidated, self-referencing, entity to take the place of the consolidated members.  
                SET @NewEntity_ID = 0;  
                EXEC mdm.udpEntitySave   
                     @User_ID = @User_ID  
                    ,@Model_ID = @Model_ID  
                    ,@EntityName = @NewEntityName  
                    ,@DataCompression = @DataCompression  
                    ,@TransactionLogType = @TransactionLogType  
                    ,@RequireApproval = 0 -- Consolidated and Collection members don't support the Approval Flow feature, so the new entity created doesn't either. Users may manually change this later, if desired.  
                    ,@Description = @NewEntityDescription  
                    ,@RecreateStagingProc = 0 -- for efficiency, staging sprocs will be recreated only after all attributes have been created (rather than once for each attribute)  
                    ,@Return_ID = @NewEntity_ID OUTPUT  
  
                -- Update the new entity's audit info to match the EH's audit info.  
                UPDATE mdm.tblEntity  
                SET  EnterDTM = @EnterDTM  
                    ,EnterUserID = @EnterUserID  
                    ,EnterVersionID = @EnterVersionID  
                    ,LastChgDTM = @LastChgDTM  
                    ,LastChgUserID = @LastChgUserID  
                    ,LastChgVersionID = @LastChgVersionID  
                WHERE ID = @NewEntity_ID;  
  
  
    PRINT CONCAT(SYSDATETIME(), N': Created new entity "', @NewEntityName, N'" (ID = ', @NewEntity_ID, N') that is a copy of entity "', @EntityName, N'" (ID = ', @Entity_ID, N')''s consolidated members.');  
      
                -- Get the name of the new entity's EN table.  
                SELECT   
                     @NewEntityTableName_EN = EntityTable  
                    ,@NewEntityTableName_EN_HS  = CONCAT(EntityTable, N'_HS')  
                    ,@NewEntityTableName_EN_AN  = CONCAT(EntityTable, N'_AN')  
                    ,@NewEntityStagingLeafName = StagingLeafName  
                FROM mdm.tblEntity  
                WHERE ID = @NewEntity_ID;  
  
  
                -- Create attributes in the new entity that match the consolidated attributes in the old entity.  
    PRINT CONCAT(SYSDATETIME(), N': Copying consolidated attribute metadata from old entity to new entity');  
      
                -- Add the consolidated system attributes to the mapping table (needed for converting transactions, object security, and BRs)  
                INSERT INTO #AttributeMapping  
                (  
                     OldAttribute_ID  
                    ,OldMemberType  
                    ,OldEntity_ID  
                    ,NewAttribute_ID  
                    ,NewEntity_ID  
                )  
                SELECT  
                     oldA.ID  
                    ,oldA.MemberType_ID  
                    ,oldA.Entity_ID  
                    ,newA.ID  
                    ,newA.Entity_ID  
                FROM mdm.tblAttribute oldA  
                INNER JOIN mdm.tblAttribute newA  
                ON oldA.Name = newA.Name  
                WHERE   oldA.Entity_ID = @Entity_ID  
                    AND oldA.MemberType_ID = @MemberType_Consolidated  
                    AND oldA.IsSystem = 1  
                    AND newA.Entity_ID = @NewEntity_ID  
                    AND newA.IsSystem = 1  
  
                -- Get a list of all non-system consolidated attributes in the entity.  
                DELETE FROM @AttributeInfo;  
                INSERT INTO @AttributeInfo  
                SELECT  
                     ID  
                    ,DisplayName  
                    ,Name  
                    ,Description  
                    ,TableColumn  
                    ,AttributeType_ID  
                    ,DataType_ID  
                    ,DataTypeInformation  
                    ,InputMask_ID  
                    ,DisplayWidth  
                    ,SortOrder  
                    ,DomainEntity_ID  
                    ,ChangeTrackingGroup  
                FROM mdm.tblAttribute   
                WHERE   Entity_ID = @Entity_ID  
                    AND MemberType_ID = @MemberType_Consolidated  
                    AND IsSystem = 0  
                SET @Attribute_ID = 0;  
  
                -- Loop through each non-system consolidated attribute, copying it to the new entity as a leaf attribute.  
                SET @NewAttributeColumnNames = N'';  
                SET @OldAttributeColumnNames = N'';  
                WHILE EXISTS (SELECT 1 FROM @AttributeInfo WHERE Attribute_ID > @Attribute_ID)  
                BEGIN  
                    -- Get the next attribute's info.  
                    SELECT TOP 1   
                         @Attribute_ID = Attribute_ID  
                        ,@DisplayName = DisplayName  
                        ,@Name = Name  
                        ,@Description = Description  
                        ,@OldAttributeColumnNames += @TruncationGuard + N'  
                    ,hp.' + ColumnName  
                        ,@AttributeType_ID = AttributeType_ID  
                        ,@DataType_ID = DataType_ID  
                        ,@DataTypeInformation = DataTypeInformation  
                        ,@InputMask_ID = InputMask_ID  
                        ,@DisplayWidth = DisplayWidth  
                        ,@SortOrder = SortOrder  
                        ,@DomainEntity_ID = DomainEntity_ID  
                        ,@ChangeTrackingGroup = ChangeTrackingGroup  
                    FROM @AttributeInfo   
                    WHERE Attribute_ID > @Attribute_ID  
                    ORDER BY Attribute_ID  
  
                    -- Add an attribute to the new entity that is a leaf copy of the consolidated attribute.  
                    SET @NewAttribute_ID = NULL;  
                    EXEC mdm.udpAttributeSave  
                         @User_ID = @User_ID  
                        ,@Model_ID = @Model_ID  
                        ,@Entity_ID = @NewEntity_ID  
                        ,@IsHierarchyEnabled = 0  
                        ,@IsCollectionEnabled = 0  
                        ,@DataCompression = @DataCompression  
                        ,@TableName = @NewEntityTableName_EN  
                        ,@StagingTableName = @NewEntityStagingLeafName  
                        ,@MemberType_ID = @MemberType_Leaf  
                        ,@AttributeType_ID = @AttributeType_ID  
                        ,@AttributeName = @Name  
                        ,@Description = @Description  
                        ,@DisplayName = @DisplayName  
                        ,@DisplayWidth = @DisplayWidth  
                        ,@DomainEntity_ID = @DomainEntity_ID  
                        ,@DataType_ID = @DataType_ID  
                        ,@DataTypeInformation = @DataTypeInformation  
                        ,@InputMask_ID = @InputMask_ID  
                        ,@ChangeTrackingGroup = @ChangeTrackingGroup  
                        ,@SortOrder = @SortOrder  
                        ,@RecreateStagingProc = 0 -- for efficiency, staging sprocs will be recreated only after all attributes have been created (rather than once for each attribute)  
                        ,@Return_ID = @NewAttribute_ID OUTPUT;    
  
                    -- Update the new attribute's audit info to match the EH's audit info.  
                    UPDATE mdm.tblAttribute  
                    SET  EnterDTM = @EnterDTM  
                        ,EnterUserID = @EnterUserID  
                        ,EnterVersionID = @EnterVersionID  
                        ,LastChgDTM = @LastChgDTM  
                        ,LastChgUserID = @LastChgUserID  
                        ,LastChgVersionID = @LastChgVersionID  
                    WHERE ID = @NewAttribute_ID;  
          
                    SELECT @NewAttributeColumnNames += @TruncationGuard + N'  
                    ,' + TableColumn  
                    FROM mdm.tblAttribute WHERE ID = @NewAttribute_ID;  
  
    PRINT CONCAT(SYSDATETIME(), N': Copied attribute "', @Name, N'" (ID = ', @Attribute_ID, N') to new entity. New attribute ID = ', @NewAttribute_ID);  
                    -- Keep track of the mapping between the old and new attributes.  
                    INSERT INTO #AttributeMapping  
                    (  
                         OldAttribute_ID  
                        ,OldMemberType  
                        ,OldEntity_ID  
                        ,NewAttribute_ID  
                        ,NewEntity_ID  
                    )  
                    SELECT  
                         @Attribute_ID  
                        ,@MemberType_Consolidated  
                        ,@Entity_ID  
                        ,@NewAttribute_ID  
                        ,@NewEntity_ID  
                END -- WHILE (loop through entity's consolidated attributes)  
  
                -- Add a self-referencing DBA to the new entity, to represent the consolidated parent-child relationships defined in the HR table.  
  
                -- Get a unique name for the new DBA  
                SET @counter = 0;  
                WHILE (1=1) -- TSQL doesn't support a DO-WHILE loop, so use a tautology as this WHILE condition to simulate a post-test loop.  
                BEGIN  
                    SET @NewRecursiveAttributeName = CONCAT(N'Parent', CASE @counter WHEN 0 THEN N'' ELSE CONVERT(NVARCHAR, @counter) END);  
  
                    -- If the new attribute name is unique within the entity, then exit the loop.  
                    IF NOT EXISTS (SELECT 1 FROM mdm.tblAttribute WHERE Entity_ID = @NewEntity_ID AND Name = @NewRecursiveAttributeName) -- No need to check MemberType_ID here, since all attributes in the new Entity are leaf attributes.  
                    BEGIN  
                        BREAK;  
                    END;  
  
                    -- The name wasn't unique, so increment the counter for the next loop iteration.  
                    SET @counter += 1;  
                END; -- WHILE (get unique attribute name)  
  
                -- Save the new self-referencing DBA.  
                EXEC mdm.udpAttributeSave   
                     @User_ID = @User_ID  
                    ,@Model_ID = @Model_ID  
                    ,@Entity_ID = @NewEntity_ID  
                    ,@IsHierarchyEnabled = 0  
                    ,@IsCollectionEnabled = 0  
                    ,@DataCompression = @DataCompression  
                    ,@TableName = @NewEntityTableName_EN  
                    ,@StagingTableName = @NewEntityStagingLeafName  
                    ,@MemberType_ID = @MemberType_Leaf  
                    ,@AttributeName = @NewRecursiveAttributeName  
                    ,@Description = N''  
                    ,@AttributeType_ID = @AttributeType_Domain  
                    ,@DisplayName = @NewRecursiveAttributeName  
                    ,@DisplayWidth = 175  
                    ,@DomainEntity_ID = @NewEntity_ID -- Self-referencing DBA  
                    ,@DataType_ID = @DataType_Text  
                    ,@DataTypeInformation = 100  
                    ,@InputMask_ID = 1  
                    ,@ChangeTrackingGroup = 0  
                    ,@SortOrder = NULL -- let the sproc determine the sort order (it will set it to MAX(SortOrder) + 1)  
                    ,@RecreateStagingProc = 0 -- for efficiency, staging sprocs will be recreated only after all attributes have been created (rather than once for each attribute)  
                    ,@Return_ID = @NewRecursiveAttribute_ID OUTPUT;    
  
                -- Update the new attribute's audit info to match the EH's audit info.  
                UPDATE mdm.tblAttribute  
                SET  EnterDTM = @EnterDTM  
                    ,EnterUserID = @EnterUserID  
                    ,EnterVersionID = @EnterVersionID  
                    ,LastChgDTM = @LastChgDTM  
                    ,LastChgUserID = @LastChgUserID  
                    ,LastChgVersionID = @LastChgVersionID  
                WHERE ID = @NewRecursiveAttribute_ID;  
  
    PRINT CONCAT(SYSDATETIME(), N': Added a self-referencing DBA "', @NewRecursiveAttributeName, N'" (ID = ', @NewRecursiveAttribute_ID, N') to the new entity.');  
  
                -- Get the column name in the new EN table for the new attribute  
                SELECT @NewRecursiveAttribute_ColumnName = TableColumn  
                FROM mdm.tblAttribute   
                WHERE ID = @NewRecursiveAttribute_ID  
  
    PRINT CONCAT(SYSDATETIME(), N': Copy the member master data, from consolidated members in the old entity to leaf members in the new entity.');  
                SET @SQL = @TruncationGuard + N'  
                --SELECT * FROM mdm.' + QUOTENAME(@EntityTableName_HP) + N' WHERE Hierarchy_ID = @ExplicitHierarchy_ID;  
  
                SET IDENTITY_INSERT mdm.' + QUOTENAME(@NewEntityTableName_EN) + N' ON; -- This allows the query to specify the ID column, which will be set to match the ID in the old HP table, so that the parent values can be directly copied from the HR table to the new self-referencing DBA  
  
                INSERT INTO mdm.' + QUOTENAME(@NewEntityTableName_EN) + N'  
                (  
                    -- System attributes  
                     Version_ID  
                    ,ID  
                    ,Status_ID  
                    ,ValidationStatus_ID  
                    ,Name  
                    ,Code  
                    ,ChangeTrackingMask  
                    ,EnterDTM  
                    ,EnterUserID  
                    ,EnterVersionID  
                    ,LastChgDTM  
                    ,LastChgUserID  
                    ,LastChgVersionID  
                    ,AsOf_ID'   
                    + CASE @DeleteOriginals WHEN 1 THEN N'  
                    ,MUID' ELSE N'' END -- Use the original MUID when the original will be deleted  
                    + N'  
  
                    -- User-defined attributes  
                    ' + @NewAttributeColumnNames + N'  
  
                    -- The new self-referencing DBA  
                    ,' + QUOTENAME(@NewRecursiveAttribute_ColumnName) + N'   
                )  
                SELECT  
                    -- System attributes  
                     hp.Version_ID  
                    ,hp.ID  
                    ,hp.Status_ID  
                    ,hp.ValidationStatus_ID  
                    ,hp.Name  
                    ,hp.Code  
                    ,hp.ChangeTrackingMask  
                    ,hp.EnterDTM  
                    ,hp.EnterUserID  
                    ,hp.EnterVersionID  
                    ,hp.LastChgDTM  
                    ,hp.LastChgUserID  
                    ,hp.LastChgVersionID   
                    ,hp.AsOf_ID'  
                    + CASE @DeleteOriginals WHEN 1 THEN N'  
                    ,hp.MUID' ELSE N'' END -- Use the original MUID when the original will be deleted  
                    + N'  
  
                    -- User-defined attributes  
                    ' + @OldAttributeColumnNames + N'  
  
                    -- The new self-referencing DBA (pulled from the HR table)  
                    ,hr.Parent_HP_ID   
                FROM mdm.' + QUOTENAME(@EntityTableName_HP) + N' hp  
                LEFT JOIN mdm.' + QUOTENAME(@EntityTableName_HR) + N' hr  
                ON      hp.ID = hr.Child_HP_ID  
                    AND hp.ID <> hr.Parent_HP_ID -- This fixes the data in the unlikely event that the data has been corrupted by a consolidated member somehow having been made its own parent.  
                WHERE hp.Hierarchy_ID = @ExplicitHierarchy_ID; -- Only copy consolidated members that pertain to the current explicit hierarchy  
  
                SET IDENTITY_INSERT mdm.' + QUOTENAME(@NewEntityTableName_EN) + N' OFF;   
  
                --SELECT * FROM mdm.' + QUOTENAME(@NewEntityTableName_EN) + N';  
                ';  
                --PRINT @SQL  
                EXEC sp_executesql @SQL, N'@ExplicitHierarchy_ID INT', @ExplicitHierarchy_ID;  
  
  
  
  
  
                -- Add a new DBA to the original entity, that references the new parent entity.  
  
                -- Get a unique name for the new DBA  
                SET @counter = 0;  
                WHILE (1=1) -- TSQL doesn't support a DO-WHILE loop, so use a tautology as this WHILE condition to simulate a post-test loop.  
                BEGIN  
                    SET @NewLeafDbaName = CONCAT(@ExplicitHierarchyName, CASE WHEN @counter > 0 THEN @counter END);  
  
                    -- If the new attribute name is unique within the entity-member type, then exit the loop.  
                    IF NOT EXISTS (SELECT 1 FROM mdm.tblAttribute WHERE Entity_ID = @Entity_ID AND MemberType_ID = @MemberType_Leaf AND Name = @NewLeafDbaName)  
                    BEGIN  
                        BREAK;  
                    END;  
  
                    -- The name wasn't unique, so increment the counter for the next loop iteration.  
                    SET @counter += 1;  
                END; -- WHILE (get unique attribute name)  
  
                EXEC mdm.udpAttributeSave    
                     @User_ID = @User_ID  
                    ,@Model_ID = @Model_ID  
                    ,@Entity_ID = @Entity_ID  
                    ,@IsHierarchyEnabled = 0  
                    ,@IsCollectionEnabled = 0  
                    ,@DataCompression = @DataCompression  
                    ,@TableName = @EntityTableName_EN  
                    ,@StagingTableName = @StagingLeafName  
                    ,@MemberType_ID = @MemberType_Leaf  
                    ,@AttributeType_ID = @AttributeType_Domain  
                    ,@AttributeName = @NewLeafDbaName  
                    ,@Description = N''  
                    ,@DisplayName = @NewLeafDbaName  
                    ,@DisplayWidth = 175  
                    ,@DomainEntity_ID = @NewEntity_ID -- Self-referencing DBA  
                    ,@DataType_ID = @DataType_Text  
                    ,@DataTypeInformation = 100  
                    ,@InputMask_ID = 1  
                    ,@ChangeTrackingGroup = 0  
                    ,@RecreateStagingProc = 0 -- for efficiency, staging sprocs will be recreated only after all attributes have been created (rather than once for each attribute)  
                    ,@Return_ID = @NewLeafDba_ID OUTPUT;    
  
                -- Update the new attribute's audit info to match the EH's audit info.  
                UPDATE mdm.tblAttribute  
                SET  EnterDTM = @EnterDTM  
                    ,EnterUserID = @EnterUserID  
                    ,EnterVersionID = @EnterVersionID  
                    ,LastChgDTM = @LastChgDTM  
                    ,LastChgUserID = @LastChgUserID  
                    ,LastChgVersionID = @LastChgVersionID  
                WHERE ID = @NewLeafDba_ID;  
    PRINT CONCAT(SYSDATETIME(), N': Added a DBA "', @NewLeafDbaName, N'" (ID = ', @NewLeafDba_ID, N') to the old leaf entity, that references the new entity.');  
  
                -- Get the column name in the new EN table for the new attribute  
                SELECT @NewLeafDba_ColumnName = TableColumn  
                FROM mdm.tblAttribute   
                WHERE ID = @NewLeafDba_ID  
  
    PRINT CONCAT(SYSDATETIME(), N': Updating the new DBA to point to the newly-copied Leaf member, corresponding to its old consolidated parent.');  
                SET @SQL = CONCAT(@TruncationGuard, N'  
                UPDATE en  
                SET  en.', QUOTENAME(@NewLeafDba_ColumnName), N' = hr.Parent_HP_ID',   
                CASE WHEN @TransactionLogType = @TransactionLogType_Member THEN CONCAT(N'  
                    ,en.', QUOTENAME(@TempTimestampColumnName), N' = COALESCE(en.', QUOTENAME(@TempTimestampColumnName), N', en.LastChgTS)-- keep track of the original timestamp, to facilitate copying member history from HR_HS table') END, N'  
                FROM mdm.', QUOTENAME(@EntityTableName_EN), N' en  
                INNER JOIN mdm.', QUOTENAME(@EntityTableName_HR), N' hr  
                ON      en.Version_ID = hr.Version_ID  
                    AND en.ID = hr.Child_EN_ID  
                WHERE hr.Hierarchy_ID = @ExplicitHierarchy_ID  
              
                IF @IsMandatory = 1  
                BEGIN  
                    -- Get a list of leaf members with no consolidated parents. In a mandatory EH these members would be displayed directly under Root. But this  
                    -- is not allowed in a DH. So create a pseudo-"Root" member of the new parent entity, which will server as the parent of these leaf members  
                    DECLARE @MembersWithNoParent TABLE  
                    (   
                        Member_ID  INT PRIMARY KEY  
                    );      
                    INSERT INTO @MembersWithNoParent  
                    SELECT ID  
                    FROM mdm.', QUOTENAME(@EntityTableName_EN), N'  
                    WHERE ', QUOTENAME(@NewLeafDba_ColumnName), N' IS NULL;  
  
                    IF EXISTS (SELECT 1 FROM @MembersWithNoParent)  
                    BEGIN  
                        -- Get a unique member Code for the new root pseudo parent member.  
                        DECLARE   
                             @MemberCode NVARCHAR(250)  
                            ,@counter INT = 0;  
                        WHILE (1=1) -- post-test loop  
                        BEGIN   
                            SET @MemberCode = CONCAT(N''Pseudo Root'', CASE @counter WHEN 0 THEN N'''' ELSE CONVERT(NVARCHAR, @counter) END);  
                PRINT CONCAT(SYSDATETIME(), N'': Getting new member Code, @counter = '', @counter, N'', @MemberCode = "'', @MemberCode, ''"'');  
                            IF NOT EXISTS (SELECT 1 FROM mdm.', QUOTENAME(@NewEntityTableName_EN), N' WHERE Code = @MemberCode)  
                            BEGIN  
                                BREAK; -- The code is unique, so exit the loop.  
                            END;  
                            SET @counter += 1;  
                        END;  
  
                PRINT CONCAT(SYSDATETIME(), N'': Adding pseudo-members to new entity table'');  
                        WITH versions AS  
                        (  
                            SELECT DISTINCT ID AS Version_ID  
                            FROM mdm.tblModelVersion   
                            WHERE Model_ID = @Model_ID  
                        )  
                        INSERT INTO  mdm.', QUOTENAME(@NewEntityTableName_EN), N'  
                        (  
                            -- System attributes  
                             Version_ID  
                            ,Name  
                            ,Code  
                            ,EnterUserID  
                            ,EnterVersionID  
                            ,LastChgUserID  
                            ,LastChgVersionID  
                        )  
                        SELECT  
                            -- System attributes  
                             Version_ID  
                            ,@MemberCode  
                            ,@MemberCode  
                            ,@User_ID  
                            ,Version_ID  
                            ,@User_ID  
                            ,Version_ID  
                        FROM versions;   
  
                PRINT CONCAT(SYSDATETIME(), N'': Updating old leaf table members to point to pseudo-members'');  
                        WITH pseudoMembersCTE AS  
                        (  
                            SELECT   
                                ID  
                                ,Version_ID  
                            FROM mdm.', QUOTENAME(@NewEntityTableName_EN), N'  
                            WHERE Code = @MemberCode  
                        )  
                        UPDATE en   
                        SET ', QUOTENAME(@NewLeafDba_ColumnName), N' = cte.ID',   
                        CASE WHEN @TransactionLogType = @TransactionLogType_Member THEN CONCAT(N'  
                            ,', QUOTENAME(@TempTimestampColumnName), N' = COALESCE(en.', QUOTENAME(@TempTimestampColumnName), N', en.LastChgTS)-- keep track of the original timestamp, to facilitate copying member history from HR_HS table') END, N'  
                        FROM mdm.', QUOTENAME(@EntityTableName_EN), N' en  
                        INNER JOIN @MembersWithNoParent m  
                        ON en.ID = m.Member_ID  
                        INNER JOIN pseudoMembersCTE cte -- CROSS JOIN pseudoMembersCTE cte  
                        ON en.Version_ID = cte.Version_ID  
  
                PRINT CONCAT(SYSDATETIME(), N'': Done updating old leaf table members to point to pseudo-members'');  
                        --SELECT * FROM mdm.', QUOTENAME(@NewEntityTableName_EN), N';  
                        --SELECT * FROM mdm.', QUOTENAME(@EntityTableName_EN), N';  
  
                    END -- IF there are unparented LEAF members.   
                END -- IF the hierarchy is mandatory  
                ');  
                --PRINT @SQL  
                EXEC sp_executesql @SQL, N'@User_ID INT, @Model_ID INT, @ExplicitHierarchy_ID INT, @IsMandatory BIT', @LastChgUserID, @Model_ID, @ExplicitHierarchy_ID, @IsMandatory;  
  
  
  
  
  
                IF @TransactionLogType = @TransactionLogType_Attribute  
                BEGIN  
                    SET @TransactionTableName = mdm.udfGetTransactionTableName(@Model_ID);  
                    IF @DeleteOriginals = 1  
                    BEGIN  
                        -- If the originals should be deleted, then merely update the existing transaction rows, rather than copying and then (later) deleting the originals. More efficient, and allows us to skip modifying the transaction annotations table.  
                        PRINT CONCAT(SYSDATETIME(), N': Updating consolidated member transaction rows (deprecated Attribute transaction type) to reference the new Leaf entities.');  
                        SET @SQL = CONCAT(@TruncationGuard, N'  
                        --SELECT * FROM mdm.', QUOTENAME(@TransactionTableName), N' WHERE Entity_ID = @Entity_ID AND (MemberType_ID = ', @MemberType_Consolidated, N' OR Hierarchy_ID = @ExplicitHierarchy_ID)  
  
                        DECLARE @RootID NVARCHAR = N''0'';  
                        UPDATE tr  
                        SET  
                             TransactionType_ID = CASE WHEN tr.TransactionType_ID IN (', @TransactionType_MoveMemberToParent, N', ', @TransactionType_MoveMemberToSibling, N')   
                                THEN ', @TransactionType_SetAttributeValue, N' -- Change EH move transactions to attribute change transaction  
                                ELSE tr.TransactionType_ID END   
                            ,Hierarchy_ID = NULL  
                            ,Entity_ID = CASE tr.MemberType_ID   
                                WHEN ', @MemberType_Consolidated, N' THEN @NewEntity_ID -- Use the new entity for consolidated member transactions ....  
                                ELSE tr.Entity_ID END                                   -- ... but keep the old entity for other member types (probably always leaf)  
                            ,Attribute_ID = COALESCE(  
                                 a.NewAttribute_ID -- Changing the value of a consolidated attribute.  
                                ,CASE tr.MemberType_ID  
                                    WHEN ', @MemberType_Leaf, N' THEN @NewLeafDba_ID -- Moving a leaf member to a new parent  
                                    WHEN ', @MemberType_Consolidated, N' THEN @NewRecursiveAttribute_ID -- Moving a consolidated member to a new parent  
                                    ELSE NULL END)  
                            ,MemberType_ID = ', @MemberType_Leaf, N'  
  
                            ,OldValue = CASE WHEN tr.OldValue = @RootID AND tr.TransactionType_ID IN (', @TransactionType_MoveMemberToParent, N', ', @TransactionType_MoveMemberToSibling, N')   
                                THEN NULL  
                                ELSE tr.OldValue  
                                END  
                            ,OldCode = CASE WHEN tr.OldValue = @RootID AND tr.TransactionType_ID IN (', @TransactionType_MoveMemberToParent, N', ', @TransactionType_MoveMemberToSibling, N')   
                                THEN NULL  
                                ELSE tr.OldCode  
                                END  
                            ,NewValue = CASE WHEN tr.NewValue = @RootID AND tr.TransactionType_ID IN (', @TransactionType_MoveMemberToParent, N', ', @TransactionType_MoveMemberToSibling, N')   
                                THEN NULL  
                                ELSE tr.NewValue  
                                END  
                            ,NewCode = CASE WHEN tr.NewValue = @RootID AND tr.TransactionType_ID IN (', @TransactionType_MoveMemberToParent, N', ', @TransactionType_MoveMemberToSibling, N')   
                                THEN NULL  
                                ELSE tr.NewCode  
                                END  
  
                        FROM mdm.', QUOTENAME(@TransactionTableName), N' tr  
  
                        -- Get new attribute ID for consolidated members  
                        LEFT JOIN #AttributeMapping a  
                        ON      tr.Attribute_ID = a.OldAttribute_ID  
                            AND a.NewEntity_ID = @NewEntity_ID -- The attribute may have multiple copies (if the original entity has more than one EH) so filter on the new Entity_ID to get the right attribute ID.  
  
                        WHERE   tr.Entity_ID = @Entity_ID  
                            AND (   tr.MemberType_ID = ', @MemberType_Consolidated, N'     -- Copy all consolidated transactions...  
                                    OR tr.Hierarchy_ID = @ExplicitHierarchy_ID)        -- ... and all leaf member transactions that involve movement within the EH  
  
                        --SELECT * FROM mdm.', QUOTENAME(@TransactionTableName), N' WHERE Entity_ID IN (@Entity_ID, @NewEntity_ID)  
                            ');  
                        -- Note: No need to copy or update the transaction annotations, since we merely modified existing transaction rows.  
                    END ELSE  
                    BEGIN  
                        -- We're not deleting originals, so copy (rather than update) transaction rows. The transaction annotations will also need to be copied.  
                        SET @TransactionAnnotationTableName = mdm.udfGetTransactionAnnotationTableName(@Model_ID);  
                        -- Copy transactions pertaining to the EH being copied: Leaf transactions that move members in the EH, and all Consolidated transactions  
        PRINT CONCAT(SYSDATETIME(), N': Copying consolidated member transactions.');  
                        SET @SQL = CONCAT(@TruncationGuard, N'  
                        DECLARE @RootID NVARCHAR = N''0'';  
  
                        DECLARE @TransactionMappings TABLE  
                        (  
                             Old_ID INT PRIMARY KEY  
                            ,New_ID INT  
                        )  
  
                        MERGE mdm.', QUOTENAME(@TransactionTableName), N'  
                        USING  
                        (  
                            SELECT  
                                 tr.ID  
                                ,tr.Version_ID  
                                ,CASE WHEN tr.TransactionType_ID IN (', @TransactionType_MoveMemberToParent, N', ', @TransactionType_MoveMemberToSibling, N')   
                                    THEN ', @TransactionType_SetAttributeValue, N' -- Change EH move transactions to attribute change transaction  
                                    ELSE tr.TransactionType_ID END AS TransactionType_ID  
                                ,tr.OriginalTransaction_ID -- This references the old ID and will need to be updated after the MERGE  
                                ,NULL AS Hierarchy_ID  
                                ,CASE tr.MemberType_ID   
                                    WHEN ', @MemberType_Consolidated, N' THEN @NewEntity_ID -- Use the new entity for consolidated member transactions ....  
                                    ELSE tr.Entity_ID END                            -- ... but keep the old entity for other member types (probably always leaf)  
                                    AS Entity_ID  
                                ,COALESCE(a.NewAttribute_ID -- Changing the value of a consolidated attribute.  
                                    ,CASE tr.MemberType_ID  
                                        WHEN ', @MemberType_Leaf, N' THEN @NewLeafDba_ID -- Moving a leaf member to a new parent  
                                        WHEN ', @MemberType_Consolidated, N' THEN @NewRecursiveAttribute_ID -- Moving a consolidated member to a new parent  
                                        ELSE NULL END)  
                                    AS Attribute_ID  
                                ,tr.Member_ID                                        -- The old member ID will always be the same ...  
                                ,COALESCE(newEn.MUID, tr.Member_MUID) AS Member_MUID -- ... but the member MUID will be different for consolidated member transactions (not for leaf member EH move transactions)  
                                ,', @MemberType_Leaf, N' AS MemberType_ID  
                                ,tr.MemberCode  
  
                                ,CASE WHEN tr.OldValue = @RootID AND tr.TransactionType_ID IN (', @TransactionType_MoveMemberToParent, N', ', @TransactionType_MoveMemberToSibling, N')   
                                    THEN NULL  
                                    ELSE tr.OldValue  
                                    END AS OldValue  
                                ,CASE WHEN tr.OldValue = @RootID AND tr.TransactionType_ID IN (', @TransactionType_MoveMemberToParent, N', ', @TransactionType_MoveMemberToSibling, N')   
                                    THEN NULL  
                                    ELSE tr.OldCode  
                                    END AS OldCode  
                                ,CASE WHEN tr.NewValue = @RootID AND tr.TransactionType_ID IN (', @TransactionType_MoveMemberToParent, N', ', @TransactionType_MoveMemberToSibling, N')   
                                    THEN NULL  
                                    ELSE tr.NewValue  
                                    END AS NewValue  
                                ,CASE WHEN tr.NewValue = @RootID AND tr.TransactionType_ID IN (', @TransactionType_MoveMemberToParent, N', ', @TransactionType_MoveMemberToSibling, N')   
                                    THEN NULL  
                                    ELSE tr.NewCode  
                                    END AS NewCode  
  
                                ,tr.Batch_ID  
                                ,tr.EnterDTM  
                                ,tr.EnterUserID  
                                ,tr.LastChgDTM  
                                ,tr.LastChgUserID  
                            FROM mdm.', QUOTENAME(@TransactionTableName), ' tr  
  
                            -- Get new member MUID for copied consolidated members (note that this is a left join because some of the transactions that need to be copied may be for Leaf members being moved in the EH)  
                            LEFT JOIN mdm.', QUOTENAME(@NewEntityTableName_EN), N' newEn  
                            ON      tr.MemberType_ID = ', @MemberType_Consolidated, N'  
                                AND tr.Version_ID = newEn.Version_ID  
                                AND tr.Member_ID = newEn.ID  
  
                            -- Get new attribute ID for consolidated members  
                            LEFT JOIN #AttributeMapping a  
                            ON      tr.Attribute_ID = a.OldAttribute_ID  
                                AND a.NewEntity_ID = @NewEntity_ID -- The attribute may have multiple copies (if the original entity has more than one EH) so filter on the new Entity_ID to get the right attribute ID.  
  
                            WHERE   tr.Entity_ID = @Entity_ID  
                                AND (   tr.MemberType_ID = ', @MemberType_Consolidated, N'     -- Copy all consolidated transactions...  
                                     OR tr.Hierarchy_ID = @ExplicitHierarchy_ID)        -- ... and all leaf member transactions that involve movement within the EH  
                        ) t  
                        ON (1 = 0) -- An arbitrary condition that is always false, so that the NOT MATCHED block will always be hit.  
                        WHEN NOT MATCHED THEN  
                        INSERT  
                        (  
                             Version_ID  
                            ,TransactionType_ID  
                            ,OriginalTransaction_ID  
                            ,Hierarchy_ID  
                            ,Entity_ID  
                            ,Attribute_ID  
                            ,Member_ID  
                            ,Member_MUID  
                            ,MemberType_ID  
                            ,MemberCode  
                            ,OldValue  
                            ,OldCode  
                            ,NewValue  
                            ,NewCode  
                            ,Batch_ID  
                            ,EnterDTM  
                            ,EnterUserID  
                            ,LastChgDTM  
                            ,LastChgUserID  
                        )  
                        VALUES  
                        (  
                             Version_ID  
                            ,TransactionType_ID  
                            ,OriginalTransaction_ID  
                            ,Hierarchy_ID  
                            ,Entity_ID  
                            ,Attribute_ID  
                            ,Member_ID  
                            ,Member_MUID  
                            ,MemberType_ID  
                            ,MemberCode  
                            ,OldValue  
                            ,OldCode  
                            ,NewValue  
                            ,NewCode  
                            ,Batch_ID  
                            ,EnterDTM  
                            ,EnterUserID  
                            ,LastChgDTM  
                            ,LastChgUserID  
                        )  
                        OUTPUT t.ID, inserted.ID  
                        INTO @TransactionMappings(Old_ID, New_ID);  
  
                        -- Update original transaction ID columns  
                        UPDATE tr  
                        SET OriginalTransaction_ID = newParent.New_ID  
                        FROM mdm.', QUOTENAME(@TransactionTableName), N' tr  
                        INNER JOIN @TransactionMappings newRow  
                        ON tr.ID = newRow.New_ID  
                        INNER JOIN @TransactionMappings newParent  
                        ON tr.OriginalTransaction_ID = newParent.Old_ID;  
  
                        -- Copy transaction annotations  
        PRINT CONCAT(SYSDATETIME(), N'': Copying consolidated transaction annotations.'');  
                        INSERT INTO mdm.', QUOTENAME(@TransactionAnnotationTableName), N'  
                        (  
                             Version_ID  
                            ,Transaction_ID  
                            ,Comment  
                            ,EnterUserID  
                            ,EnterDTM  
                            ,LastChgDTM  
                            ,LastChgUserID  
                        )  
                        SELECT  
                             ta.Version_ID   
                            ,newRow.New_ID  
                            ,ta.Comment  
                            ,ta.EnterUserID  
                            ,ta.EnterDTM  
                            ,ta.LastChgDTM  
                            ,ta.LastChgUserID  
                        FROM mdm.', QUOTENAME(@TransactionAnnotationTableName), N' ta  
                        INNER JOIN @TransactionMappings newRow  
                        ON ta.Transaction_ID = newRow.Old_ID  
                        ');  
                        END  
                    --PRINT @SQL  
                    EXEC sp_executesql @SQL  
                        ,N'@ExplicitHierarchy_ID INT, @Entity_ID INT, @NewEntity_ID INT, @NewRecursiveAttribute_ID INT, @NewLeafDba_ID INT'  
                          ,@ExplicitHierarchy_ID,     @Entity_ID,     @NewEntity_ID,     @NewRecursiveAttribute_ID,     @NewLeafDba_ID;  
                END   
                ELSE IF @TransactionLogType = @TransactionLogType_Member  
                BEGIN  
  
PRINT CONCAT(SYSDATETIME(), N': Copying consolidated member history to the new entity.');  
  
                    SET @SQL = CONCAT(@TruncationGuard, N'  
                    -- Combine the old HP_HS and HR_HS tables into the new EN_HS table for hierarchy ', @ExplicitHierarchyName, N', entity ', @EntityName, N', to new entity ', @NewEntityName, N'  
                    ;WITH combinedHPCte AS -- Combine current HP values with history  
                    (  
                        -- current values  
                        SELECT  
                             hp.Version_ID  
                            ,CONVERT(BIGINT, hp.LastChgTS) AS ID  
                            ,hp.ID AS HP_ID  
                            ,hp.Status_ID  
                            ,hp.Name  
                            ,hp.Code  
                            ,hp.EnterDTM  
                            ,hp.EnterUserID  
                            ,hp.LastChgDTM  
                            ,hp.LastChgUserID  
                            ,hp.MUID  
                            -- User-defined attributes  
                            ', @OldAttributeColumnNames, N'  
                        FROM mdm.', QUOTENAME(@EntityTableName_HP), N' hp  
                        WHERE hp.Hierarchy_ID = @ExplicitHierarchy_ID  
  
                        UNION ALL -- deduplication not needed  
  
                        -- historical values  
                        SELECT  
                             hp.Version_ID  
                            ,hp.ID  
                            ,hp.HP_ID  
                            ,hp.Status_ID  
                            ,hp.Name  
                            ,hp.Code  
                            ,hp.EnterDTM  
                            ,hp.EnterUserID  
                            ,hp.LastChgDTM  
                            ,hp.LastChgUserID  
                            ,hp.MUID  
                            -- User-defined attributes  
                            ', @OldAttributeColumnNames, N'  
                        FROM mdm.', QUOTENAME(@EntityTableName_HP_HS), N' hp  
                        WHERE hp.Hierarchy_ID = @ExplicitHierarchy_ID  
                    )  
                    ,combinedHRCte AS -- Combine current HR values with history  
                    (  
                        -- current values  
                        SELECT  
                             hr.Version_ID  
                            ,CONVERT(BIGINT, hr.LastChgTS) AS ID  
                            ,hr.ID AS HR_ID  
                            ,hr.Status_ID  
                            ,hr.Parent_HP_ID  
                            ,hr.Child_HP_ID  
                            ,hr.EnterDTM  
                            ,hr.EnterUserID  
                            ,hr.LastChgDTM  
                            ,hr.LastChgUserID  
                        FROM mdm.', QUOTENAME(@EntityTableName_HR), N' hr  
                        WHERE   hr.Hierarchy_ID = @ExplicitHierarchy_ID  
                            AND hr.Child_HP_ID IS NOT NULL -- only include rows that assign a consolidated member to a parent  
  
                        UNION ALL -- deduplication not needed  
  
                        -- historical values  
                        SELECT  
                             hr.Version_ID  
                            ,hr.ID  
                            ,hr.HR_ID  
                            ,hr.Status_ID  
                            ,hr.Parent_HP_ID  
                            ,hr.Child_HP_ID  
                            ,hr.EnterDTM  
                            ,hr.EnterUserID  
                            ,hr.LastChgDTM  
                            ,hr.LastChgUserID  
                        FROM mdm.', QUOTENAME(@EntityTableName_HR_HS), N' hr  
                        WHERE   hr.Hierarchy_ID = @ExplicitHierarchy_ID  
                            AND hr.Child_HP_ID IS NOT NULL -- only include rows that assign a consolidated member to a parent  
                    )  
                    ,HPtoPreviousHRmapCte AS -- Link each HP_HS row with the previous HR_HS row, that assigned the consolidated member to a parent  
                    (  
                        SELECT   
                             hp.Version_ID  
                            ,hp.ID  
                            ,MAX(hr.ID) Prev_HR  
                        FROM mdm.', QUOTENAME(@EntityTableName_HP_HS), N' hp  
                        INNER JOIN combinedHRCte hr  
                        ON      hp.Version_ID = hr.Version_ID  
                            AND hp.HP_ID = hr.Child_HP_ID  
                            AND hp.ID >= hr.ID  
                        WHERE hp.Hierarchy_ID = @ExplicitHierarchy_ID  
                        GROUP BY hp.Version_ID, hp.ID  
                    )  
                    ,HRtoPreviousHPmapCte AS -- Link each HR_HS row with the previous HP_HS row, that set the member attribute values  
                    (  
                        SELECT   
                             hr.Version_ID  
                            ,hr.ID  
                            ,MAX(hr.Child_HP_ID) Child_HP_ID  
                            ,MAX(hp.ID) Prev_HP  
                        FROM mdm.', QUOTENAME(@EntityTableName_HR_HS), N' hr  
                        INNER JOIN combinedHPCte hp  
                        ON      hr.Version_ID = hp.Version_ID  
                            AND hr.Child_HP_ID = hp.HP_ID  
                            AND hr.ID >= hp.ID  
                        WHERE hr.Hierarchy_ID = @ExplicitHierarchy_ID  
                        GROUP BY hr.Version_ID, hr.ID  
                    )  
                    INSERT INTO mdm.', QUOTENAME(@NewEntityTableName_EN_HS), N'  
                    (  
                         Version_ID  
                        ,ID  
                        ,EN_ID  
                        ,Status_ID  
                        ,Name  
                        ,Code  
                        ,EnterDTM  
                        ,EnterUserID  
                        ,LastChgDTM  
                        ,LastChgUserID  
                        ,MUID  
                        -- User-defined attributes  
                        ', @NewAttributeColumnNames, N'  
                        -- The new self-referencing DBA  
                        ,', QUOTENAME(@NewRecursiveAttribute_ColumnName), N'   
                    )  
                    SELECT  
                         hp.Version_ID  
                        ,hp.ID  
                        ,hp.HP_ID  
                        ,hp.Status_ID  
                        ,hp.Name  
                        ,hp.Code  
                        ,hp.EnterDTM  
                        ,hp.EnterUserID  
                        ,hp.LastChgDTM  
                        ,hp.LastChgUserID  
                        ,COALESCE(newEn.MUID, hp.MUID) -- actual member MUID. Same when deleting originals, different when copying.  
                        -- User-defined attributes  
                        ', @OldAttributeColumnNames, N'  
                        -- The new self-referencing DBA (pulled from the HR_HS table)  
                        ,hrhs.Parent_HP_ID   
                    FROM mdm.', QUOTENAME(@EntityTableName_HP_HS), N' hp  
                    LEFT JOIN mdm.', QUOTENAME(@NewEntityTableName_EN), N' newEn  
                    ON      hp.Version_ID = newEn.Version_ID  
                        AND hp.HP_ID = newEn.ID  
                    LEFT JOIN HPtoPreviousHRmapCte hpMap  
                    ON      hp.Version_ID = hpMap.Version_ID  
                        AND hp.ID = hpMap.ID  
                    LEFT JOIN combinedHRCte hrhs  
                    ON      hp.Version_ID = hrhs.Version_ID  
                        AND hpMap.Prev_HR = hrhs.ID  
                    WHERE hp.Hierarchy_ID = @ExplicitHierarchy_ID  
  
                    UNION ALL -- deduplication not needed  
  
                    SELECT  
                         hp.Version_ID  
                        ,hrhs.ID  
                        ,hp.HP_ID  
                        ,hp.Status_ID  
                        ,hp.Name  
                        ,hp.Code  
                        ,hp.EnterDTM  
                        ,hp.EnterUserID  
                        ,hp.LastChgDTM  
                        ,hp.LastChgUserID  
                        ,COALESCE(newEn.MUID, hp.MUID) -- actual member MUID. Same when deleting originals, different when copying.  
                        -- User-defined attributes  
                        ', @OldAttributeColumnNames, N'  
                        -- The new self-referencing DBA (pulled from the HR_HS table)  
                        ,hrhs.Parent_HP_ID   
                    FROM mdm.', QUOTENAME(@EntityTableName_HR_HS), N' hrhs   
                    INNER JOIN HRtoPreviousHPmapCte hrMap    
                    ON      hrhs.Version_ID = hrMap.Version_ID  
                        AND hrhs.ID = hrMap.ID  
                    INNER JOIN combinedHPCte hp  
                    ON      hrhs.Version_ID = hp.Version_ID  
                        AND hrMap.Prev_HP = hp.ID  
                    LEFT JOIN mdm.', QUOTENAME(@NewEntityTableName_EN), N' newEn  
                    ON      hp.Version_ID = newEn.Version_ID  
                        AND hp.HP_ID = newEn.ID  
                    WHERE   hrhs.Child_HP_ID IS NOT NULL -- only copy rows that assign a consolidated member to a parent  
                        --AND hp.Hierarchy_ID = @ExplicitHierarchy_ID  
                    ')  
  
                    --PRINT CONCAT('DECLARE @ExplicitHierarchy_ID INT = ', @ExplicitHierarchy_ID)  
                    --PRINT SUBSTRING(@SQL, 0, 4000)  
                    --PRINT SUBSTRING(@SQL, 4000, 4000)  
                    --PRINT SUBSTRING(@SQL, 8000, 4000)  
                    EXEC sp_executesql @SQL ,N'@ExplicitHierarchy_ID INT' ,@ExplicitHierarchy_ID;  
  
PRINT CONCAT(SYSDATETIME(), N': Updating old leaf member history with the HR history info.');  
                    DECLARE @OldLeafAttributeColumnNames NVARCHAR(MAX) = N'';  
                    SELECT  
                        -- Note that this will include new Parent DBAs for other EHs, that have already been converted by a previous loop iteration  
                        @OldLeafAttributeColumnNames = CONCAT(@TruncationGuard, @OldLeafAttributeColumnNames, N'  
                        ,en.', QUOTENAME(TableColumn))  
                    FROM mdm.tblAttribute  
                    WHERE   Entity_ID = @Entity_ID  
                        AND MemberType_ID = @MemberType_Leaf  
                        AND IsSystem = 0  
                        AND ID <> @NewLeafDba_ID; -- Don't include the new DBA here. It will be added separately  
                  
PRINT CONCAT(SYSDATETIME(), N': Update the EN_HS table, setting values for the new DBA column, which come from the old HR and HR_HS tables, for hierarchy ', @ExplicitHierarchyName, N', entity ', @EntityName, N', to new entity ', @NewEntityName);  
                    SET @SQL = CONCAT(@TruncationGuard, N'  
                    -- Update the EN_HS table, setting values for the new DBA column, which come from the old HR and HR_HS tables, for hierarchy ', @ExplicitHierarchyName, N', entity ', @EntityName, N', to new entity ', @NewEntityName, N'  
                    ;WITH combinedENCte AS -- Combine current EN values with history  
                    (  
                        -- current values  
                        SELECT  
                             en.Version_ID  
                            ,COALESCE(en.', QUOTENAME(@TempTimestampColumnName), N', CONVERT(BIGINT, en.LastChgTS)) AS ID -- Use the original Timestamp. The current one may have been modified by setting the new DBA Parent value  
                            ,en.ID AS EN_ID  
                            ,en.Status_ID  
                            ,en.Name  
                            ,en.Code  
                            ,en.EnterDTM  
                            ,en.EnterUserID  
                            ,en.LastChgDTM  
                            ,en.LastChgUserID  
                            ,en.MUID',   
                            @OldLeafAttributeColumnNames, N'  
                            ,en.', QUOTENAME(@NewLeafDba_ColumnName), N' -- New DBA that references the new HP entity  
                        FROM mdm.', QUOTENAME(@EntityTableName_EN), N' en  
                        -- Previous iterations for other EHs on this same entity might have already copied the EN row to the EN_HS table. If so, do not re-add it  
                        LEFT JOIN mdm.', QUOTENAME(@EntityTableName_EN_HS), N' enhs  
                        ON      en.Version_ID = enhs.Version_ID  
                            AND ISNULL(en.', QUOTENAME(@TempTimestampColumnName), N', CONVERT(BIGINT, en.LastChgTS)) = enhs.ID  
                        WHERE enhs.ID IS NULL  
  
                        UNION ALL -- deduplication not needed  
  
                        -- historical values  
                        SELECT  
                             en.Version_ID  
                            ,en.ID  
                            ,en.EN_ID  
                            ,en.Status_ID  
                            ,en.Name  
                            ,en.Code  
                            ,en.EnterDTM  
                            ,en.EnterUserID  
                            ,en.LastChgDTM  
                            ,en.LastChgUserID  
                            ,en.MUID',   
                            @OldLeafAttributeColumnNames, N'  
                            ,en.', QUOTENAME(@NewLeafDba_ColumnName), N' -- New DBA that references the new HP entity  
                        FROM mdm.', QUOTENAME(@EntityTableName_EN_HS), N' en  
                    )  
                    ,combinedHRCte AS -- Combine current HR values with history  
                    (  
                        -- current values  
                        SELECT  
                             hr.Version_ID  
                            ,CONVERT(BIGINT, hr.LastChgTS) AS ID  
                            ,hr.ID AS HR_ID  
                            ,hr.Status_ID  
                            ,hr.Parent_HP_ID  
                            ,hr.Child_EN_ID  
                            ,hr.EnterDTM  
                            ,hr.EnterUserID  
                            ,hr.LastChgDTM  
                            ,hr.LastChgUserID  
                        FROM mdm.', QUOTENAME(@EntityTableName_HR), N' hr  
                        WHERE   hr.Hierarchy_ID = @ExplicitHierarchy_ID  
                            AND hr.Child_EN_ID IS NOT NULL -- only include rows that assign a leaf member to a parent  
  
                        UNION ALL -- deduplication not needed  
  
                        -- historical values. Note: some rows only differ by sort order. But we do not filter those out because they may have their own annotations.  
                        SELECT   
                             hr.Version_ID  
                            ,hr.ID  
                            ,hr.HR_ID  
                            ,hr.Status_ID  
                            ,hr.Parent_HP_ID  
                            ,hr.Child_EN_ID  
                            ,hr.EnterDTM  
                            ,hr.EnterUserID  
                            ,hr.LastChgDTM  
                            ,hr.LastChgUserID  
                        FROM mdm.', QUOTENAME(@EntityTableName_HR_HS), N' hr  
                        WHERE   hr.Hierarchy_ID = @ExplicitHierarchy_ID  
                            AND hr.Child_EN_ID IS NOT NULL -- only include rows that assign a leaf member to a parent  
                    )  
                    ,ENtoPreviousHRmapCte AS -- Link each EN_HS row with the previous HR_HS row, that assigned the leaf member to a parent  
                    (  
                        SELECT   
                             en.Version_ID  
                            ,en.ID  
                            ,MAX(hr.ID) Prev_HR  
                        FROM combinedENCte en  
                        INNER JOIN combinedHRCte hr  
                        ON      en.Version_ID = hr.Version_ID  
                            AND en.EN_ID = hr.Child_EN_ID  
                            AND en.ID >= hr.ID  
                        GROUP BY en.Version_ID, en.ID  
                    )  
                    ,HRtoPreviousENmapCte AS -- Link each HR_HS row with the previous EN_HS row, that set the member attribute values  
                    (  
                        SELECT   
                             hr.Version_ID  
                            ,hr.ID  
                            ,MAX(en.ID) Prev_EN  
                        FROM combinedHRCte hr  
                        INNER JOIN combinedENCte en  
                        ON      hr.Version_ID = en.Version_ID  
                            AND hr.Child_EN_ID = en.EN_ID  
                            AND hr.ID >= en.ID  
                        GROUP BY hr.Version_ID, hr.ID  
                    )  
                    ,combinedRowsCte AS  
                    (  
                        SELECT  
                             en.Version_ID  
                            ,en.ID  
                            ,en.EN_ID  
                            ,en.Status_ID  
                            ,en.Name  
                            ,en.Code  
                            ,en.EnterDTM  
                            ,en.EnterUserID  
                            ,en.LastChgDTM  
                            ,en.LastChgUserID  
                            ,en.MUID  
                            -- User-defined attributes  
                            ', @OldLeafAttributeColumnNames, N'  
                            -- The new leaf parent DBA (value pulled from the HR_HS table)  
                            ,hrhs.Parent_HP_ID ', QUOTENAME(@NewLeafDba_ColumnName), N' -- Alias the parent as its new column name  
                        FROM combinedENCte en  
                        INNER JOIN ENtoPreviousHRmapCte enMap  
                        ON      en.Version_ID = enMap.Version_ID  
                            AND en.ID = enMap.ID  
                        INNER JOIN combinedHRCte hrhs  
                        ON      en.Version_ID = hrhs.Version_ID  
                            AND enMap.Prev_HR = hrhs.ID  
  
                        UNION ALL -- deduplication not needed  
  
                        SELECT  
                             en.Version_ID  
                            ,hrhs.ID  
                            ,en.EN_ID  
                            ,en.Status_ID  
                            ,en.Name  
                            ,en.Code  
                            ,hrhs.EnterDTM  
                            ,hrhs.EnterUserID  
                            ,hrhs.LastChgDTM  
                            ,hrhs.LastChgUserID  
                            ,en.MUID  
                            -- User-defined attributes  
                            ', @OldLeafAttributeColumnNames, N'  
                            -- The new leaf parent DBA (value pulled from the HR_HS table)  
                            ,hrhs.Parent_HP_ID ', QUOTENAME(@NewLeafDba_ColumnName), N' -- Alias the parent as its new column name  
                        FROM combinedHRCte hrhs  
                        INNER JOIN HRtoPreviousENmapCte hrMap    
                        ON      hrhs.Version_ID = hrMap.Version_ID  
                            AND hrhs.ID = hrMap.ID  
                        INNER JOIN combinedENCte en  
                        ON      hrhs.Version_ID = en.Version_ID  
                            AND hrMap.Prev_EN = en.ID  
                    )  
                    MERGE mdm.', QUOTENAME(@EntityTableName_EN_HS), N' enhs  
                    USING combinedRowsCte en  
                    ON      enhs.Version_ID = en.Version_ID  
                        AND enhs.ID = en.ID  
                    WHEN MATCHED THEN  
                        -- The row already exists in the EN_HS table. Simply update the attribute value of the new DBA that references the new HP entity  
                        UPDATE SET enhs.', QUOTENAME(@NewLeafDba_ColumnName), N' = en.', QUOTENAME(@NewLeafDba_ColumnName), N'  
              
                    WHEN NOT MATCHED THEN  
                        -- The row pertains to a row in the HR_HS table. Add a corresponding row to the EN_HS table  
                        INSERT  
                        (  
                             Version_ID  
                            ,ID  
                            ,EN_ID  
                            ,Status_ID  
                            ,Name  
                            ,Code  
                            ,EnterDTM  
                            ,EnterUserID  
                            ,LastChgDTM  
                            ,LastChgUserID  
                            ,MUID  
                            -- User-defined attributes  
                            ', REPLACE(@OldLeafAttributeColumnNames, N'en.', N''), N'  
                            -- The new leaf parent DBA  
                            ,', QUOTENAME(@NewLeafDba_ColumnName), N'   
                        )  
                        VALUES  
                        (  
                             en.Version_ID  
                            ,en.ID  
                            ,en.EN_ID  
                            ,en.Status_ID  
                            ,en.Name  
                            ,en.Code  
                            ,en.EnterDTM  
                            ,en.EnterUserID  
                            ,en.LastChgDTM  
                            ,en.LastChgUserID  
                            ,en.MUID  
                            -- User-defined attributes  
                            ', @OldLeafAttributeColumnNames, N'  
                            -- The new leaf parent DBA  
                            ,en.', QUOTENAME(@NewLeafDba_ColumnName), N'  
                        );')  
  
                    --PRINT CONCAT('DECLARE @ExplicitHierarchy_ID INT = ', @ExplicitHierarchy_ID)  
                    --PRINT SUBSTRING(@SQL, 0, 4000)  
                    --PRINT SUBSTRING(@SQL, 4000, 4000)  
                    --PRINT SUBSTRING(@SQL, 8000, 4000)  
                    --PRINT SUBSTRING(@SQL, 12000, 4000)  
                    EXEC sp_executesql @SQL ,N'@ExplicitHierarchy_ID INT' ,@ExplicitHierarchy_ID;  
  
  
PRINT CONCAT(SYSDATETIME(), N': Copying consolidated member revision annotations from table ', @EntityTableName_HP_AN, N' to ', @NewEntityTableName_EN_AN);  
                    SET @SQL = CONCAT(N'  
                    INSERT INTO mdm.', QUOTENAME(@NewEntityTableName_EN_AN), N'  
                    (  
                         Version_ID  
                        ,Revision_ID  
                        ,Comment  
                        ,EnterDTM  
                        ,EnterUserID  
                        ,LastChgDTM  
                        ,LastChgUserID  
                    )  
                    -- member current revision, need to map old to new revision (LastChgTS)  
                    SELECT   
                         hpAn.Version_ID  
                        ,newEn.LastChgTS AS Revision_ID-- map to the current timestamp in the new leaf entity  
                        ,hpAn.Comment  
                        ,hpAn.EnterDTM  
                        ,hpAn.EnterUserID  
                        ,hpAn.LastChgDTM  
                        ,hpAn.LastChgUserID  
                    FROM mdm.', QUOTENAME(@EntityTableName_HP_AN), N' hpAn  
                    INNER JOIN mdm.', QUOTENAME(@EntityTableName_HP), N' hp  
                    ON      hpAn.Version_ID = hp.Version_ID  
                        AND hpAn.Revision_ID = hp.LastChgTS  
                    INNER JOIN mdm.', QUOTENAME(@NewEntityTableName_EN), N' newEn  
                    ON      hp.Version_ID = newEn.Version_ID  
                        AND hp.ID = newEn.ID  
                    WHERE hp.Hierarchy_ID = @ExplicitHierarchy_ID  
  
                    UNION ALL -- deduplication not needed  
  
                    -- member history  
                    SELECT   
                         hpAn.Version_ID  
                        ,hpAn.Revision_ID  
                        ,hpAn.Comment  
                        ,hpAn.EnterDTM  
                        ,hpAn.EnterUserID  
                        ,hpAn.LastChgDTM  
                        ,hpAn.LastChgUserID  
                    FROM mdm.', QUOTENAME(@EntityTableName_HP_AN), N' hpAn  
                    INNER JOIN mdm.', QUOTENAME(@NewEntityTableName_EN_HS), N' enHs  
                    ON      hpAn.Version_ID = enHs.Version_ID  
                        AND hpAn.Revision_ID = enHs.ID');  
                    --PRINT @SQL  
                    EXEC sp_executesql @SQL, N'@ExplicitHierarchy_ID INT' ,@ExplicitHierarchy_ID;  
  
PRINT CONCAT(SYSDATETIME(), N': Copying member history annotations from table ', @EntityTableName_HR_AN, N' to ', @EntityTableName_EN_AN);  
                    SET @SQL = CONCAT(N'  
                    INSERT INTO mdm.', QUOTENAME(@EntityTableName_EN_AN), N'  
                    (  
                         Version_ID  
                        ,Revision_ID  
                        ,Comment  
                        ,EnterDTM  
                        ,EnterUserID  
                        ,LastChgDTM  
                        ,LastChgUserID  
                    )  
                    -- hierarchy move current revision, need to map old to new revision (LastChgTS)  
                    SELECT   
                         hrAn.Version_ID  
                        ,newEn.LastChgTS AS Revision_ID-- map to the current timestamp in the new leaf entity  
                        ,hrAn.Comment  
                        ,hrAn.EnterDTM  
                        ,hrAn.EnterUserID  
                        ,hrAn.LastChgDTM  
                        ,hrAn.LastChgUserID  
                    FROM mdm.', QUOTENAME(@EntityTableName_HR_AN), N' hrAn  
                    INNER JOIN mdm.', QUOTENAME(@EntityTableName_HR), N' hr  
                    ON      hrAn.Version_ID = hr.Version_ID  
                        AND hrAn.Revision_ID = hr.LastChgTS  
                    INNER JOIN mdm.', QUOTENAME(@NewEntityTableName_EN), N' newEn  
                    ON      hr.Version_ID = newEn.Version_ID  
                        AND hr.Child_HP_ID = newEn.ID  
                    LEFT JOIN mdm.', QUOTENAME(@EntityTableName_EN_HS), N' enHs  
                    ON      hrAn.Version_ID = enHs.Version_ID  
                        AND hrAn.Revision_ID = enHs.ID  
                    WHERE   hr.Hierarchy_ID = @ExplicitHierarchy_ID  
                        AND enHs.ID IS NULL -- do not include revisions that are already in the new EN_HS table. They will be covered by the below query  
  
                    UNION ALL -- deduplication not needed  
  
                    -- historical hierarchy moves  
                    SELECT   
                         hrAn.Version_ID  
                        ,hrAn.Revision_ID  
                        ,hrAn.Comment  
                        ,hrAn.EnterDTM  
                        ,hrAn.EnterUserID  
                        ,hrAn.LastChgDTM  
                        ,hrAn.LastChgUserID  
                    FROM mdm.', QUOTENAME(@EntityTableName_HR_AN), N' hrAn  
                    INNER JOIN mdm.', QUOTENAME(@EntityTableName_EN_HS), N' enHs  
                    ON      hrAn.Version_ID = enHs.Version_ID  
                        AND hrAn.Revision_ID = enHs.ID  
                        ');  
                    --PRINT @SQL  
                    EXEC sp_executesql @SQL, N'@ExplicitHierarchy_ID INT' ,@ExplicitHierarchy_ID;  
                END -- Copy Member history for consolidated members  
  
                -- Create new Derived Hierarchy.  
  
                -- Get a unique Derived Hierarchy name. First, try to use the same name as the EH (if the name isn't already being used by an existing DH, then this would be more user-friendly. Otherwise, generate a unique name)  
                SET @NewDerivedHierarchyName = @ExplicitHierarchyName;  
                SET @counter = -1;  
                WHILE (1=1) -- TSQL doesn't support a DO-WHILE loop, so use a tautology as this WHILE condition to simulate a post-test loop.  
                BEGIN  
                    -- If the new entity name is unique within the model, then exit the loop.  
                    IF NOT EXISTS (SELECT 1 FROM mdm.tblDerivedHierarchy WHERE Model_ID = @Model_ID AND Name = @NewDerivedHierarchyName)  
                    BEGIN  
                        BREAK;  
                    END;  
  
                    -- The name wasn't unique, so increment the counter.  
                    SET @counter += 1;  
  
                    -- Ideally, the new entity name should reference both the leaf entity name and the explicit hierarchy name. However, there is a risk  
                    -- that this could exceed the max name length, in which case we need to be smart about where to do the truncation.  
                    IF (@EntityNameLength + @HierarchyNameLength + 4/*allow room for the underscore and the counter*/ <= @MaxMetadataObjectNameLength)  
                    BEGIN  
                        -- The entity and hierarchy names are short enough that they can be concatenated together without exceeding the max length  
                        SET @NewDerivedHierarchyName = CONCAT(@EntityName, N'_', @ExplicitHierarchyName, CASE @counter WHEN 0 THEN N'' ELSE CONVERT(NVARCHAR, @counter) END);  
                    END  
                    ELSE  
                    BEGIN  
                        -- The entity and hierarchy names are together too long, so use truncation. Each name is limited to slightly less than half of the max length. Note  
                        -- that this approach may not be the most sophisticated way of doing it (it could result in overly-aggressive truncation in the case where one name  
                        -- is significantly longer than the other), but it is cheap to implement and should be sufficient since this is an edge case, anyways.  
                        SET @NewDerivedHierarchyName = CONCAT(SUBSTRING(@EntityName, 0, @HalfMaxLen), N'_', SUBSTRING(@ExplicitHierarchyName, 0, @HalfMaxLen), CASE @counter WHEN 0 THEN N'' ELSE CONVERT(NVARCHAR, @counter) END);  
                    END;  
  
                END; -- WHILE (get unique derived hierarchy name)  
  
                -- Create the new derived hierarchy.  
PRINT CONCAT(SYSDATETIME(), N': Creating a new recursive derived hierarchy "', @NewDerivedHierarchyName, N'"');  
                SET @NewDerivedHierarchy_ID = 0;  
                EXEC mdm.udpDerivedHierarchySave   
                     @User_ID = @User_ID  
                    ,@Model_ID = @Model_ID  
                    ,@Name = @NewDerivedHierarchyName  
                    ,@AnchorNullRecursions = 1  
                    ,@Return_ID = @NewDerivedHierarchy_ID OUTPUT  
  
                -- Save conversion info to facilitate BR and security permission copying later in the script.  
                INSERT INTO #EH_ConversionLog  
                SELECT   
                     @ExplicitHierarchy_ID  
                    ,@ExplicitHierarchyName  
                    ,@Entity_ID  
                    ,@NewLeafDba_ID  
                    ,@NewLeafDbaName  
                    ,@NewEntity_ID  
                    ,@NewDerivedHierarchy_ID  
                    ,@NewRecursiveAttribute_ID  
                    ,@NewRecursiveAttributeName  
  
  
                -- Update the new DH's audit info to match the EH's audit info.  
                UPDATE mdm.tblDerivedHierarchy  
                SET  EnterDTM = @EnterDTM  
                    ,EnterUserID = @EnterUserID  
                    ,EnterVersionID = @EnterVersionID  
                    ,LastChgDTM = @LastChgDTM  
                    ,LastChgUserID = @LastChgUserID  
                    ,LastChgVersionID = @LastChgVersionID  
                WHERE ID = @NewDerivedHierarchy_ID;  
  
                -- Add the leaf member level.  
PRINT CONCAT(SYSDATETIME(), N': Adding leaf level "', @EntityName, '" to hierarchy "', @NewDerivedHierarchyName, N'"');  
                EXEC mdm.udpDerivedHierarchyDetailSave  
                  @User_ID = @User_ID  
                 ,@Model_ID = @Model_ID  
                 ,@DerivedHierarchy_ID = @NewDerivedHierarchy_ID  
                 ,@Foreign_ID = @Entity_ID  
                 ,@ForeignType_ID = @HierarchyItemType_Entity  
                 ,@Name = @EntityName  
                 ,@DisplayName = @EntityName  
                 ,@IsVisible = 1  
                 ,@Return_ID = @NewLevel_ID OUTPUT  
  
                -- Add the two recursive levels.  
                 SET @NewLevelName = SUBSTRING(@NewLeafDbaName, 0, @MaxHierarchyLevelNameLength)  
                 IF @NewLevelName = @EntityName  
                 BEGIN  
                    SET @NewLevelName = CONCAT(SUBSTRING(@NewLevelName, 0, @MaxHierarchyLevelNameLength - 1), N'1');  
                 END  
PRINT CONCAT(SYSDATETIME(), N': Adding recursive level "', @NewLevelName, '" to hierarchy "', @NewDerivedHierarchyName, N'"');  
                EXEC mdm.udpDerivedHierarchyDetailSave  
                  @User_ID = @User_ID  
                 ,@Model_ID = @Model_ID  
                 ,@DerivedHierarchy_ID = @NewDerivedHierarchy_ID  
                 ,@Foreign_ID = @NewLeafDba_ID  
                 ,@ForeignType_ID = @HierarchyItemType_DBA  
                 ,@Name = @NewLevelName  
                 ,@DisplayName = @NewLevelName  
                 ,@IsVisible = 1  
                 ,@Return_ID = @NewLevel_ID OUTPUT  
              
                -- Update the new DH level's audit info to match the EH's audit info.  
                UPDATE mdm.tblDerivedHierarchyDetail  
                SET  EnterDTM = @EnterDTM  
                    ,EnterUserID = @EnterUserID  
                    ,EnterVersionID = @EnterVersionID  
                    ,LastChgDTM = @LastChgDTM  
                    ,LastChgUserID = @LastChgUserID  
                    ,LastChgVersionID = @LastChgVersionID  
                WHERE ID = @NewLevel_ID;  
  
  
                 SET @NewLevelName = SUBSTRING(@NewRecursiveAttributeName, 0, @MaxHierarchyLevelNameLength)  
                 SET @counter = 0;  
                 WHILE EXISTS (SELECT 1 FROM mdm.tblDerivedHierarchyDetail WHERE DerivedHierarchy_ID = @NewDerivedHierarchy_ID AND Name = @NewLevelName)  
                 BEGIN  
                    SET @counter += 1;  
                    SET @NewLevelName += CONCAT(@NewRecursiveAttributeName, @counter);  
                 END  
PRINT CONCAT(SYSDATETIME(), N': Adding recursive level "', @NewLevelName, '" to hierarchy "', @NewDerivedHierarchyName, N'"');  
                EXEC mdm.udpDerivedHierarchyDetailSave  
                  @User_ID = @User_ID  
                 ,@Model_ID = @Model_ID  
                 ,@DerivedHierarchy_ID = @NewDerivedHierarchy_ID  
                 ,@Foreign_ID = @NewRecursiveAttribute_ID  
                 ,@ForeignType_ID = @HierarchyItemType_DBA  
                 ,@Name = @NewLevelName  
                 ,@DisplayName = @NewRecursiveAttributeName  
                 ,@IsVisible = 1  
                 ,@Return_ID = @NewLevel_ID OUTPUT  
  
                -- Update the new DH level's audit info to match the EH's audit info.  
                UPDATE mdm.tblDerivedHierarchyDetail  
                SET  EnterDTM = @EnterDTM  
                    ,EnterUserID = @EnterUserID  
                    ,EnterVersionID = @EnterVersionID  
                    ,LastChgDTM = @LastChgDTM  
                    ,LastChgUserID = @LastChgUserID  
                    ,LastChgVersionID = @LastChgVersionID  
                WHERE ID = @NewLevel_ID;  
  
  
                -- Determine if the explicit hierarchy was being used as an explicit cap of any DHs. If so, create a copy of each DH with the explicit cap replaced by a recursive level.  
PRINT CONCAT(SYSDATETIME(), N': Getting list of derived hierarchies that use EH "', @ExplicitHierarchyName, N'" as an explicit cap');  
                DELETE FROM @ExplicitCapHierarchies;  
                INSERT INTO @ExplicitCapHierarchies  
                SELECT DISTINCT   
                     dh.ID  
                    ,dh.Name  
                FROM mdm.tblDerivedHierarchy dh  
                INNER JOIN mdm.tblDerivedHierarchyDetail dhd  
                ON dh.ID = dhd.DerivedHierarchy_ID  
                WHERE   dhd.ForeignType_ID = @HierarchyItemType_ExplicitHierarchy  
                    AND dhd.Foreign_ID = @ExplicitHierarchy_ID;  
  
                -- Loop through each DH that the current explicit hierarchy caps.  
                DECLARE   
                     @DerivedHierarchy_ID INT = 0  
                    ,@DerivedHierarchyName NVARCHAR(50) = NULL;  
                WHILE EXISTS (SELECT 1 FROM @ExplicitCapHierarchies WHERE DerivedHierarchy_ID > @DerivedHierarchy_ID)  
                BEGIN  
                    -- Get the next explicit cap hierarchy id.  
                    SELECT TOP 1   
                         @DerivedHierarchy_ID = DerivedHierarchy_ID  
                        ,@DerivedHierarchyName = DerivedHierarchyName  
                    FROM @ExplicitCapHierarchies   
                    WHERE DerivedHierarchy_ID > @DerivedHierarchy_ID  
                    ORDER BY DerivedHierarchy_ID;  
  
                    -- Get a unique Derived Hierarchy name.  
                    SET @counter = 0;  
                    DECLARE @NoCap NVARCHAR(10) = N'_NoCap';  
                    WHILE (1=1) -- TSQL doesn't support a DO-WHILE loop, so use a tautology as this WHILE condition to simulate a post-test loop.  
                    BEGIN  
                        SET @NewDerivedHierarchyName = CONCAT(SUBSTRING(@DerivedHierarchyName, 0, @MaxMetadataObjectNameLength - LEN(@NoCap) - 3), @NoCap, CASE @counter WHEN 0 THEN N'' ELSE CONVERT(NVARCHAR, @counter) END);  
  
                        -- If the new entity name is unique within the model, then exit the loop.  
                        IF NOT EXISTS (SELECT 1 FROM mdm.tblDerivedHierarchy WHERE Model_ID = @Model_ID AND Name = @NewDerivedHierarchyName)  
                        BEGIN  
                            BREAK;  
                        END;  
  
                        -- The name wasn't unique, so increment the counter for the next loop iteration.  
                        SET @counter += 1;  
                    END; -- WHILE (get unique derived hierarchy name)  
  
                    -- Create a new derived hierarchy.  
PRINT CONCAT(SYSDATETIME(), N': Created new hierarchy, "', @NewDerivedHierarchyName, N'", as a copy of explicit cap hierarchy "', @DerivedHierarchyName, N'".');  
                    SET @NewDerivedHierarchy_ID = 0;  
                    EXEC mdm.udpDerivedHierarchySave  
                         @User_ID = @User_ID  
                        ,@Model_ID = @Model_ID  
                        ,@Name = @NewDerivedHierarchyName  
                        ,@AnchorNullRecursions = 1  
                        ,@Return_ID = @NewDerivedHierarchy_ID OUTPUT;  
  
                    -- Update the new DH's audit info to match the EH's audit info.  
                    UPDATE mdm.tblDerivedHierarchy  
                    SET  EnterDTM = @EnterDTM  
                        ,EnterUserID = @EnterUserID  
                        ,EnterVersionID = @EnterVersionID  
                        ,LastChgDTM = @LastChgDTM  
                        ,LastChgUserID = @LastChgUserID  
                        ,LastChgVersionID = @LastChgVersionID  
                    WHERE ID = @NewDerivedHierarchy_ID;  
          
                    -- Copy the existing DH levels, minus the explicit cap.  
PRINT CONCAT(SYSDATETIME(), N': Copying non-explicit levels.');  
                    INSERT INTO mdm.tblDerivedHierarchyDetail  
                    (  
                         DerivedHierarchy_ID  
                        ,Name  
                        ,DisplayName  
                        ,ForeignParent_ID  
                        ,Foreign_ID  
                        ,ForeignType_ID  
                        ,Level_ID  
                        ,IsVisible  
                        ,EnterDTM  
                        ,EnterUserID  
                        ,EnterVersionID  
                        ,LastChgDTM  
                        ,LastChgUserID  
                        ,LastChgVersionID  
                    )  
                    SELECT  
                         @NewDerivedHierarchy_ID  
                        ,Name  
                        ,DisplayName  
                        ,ForeignParent_ID  
                        ,Foreign_ID  
                        ,ForeignType_ID  
                        ,Level_ID  
                        ,IsVisible  
                        ,EnterDTM  
                        ,EnterUserID  
                        ,EnterVersionID  
                        ,LastChgDTM  
                        ,LastChgUserID  
                        ,LastChgVersionID  
                    FROM mdm.tblDerivedHierarchyDetail  
                    WHERE   DerivedHierarchy_ID = @DerivedHierarchy_ID  
                        AND ForeignType_ID <> @HierarchyItemType_ExplicitHierarchy -- Exclude the explicit cap level  
          
                    -- Add two levels for the new recursive cap that takes the place of the explicit cap.  
                 SET @NewLevelName = SUBSTRING(@NewLeafDbaName, 0, @MaxHierarchyLevelNameLength)  
                 SET @counter = 0;  
                 WHILE EXISTS (SELECT 1 FROM mdm.tblDerivedHierarchyDetail WHERE DerivedHierarchy_ID = @NewDerivedHierarchy_ID AND Name = @NewLevelName)  
                 BEGIN  
                    SET @counter += 1;  
                    SET @NewLevelName += CONCAT(@NewRecursiveAttributeName, @counter);  
                 END  
PRINT CONCAT(SYSDATETIME(), N': Adding recursive level "', @NewLevelName, '" to hierarchy "', @NewDerivedHierarchyName, N'" to take the place of the explicit cap.');  
                    EXEC mdm.udpDerivedHierarchyDetailSave  
                      @User_ID = @User_ID  
                     ,@Model_ID = @Model_ID  
                     ,@DerivedHierarchy_ID = @NewDerivedHierarchy_ID  
                     ,@Foreign_ID = @NewLeafDba_ID  
                     ,@ForeignType_ID = @HierarchyItemType_DBA  
                     ,@Name = @NewLevelName  
                     ,@DisplayName = @NewLevelName  
                     ,@IsVisible = 1  
                     ,@Return_ID = @NewLevel_ID OUTPUT;  
                  
                    -- Update the new DH level's audit info to match the EH's audit info.  
                    UPDATE mdm.tblDerivedHierarchyDetail  
                    SET  EnterDTM = @EnterDTM  
                        ,EnterUserID = @EnterUserID  
                        ,EnterVersionID = @EnterVersionID  
                        ,LastChgDTM = @LastChgDTM  
                        ,LastChgUserID = @LastChgUserID  
                        ,LastChgVersionID = @LastChgVersionID  
                    WHERE ID = @NewLevel_ID;  
  
                 SET @NewLevelName = SUBSTRING(@NewRecursiveAttributeName, 0, @MaxHierarchyLevelNameLength)  
                 SET @counter = 0;  
                 WHILE EXISTS (SELECT 1 FROM mdm.tblDerivedHierarchyDetail WHERE DerivedHierarchy_ID = @NewDerivedHierarchy_ID AND Name = @NewLevelName)  
                 BEGIN  
                    SET @counter += 1;  
                    SET @NewLevelName += CONCAT(@NewRecursiveAttributeName, @counter);  
                 END  
PRINT CONCAT(SYSDATETIME(), N': Adding recursive level "', @NewLevelName, '" to hierarchy "', @NewDerivedHierarchyName, N'" to take the place of the explicit cap.');  
                    EXEC mdm.udpDerivedHierarchyDetailSave  
                      @User_ID = @User_ID  
                     ,@Model_ID = @Model_ID  
                     ,@DerivedHierarchy_ID = @NewDerivedHierarchy_ID  
                     ,@Foreign_ID = @NewRecursiveAttribute_ID  
                     ,@ForeignType_ID = @HierarchyItemType_DBA  
                     ,@Name = @NewLevelName  
                     ,@DisplayName = @NewLevelName  
                     ,@IsVisible = 1  
                     ,@Return_ID = @NewLevel_ID OUTPUT;  
  
                    -- Update the new DH level's audit info to match the EH's audit info.  
                    UPDATE mdm.tblDerivedHierarchyDetail  
                    SET  EnterDTM = @EnterDTM  
                        ,EnterUserID = @EnterUserID  
                        ,EnterVersionID = @EnterVersionID  
                        ,LastChgDTM = @LastChgDTM  
                        ,LastChgUserID = @LastChgUserID  
                        ,LastChgVersionID = @LastChgVersionID  
                    WHERE ID = @NewLevel_ID;  
                END -- WHILE (loop through explicit cap DHs)  
            END; -- WHILE (loop through explicit hierarchies)  
  
            IF @TransactionLogType = @TransactionLogType_Member  
            BEGIN  
PRINT CONCAT(SYSDATETIME(), N': Deleting temporary LastChgTS column from table ', @EntityTableName_EN);  
                -- Remove the temporary LastChgTS column that was added to the EN table (it is not needed for Collection processing below, because the process does not change the original EN table)  
                SET @SQL = CONCAT(N'  
                DROP INDEX ', QUOTENAME(CONCAT(N'ix_', @EntityTableName_EN, N'_Version_ID_', @TempTimestampColumnName)), N' ON mdm.', QUOTENAME(@EntityTableName_EN), N';  
                ALTER TABLE mdm.', QUOTENAME(@EntityTableName_EN), N' DROP COLUMN ', QUOTENAME(@TempTimestampColumnName));  
                --PRINT @SQL  
  
                EXEC sp_executesql @SQL;  
            END  
  
  
        END -- Loop through entities, converting their EHs  
  
        -- Copy business rules. This is done after all of the EHs are copied (rather than for each hierarchy, within the above loop  
        -- because a rule could reference more than one EH parent.)  
PRINT CONCAT(SYSDATETIME(), N': Copying business rules.');  
  
  
        -- Get a list of all rules that need to be copied, including  
        -- 1. Consolidated BRs  
        -- 2. Leaf BRs that reference any of the explicit hierarchies that were converted to derived hierarchies.  
        CREATE TABLE #BusinessRule_IDs   
        (     
              BusinessRule_ID   INT --PRIMARY KEY -- Consolidated members could be copied to multiple entities, so may not be unique.  
             ,Entity_ID         INT NOT NULL DEFAULT 0  
             ,NewEntity_ID      INT -- N/A for leaf BRs  
             ,MemberType_ID     TINYINT   
        );  
        CREATE INDEX #ix_BusinessRule_IDs_BusinessRule_ID ON #BusinessRule_IDs(BusinessRule_ID);  
        WITH convertedEntities AS  
        (  
            SELECT DISTINCT Entity_ID  
            FROM @ExplicitHierarchies  
        )  
        ,brsToCopyCte AS -- get list of all BRs that need to be copied  
        (  
            SELECT DISTINCT   
                 b.ID  
                ,b.Entity_ID  
                --,cl2.NewEntity_ID  
                ,b.MemberType_ID  
            FROM mdm.tblBRBusinessRule b  
            INNER JOIN mdm.viw_SYSTEM_SCHEMA_BUSINESSRULE_PROPERTIES bp  
            ON b.ID = bp.BusinessRule_ID  
            LEFT JOIN #EH_ConversionLog cl  
            ON      bp.PropertyType_ID = @BRPropertyType_ParentAttribute  
                AND bp.Property_Value = CONVERT(NVARCHAR, cl.ExplicitHierarchy_ID)  
            LEFT JOIN convertedEntities en  
            ON      b.MemberType_ID = @MemberType_Consolidated  
                AND b.Entity_ID = en.Entity_ID  
            WHERE  cl.ExplicitHierarchy_ID IS NOT NULL  -- Get only rules that either reference a copied consolidated parent, or...  
                OR en.Entity_ID IS NOT NULL             -- ... apply to copied consolidated members.  
        )  
        INSERT INTO #BusinessRule_IDs  
        SELECT DISTINCT   
             b.ID AS BusinessRule_ID  
            ,b.Entity_ID  
            ,cl.NewEntity_ID  
            ,b.MemberType_ID  
        FROM brsToCopyCte b  
        LEFT JOIN #EH_ConversionLog cl -- for each Consolidated BR, make one copy per EH. Make only a single copy of each Leaf BR that references consolidated members  
        ON      b.MemberType_ID = @MemberType_Consolidated  
            AND b.Entity_ID = cl.Entity_ID  
  
        -- Create temp tables to map between old (original) and new (copied) table rows.  
        CREATE TABLE #BRBusinessRuleRowMappings   
        (  
             OldRow_ID      INT --PRIMARY KEY -- Consolidated members could be copied to multiple entities, so may not be unique.  
            ,NewRow_ID      INT  
            ,MemberType_ID  TINYINT  
            ,NewEntity_ID   INT -- N/A for leaf BRs  
        );  
        CREATE INDEX #ix_BRBusinessRuleRowMappings_OldRow_ID ON #BRBusinessRuleRowMappings(OldRow_ID);  
        CREATE TABLE #BRLogicalOperatorRowMappings  
        (  
             OldRow_ID      INT --PRIMARY KEY -- Consolidated members could be copied to multiple entities, so may not be unique.  
            ,NewRow_ID      INT  
            ,MemberType_ID  TINYINT  
        );  
        CREATE INDEX #ix_BRLogicalOperatorRowMappings_OldRow_ID ON #BRLogicalOperatorRowMappings(OldRow_ID);  
        CREATE TABLE #BRItemRowMappings  
        (  
             OldRow_ID      INT --PRIMARY KEY -- Consolidated members could be copied to multiple entities, so may not be unique.  
            ,NewRow_ID      INT  
        );  
        CREATE INDEX #ix_BRItemRowMappings_OldRow_ID ON #BRItemRowMappings(OldRow_ID);  
        CREATE TABLE #BRItemPropertiesRowMappings  
        (  
             OldRow_ID      INT --PRIMARY KEY -- Consolidated members could be copied to multiple entities, so may not be unique.  
            ,NewRow_ID      INT  
            ,NewBRItem_ID   INT  
        );  
        CREATE INDEX #ix_BRItemPropertiesRowMappings_OldRow_ID ON #BRItemPropertiesRowMappings(OldRow_ID);  
  
        DECLARE @RuleIDs        mdm.IdList;  
  
        SET @Entity_ID = 0;  
        DECLARE @ReplaceSQL NVARCHAR(MAX);  
        WHILE EXISTS (SELECT 1 FROM #BusinessRule_IDs WHERE Entity_ID > @Entity_ID)  
        BEGIN  
            -- Get the next entity ID.  
            SELECT TOP 1   
                @Entity_ID = Entity_ID  
            FROM #BusinessRule_IDs   
            WHERE Entity_ID > @Entity_ID   
            ORDER BY Entity_ID  
PRINT CONCAT(SYSDATETIME(), N': Copying Leaf Business Rules for @Entity_ID = ', @Entity_ID);  
  
            -- Ensure the row mapping tables are empty.  
            DELETE FROM #BRBusinessRuleRowMappings;  
            DELETE FROM #BRLogicalOperatorRowMappings;  
            DELETE FROM #BRItemRowMappings;  
            DELETE FROM #BRItemPropertiesRowMappings;  
  
            -- Create a dynamic SQL string that will replace all EH attribute references with new domain entity attribute references. This requires one REPLACE statement per EH in the entity.  
            SET @ReplaceSQL = NULL;  
            SELECT @ReplaceSQL = @TruncationGuard + CONCAT(N'REPLACE( ' + COALESCE(@ReplaceSQL, N'{0}') + N', N''Parent.', c.ExplicitHierarchyName, N'.'', CONCAT(N''DBA.'', CASE id.MemberType_ID WHEN ', @MemberType_Leaf, N' THEN N''', c.LeafParentDbaName, N''' ELSE N''', c.NewEntityRecursiveDbaName, N''' END, N''.''))')  
            FROM #EH_ConversionLog c  
            WHERE Entity_ID = @Entity_ID;  
PRINT CONCAT(SYSDATETIME(), N': @ReplaceSQL = "',   @ReplaceSQL, N'"');  
  
            -- Copy  mdm.tblBRBusinessRule rows.  
PRINT CONCAT(SYSDATETIME(), N': Copying mdm.tblBRBusinessRule rows.');  
            SET @SQL = CONCAT(@TruncationGuard, N'  
            MERGE mdm.tblBRBusinessRule  
            USING  
            (  
                SELECT    
                     b.ID  
                    ,SUBSTRING(CONCAT(b.Name, N''_NoEH''), 0, 50) AS Name -- Name is not constrained to be unique  
                    ,b.Description  
                    ,', REPLACE(@ReplaceSQL, N'{0}', N'b.RuleConditionText' ), N' AS RuleConditionText  
                    ,', REPLACE(@ReplaceSQL, N'{0}', N'b.RuleActionText' ), N' AS RuleActionText  
                    ,', REPLACE(@ReplaceSQL, N'{0}', N'b.RuleElseActionText' ), N' AS RuleElseActionText  
                    ,b.MemberType_ID  
                    ,b.Entity_ID  
                    ,id.NewEntity_ID  
                    ,CASE b.Status_ID  
                        WHEN ', @BRStatus_Active, N'           THEN ', @BRStatus_ActivationPending, N'  
                        WHEN ', @BRStatus_ChangesPending, N'   THEN ', @BRStatus_ActivationPending, N'  
                        WHEN ', @BRStatus_ExcludePending, N'   THEN ', @BRStatus_Excluded, N'  
                        ELSE b.Status_ID END AS Status_ID  
                    ,b.Priority  
                    ,b.NotificationGroupID  
                    ,b.NotificationUserID  
                    ,b.EnterDTM  
                    ,b.EnterUserID  
                    ,b.LastChgDTM  
                    ,b.LastChgUserID  
                FROM mdm.tblBRBusinessRule b  
                INNER JOIN #BusinessRule_IDs id  
                ON b.ID = id.BusinessRule_ID  
                WHERE id.Entity_ID = @Entity_ID  
            ) r  
            ON (1 = 0) -- An arbitrary condition that is always false, so that the NOT MATCHED block will always be hit.  
            WHEN NOT MATCHED THEN  
            INSERT  
            (  
                 Name  
                ,Description  
                ,RuleConditionText  
                ,RuleActionText  
                ,RuleElseActionText  
                ,MemberType_ID  
                ,Entity_ID  
                ,Status_ID  
                ,Priority  
                ,NotificationGroupID  
                ,NotificationUserID  
                ,EnterDTM  
                ,EnterUserID  
                ,LastChgDTM  
                ,LastChgUserID  
            )  
            VALUES  
            (  
                 r.Name  
                ,r.Description  
                ,r.RuleConditionText  
                ,r.RuleActionText  
                ,r.RuleElseActionText  
                ,', @MemberType_Leaf, N' -- The BR copy is always leaf  
                ,CASE r.MemberType_ID WHEN ', @MemberType_Consolidated, N' THEN r.NewEntity_ID ELSE r.Entity_ID END  
                ,r.Status_ID  
                ,r.Priority  
                ,r.NotificationGroupID  
                ,r.NotificationUserID  
                ,r.EnterDTM  
                ,r.EnterUserID  
                ,r.LastChgDTM  
                ,r.LastChgUserID  
            )  
            OUTPUT   
                 r.ID  
                ,inserted.ID  
                ,r.MemberType_ID  
                ,r.NewEntity_ID  
            --INTO @RuleMappings(OldRule_ID, NewRule_ID);  
            INTO #BRBusinessRuleRowMappings  
            (  
                 OldRow_ID  
                ,NewRow_ID  
                ,MemberType_ID  
                ,NewEntity_ID  
            );  
');  
            --PRINT @SQL;  
            EXEC sp_executesql @SQL, N'@Entity_ID INT', @Entity_ID;  
  
            -- Copy  mdm.tblBRLogicalOperatorGroup rows. No special processing needed here.  
PRINT CONCAT(SYSDATETIME(), N': Copying mdm.tblBRLogicalOperatorGroup rows.');  
            MERGE mdm.tblBRLogicalOperatorGroup  
            USING  
            (  
                SELECT  
                     brlog.ID  
                    ,brlog.LogicalOperator_ID  
                    ,br.NewRow_ID AS NewBusinessRule_ID  
                    ,brlog.Parent_ID   
                    ,brlog.Sequence  
                    ,br.MemberType_ID  
                FROM mdm.tblBRLogicalOperatorGroup brlog  
                INNER JOIN #BRBusinessRuleRowMappings br  
                ON brlog.BusinessRule_ID = br.OldRow_ID  
            ) lg  
            ON (1 = 0) -- An arbitrary condition that is always false, so that the NOT MATCHED block will always be hit.  
            WHEN NOT MATCHED THEN  
            INSERT  
            (  
                 LogicalOperator_ID  
                ,BusinessRule_ID  
                ,Parent_ID  
                ,Sequence  
            )  
            VALUES  
            (  
                 lg.LogicalOperator_ID  
                ,lg.NewBusinessRule_ID  
                ,lg.Parent_ID -- This is the old parent. It will need to be updated to reference the copy of the original parent.  
                ,lg.Sequence  
            )  
            OUTPUT lg.ID, inserted.ID, lg.MemberType_ID  
            INTO #BRLogicalOperatorRowMappings (OldRow_ID, NewRow_ID, MemberType_ID);  
  
  
PRINT CONCAT(SYSDATETIME(), N': Updating tblBRLogicalOperatorGroup.Parent_ID');  
            -- Update the Parent_ID column to point to the copied row.  
            UPDATE new  
            SET Parent_ID = newParent.NewRow_ID  
            FROM mdm.tblBRLogicalOperatorGroup new  
            INNER JOIN #BRLogicalOperatorRowMappings newChild  
            ON new.ID = newChild.NewRow_ID  
            INNER JOIN #BRLogicalOperatorRowMappings newParent  
            ON new.Parent_ID = newParent.OldRow_ID  
  
            -- Copy mdm.tblBRItem rows  
PRINT CONCAT(SYSDATETIME(), N': Copying mdm.tblBRItem rows');  
            SET @SQL = @TruncationGuard + N'  
            MERGE mdm.tblBRItem  
            USING  
            (  
                SELECT  
                     i.ID    
                    ,id.NewRow_ID AS NewBRLogicalOperatorGroup_ID  
                    ,i.BRItemAppliesTo_ID  
                    ,i.Sequence  
                    ,' + REPLACE(@ReplaceSQL, N'{0}', N'i.ItemText' ) + N' AS ItemText  
                    ,' + REPLACE(@ReplaceSQL, N'{0}', N'i.AnchorName' ) + N' AS AnchorName  
                    ,i.AnchorAttributeType  
                FROM mdm.tblBRItem i  
                INNER JOIN #BRLogicalOperatorRowMappings id  
                ON i.BRLogicalOperatorGroup_ID = id.OldRow_ID  
            ) i  
            ON (1 = 0) -- An arbitrary condition that is always false, so that the NOT MATCHED block will always be hit.  
            WHEN NOT MATCHED THEN  
            INSERT  
            (  
                 BRLogicalOperatorGroup_ID  
                ,BRItemAppliesTo_ID  
                ,Sequence  
                ,ItemText  
                ,AnchorName  
                ,AnchorAttributeType  
            )  
            VALUES  
            (  
                 i.NewBRLogicalOperatorGroup_ID  
                ,i.BRItemAppliesTo_ID  
                ,i.Sequence  
                ,i.ItemText  
                ,i.AnchorName   
                ,i.AnchorAttributeType  
            )  
            OUTPUT i.ID, inserted.ID  
            INTO #BRItemRowMappings(OldRow_ID, NewRow_ID);  
            ';  
            --PRINT @SQL;  
            EXEC sp_executesql @SQL;  
  
PRINT CONCAT(SYSDATETIME(), N': Copying mdm.tblBRItemProperties rows');  
            MERGE mdm.tblBRItemProperties  
            USING  
            (  
                SELECT  
                     bip.ID  
                    ,bi.NewRow_ID AS NewBRItem_ID  
                    ,CASE bip.PropertyType_ID WHEN @BRPropertyType_ParentAttribute THEN @BRPropertyType_DBA ELSE bip.PropertyType_ID END AS PropertyType_ID  
                    ,bip.PropertyName_ID  
                    ,COALESCE(CONVERT(NVARCHAR(999), eh.LeafParentDba_ID), CONVERT(NVARCHAR(999), ca.NewAttribute_ID), bip.Value) AS Value  
                    ,bip.Sequence  
                    ,bip.IsLeftHandSide  
                    ,bip.Parent_ID  
                    ,bip.SuppressText  
                FROM mdm.tblBRItemProperties bip  
                INNER JOIN #BRItemRowMappings bi  
                ON bip.BRItem_ID = bi.OldRow_ID  
  
                -- Match rows whose Value is an EH ID  
                LEFT JOIN #EH_ConversionLog eh --   
                ON      bip.PropertyType_ID = @BRPropertyType_ParentAttribute  
                    AND bip.Value = CONVERT(NVARCHAR(999), eh.ExplicitHierarchy_ID)  
  
                -- Match rows whose Value is a consolidated attribute ID.  
                LEFT JOIN #AttributeMapping ca   
                ON      ca.OldMemberType = @MemberType_Consolidated  
                    AND bip.PropertyType_ID = @BRPropertyType_Attribute  
                    AND bip.Value = CONVERT(NVARCHAR(999), ca.OldAttribute_ID)  
            ) p  
            ON (1 = 0) -- An arbitrary condition that is always false, so that the NOT MATCHED block will always be hit.  
            WHEN NOT MATCHED THEN  
            INSERT  
            (  
                 BRItem_ID  
                ,PropertyType_ID  
                ,PropertyName_ID  
                ,Value  
                ,Sequence  
                ,IsLeftHandSide  
                ,Parent_ID  
                ,SuppressText  
            )  
            VALUES  
            (  
                 p.NewBRItem_ID  
                ,p.PropertyType_ID  
                ,p.PropertyName_ID  
                ,p.Value  
                ,p.Sequence  
                ,p.IsLeftHandSide  
                ,p.Parent_ID -- This is the old parent. It will need to be updated to reference the copy of the original parent.  
                ,p.SuppressText  
            )  
            OUTPUT p.ID, inserted.ID, inserted.BRItem_ID  
            INTO #BRItemPropertiesRowMappings (OldRow_ID, NewRow_ID, NewBRItem_ID);  
  
            -- Update the Parent_ID column to point to the copied row.  
PRINT CONCAT(SYSDATETIME(), N': Updating the Parent_ID column to point to the copied row');  
            UPDATE new  
            SET Parent_ID = newParent.NewRow_ID  
            FROM mdm.tblBRItemProperties new  
            INNER JOIN #BRItemPropertiesRowMappings newChild  
            ON new.ID = newChild.NewRow_ID  
            INNER JOIN #BRItemPropertiesRowMappings newParent  
            ON      new.Parent_ID = newParent.OldRow_ID  
                AND new.BRItem_ID = newParent.NewBRItem_ID  
  
            IF @DeleteOriginals = 1  
            BEGIN  
PRINT CONCAT(SYSDATETIME(), N': Looking for old BR sprocs to delete');  
                SET @SQL = N'';  
                ;WITH brSprocsCte AS  
                (  
                    SELECT DISTINCT  
                        mdm.udfBusinessRuleAttributeMemberControllerNameGetByID(@Entity_ID, br.MemberType_ID) AS SprocName  
                    FROM #BRBusinessRuleRowMappings br  
                )  
                SELECT  
                    @SQL += CONCAT(N'DROP PROCEDURE mdm.', QUOTENAME(SprocName), N'  
')  
                FROM brSprocsCte br  
                INNER JOIN sys.procedures p  
                ON OBJECT_ID(br.SprocName) = p.object_id  
  
                IF LEN(@SQL) > 0  
                BEGIN   
PRINT CONCAT(SYSDATETIME(), N': Deleting entity''s old BR sprocs');  
                    PRINT @SQL;  
                    EXEC sp_executesql @SQL;  
                END  
  
PRINT CONCAT(SYSDATETIME(), N': Deleting entity''s old BRs from BR tables');  
                DELETE @RuleIDs  
                INSERT INTO @RuleIDs(ID)  
                SELECT DISTINCT OldRow_ID  
                FROM #BRBusinessRuleRowMappings;  
  
                EXEC mdm.udpBusinessRulesDelete @RuleIDs = @RuleIDs  
  
PRINT CONCAT(SYSDATETIME(), N': Updating status of entity''s remaining BRs');  
                UPDATE br  
                SET   
                    br.Status_ID = CASE br.Status_ID  
                        WHEN @BRStatus_Active           THEN @BRStatus_ActivationPending  
                        WHEN @BRStatus_ChangesPending   THEN @BRStatus_ActivationPending  
                        WHEN @BRStatus_ExcludePending   THEN @BRStatus_Excluded  
                        ELSE br.Status_ID END  
                FROM mdm.tblBRBusinessRule br  
                INNER JOIN #BRBusinessRuleRowMappings newbr  
                ON br.MemberType_ID = newbr.MemberType_ID  
                    AND br.Entity_ID = @Entity_ID  
            END  
        END; -- WHILE (loop through each entity's leaf business rules)  
  
  
  
  
  
        -- Loop through each entity with collections and copy the collections.  
        SET @Entity_ID = 0;  
        DECLARE @HasCustomCollectionMetadata BIT;  
        WHILE EXISTS (SELECT 1 FROM @EntityInfo WHERE Entity_ID > @Entity_ID AND EntityTableName_CN IS NOT NULL)  
        BEGIN  
            -- Get the next entity with collections in the list.  
            SELECT TOP 1  
                 @Entity_ID = Entity_ID  
                ,@EntityName = EntityName  
                ,@DataCompression = DataCompression  
                ,@TransactionLogType = TransactionLogType  
                ,@Model_ID = Model_ID  
                ,@EntityTableName_CN = EntityTableName_CN  
                ,@EntityTableName_CN_HS = CONCAT(EntityTableName_CN, N'_HS')  
                ,@EntityTableName_CN_AN = CONCAT(EntityTableName_CN, N'_AN')  
                ,@EntityTableName_CM = EntityTableName_CM  
                ,@EntityTableName_CM_HS = CONCAT(EntityTableName_CM, N'_HS')  
                ,@EntityTableName_CM_AN = CONCAT(EntityTableName_CM, N'_AN')  
                ,@EntityTableName_HP = EntityTableName_HP  
                ,@HasCustomCollectionMetadata = HasCustomCollectionMetadata  
            FROM @EntityInfo  
            WHERE   Entity_ID > @Entity_ID   
                AND EntityTableName_CN IS NOT NULL  
            ORDER BY Entity_ID;  
  
PRINT ''  
            IF @HasCustomCollectionMetadata = 0  
            BEGIN  
                -- There is no custom collection metadata. See if the collection table has members. If there is no user-defined metadata or master data, then we don't need to bother creating new entities, etc, for it.  
                DECLARE @HasCollections BIT;  
                SET @SQL = CONCAT(N'SET @HasCollections = CASE WHEN EXISTS(SELECT 1 FROM mdm.', QUOTENAME(@EntityTableName_CN), N') THEN 1 ELSE 0 END;' )  
                EXEC sp_executesql @SQL, N'@HasCollections BIT OUTPUT', @HasCollections OUTPUT  
                IF @HasCollections = 0   
                BEGIN  
PRINT CONCAT(SYSDATETIME(), N': Entity "', @EntityName, N'" has collection tables but contains no collection metadata or members to convert. Skipping...');  
                    CONTINUE;  
                END  
            END  
  
PRINT CONCAT(SYSDATETIME(), N': Create new entity for entity "', @EntityName, N'"''s collection members.');  
            SET @counter = 0;  
            WHILE (1=1) -- TSQL doesn't support a DO-WHILE loop, so use a tautology as this WHILE condition to simulate a post-test loop.  
            BEGIN  
                SET @suffix = '_Col';  
                SET @NewEntityName = CONCAT(SUBSTRING(@EntityName, 0, @MaxMetadataObjectNameLength - LEN(@suffix) - 4), @suffix, CASE @counter WHEN 0 THEN N'' ELSE CONVERT(NVARCHAR, @counter) END);  
  
                -- If the new attribute name is unique within the entity-member type, then exit the loop.  
                IF NOT EXISTS (SELECT 1 FROM mdm.tblEntity WHERE Model_ID = @Model_ID AND Name = @NewEntityName)  
                BEGIN  
                    BREAK;  
                END;  
  
                -- The name wasn't unique, so increment the counter for the next loop iteration.  
                SET @counter += 1;  
            END; -- WHILE (get unique attribute name)  
  
            SET @NewEntityDescription = CONCAT(N'Contains collection members, converted to leaf members, copied from the "', @EntityName, N'" entity.');  
              
            SET @NewEntity_ID = 0;  
            EXEC mdm.udpEntitySave   
                 @User_ID = @User_ID  
                ,@Model_ID = @Model_ID  
                ,@EntityName = @NewEntityName  
                ,@DataCompression = @DataCompression  
                ,@TransactionLogType = @TransactionLogType  
                ,@RequireApproval = 0 -- Consolidated and Collection members don't support the Approval Flow feature, so the new entity created doesn't either. Users may manually change this later, if desired.  
                ,@Description = @NewEntityDescription  
                ,@RecreateStagingProc = 0 -- for efficiency, staging sprocs will be recreated only after all attributes have been created (rather than once for each attribute)  
                ,@Return_ID = @NewEntity_ID OUTPUT  
  
PRINT CONCAT(SYSDATETIME(), N': Created new entity "', @NewEntityName, N'" (ID = ', @NewEntity_ID, N') that is a copy of entity "', @EntityName, N'" (ID = ', @Entity_ID, N').''s collection members.');  
              
            UPDATE @EntityInfo  
            SET New_CN_Entity_ID = @NewEntity_ID  
            WHERE Entity_ID = @Entity_ID  
  
            -- Get the name of the new entity's EN table.  
            DECLARE   
                 @NewEntityTableName_CN     SYSNAME  
                ,@NewEntityTableName_CN_HS  SYSNAME  
                ,@NewEntityTableName_CN_AN  SYSNAME  
            SELECT   
                 @NewEntityTableName_CN = EntityTable  
                ,@NewEntityTableName_CN_HS  = CONCAT(EntityTable, N'_HS')  
                ,@NewEntityTableName_CN_AN  = CONCAT(EntityTable, N'_AN')  
                ,@NewEntityStagingLeafName = StagingLeafName  
            FROM mdm.tblEntity  
            WHERE ID = @NewEntity_ID;  
  
            -- Add the collection system attributes (CN table only, not CM table) to the mapping table (needed for converting transactions, object security, and BRs)  
            INSERT INTO #AttributeMapping  
            (  
                 OldAttribute_ID  
                ,OldMemberType  
                ,OldEntity_ID  
                ,NewAttribute_ID  
                ,NewEntity_ID  
            )  
            SELECT  
                 oldA.ID  
                ,oldA.MemberType_ID  
                ,oldA.Entity_ID  
                ,newA.ID  
                ,newA.Entity_ID  
            FROM mdm.tblAttribute oldA  
            INNER JOIN mdm.tblAttribute newA  
            ON oldA.Name = newA.Name  
            WHERE   oldA.Entity_ID = @Entity_ID  
                AND oldA.MemberType_ID = @MemberType_Collection  
                AND oldA.IsSystem = 1  
                AND oldA.Name NOT IN (N'Owner_ID', N'Description') -- These collection system attributes will be added later  
                AND newA.Entity_ID = @NewEntity_ID  
                AND newA.IsSystem = 1  
  
            -- Get a list of all non-system collection attributes in the entity.  
            DELETE FROM @AttributeInfo;  
            INSERT INTO @AttributeInfo  
            SELECT  
                 ID  
                ,DisplayName  
                ,Name  
                ,Description  
                ,TableColumn  
                ,AttributeType_ID  
                ,DataType_ID  
                ,DataTypeInformation  
                ,InputMask_ID  
                ,DisplayWidth  
                ,SortOrder  
                ,DomainEntity_ID  
                ,ChangeTrackingGroup  
            FROM mdm.tblAttribute   
            WHERE   Entity_ID = @Entity_ID  
                AND MemberType_ID = @MemberType_Collection  
                AND (IsSystem = 0 OR Name IN (N'Owner_ID', N'Description'))  
            SET @Attribute_ID = 0;  
  
            -- Loop through each collection attribute, copying it to the new entity as a leaf attribute.  
            SET @NewAttributeColumnNames = N'';  
            SET @OldAttributeColumnNames = N'';  
            WHILE EXISTS (SELECT 1 FROM @AttributeInfo WHERE Attribute_ID > @Attribute_ID)  
            BEGIN  
                -- Get the next attribute's info.  
                SELECT TOP 1   
                     @Attribute_ID = Attribute_ID  
                    ,@DisplayName = DisplayName  
                    ,@Name = Name  
                    ,@Description = Description  
                    ,@OldAttributeColumnNames += @TruncationGuard + N'  
                ,' + CASE Name WHEN 'Owner_ID'   
                        THEN 'u.UserName' -- User the owner's user name, rather than its INT id (cn.Owner_ID)  
                        ELSE 'cn.' + ColumnName END  
                    ,@AttributeType_ID = AttributeType_ID  
                    ,@DataType_ID = DataType_ID  
                    ,@DataTypeInformation = DataTypeInformation  
                    ,@InputMask_ID = InputMask_ID  
                    ,@DisplayWidth = DisplayWidth  
                    ,@SortOrder = SortOrder  
                    ,@DomainEntity_ID = DomainEntity_ID  
                    ,@ChangeTrackingGroup = ChangeTrackingGroup  
                FROM @AttributeInfo   
                WHERE Attribute_ID > @Attribute_ID  
                ORDER BY Attribute_ID  
  
                -- Add an attribute to the new entity that is a leaf copy of the collection attribute.  
                SET @NewAttribute_ID = NULL;  
                EXEC mdm.udpAttributeSave  
                     @User_ID = @User_ID  
                    ,@Model_ID = @Model_ID  
                    ,@Entity_ID = @NewEntity_ID  
                    ,@IsHierarchyEnabled = 0  
                    ,@IsCollectionEnabled = 0  
                    ,@DataCompression = @DataCompression  
                    ,@TableName = @NewEntityTableName_CN  
                    ,@StagingTableName = @NewEntityStagingLeafName  
                    ,@MemberType_ID = @MemberType_Leaf  
                    ,@AttributeType_ID = @AttributeType_ID  
                    ,@AttributeName = @Name  
                    ,@Description = @Description  
                    ,@DisplayName = @DisplayName  
                    ,@DisplayWidth = @DisplayWidth  
                    ,@DomainEntity_ID = @DomainEntity_ID  
                    ,@DataType_ID = @DataType_ID  
                    ,@DataTypeInformation = @DataTypeInformation  
                    ,@InputMask_ID = @InputMask_ID  
                    ,@ChangeTrackingGroup = @ChangeTrackingGroup  
                    ,@SortOrder = @SortOrder  
                    ,@RecreateStagingProc = 0 -- for efficiency, staging sprocs will be recreated only after all attributes have been created (rather than once for each attribute)  
                    ,@Return_ID = @NewAttribute_ID OUTPUT;    
  
                SELECT @NewAttributeColumnNames += @TruncationGuard + N'  
                ,' + TableColumn  
                FROM mdm.tblAttribute WHERE ID = @NewAttribute_ID;  
  
PRINT CONCAT(SYSDATETIME(), N': Copied attribute "', @Name, N'" (ID = ', @Attribute_ID, N') to new entity. New attribute ID = ', @NewAttribute_ID);  
                -- Keep track of the mapping between the old and new attributes.  
                INSERT INTO #AttributeMapping  
                (  
                     OldAttribute_ID  
                    ,OldMemberType  
                    ,OldEntity_ID  
                    ,NewAttribute_ID  
                    ,NewEntity_ID  
                )  
                SELECT  
                     @Attribute_ID  
                    ,@MemberType_Collection  
                    ,@Entity_ID  
                    ,@NewAttribute_ID  
                    ,@NewEntity_ID  
            END -- WHILE (loop through entity's collection attributes)  
  
PRINT CONCAT(SYSDATETIME(), N': Copy the member master data, from collection members in the old entity to leaf members in the new entity.');  
            SET @SQL = @TruncationGuard + N'  
            SET IDENTITY_INSERT mdm.' + QUOTENAME(@NewEntityTableName_CN) + N' ON; -- This allows the query to specify the ID column, which will be set to match the ID in the old CN table, so that the parent-child values can be directly copied from the CM table to the new collection membership mapping entity  
  
            INSERT INTO mdm.' + QUOTENAME(@NewEntityTableName_CN) + N'  
            (  
                -- System attributes  
                 Version_ID  
                ,ID  
                ,Status_ID  
                ,ValidationStatus_ID  
                ,Name  
                ,Code  
                ,EnterDTM  
                ,EnterUserID  
                ,EnterVersionID  
                ,LastChgDTM  
                ,LastChgUserID  
                ,LastChgVersionID  
                ,AsOf_ID'   
                + CASE @DeleteOriginals WHEN 1 THEN N'  
                ,MUID' ELSE N'' END -- Use the original MUID when the original will be deleted  
                + N'  
  
                -- User-defined attributes  
                ' + @NewAttributeColumnNames + N'  
            )  
            SELECT  
                -- System attributes  
                 cn.Version_ID  
                ,cn.ID  
                ,cn.Status_ID  
                ,cn.ValidationStatus_ID  
                ,cn.Name  
                ,cn.Code  
                ,cn.EnterDTM  
                ,cn.EnterUserID  
                ,cn.EnterVersionID  
                ,cn.LastChgDTM  
                ,cn.LastChgUserID  
                ,cn.LastChgVersionID   
                ,cn.AsOf_ID'  
                + CASE @DeleteOriginals WHEN 1 THEN N'  
                ,cn.MUID' ELSE N'' END -- Use the original MUID when the original will be deleted  
                + N'  
  
                -- User-defined attributes  
                ' + @OldAttributeColumnNames + N'  
            FROM mdm.' + QUOTENAME(@EntityTableName_CN) + N' cn  
            LEFT JOIN mdm.tblUser u -- used to get the user name for the Owner_ID attribute  
            ON cn.Owner_ID = u.ID  
  
            SET IDENTITY_INSERT mdm.' + QUOTENAME(@NewEntityTableName_CN) + N' OFF;   
            ';  
            --PRINT @SQL  
            EXEC sp_executesql @SQL;  
  
            IF @TransactionLogType = @TransactionLogType_Member  
            BEGIN  
PRINT CONCAT(SYSDATETIME(), N': Copying collection history from ', @EntityTableName_CN_HS, N' to ', @NewEntityTableName_CN_HS);  
  
                SET @SQL = CONCAT(@TruncationGuard, N'  
                INSERT INTO mdm.', QUOTENAME(@NewEntityTableName_CN_HS), N'  
                (  
                     Version_ID  
                    ,ID  
                    ,EN_ID  
                    ,Status_ID  
                    ,Name  
                    ,Code  
                    ,EnterDTM  
                    ,EnterUserID  
                    ,LastChgDTM  
                    ,LastChgUserID  
                    ,MUID  
                    -- User-defined attributes  
                    ',@NewAttributeColumnNames, N'  
                )  
                SELECT  
                     cn.Version_ID  
                    ,cn.ID  
                    ,cn.CN_ID  
                    ,cn.Status_ID  
                    ,cn.Name  
                    ,cn.Code  
                    ,cn.EnterDTM  
                    ,cn.EnterUserID  
                    ,cn.LastChgDTM  
                    ,cn.LastChgUserID  
                    ,COALESCE(newEn.MUID, cn.MUID) -- actual member MUID. Same when deleting originals, different when copying.  
                    -- User-defined attributes  
                    ', @OldAttributeColumnNames, N'  
                FROM mdm.', QUOTENAME(@EntityTableName_CN_HS), N' cn  
                LEFT JOIN mdm.', QUOTENAME(@NewEntityTableName_CN), N' newEn  
                ON      cn.Version_ID = newEn.Version_ID  
                    AND cn.CN_ID = newEn.ID  
                LEFT JOIN mdm.tblUser u -- used to get the user name for the Owner_ID attribute  
                ON cn.Owner_ID = u.ID  
                ')  
  
                --PRINT @SQL  
                EXEC sp_executesql @SQL;  
  
PRINT CONCAT(SYSDATETIME(), N': Copying collection annotations from table ', @EntityTableName_CN_AN, N' to ', @NewEntityTableName_CN_AN);  
                SET @SQL = CONCAT(N'  
                INSERT INTO mdm.', QUOTENAME(@NewEntityTableName_CN_AN), N'  
                (  
                        Version_ID  
                    ,Revision_ID  
                    ,Comment  
                    ,EnterDTM  
                    ,EnterUserID  
                    ,LastChgDTM  
                    ,LastChgUserID  
                )  
                -- collection current revision, need to map old to new revision (LastChgTS)  
                SELECT   
                     cnAn.Version_ID  
                    ,newEn.LastChgTS AS Revision_ID-- map to the current timestamp in the new leaf entity  
                    ,cnAn.Comment  
                    ,cnAn.EnterDTM  
                    ,cnAn.EnterUserID  
                    ,cnAn.LastChgDTM  
                    ,cnAn.LastChgUserID  
                FROM mdm.', QUOTENAME(@EntityTableName_CN_AN), N' cnAn  
                INNER JOIN mdm.', QUOTENAME(@EntityTableName_CN), N' cn  
                ON      cnAn.Version_ID = cn.Version_ID  
                    AND cnAn.Revision_ID = cn.LastChgTS  
                INNER JOIN mdm.', QUOTENAME(@NewEntityTableName_CN), N' newEn  
                ON      cn.Version_ID = newEn.Version_ID  
                    AND cn.ID = newEn.ID  
                LEFT JOIN mdm.', QUOTENAME(@EntityTableName_CN_HS), N' cnHs  
                ON      cnAn.Version_ID = cnHs.Version_ID  
                    AND cnAn.Revision_ID = cnHs.ID  
                WHERE cnHs.ID IS NULL -- do not include revisions that are already in the new EN_HS table. They will be covered by the below query  
  
                UNION ALL -- deduplication not needed  
  
                -- collection history  
                SELECT   
                     cnAn.Version_ID  
                    ,cnAn.Revision_ID  
                    ,cnAn.Comment  
                    ,cnAn.EnterDTM  
                    ,cnAn.EnterUserID  
                    ,cnAn.LastChgDTM  
                    ,cnAn.LastChgUserID  
                FROM mdm.', QUOTENAME(@EntityTableName_CN_AN), N' cnAn  
                INNER JOIN mdm.', QUOTENAME(@EntityTableName_CN_HS), N' cnHs  
                ON      cnAn.Version_ID = cnHs.Version_ID  
                    AND cnAn.Revision_ID = cnHs.ID  
                    ');  
                --PRINT @SQL  
                EXEC sp_executesql @SQL;  
  
            END -- copy CN member history and annotations  
  
  
  
  
  
PRINT CONCAT(SYSDATETIME(), N': Create new entity for collection membership info');  
            DECLARE @NewEntity_ID_CN INT = @NewEntity_ID; -- save the ID of the new CN-table-equivalent entity  
            DECLARE @NewEntityName_CN NVARCHAR(50) = @NewEntityName; -- save the name of the new CN-table-equivalent entity  
            SET @counter = 0;  
            WHILE (1=1) -- TSQL doesn't support a DO-WHILE loop, so use a tautology as this WHILE condition to simulate a post-test loop.  
            BEGIN  
                SET @suffix = '_ColMem';  
                SET @NewEntityName = CONCAT(SUBSTRING(@EntityName, 0, @MaxMetadataObjectNameLength - LEN(@suffix) - 4), @suffix, CASE @counter WHEN 0 THEN N'' ELSE CONVERT(NVARCHAR, @counter) END);  
  
                -- If the new attribute name is unique within the entity-member type, then exit the loop.  
                IF NOT EXISTS (SELECT 1 FROM mdm.tblEntity WHERE Model_ID = @Model_ID AND Name = @NewEntityName)  
                BEGIN  
                    BREAK;  
                END;  
  
                -- The name wasn't unique, so increment the counter for the next loop iteration.  
                SET @counter += 1;  
            END; -- WHILE (get unique entity name)  
  
            SET @NewEntityDescription = CONCAT(N'Contains collection membership info, copied from the "', @EntityName, N'" entity.');  
              
            SET @NewEntity_ID = 0;  
            EXEC mdm.udpEntitySave   
                 @User_ID = @User_ID  
                ,@Model_ID = @Model_ID  
                ,@EntityName = @NewEntityName  
                ,@DataCompression = @DataCompression  
                ,@TransactionLogType = @TransactionLogType  
                ,@RequireApproval = 0 -- Consolidated and Collection members don't support the Approval Flow feature, so the new entity created doesn't either. Users may manually change this later, if desired.  
                ,@Description = @NewEntityDescription  
                ,@RecreateStagingProc = 0 -- for efficiency, staging sprocs will be recreated only after all attributes have been created (rather than once for each attribute)  
                ,@Return_ID = @NewEntity_ID OUTPUT  
  
PRINT CONCAT(SYSDATETIME(), N': Created new entity "', @NewEntityName, N'" (ID = ', @NewEntity_ID, N') that is a copy of entity "', @EntityName, N'" (ID = ', @Entity_ID, N').''s collection membership info.');  
            UPDATE @EntityInfo  
            SET New_CM_Entity_ID = @NewEntity_ID  
            WHERE Entity_ID = @Entity_ID  
  
            -- Get the name of the new entity's EN table.  
            DECLARE   
                 @NewEntityTableName_CM     SYSNAME  
                ,@NewEntityTableName_CM_HS  SYSNAME  
                ,@NewEntityTableName_CM_AN  SYSNAME  
            SELECT   
                 @NewEntityTableName_CM = EntityTable  
                ,@NewEntityTableName_CM_HS  = CONCAT(EntityTable, N'_HS')  
                ,@NewEntityTableName_CM_AN  = CONCAT(EntityTable, N'_AN')  
                ,@NewEntityStagingLeafName = StagingLeafName  
            FROM mdm.tblEntity  
            WHERE ID = @NewEntity_ID;  
  
  
PRINT CONCAT(SYSDATETIME(), N': Creating collection membership entity attributes.');  
            DELETE FROM @CollectionMembershipAttributes  
            DECLARE   
                 @CollectionHasChildren     BIT  
                ,@RowID                     INT  
                ,@ChildAttributeNamePrefix  NVARCHAR(50) = N'Child_'  
  
  
            IF @EntityTableName_HP IS NOT NULL -- Check for consolidated children, if the entity being copied support consolidated members   
            BEGIN  
                -- See if the CM table references any HP members  
                SET @SQL = CONCAT(N'SET @CollectionHasConsolidatedChildren = CASE WHEN EXISTS (SELECT 1 FROM mdm.', QUOTENAME(@EntityTableName_CM), N' WHERE Child_HP_ID IS NOT NULL AND Status_ID = 1/*Active*/) THEN 1 ELSE 0 END')  
                --PRINT @SQL  
                EXEC sp_executesql @SQL, N'@CollectionHasConsolidatedChildren BIT OUTPUT', @CollectionHasChildren OUTPUT;  
                IF @CollectionHasChildren = 1  
                BEGIN  
                    -- Check each converted EH's entity tables, to see if its members are referenced by the CM table  
  
                    INSERT INTO @CollectionMembershipAttributes -- consolidated children DBAs  
                    (  
                         Name  
                        ,DomainEntity_ID  
                        ,DomainEntityName  
                        ,DomainEntityTableName  
                    )  
                    SELECT  
                         CONCAT(@ChildAttributeNamePrefix, e.Name)  
                        ,e.ID  
                        ,e.Name  
                        ,e.EntityTable  
                    FROM #EH_ConversionLog eh  
                    INNER JOIN mdm.tblEntity e  
                    ON eh.NewEntity_ID = e.ID  
                    WHERE eh.Entity_ID = @Entity_ID;  
  
                    -- Prune out rows for new consolidated entities that are not referenced by the CM table  
                    SET @RowID = 0  
                    WHILE EXISTS (SELECT 1 FROM @CollectionMembershipAttributes WHERE RowID > @RowID)  
                    BEGIN   
                        SELECT TOP 1   
                              @RowID = RowID  
                             ,@SQL = CONCAT(N'SET @CollectionHasConsolidatedChildren = CASE WHEN EXISTS   
                                                    (SELECT 1   
                                                    FROM mdm.', QUOTENAME(@EntityTableName_CM), N' cm  
                                                    INNER JOIN mdm.', QUOTENAME(DomainEntityTableName), N' en  
                                                    ON cm.Child_HP_ID = en.ID  
                                                    WHERE cm.Status_ID = 1/*Active*/)   
                                                THEN 1 ELSE 0 END')  
                        FROM @CollectionMembershipAttributes  
                        WHERE RowID > @RowID  
                        ORDER BY RowID  
  
                        --PRINT @SQL  
                        EXEC sp_executesql @SQL, N'@CollectionHasConsolidatedChildren BIT OUTPUT', @CollectionHasChildren OUTPUT;  
                        IF @CollectionHasChildren = 0  
                        BEGIN  
                            -- The old EH doesn't have any consolidated members referenced by the CM table. So we don't need to add to the new CM entity a DBA that references the new consolidated entity.  
                            DELETE @CollectionMembershipAttributes WHERE RowID = @RowID;  
                        END  
  
                    END -- while  
  
                END  
            END -- if the copied entity supports consolidated members  
  
            DECLARE   
                 @ManyToManyParentAttribute_ID  INT  
                ,@ManyToManyParentAttributeName NVARCHAR(100) = CONCAT(N'Parent_', @NewEntityName_CN)  
            INSERT INTO @CollectionMembershipAttributes  
            (  
                 Name  
                ,DomainEntity_ID  
                ,DomainEntityName  
                ,OldColumnName  
            )  
            SELECT   
                  @ManyToManyParentAttributeName  
                 ,@NewEntity_ID_CN  
                 ,@NewEntityName_CN  
                 ,N'Parent_CN_ID' -- parent DBA  
  
            -- Don't add a DBA for leaf children unless the CM table actually references some  
            --PRINT @SQL  
            SET @SQL = CONCAT(N'SET @CollectionHasLeafChildren = CASE WHEN EXISTS (SELECT 1 FROM mdm.', QUOTENAME(@EntityTableName_CM), N' WHERE Child_EN_ID IS NOT NULL AND Status_ID = 1/*Active*/) THEN 1 ELSE 0 END')  
            --PRINT @SQL  
            EXEC sp_executesql @SQL, N'@CollectionHasLeafChildren BIT OUTPUT', @CollectionHasChildren OUTPUT;  
            IF @CollectionHasChildren = 1  
            BEGIN   
                INSERT INTO @CollectionMembershipAttributes  
                (  
                     Name  
                    ,DomainEntity_ID  
                    ,DomainEntityName  
                    ,OldColumnName  
                )  
                SELECT   
                     CONCAT(@ChildAttributeNamePrefix, @EntityName)  
                    ,@Entity_ID  
                    ,@EntityName  
                    ,N'Child_EN_ID' -- leaf children DBA  
            END  
  
            -- Don't add a DBA for collection children unless the CM table actually references some  
            SET @SQL = CONCAT(N'SET @CollectionHasCollectionChildren = CASE WHEN EXISTS (SELECT 1 FROM mdm.', QUOTENAME(@EntityTableName_CM), N' WHERE Child_CN_ID IS NOT NULL AND Status_ID = 1/*Active*/) THEN 1 ELSE 0 END')  
              
            --PRINT @SQL  
            EXEC sp_executesql @SQL, N'@CollectionHasCollectionChildren BIT OUTPUT', @CollectionHasChildren OUTPUT;  
            IF @CollectionHasChildren = 1  
            BEGIN   
                INSERT INTO @CollectionMembershipAttributes  
                (  
                     Name  
                    ,DomainEntity_ID  
                    ,DomainEntityName  
                    ,OldColumnName  
                )  
                SELECT   
                     CONCAT(@ChildAttributeNamePrefix, @NewEntityName_CN)  
                    ,@NewEntity_ID_CN  
                    ,@NewEntityName_CN  
                    ,N'Child_CN_ID' -- collection children DBA  
            END  
  
            INSERT INTO @CollectionMembershipAttributes  
            (  
                  Name  
                 ,DataTypeInformation  
            )  
            VALUES   
                 (N'Weight', 3)  
                ,(N'SortOrder', 0)   
  
            DECLARE   
                 @JoinSQL               NVARCHAR(MAX) = N''  
            SET @NewAttributeColumnNames = N'';  
            SET @OldAttributeColumnNames = N'';  
            SET @RowID = 0  
            WHILE EXISTS (SELECT 1 FROM @CollectionMembershipAttributes WHERE RowID > @RowID)  
            BEGIN   
                -- Get the next attribute's info.  
                SELECT TOP 1   
                     @RowID = RowID  
                    ,@Name = Name  
                    ,@AttributeType_ID = CASE WHEN DomainEntity_ID IS NULL THEN @AttributeType_Freeform ELSE @AttributeType_Domain END  
                    ,@DataType_ID = CASE WHEN DomainEntity_ID IS NULL THEN @DataType_Number ELSE @DataType_Text END  
                    ,@DataTypeInformation = COALESCE(DataTypeInformation, 100)  
                    ,@DomainEntity_ID = DomainEntity_ID  
  
                    ,@OldAttributeColumnNames += CONCAT(@TruncationGuard, N'  
                ,cm', CASE   
                        WHEN OldColumnName IS NOT NULL THEN CONCAT(N'.', QUOTENAME(OldColumnName))  
                        WHEN DomainEntity_ID IS NOT NULL THEN CONCAT(DomainEntity_ID, N'.ID ', QUOTENAME(Name))  
                        ELSE CONCAT(N'.', QUOTENAME(Name)) END)  
  
                    ,@JoinSQL += CONCAT(@TruncationGuard, CASE WHEN DomainEntityTableName IS NOT NULL THEN CONCAT(N'  
            LEFT JOIN mdm.', QUOTENAME(DomainEntityTableName), N' cm', DomainEntity_ID, N'  
            ON cm.Child_HP_ID = cm', DomainEntity_ID, N'.ID  
                AND cm.Version_ID = cm', DomainEntity_ID, N'.Version_ID')  
                        END)  
                FROM @CollectionMembershipAttributes   
                WHERE RowID > @RowID  
                ORDER BY RowID  
  
PRINT CONCAT(SYSDATETIME(), N': Creating attribute "', @Name, N'", DomainEntityID = ', @DomainEntity_ID, N') in collection membership entity "', @NewEntityName, N'" (ID = ', @NewEntity_ID, N').');  
                SET @NewAttribute_ID = NULL;  
                EXEC mdm.udpAttributeSave  
                     @User_ID = @User_ID  
                    ,@Model_ID = @Model_ID  
                    ,@Entity_ID = @NewEntity_ID  
                    ,@IsHierarchyEnabled = 0  
                    ,@IsCollectionEnabled = 0  
                    ,@DataCompression = @DataCompression  
                    ,@TableName = @NewEntityTableName_CM  
                    ,@StagingTableName = @NewEntityStagingLeafName  
                    ,@MemberType_ID = @MemberType_Leaf  
                    ,@AttributeType_ID = @AttributeType_ID  
                    ,@AttributeName = @Name  
                    ,@Description = NULL  
                    ,@DisplayName = @Name  
                    ,@DisplayWidth = 100  
                    ,@DomainEntity_ID = @DomainEntity_ID  
                    ,@DataType_ID = @DataType_ID  
                    ,@DataTypeInformation = @DataTypeInformation  
                    ,@InputMask_ID = 1  
                    ,@ChangeTrackingGroup = 0  
                    ,@SortOrder = NULL  
                    ,@RecreateStagingProc = 0 -- for efficiency, staging sprocs will be recreated only after all attributes have been created (rather than once for each attribute)  
                    ,@Return_ID = @NewAttribute_ID OUTPUT;    
PRINT CONCAT(SYSDATETIME(), N': Created attribute "', @Name, N'" (ID = ', @NewAttribute_ID, N').');  
                  
                UPDATE @CollectionMembershipAttributes  
                SET  
                     NewAttribute_ID = @NewAttribute_ID  
                    ,NewColumnName = (SELECT TableColumn FROM mdm.tblAttribute WHERE ID = @NewAttribute_ID)  
                WHERE RowID = @RowID  
  
                IF @Name = @ManyToManyParentAttributeName  
                BEGIN  
                    SET @ManyToManyParentAttribute_ID = @NewAttribute_ID;  
                END  
            END -- WHILE (create collection membership DBAs)  
  
            SELECT @NewAttributeColumnNames += CONCAT(@TruncationGuard, N'  
                ,', NewColumnName)  
            FROM @CollectionMembershipAttributes  
            ORDER BY RowID  
  
            -- Create new members for CM table rows  
  
PRINT CONCAT(SYSDATETIME(), N': Adding collection membership info members to entity "', @NewEntityName, N'" (ID = ', @NewEntity_ID, N').');  
            SET @SQL = CONCAT(@TruncationGuard, N'  
            --SELECT * FROM mdm.', QUOTENAME(@EntityTableName_CM), N'  
  
            SET IDENTITY_INSERT mdm.', QUOTENAME(@NewEntityTableName_CM), N' ON; -- This allows the query to specify the ID column, which will be set to match the ID in the old CM table  
              
            INSERT INTO mdm.', QUOTENAME(@NewEntityTableName_CM), N'  
            (  
                 Version_ID  
                ,ID  
                ,Status_ID  
                ,Code  
  
                ,EnterDTM  
                ,EnterUserID  
                ,EnterVersionID  
                ,LastChgDTM  
                ,LastChgUserID  
                ,LastChgVersionID  
                ,AsOf_ID'   
                ,CASE @DeleteOriginals WHEN 1 THEN N'  
                ,MUID' END -- Use the original MUID when the original will be deleted  
                ,@NewAttributeColumnNames, N'  
  
            )  
            SELECT  
                 cm.Version_ID  
                ,cm.ID  
                ,cm.Status_ID  
                ,CONVERT(NVARCHAR(250), cm.ID) -- Code  
  
                ,cm.EnterDTM  
                ,cm.EnterUserID  
                ,cm.EnterVersionID  
                ,cm.LastChgDTM  
                ,cm.LastChgUserID  
                ,cm.LastChgVersionID  
                ,cm.AsOf_ID'   
                ,CASE @DeleteOriginals WHEN 1 THEN N'  
                ,cm.MUID' END -- Use the original MUID when the original will be deleted  
                ,@OldAttributeColumnNames, N'  
  
  
            FROM mdm.', QUOTENAME(@EntityTableName_CM), N' cm  
            ', @JoinSQL, N'  
  
            SET IDENTITY_INSERT mdm.', QUOTENAME(@NewEntityTableName_CM), N' OFF;   
  
            --SELECT * FROM mdm.', QUOTENAME(@NewEntityTableName_CM), N'  
            ');  
            --PRINT @SQL  
            EXEC sp_executesql @SQL;  
  
            IF @TransactionLogType = @TransactionLogType_Member  
            BEGIN  
PRINT CONCAT(SYSDATETIME(), N': Copying collection membership history from ', @EntityTableName_CM_HS, N' to ', @NewEntityTableName_CM_HS);  
  
                SET @SQL = CONCAT(@TruncationGuard, N'  
                INSERT INTO mdm.', QUOTENAME(@NewEntityTableName_CM_HS), N'  
                (  
                     Version_ID  
                    ,ID  
                    ,EN_ID  
                    ,Status_ID  
                    ,Code  
                    ,EnterDTM  
                    ,EnterUserID  
                    ,LastChgDTM  
                    ,LastChgUserID  
                    ,MUID  
                    ',@NewAttributeColumnNames, N'  
                )  
                SELECT  
                     cm.Version_ID  
                    ,cm.ID  
                    ,cm.CM_ID  
                    ,cm.Status_ID  
                    ,CONVERT(NVARCHAR(250), cm.CM_ID) -- Code  
                    ,cm.EnterDTM  
                    ,cm.EnterUserID  
                    ,cm.LastChgDTM  
                    ,cm.LastChgUserID  
                    ,COALESCE(newEn.MUID, cm.MUID) -- actual member MUID. Same when deleting originals, different when copying.  
                    ', @OldAttributeColumnNames, N'  
                FROM mdm.', QUOTENAME(@EntityTableName_CM_HS), N' cm  
                ', @JoinSQL, N'  
                LEFT JOIN mdm.', QUOTENAME(@NewEntityTableName_CM), N' newEn  
                ON      cm.Version_ID = newEn.Version_ID  
                    AND cm.CM_ID = newEn.ID  
                ')  
  
                --PRINT @SQL  
                EXEC sp_executesql @SQL;  
  
PRINT CONCAT(SYSDATETIME(), N': Copying collection membership annotations from table ', @EntityTableName_CM_AN, N' to ', @NewEntityTableName_CM_AN);  
                SET @SQL = CONCAT(N'  
                INSERT INTO mdm.', QUOTENAME(@NewEntityTableName_CM_AN), N'  
                (  
                     Version_ID  
                    ,Revision_ID  
                    ,Comment  
                    ,EnterDTM  
                    ,EnterUserID  
                    ,LastChgDTM  
                    ,LastChgUserID  
                )  
                -- collection current revision, need to map old to new revision (LastChgTS)  
                SELECT   
                     cmAn.Version_ID  
                    ,newEn.LastChgTS AS Revision_ID-- map to the current timestamp in the new leaf entity  
                    ,cmAn.Comment  
                    ,cmAn.EnterDTM  
                    ,cmAn.EnterUserID  
                    ,cmAn.LastChgDTM  
                    ,cmAn.LastChgUserID  
                FROM mdm.', QUOTENAME(@EntityTableName_CM_AN), N' cmAn  
                INNER JOIN mdm.', QUOTENAME(@EntityTableName_CM), N' cm  
                ON      cmAn.Version_ID = cm.Version_ID  
                    AND cmAn.Revision_ID = cm.LastChgTS  
                INNER JOIN mdm.', QUOTENAME(@NewEntityTableName_CM), N' newEn  
                ON      cm.Version_ID = newEn.Version_ID  
                    AND cm.ID = newEn.ID  
                LEFT JOIN mdm.', QUOTENAME(@EntityTableName_CM_HS), N' cmHs  
                ON      cmAn.Version_ID = cmHs.Version_ID  
                    AND cmAn.Revision_ID = cmHs.ID  
                WHERE cmHs.ID IS NULL -- do not include revisions that are already in the new EN_HS table. They will be covered by the below query  
  
                UNION ALL -- deduplication not needed  
  
                -- collection history  
                SELECT   
                     cmAn.Version_ID  
                    ,cmAn.Revision_ID  
                    ,cmAn.Comment  
                    ,cmAn.EnterDTM  
                    ,cmAn.EnterUserID  
                    ,cmAn.LastChgDTM  
                    ,cmAn.LastChgUserID  
                FROM mdm.', QUOTENAME(@EntityTableName_CM_AN), N' cmAn  
                INNER JOIN mdm.', QUOTENAME(@EntityTableName_CN_HS), N' cmHs  
                ON      cmAn.Version_ID = cmHs.Version_ID  
                    AND cmAn.Revision_ID = cmHs.ID  
                    ');  
                --PRINT @SQL  
                EXEC sp_executesql @SQL;  
  
            END -- copy collection membership history  
            ELSE IF @TransactionLogType = @TransactionLogType_Attribute  
            BEGIN  
  
                -- Copy transactions pertaining to the collections being copied. Note: collection membership changes do not produce transactions  
                SET @TransactionTableName = mdm.udfGetTransactionTableName(@Model_ID);  
  
                IF @DeleteOriginals = 1  
                BEGIN  
    PRINT CONCAT(SYSDATETIME(), N': Changing collection member transactions to reference the new Leaf entity.');  
                    SET @SQL = CONCAT(@TruncationGuard, N'  
                    --SELECT * FROM mdm.', QUOTENAME(@TransactionTableName), N' WHERE Entity_ID = @Entity_ID AND MemberType_ID = ', @MemberType_Collection, N'  
  
                    UPDATE tr  
                    SET  
                         Entity_ID = @NewEntity_ID_CN  
                        ,Attribute_ID = a.NewAttribute_ID  
                        ,MemberType_ID = ', @MemberType_Leaf, N'  
                    FROM mdm.', QUOTENAME(@TransactionTableName), N' tr  
  
                    -- Get new attribute ID for consolidated members  
                    LEFT JOIN #AttributeMapping a  
                    ON      tr.Attribute_ID = a.OldAttribute_ID  
                        -- AND a.NewEntity_ID = @NewEntity_ID_CN -- For collections, there is a one-to-one mapping from old-to-new attribute (unlike consolidated attributes, which can have one-to-many), so no need to also join on entity ID  
  
                    WHERE   tr.Entity_ID = @Entity_ID  
                        AND tr.MemberType_ID = ', @MemberType_Collection, N'  
  
                    --SELECT * FROM mdm.', QUOTENAME(@TransactionTableName), N' WHERE Entity_ID = @NewEntity_ID_CN  
                        ');  
                    -- Note: No need to copy or update the transaction annotations, since we merely modified existing transaction rows.  
                END ELSE  
                BEGIN  
                    -- We're not deleting originals, so copy (rather than update) transaction rows  
PRINT CONCAT(SYSDATETIME(), N': Copying collection transactions.');  
                    SET @TransactionAnnotationTableName = mdm.udfGetTransactionAnnotationTableName(@Model_ID);  
                    SET @SQL = CONCAT(@TruncationGuard, N'  
                    DECLARE @TransactionMappings TABLE  
                    (  
                         Old_ID INT PRIMARY KEY  
                        ,New_ID INT  
                    )  
  
                    MERGE mdm.', QUOTENAME(@TransactionTableName), N'  
                    USING  
                    (  
                        SELECT  
                             tr.ID  
                            ,tr.Version_ID  
                            ,tr.TransactionType_ID   
                            ,tr.OriginalTransaction_ID -- This references the old ID and will need to be updated after the MERGE  
                            ,tr.Hierarchy_ID -- should always be null for collection transactions  
                            ,@NewEntity_ID_CN AS Entity_ID -- Use the new entity for collection member transactions ....  
                            ,a.NewAttribute_ID AS Attribute_ID -- Changing the value of a collection attribute.  
                            ,tr.Member_ID            -- The old member ID will always be the same ...  
                            ,newEn.MUID Member_MUID  -- ... but the member MUID may be different for collection member transactions  
                            ,', @MemberType_Leaf, N' AS MemberType_ID  
                            ,tr.MemberCode  
  
                            ,tr.OldValue  
                            ,tr.OldCode  
                            ,tr.NewValue  
                            ,tr.NewCode  
  
                            ,tr.Batch_ID  
                            ,tr.EnterDTM  
                            ,tr.EnterUserID  
                            ,tr.LastChgDTM  
                            ,tr.LastChgUserID  
                        FROM mdm.', QUOTENAME(@TransactionTableName), ' tr  
  
                        -- Get new member MUID for copied collection members (note that this is a left join because some of the transactions that need to be copied may be for Leaf members being moved in the EH)  
                        LEFT JOIN mdm.', QUOTENAME(@NewEntityTableName_CN), N' newEn  
                        ON      tr.Version_ID = newEn.Version_ID  
                            AND tr.Member_ID = newEn.ID  
  
                        -- Get new attribute ID for consolidated members  
                        LEFT JOIN #AttributeMapping a  
                        ON      tr.Attribute_ID = a.OldAttribute_ID  
                            -- AND a.NewEntity_ID = @NewEntity_ID_CN -- For collections, there is a one-to-one mapping from old-to-new attribute (unlike consolidated attributes, which can have one-to-many), so no need to also join on entity ID  
  
                        WHERE   tr.Entity_ID = @Entity_ID  
                            AND tr.MemberType_ID = ', @MemberType_Collection, N'  
  
                    ) t  
                    ON (1 = 0) -- An arbitrary condition that is always false, so that the NOT MATCHED block will always be hit.  
                    WHEN NOT MATCHED THEN  
                    INSERT  
                    (  
                         Version_ID  
                        ,TransactionType_ID  
                        ,OriginalTransaction_ID  
                        ,Hierarchy_ID  
                        ,Entity_ID  
                        ,Attribute_ID  
                        ,Member_ID  
                        ,Member_MUID  
                        ,MemberType_ID  
                        ,MemberCode  
                        ,OldValue  
                        ,OldCode  
                        ,NewValue  
                        ,NewCode  
                        ,Batch_ID  
                        ,EnterDTM  
                        ,EnterUserID  
                        ,LastChgDTM  
                        ,LastChgUserID  
                    )  
                    VALUES  
                    (  
                         Version_ID  
                        ,TransactionType_ID  
                        ,OriginalTransaction_ID  
                        ,Hierarchy_ID  
                        ,Entity_ID  
                        ,Attribute_ID  
                        ,Member_ID  
                        ,Member_MUID  
                        ,MemberType_ID  
                        ,MemberCode  
                        ,OldValue  
                        ,OldCode  
                        ,NewValue  
                        ,NewCode  
                        ,Batch_ID  
                        ,EnterDTM  
                        ,EnterUserID  
                        ,LastChgDTM  
                        ,LastChgUserID  
                    )  
                    OUTPUT t.ID, inserted.ID  
                    INTO @TransactionMappings(Old_ID, New_ID);  
  
                    -- Update original transaction ID columns  
                    UPDATE tr  
                    SET OriginalTransaction_ID = newParent.New_ID  
                    FROM mdm.', QUOTENAME(@TransactionTableName), N' tr  
                    INNER JOIN @TransactionMappings newRow  
                    ON tr.ID = newRow.New_ID  
                    INNER JOIN @TransactionMappings newParent  
                    ON tr.OriginalTransaction_ID = newParent.Old_ID;  
  
  
                    -- Copy transaction annotations  
    PRINT CONCAT(SYSDATETIME(), N'': Copying collection transaction annotations.'');  
                    INSERT INTO mdm.', QUOTENAME(@TransactionAnnotationTableName), N'  
                    (  
                         Version_ID  
                        ,Transaction_ID  
                        ,Comment  
                        ,EnterUserID  
                        ,EnterDTM  
                        ,LastChgDTM  
                        ,LastChgUserID  
                    )  
                    SELECT  
                         ta.Version_ID  
                        ,newRow.New_ID  
                        ,ta.Comment  
                        ,ta.EnterUserID  
                        ,ta.EnterDTM  
                        ,ta.LastChgDTM  
                        ,ta.LastChgUserID  
                    FROM mdm.', QUOTENAME(@TransactionAnnotationTableName), N' ta  
                    INNER JOIN @TransactionMappings newRow  
                    ON ta.Transaction_ID = newRow.Old_ID  
  
                    --SELECT * FROM mdm.', QUOTENAME(@TransactionTableName), N' WHERE Entity_ID = @Entity_ID AND MemberType_ID = ', @MemberType_Collection, N'  
                    --SELECT * FROM mdm.', QUOTENAME(@TransactionAnnotationTableName), N' ta INNER JOIN mdm.', QUOTENAME(@TransactionTableName), N' tr ON ta.Transaction_ID = tr.ID WHERE tr.Entity_ID = @Entity_ID AND tr.MemberType_ID = ', @MemberType_Collection, N'  
                    --SELECT * FROM mdm.', QUOTENAME(@TransactionTableName), N' WHERE Entity_ID = @NewEntity_ID_CN    
                    --SELECT * FROM mdm.', QUOTENAME(@TransactionAnnotationTableName), N' ta INNER JOIN mdm.', QUOTENAME(@TransactionTableName), N' tr ON ta.Transaction_ID = tr.ID WHERE tr.Entity_ID = @NewEntity_ID_CN   
                    ');  
                END -- IF not @DeleteOriginals, copy transactions  
  
                --PRINT @SQL  
                EXEC sp_executesql @SQL  
                    ,N'@Entity_ID INT, @NewEntity_ID_CN INT'  
                      ,@Entity_ID,     @NewEntity_ID_CN;  
                END -- Copy Attribute (deprecated) transactions  
            ELSE   
PRINT N''  
PRINT CONCAT(SYSDATETIME(), N': Adding Many-To-Many hierarchies for collection membership info');  
            -- Create new Derived Hierarchy (one per child DBA) with a Many-To-Many level.  
            DECLARE   
                 @prefix                        NVARCHAR(50) = N'Collection_'  
                ,@MappingEntityName             NVARCHAR(50) = @NewEntityName  
                ,@ManyToManyChildDomainEntity_ID    INT  
                ,@ManyToManyChildDomainEntityName   NVARCHAR(50)  
                ,@ManyToManyChildAttribute_ID   INT  
                ,@ManyToManyChildAttributeName  NVARCHAR(100)  
  
            SET @RowID = 0  
            WHILE EXISTS (SELECT 1 FROM @CollectionMembershipAttributes WHERE RowID > @RowID)  
            BEGIN   
                SELECT TOP 1  
                     @RowID = RowID  
                    ,@ManyToManyChildAttributeName = Name  
                    ,@ManyToManyChildAttribute_ID = NewAttribute_ID  
  
                    ,@ManyToManyChildDomainEntity_ID = DomainEntity_ID  
                    ,@ManyToManyChildDomainEntityName = DomainEntityName  
                FROM @CollectionMembershipAttributes  
                WHERE RowID > @RowID  
                ORDER BY RowID  
  
                IF @ManyToManyChildAttributeName NOT LIKE @ChildAttributeNamePrefix + N'%'  
                BEGIN  
                    CONTINUE;  
                END  
  
                SET @counter = 0;  
                WHILE (1=1) -- TSQL doesn't support a DO-WHILE loop, so use a tautology as this WHILE condition to simulate a post-test loop.  
                BEGIN  
                    SET @NewDerivedHierarchyName = CONCAT(@prefix,   
                            SUBSTRING(@ManyToManyChildAttributeName, LEN(@ChildAttributeNamePrefix) + 1, @MaxMetadataObjectNameLength - LEN(@prefix) - 4),   
                            CASE WHEN @counter > 0 THEN @counter END);  
  
                    -- If the new DH name is unique within the model, then exit the loop.  
                    IF NOT EXISTS (SELECT 1 FROM mdm.tblDerivedHierarchy WHERE Model_ID = @Model_ID AND Name = @NewDerivedHierarchyName)  
                    BEGIN  
                        BREAK;  
                    END;  
  
                    -- The name wasn't unique, so increment the counter for the next loop iteration.  
                    SET @counter += 1;  
                END; -- WHILE (get unique DH name)  
  
PRINT CONCAT(SYSDATETIME(), N': Creating a new derived hierarchy "', @NewDerivedHierarchyName, N'"');  
                SET @NewDerivedHierarchy_ID = 0;  
                EXEC mdm.udpDerivedHierarchySave   
                     @User_ID = @User_ID  
                    ,@Model_ID = @Model_ID  
                    ,@Name = @NewDerivedHierarchyName  
                    ,@AnchorNullRecursions = 1  
                    ,@Return_ID = @NewDerivedHierarchy_ID OUTPUT  
  
                -- Add the leaf member level.  
PRINT CONCAT(SYSDATETIME(), N': Adding leaf level "', @ManyToManyChildDomainEntityName, '" to hierarchy "', @NewDerivedHierarchyName, N'"');  
                EXEC mdm.udpDerivedHierarchyDetailSave  
                  @User_ID = @User_ID  
                 ,@Model_ID = @Model_ID  
                 ,@DerivedHierarchy_ID = @NewDerivedHierarchy_ID  
                 ,@Foreign_ID = @ManyToManyChildDomainEntity_ID  
                 ,@ForeignType_ID = @HierarchyItemType_Entity  
                 ,@Name = @ManyToManyChildDomainEntityName  
                 ,@DisplayName = @ManyToManyChildDomainEntityName  
                 ,@IsVisible = 1  
                 ,@Return_ID = @NewLevel_ID OUTPUT  
  
            -- Add the Many-To-Many level.  
                SET @NewLevelName = SUBSTRING(CONCAT(@ManyToManyParentAttributeName, N' (via ', @MappingEntityName, N'.', @ManyToManyChildAttributeName, N')'), 0, @MaxHierarchyLevelNameLength);  
PRINT CONCAT(SYSDATETIME(), N': Adding Many-To-Many level "', @NewLevelName, '" to hierarchy "', @NewDerivedHierarchyName, N'"');  
                EXEC mdm.udpDerivedHierarchyDetailSave  
                  @User_ID = @User_ID  
                 ,@Model_ID = @Model_ID  
                 ,@DerivedHierarchy_ID = @NewDerivedHierarchy_ID  
                 ,@Foreign_ID = @ManyToManyParentAttribute_ID  
                 ,@ForeignType_ID = @HierarchyItemType_ManyToMany  
                 ,@Name = @NewLevelName  
                 ,@DisplayName = @NewLevelName  
                 ,@ManyToManyChildAttribute_ID = @ManyToManyChildAttribute_ID  
                 ,@IsVisible = 1  
                 ,@Return_ID = @NewLevel_ID OUTPUT  
  
            END  
  
  
        END -- WHILE (copy collections)  
  
  
  
PRINT N''  
PRINT CONCAT(SYSDATETIME(), N': Recreate leaf staging sprocs.');  
    DECLARE @EntitiesToRefresh TABLE  
    (  
         ID     INT PRIMARY KEY  
        ,Name   NVARCHAR(50) NOT NULL  
    );  
    ;WITH entityIdCte AS  
    (  
        SELECT Entity_ID AS ID FROM #EH_ConversionLog -- old entity had new DBA added to reference the new "consolidated" parent  
        UNION  
        SELECT NewEntity_ID FROM #EH_ConversionLog   
        UNION   
        SELECT New_CN_Entity_ID FROM @EntityInfo WHERE New_CN_Entity_ID IS NOT NULL  
        UNION   
        SELECT New_CM_Entity_ID FROM @EntityInfo WHERE New_CM_Entity_ID IS NOT NULL  
    )  
    INSERT INTO @EntitiesToRefresh(ID, Name)  
    SELECT   
         e.ID  
        ,e.Name  
    FROM entityIdCte id  
    INNER JOIN mdm.tblEntity e  
    ON id.ID = e.ID  
          
    SET @Entity_ID = 0  
    WHILE EXISTS (SELECT 1 FROM @EntitiesToRefresh WHERE ID > @Entity_ID)  
    BEGIN  
        SELECT TOP 1  
             @Entity_ID = ID  
            ,@EntityName = Name  
        FROM @EntitiesToRefresh  
        WHERE ID > @Entity_ID  
        ORDER BY ID  
  
PRINT CONCAT(SYSDATETIME(), N': Recreating leaf staging sproc for entity ', @EntityName, N' (ID = ', @Entity_ID, N')');  
        EXEC mdm.udpEntityStagingCreateLeafStoredProcedure @Entity_ID  
  
    END  
  
PRINT CONCAT(SYSDATETIME(), N': Copying all attribute groups from old entities to new entities.');  
  
        MERGE mdm.tblAttributeGroup  
        USING  
        (  
            -- Consolidated AGs  
            SELECT  
                 ag.ID  
                ,ag.Name  
                ,ag.SortOrder  
                ,ag.FreezeNameCode  
                ,ag.IsSystem  
                ,ag.EnterDTM  
                ,ag.EnterUserID  
                ,ag.EnterVersionID  
                ,ag.LastChgDTM  
                ,ag.LastChgUserID  
                ,ag.LastChgVersionID  
                ,eh.NewEntity_ID  
                ,ag.Entity_ID OldEntitiy_ID  
            FROM mdm.tblAttributeGroup ag  
            INNER JOIN #EH_ConversionLog eh  
            ON ag.Entity_ID = eh.Entity_ID  
            WHERE ag.MemberType_ID = @MemberType_Consolidated  
            UNION  
            -- Collection AGs  
            SELECT  
                 ag.ID  
                ,ag.Name  
                ,ag.SortOrder  
                ,ag.FreezeNameCode  
                ,ag.IsSystem  
                ,ag.EnterDTM  
                ,ag.EnterUserID  
                ,ag.EnterVersionID  
                ,ag.LastChgDTM  
                ,ag.LastChgUserID  
                ,ag.LastChgVersionID  
                ,e.New_CN_Entity_ID AS NewEntity_ID  
                ,ag.Entity_ID OldEntitiy_ID  
            FROM mdm.tblAttributeGroup ag  
            INNER JOIN @EntityInfo e  
            ON ag.Entity_ID = e.  Entity_ID  
            WHERE ag.MemberType_ID = @MemberType_Collection  
        ) ag  
        ON (1 = 0) -- An arbitrary condition that is always false, so that the NOT MATCHED block will always be hit.    
        WHEN NOT MATCHED THEN    
        INSERT    
        (    
             Entity_ID  
            ,MemberType_ID  
            ,Name  
            ,SortOrder  
            ,FreezeNameCode  
            ,IsSystem  
            ,EnterDTM  
            ,EnterUserID  
            ,EnterVersionID  
            ,LastChgDTM  
            ,LastChgUserID  
            ,LastChgVersionID  
        )  
        VALUES  
        (  
             ag.NewEntity_ID  
            ,@MemberType_Leaf  
            ,ag.Name  
            ,ag.SortOrder  
            ,ag.FreezeNameCode  
            ,ag.IsSystem  
            ,ag.EnterDTM  
            ,ag.EnterUserID  
            ,ag.EnterVersionID  
            ,ag.LastChgDTM  
            ,ag.LastChgUserID  
            ,ag.LastChgVersionID  
        )  
        OUTPUT   
             ag.ID  
            ,ag.OldEntitiy_ID  
            ,inserted.ID  
            ,inserted.Entity_ID  
        INTO #AttributeGroupMapping  
        (  
             OldAttributeGroup_ID  
            ,Entity_ID  
            ,NewAttributeGroup_ID  
            ,NewEntity_ID  
        );  
  
  
PRINT CONCAT(SYSDATETIME(), N': Copying all AttributeGroup details.');  
        INSERT INTO mdm.tblAttributeGroupDetail  
        (  
             AttributeGroup_ID  
            ,Attribute_ID  
            ,SortOrder  
            ,EnterDTM  
            ,EnterUserID  
            ,EnterVersionID  
            ,LastChgDTM  
            ,LastChgUserID  
            ,LastChgVersionID  
        )  
        SELECT  
             agm.NewAttributeGroup_ID  
            ,am.NewAttribute_ID  
            ,agd.SortOrder  
            ,agd.EnterDTM  
            ,agd.EnterUserID  
            ,agd.EnterVersionID  
            ,agd.LastChgDTM  
            ,agd.LastChgUserID  
            ,agd.LastChgVersionID  
        FROM mdm.tblAttributeGroupDetail agd  
        INNER JOIN #AttributeGroupMapping agm  
        ON agd.AttributeGroup_ID = agm.OldAttributeGroup_ID  
        INNER JOIN #AttributeMapping am  
        ON agd.Attribute_ID = am.OldAttribute_ID  
  
  
PRINT CONCAT(N'  
', SYSDATETIME(), N': Copying subscription views.');  
        DECLARE @SubscriptionViews TABLE  
        (  
             RowID                      INT IDENTITY(1,1) PRIMARY KEY  
            ,ID                         INT NOT NULL  
            ,Entity_ID                  INT NULL  
            ,NewEntity_ID               INT NULL  
            ,Model_ID                   INT NOT NULL  
            ,DerivedHierarchy_ID        INT NULL  
            ,ViewFormat_ID              INT NOT NULL  
            ,OldViewFormat_ID           INT NOT NULL  
            ,ModelVersion_ID            INT NULL  
            ,ModelVersionFlag_ID        INT NULL  
            ,Name                       SYSNAME COLLATE DATABASE_DEFAULT NOT NULL  
            ,NewNamePrefix              SYSNAME COLLATE DATABASE_DEFAULT NOT NULL  
            ,Levels                     SMALLINT NULL  
            ,Description                NVARCHAR(500) COLLATE DATABASE_DEFAULT NULL   
            ,IncludeSoftDeletedMembers  BIT NOT NULL  
            ,EnterDTM                   DATETIME2(3) NOT NULL  
            ,EnterUserID                INT NULL  
            ,EnterVersionID             INT NOT NULL  
            ,LastChgDTM                 DATETIME2(3) NOT NULL  
            ,LastChgUserID              INT NULL  
            ,LastChgVersionID           INT NOT NULL  
        );  
        INSERT INTO @SubscriptionViews  
        (  
             ID  
            ,Entity_ID  
            ,NewEntity_ID  
            ,Model_ID  
            ,DerivedHierarchy_ID  
            ,ViewFormat_ID  
            ,OldViewFormat_ID  
            ,ModelVersion_ID  
            ,ModelVersionFlag_ID  
            ,Name  
            ,NewNamePrefix  
            ,Levels  
            ,Description  
            ,IncludeSoftDeletedMembers  
            ,EnterDTM  
            ,EnterUserID  
            ,EnterVersionID  
            ,LastChgDTM  
            ,LastChgUserID  
            ,LastChgVersionID  
        )  
        -- Consolidated views  
        SELECT   
             sv.ID  
            ,sv.Entity_ID  
            ,CASE sv.ViewFormat_ID  
                WHEN @ViewFormat_Consolidated           THEN eh.NewEntity_ID  
                WHEN @ViewFormat_ExplicitParentChild    THEN NULL  
                WHEN @ViewFormat_ExplicitLevels         THEN NULL  
                WHEN @ViewFormat_ConsolidatedHistory    THEN eh.NewEntity_ID  
                WHEN @ViewFormat_ConsolidatedType2      THEN eh.NewEntity_ID  
                END AS NewEntity_ID  
            ,sv.Model_ID  
            ,CASE sv.ViewFormat_ID  
                WHEN @ViewFormat_Consolidated           THEN NULL  
                WHEN @ViewFormat_ExplicitParentChild    THEN eh.NewDerivedHierarchy_ID  
                WHEN @ViewFormat_ExplicitLevels         THEN eh.NewDerivedHierarchy_ID  
                WHEN @ViewFormat_ConsolidatedHistory    THEN NULL  
                WHEN @ViewFormat_ConsolidatedType2      THEN NULL  
                END AS DerivedHierarchy_ID  
            ,CASE sv.ViewFormat_ID  
                WHEN @ViewFormat_Consolidated           THEN @ViewFormat_Leaf  
                WHEN @ViewFormat_ExplicitParentChild    THEN @ViewFormat_DerivedParentChild  
                WHEN @ViewFormat_ExplicitLevels         THEN @ViewFormat_DerivedLevels  
                WHEN @ViewFormat_ConsolidatedHistory    THEN @ViewFormat_LeafHistory  
                WHEN @ViewFormat_ConsolidatedType2      THEN @ViewFormat_LeafType2  
                END AS ViewFormat_ID  
            ,sv.ViewFormat_ID AS OldViewFormat_ID  
            ,sv.ModelVersion_ID  
            ,sv.ModelVersionFlag_ID  
            ,sv.Name  
            ,CONCAT(sv.Name, N'_', eh.ExplicitHierarchyName) AS NewNamePrefix  
            ,COALESCE(CONVERT(SMALLINT, sv.Levels), levels.LevelCount)  
            ,sv.Description  
            ,sv.IncludeSoftDeletedMembers  
            ,sv.EnterDTM  
            ,sv.EnterUserID  
            ,sv.EnterVersionID  
            ,sv.LastChgDTM  
            ,sv.LastChgUserID  
            ,sv.LastChgVersionID  
        FROM mdm.tblSubscriptionView sv  
        INNER JOIN #EH_ConversionLog eh  
        ON sv.Entity_ID = eh.Entity_ID  
        -- Get the total number of levels in the new RDH, needed for ExplicitLevels views that use NULL for level count (which means show all levels)  
        LEFT JOIN  
        (  
            SELECT   
                 DerivedHierarchy_ID  
                ,CONVERT(SMALLINT, COUNT(*)) LevelCount  
            FROM mdm.tblDerivedHierarchyDetail  
            GROUP BY DerivedHierarchy_ID  
        ) levels  
        ON      sv.ViewFormat_ID = @ViewFormat_ExplicitLevels  
            AND eh.NewDerivedHierarchy_ID = levels.DerivedHierarchy_ID  
        WHERE sv.ViewFormat_ID IN (@ViewFormat_Consolidated, @ViewFormat_ExplicitParentChild, @ViewFormat_ExplicitLevels, @ViewFormat_ConsolidatedHistory, @ViewFormat_ConsolidatedType2)  
        UNION  
        -- Collection views  
        SELECT  
             sv.ID  
            ,sv.Entity_ID  
            ,CASE sv.ViewFormat_ID  
                WHEN @ViewFormat_Collection             THEN ei.New_CN_Entity_ID  
                WHEN @ViewFormat_CollectionMembership   THEN ei.New_CM_Entity_ID  
                WHEN @ViewFormat_CollectionHistory      THEN ei.New_CN_Entity_ID  
                WHEN @ViewFormat_CollectionType2        THEN ei.New_CN_Entity_ID  
                END AS NewEntity_ID  
            ,sv.Model_ID  
            ,sv.DerivedHierarchy_ID -- should always be null  
            ,CASE sv.ViewFormat_ID  
                WHEN @ViewFormat_Collection             THEN @ViewFormat_Leaf  
                WHEN @ViewFormat_CollectionMembership   THEN @ViewFormat_Leaf  
                WHEN @ViewFormat_CollectionHistory      THEN @ViewFormat_LeafHistory  
                WHEN @ViewFormat_CollectionType2        THEN @ViewFormat_LeafType2  
                END AS ViewFormat_ID  
            ,sv.ViewFormat_ID AS OldViewFormat_ID  
            ,sv.ModelVersion_ID  
            ,sv.ModelVersionFlag_ID  
            ,sv.Name  
            ,sv.Name AS NewNamePrefix  
            ,CONVERT(SMALLINT, sv.Levels)  
            ,sv.Description  
            ,sv.IncludeSoftDeletedMembers  
            ,sv.EnterDTM  
            ,sv.EnterUserID  
            ,sv.EnterVersionID  
            ,sv.LastChgDTM  
            ,sv.LastChgUserID  
            ,sv.LastChgVersionID  
        FROM mdm.tblSubscriptionView sv  
        INNER JOIN @EntityInfo ei  
        ON sv.Entity_ID = ei.Entity_ID  
        WHERE sv.ViewFormat_ID IN (@ViewFormat_Collection, @ViewFormat_CollectionMembership, @ViewFormat_CollectionHistory, @ViewFormat_CollectionType2)  
  
        SET @RowID = 0;  
        DECLARE  
             @OldSubscriptionView_ID    INT = 0  
            ,@NewSubscriptionView_ID    INT  
            ,@OldSubscriptionView_Name  SYSNAME  
            ,@NewSubscriptionView_Name  SYSNAME  
            ,@NewNamePrefix             SYSNAME  
            ,@OldEntity_ID              INT = 0  
            ,@ViewFormat_ID             INT  
            ,@OldViewFormat_ID           INT  
            ,@ModelVersion_ID           INT  
            ,@ModelVersionFlag_ID       INT  
            ,@Levels                    SMALLINT  
            ,@IncludeSoftDeletedMembers BIT  
  
        WHILE EXISTS(SELECT 1 FROM @SubscriptionViews WHERE RowID > @RowID)  
        BEGIN  
            SELECT TOP 1  
                 @RowID = RowID  
                ,@OldSubscriptionView_ID = ID  
                ,@OldEntity_ID = Entity_ID  
                ,@Entity_ID = NewEntity_ID  
                ,@Model_ID = Model_ID  
                ,@DerivedHierarchy_ID = DerivedHierarchy_ID  
                ,@ViewFormat_ID = ViewFormat_ID  
                ,@OldViewFormat_ID = OldViewFormat_ID  
                ,@ModelVersion_ID = ModelVersion_ID  
                ,@ModelVersionFlag_ID = ModelVersionFlag_ID  
                ,@OldSubscriptionView_Name = Name  
                ,@NewNamePrefix = NewNamePrefix  
                ,@Levels = Levels  
                ,@Description = Description  
                ,@IncludeSoftDeletedMembers = IncludeSoftDeletedMembers  
                ,@EnterDTM = EnterDTM  
                ,@EnterUserID = EnterUserID  
                ,@EnterVersionID = EnterVersionID  
                ,@LastChgDTM = LastChgDTM  
                ,@LastChgUserID = LastChgUserID  
                ,@LastChgVersionID = LastChgVersionID  
            FROM @SubscriptionViews  
            WHERE RowID > @RowID  
            ORDER BY RowID;  
  
            IF @DeleteOriginals = 1   
            BEGIN  
                IF EXISTS (SELECT 1 FROM mdm.tblSubscriptionView WHERE ID = @OldSubscriptionView_ID) -- A single consolidated-related SV (consolidated, explicit parent child, or explicit levels) may map to multiple new SVs (one per EH). So check to make sure the old SV hasn't already been deleted in a previous loop iteration.  
                BEGIN  
PRINT CONCAT(SYSDATETIME(), N': Deleting subscription view ', @OldSubscriptionView_Name, N' (ID = ', @OldSubscriptionView_ID, N') from Entity ID = ', @OldEntity_ID, ', @OldViewFormat_ID = ', @OldViewFormat_ID);  
  
                    EXEC mdm.udpSubscriptionViewDeleteByID  @ID	= @OldSubscriptionView_ID, @DeleteView = 1  
                END ELSE  
                BEGIN  
PRINT CONCAT(SYSDATETIME(), N': Already deleted, subscription view ', @OldSubscriptionView_Name, N' (ID = ', @OldSubscriptionView_ID, N') from Entity ID = ', @OldEntity_ID, ', @OldViewFormat_ID = ', @OldViewFormat_ID);  
                END  
            END  
  
            -- Get new subscription view name  
            SET @counter = 0  
            WHILE (1=1) -- TSQL doesn't support a DO-WHILE loop, so use a tautology as this WHILE condition to simulate a post-test loop.  
            BEGIN  
                SET @NewSubscriptionView_Name = CASE @counter WHEN 0   
                    THEN @NewNamePrefix   
                    ELSE CONCAT(SUBSTRING(@NewNamePrefix, 0, 120), N'_', @counter) END;  
  
                -- If the new name is unique, then exit the loop.  
                IF NOT EXISTS (SELECT 1 FROM mdm.tblSubscriptionView WHERE Name = @NewSubscriptionView_Name)  
                BEGIN  
                    BREAK;  
                END;  
  
                -- The name wasn't unique, so increment the counter for the next loop iteration.  
                SET @counter += 1;  
            END; -- WHILE (get unique subscription view name)  
  
PRINT CONCAT(SYSDATETIME(), N': Creating new subscription view "', @NewSubscriptionView_Name, '" in   
     @Entity ID = ', @Entity_ID, N'  
    ,@Model_ID = ', @Model_ID, N'  
    ,@DerivedHierarchy_ID = ', @DerivedHierarchy_ID, N'  
    ,@ModelVersion_ID = ', @ModelVersion_ID, N'  
    ,@ModelVersionFlag_ID = ', @ModelVersionFlag_ID, N'  
    ,@ViewFormat_ID = ', @ViewFormat_ID, N'  
    ,@Levels = ', @Levels, N'  
    ,@IncludeSoftDeletedMembers = ', @IncludeSoftDeletedMembers, N'  
    ,@NewSubscriptionView_Name = ', @NewSubscriptionView_Name, N'  
    ,@Description = ', @Description, N'  
    ');  
            EXEC mdm.udpSubscriptionViewSave   
                 @User_ID               = @User_ID  
                ,@SubscriptionView_ID   = NULL  
                ,@Entity_ID             = @Entity_ID  
                ,@Model_ID              = @Model_ID  
                ,@DerivedHierarchy_ID   = @DerivedHierarchy_ID  
                ,@ModelVersion_ID       = @ModelVersion_ID  
                ,@ModelVersionFlag_ID   = @ModelVersionFlag_ID  
                ,@ViewFormat_ID         = @ViewFormat_ID  
                ,@Levels                = @Levels  
                ,@IncludeSoftDeletedMembers = @IncludeSoftDeletedMembers  
                ,@SubscriptionViewName  = @NewSubscriptionView_Name  
                ,@Description           = @Description  
                ,@Return_ID             = @NewSubscriptionView_ID OUTPUT  
                --,@Return_MUID			UNIQUEIDENTIFIER = NULL OUTPUT, --Also an input parameter for clone operations  
          
            -- Copy audit info  
            UPDATE mdm.tblSubscriptionView  
            SET  
                 EnterDTM = @EnterDTM  
                ,EnterUserID = @EnterUserID  
                ,EnterVersionID = @EnterVersionID  
                ,LastChgDTM = @LastChgDTM  
                ,LastChgUserID = @LastChgUserID  
                ,LastChgVersionID = @LastChgVersionID  
            WHERE ID = @NewSubscriptionView_ID  
  
PRINT CONCAT(SYSDATETIME(), N': New subscription view ID = ', @NewSubscriptionView_ID);  
        END  
  
  
        -- Copy model object security permissions  
PRINT CONCAT(N'  
', SYSDATETIME(), N': Copying model object security: Entity, MemberType, Attribute Group, and Attribute permissions.');  
        CREATE TABLE #ObjectPermissionMapping  
        (  
             OldRow_ID       INT  
            ,OldObject_ID    INT NOT NULL DEFAULT 0  
            ,NewRow_ID       INT  
        )  
        ;WITH cteNewEntities AS  
        (  
            -- Consolidated members  
            SELECT DISTINCT  
                 Entity_ID AS OldEntity_ID  
                ,NewEntity_ID  
                ,@ObjectType_ConsolidatedType AS Object_ID  
            FROM #EH_ConversionLog  
            UNION ALL  
            -- Collection members  
            SELECT  
                 Entity_ID AS OldEntity_ID  
                ,New_CN_Entity_ID AS NewEntity_ID  
                ,@ObjectType_CollectionType  
            FROM @EntityInfo  
            WHERE New_CN_Entity_ID IS NOT NULL  
            UNION ALL  
            -- Collection membership info  
            SELECT  
                 Entity_ID AS OldEntity_ID  
                ,New_CM_Entity_ID AS NewEntity_ID  
                ,@ObjectType_CollectionType  
            FROM @EntityInfo  
            WHERE New_CM_Entity_ID IS NOT NULL  
        )  
        ,cteMappedPermissions AS  
        (  
            SELECT  
                 ra.ID  
                ,ne.NewEntity_ID AS NewSecurable_ID-- The Securable_ID will be the new Entity ID for both entity and member type permissions  
                ,CASE ra.Object_ID  
                    WHEN @ObjectType_ConsolidatedType THEN @ObjectType_LeafType -- Copy Consolidated permissions on the old entity to a leaf permission on the new entity  
                    WHEN @ObjectType_CollectionType THEN @ObjectType_LeafType -- Copy Collection permissions on the old entity to a leaf permission on the new entity  
                    ELSE ra.Object_ID END AS NewObject_ID  
            FROM mdm.tblSecurityRoleAccess ra  
            INNER JOIN cteNewEntities ne  
            ON      ra.Securable_ID = ne.OldEntity_ID  
                AND (ra.Object_ID = @ObjectType_Entity OR ra.Object_ID = ne.Object_ID)  
  
           -- Attribute permissions  
           UNION ALL  
           SELECT  
                 ra.ID  
                ,am.NewAttribute_ID AS NewSecurable_ID  
                ,ra.Object_ID AS NewObject_ID  
            FROM mdm.tblSecurityRoleAccess ra  
            INNER JOIN #AttributeMapping am  
            ON      ra.Securable_ID = am.OldAttribute_ID  
                AND ra.Object_ID = @ObjectType_Attribute  
  
            -- Attribute group permissions  
            UNION ALL  
            SELECT  
                 ra.ID  
                ,agm.NewAttributeGroup_ID AS NewSecurable_ID  
                ,ra.Object_ID AS NewObject_ID  
            FROM mdm.tblSecurityRoleAccess ra  
            INNER JOIN #AttributeGroupMapping agm  
            ON      ra.Securable_ID = agm.OldAttributeGroup_ID  
                AND ra.Object_ID = @ObjectType_AttributeGroup  
        )  
        MERGE mdm.tblSecurityRoleAccess  
        USING  
        (  
            SELECT  
                 ra.ID AS OldRow_ID  
                ,ra.Role_ID  
                ,ra.Privilege_ID  
                ,ra.AccessPermission  
                ,ra.Model_ID  
                ,new.NewSecurable_ID  
                ,new.NewObject_ID  
                ,ra.Object_ID AS OldObject_ID  
                ,ra.Description  
                ,ra.EnterDTM  
                ,ra.EnterUserID  
                ,ra.LastChgDTM  
                ,ra.LastChgUserID  
            FROM mdm.tblSecurityRoleAccess ra  
            INNER JOIN cteMappedPermissions new  
            ON  ra.ID = new.ID  
        ) p  
        ON (1 = 0) -- An arbitrary condition that is always false, so that the NOT MATCHED block will always be hit.  
        WHEN NOT MATCHED THEN  
        INSERT  
        (  
             Role_ID  
            ,Privilege_ID  
            ,AccessPermission  
            ,Model_ID  
            ,Securable_ID  
            ,Object_ID  
            ,Description  
            ,EnterDTM  
            ,EnterUserID  
            ,LastChgDTM  
            ,LastChgUserID  
        )  
        VALUES  
        (  
             Role_ID  
            ,Privilege_ID  
            ,AccessPermission  
            ,Model_ID  
            ,NewSecurable_ID  
            ,NewObject_ID  
            ,Description  
            ,EnterDTM  
            ,EnterUserID  
            ,LastChgDTM  
            ,LastChgUserID  
        )  
        OUTPUT p.OldRow_ID, p.OldObject_ID, inserted.ID  
        INTO #ObjectPermissionMapping(OldRow_ID, OldObject_ID, NewRow_ID);  
  
        -- Copy member security permissions from the old EHs to the new RDHs.  
PRINT CONCAT(SYSDATETIME(), N': Copying member security.');  
        INSERT INTO mdm.tblSecurityRoleAccessMember  
        (  
             Role_ID  
            ,Privilege_ID  
            ,AccessPermission  
            ,Version_ID  
            ,DerivedHierarchy_ID  
            ,HierarchyType_ID  
            ,Entity_ID  
            ,MemberType_ID  
            ,Member_ID  
            ,Description  
            ,EnterDTM  
            ,EnterUserID  
            ,LastChgDTM  
            ,LastChgUserID  
        )  
        SELECT   
             ram.Role_ID  
            ,ram.Privilege_ID  
            ,AccessPermission  
            ,ram.Version_ID  
            ,cl.NewDerivedHierarchy_ID  
            ,@HierarchyType_Derived  
            ,CASE ram.MemberType_ID WHEN @MemberType_Leaf THEN cl.Entity_ID ELSE cl.NewEntity_ID END -- If the permission applied to one of the consolidated members in the EH, then use the new entity id. Otherwise, use the old (leaf) entity.  
            ,CASE ram.Member_ID WHEN 0/*ROOT*/ THEN ram.MemberType_ID ELSE @MemberType_Leaf END -- All new permissions are for Leaf members (no consolidated members in new RDH), except for the ROOT node  
            ,ram.Member_ID  
            ,ram.Description  
            ,ram.EnterDTM  
            ,ram.EnterUserID  
            ,ram.LastChgDTM  
            ,ram.LastChgUserID  
        FROM mdm.tblSecurityRoleAccessMember ram  
        INNER JOIN #EH_ConversionLog cl  
        ON ram.ExplicitHierarchy_ID = cl.ExplicitHierarchy_ID;  
  
  
        -- Optionally delete the EH and consolidated members that were copied.  
        IF (@DeleteOriginals = 1)  
        BEGIN  
  
PRINT CONCAT(SYSDATETIME(), N': Deleting object permissions');  
            DELETE sra  
            FROM mdm.tblSecurityRoleAccess sra  
            INNER JOIN #ObjectPermissionMapping opm  
            ON sra.ID = opm.OldRow_ID  
            WHERE opm.OldObject_ID <> @ObjectType_Entity -- Leave the original entity permission(s)  
  
PRINT CONCAT(SYSDATETIME(), N': Deleting attribute groups');  
            DELETE ag  
            FROM mdm.tblAttributeGroup ag  
            INNER JOIN #AttributeGroupMapping agm  
            ON ag.ID = agm.OldAttributeGroup_ID;  
  
            -- Delete collections  
            DECLARE @EntityIds mdm.IdList;  
            INSERT INTO @EntityIds  
            SELECT Entity_ID ID  
            FROM @EntityInfo  
            EXEC mdm.udpCollectionTablesDrop @EntityIds  
  
PRINT CONCAT(SYSDATETIME(), N': Deleting explicit hierarchies (includes consolidated members and attributes)');  
  
            -- Delete any DHs that use any of the converted EHs as a cap. These DHs must be deleted before deleting the EHs.  
            DELETE FROM @ExplicitCapHierarchies;  
            INSERT INTO @ExplicitCapHierarchies  
            SELECT DISTINCT   
                 dh.ID  
                ,dh.Name  
            FROM mdm.tblDerivedHierarchy dh  
            INNER JOIN mdm.tblDerivedHierarchyDetail dhd  
            ON dh.ID = dhd.DerivedHierarchy_ID  
            INNER JOIN @ExplicitHierarchies eh  
            ON      dhd.ForeignType_ID = @HierarchyItemType_ExplicitHierarchy  
                AND dhd.Foreign_ID = eh.ExplicitHierarchy_ID;  
  
            SET @DerivedHierarchy_ID = 0;  
            WHILE EXISTS (SELECT 1 FROM @ExplicitCapHierarchies)  
            BEGIN  
                -- Get the next DH in the list.  
                SELECT TOP 1  
                    @DerivedHierarchy_ID = DerivedHierarchy_ID  
                FROM @ExplicitCapHierarchies;  
                DELETE FROM @ExplicitCapHierarchies WHERE @DerivedHierarchy_ID = DerivedHierarchy_ID;  
  
                -- Delete the DH.  
PRINT CONCAT(SYSDATETIME(), N': Deleting explicit cap DH with ID = ', @DerivedHierarchy_ID);  
                EXEC mdm.udpDerivedHierarchyDelete @ID = @DerivedHierarchy_ID;  
            END; -- WHILE (loop through each explicit cap DHs and delete it)  
  
            -- Delete the converted EHs.  
            SET @ExplicitHierarchy_ID = 0;  
            WHILE EXISTS (SELECT 1 FROM @ExplicitHierarchies WHERE ExplicitHierarchy_ID > @ExplicitHierarchy_ID)  
            BEGIN  
                SELECT TOP 1  
                     @ExplicitHierarchy_ID = ExplicitHierarchy_ID  
                    ,@Entity_ID = Entity_ID  
                FROM @ExplicitHierarchies  
                WHERE ExplicitHierarchy_ID > @ExplicitHierarchy_ID  
                ORDER BY ExplicitHierarchy_ID;  
  
PRINT CONCAT(SYSDATETIME(), N': Deleting EH with ID = ', @ExplicitHierarchy_ID, ' in Entity ID = ', @Entity_ID);  
                EXEC mdm.udpEntityHierarchyDelete @User_ID = @User_ID, @Hierarchy_ID = @ExplicitHierarchy_ID;  
            END; -- WHILE (loop through each EH and delete it)  
        END; -- IF (delete originals)  
  
        --Commit only if we are not nested  
        IF @TranCounter = 0   
        BEGIN  
            COMMIT TRANSACTION;  
        END   
  
        -- Kickoff the service broker to process member security. This is done last to avoid bogging down the script.  
PRINT CONCAT(SYSDATETIME(), N': Process members security.');  
  
        -- Get the ids of all models with EHs that were converted.  
        DECLARE @Model_IDs TABLE  
        (  
            Model_ID INT PRIMARY KEY  
        );  
        INSERT INTO @Model_IDs  
        SELECT DISTINCT e.Model_ID  
        FROM @ExplicitHierarchies eh  
        INNER JOIN @EntityInfo e  
        ON eh.Entity_ID = e.Entity_ID  
  
        SET @Model_ID = 0;  
        DECLARE @ProcessNow BIT = 0;  
        WHILE EXISTS (SELECT 1 FROM @Model_IDs)  
        BEGIN  
            -- Get the next model from the list.  
            SELECT TOP 1  
                @Model_ID = Model_ID  
            FROM @Model_IDs   
            WHERE Model_ID > @Model_ID  
            ORDER BY Model_ID;  
  
            DELETE FROM @Model_IDs WHERE Model_ID = @Model_ID;  
  
PRINT CONCAT(SYSDATETIME(), N': Put message on service broker queue to process member security for model with ID = ', @Model_ID);  
            SET @ProcessNow = CASE WHEN NOT EXISTS (SELECT 1 FROM @Model_IDs) THEN 1 ELSE 0 END;-- Set the ProcessNow flag only when processing the last model.  
            -- Have the service broker queue kick off processing model security.  
            EXEC mdm.udpSecurityMemberProcessRebuildModel @Model_ID = @Model_ID, @ProcessNow = @ProcessNow;  
        END -- WHILE (loop through model ids, to process member security)  
  
PRINT CONCAT(SYSDATETIME(), N': Done');  
    END TRY  
    BEGIN CATCH  
        -- Get error info.  
        DECLARE  
            @ErrorMessage NVARCHAR(4000),  
            @ErrorSeverity INT,  
            @ErrorState INT,  
            @ErrorNumber INT,  
            @ErrorLine INT,  
            @ErrorProcedure NVARCHAR(126);  
        EXEC mdm.udpGetErrorInfo  
            @ErrorMessage = @ErrorMessage OUTPUT,  
            @ErrorSeverity = @ErrorSeverity OUTPUT,  
            @ErrorState = @ErrorState OUTPUT,  
            @ErrorNumber = @ErrorNumber OUTPUT,  
            @ErrorLine = @ErrorLine OUTPUT,  
            @ErrorProcedure = @ErrorProcedure OUTPUT  
  
        SET @ErrorMessage = CONCAT(@ErrorMessage, N', @ErrorNumber = ', @ErrorNumber, N', @ErrorProcedure = "', @ErrorProcedure, N'", line ', @ErrorLine);  
  
        -- Roll back the transaction.  
        IF @TranCounter = 0   
            ROLLBACK TRANSACTION;  
        ELSE IF XACT_STATE() <> -1   
            ROLLBACK TRANSACTION TX;  
  
        RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);  
  
    END CATCH  
  
    -- Send the message  
	EXEC mdm.udpPerformanceQueueSave;  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpCreateAllSubscriptionViews]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    DECLARE @Entity_ID INT;  
    SET @Entity_ID = 72;  
    EXEC mdm.udpCreateAllSubscriptionViews NULL, @Entity_ID;  
      
  
    EXEC mdm.udpCreateAllSubscriptionViews;  
  
*/  
CREATE PROCEDURE [mdm].[udpCreateAllSubscriptionViews]  
(  
    @Model_ID   INT = NULL,  
    @Entity_ID  INT = NULL,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON;  
  
        --    IF EXISTS(SELECT * FROM [mdm].[tblSubscriptionView] WHERE @Entity_ID IS NULL OR Entity_ID = @Entity_ID)  
        --BEGIN  
        DECLARE @SubscriptionViewID       INT,   
                @ViewEntity_ID            INT,  
                @DerivedHierarchy_ID      INT,  
                @ViewFormat_ID            INT,  
                @ModelVersion_ID          INT,  
                @ModelVersionFlag_ID      INT,  
                @SubscriptionViewName     SYSNAME,  
                @Levels                   SMALLINT,  
                @IncludeSoftDeletedMembers BIT;  
  
        --Table variable we use to iterate through subscription views  
        DECLARE @subscriptionViews TABLE     
        (    
            ID                  INT PRIMARY KEY NOT NULL,      
            Entity_ID           INT NULL,  
            DerivedHierarchy_ID INT NULL,  
            ViewFormat_ID       INT NOT NULL,  
            ModelVersion_ID     INT NULL,  
            ModelVersionFlag_ID INT NULL,  
            Name                SYSNAME NOT NULL,  
            Levels              SMALLINT NULL,  
            IncludeSoftDeletedMembers BIT NOT NULL  
        );            
              
        --Fill out the temp table with the subscription view definitions  
        INSERT INTO @subscriptionViews  
        (  
             ID  
            ,Entity_ID  
            ,DerivedHierarchy_ID  
            ,ViewFormat_ID  
            ,ModelVersion_ID  
            ,ModelVersionFlag_ID  
            ,Name  
            ,Levels  
            ,IncludeSoftDeletedMembers  
        )  
        SELECT   
             sv.ID  
            ,sv.Entity_ID  
            ,sv.DerivedHierarchy_ID  
            ,sv.ViewFormat_ID  
            ,sv.ModelVersion_ID  
            ,sv.ModelVersionFlag_ID  
            ,sv.Name  
            ,CONVERT(SMALLINT, sv.Levels)  
            ,sv.IncludeSoftDeletedMembers  
        FROM mdm.tblSubscriptionView sv  
        INNER JOIN mdm.tblEntity e   
        ON sv.Entity_ID = e.ID  
        WHERE   (@Entity_ID IS NULL OR sv.Entity_ID = @Entity_ID)  
            AND (@Model_ID IS NULL OR e.Model_ID = e.Model_ID);  
  
        --Iterate through the subscription view definitions  
        WHILE EXISTS(SELECT 1 FROM @subscriptionViews)   
        BEGIN  
  
            SELECT TOP 1  
                @SubscriptionViewID = ID,  
                @ViewEntity_ID = Entity_ID,  
                @DerivedHierarchy_ID = DerivedHierarchy_ID,  
                @ViewFormat_ID = ViewFormat_ID,  
                @ModelVersion_ID = ModelVersion_ID,  
                @ModelVersionFlag_ID = ModelVersionFlag_ID,  
                @SubscriptionViewName = Name,  
                @Levels = Levels,  
                @IncludeSoftDeletedMembers = IncludeSoftDeletedMembers  
            FROM @subscriptionViews  
            ORDER BY ID;    
  
            --Call udpCreateSubscriptionViews to create each view  
            --The SPROCS udpCreateSubscriptionViews calls are smart enough to ALTER (instead of CREATE) if the view already exists  
            -- so there is no risk of us trying to recreate an existing view  
            EXEC mdm.udpCreateSubscriptionViews @SubscriptionViewID, @ViewEntity_ID, @DerivedHierarchy_ID, @ModelVersion_ID, @ModelVersionFlag_ID, @ViewFormat_ID, @Levels, @SubscriptionViewName, @IncludeSoftDeletedMembers;  
  
            DELETE FROM @subscriptionViews WHERE ID = @SubscriptionViewID  
  
        END; -- WHILE  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpCreateAllViews]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
    This SPROC recreates all views, including subscription views  
  
	EXEC mdm.udpCreateAllViews;  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpCreateAllViews]  
(  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
	SET NOCOUNT ON;  
  
	--Defer view generation if we are in the middle of an upgrade or demo-rebuild  
	IF APPLOCK_MODE(N'public', N'DeferViewGeneration', N'Session') = N'NoLock' BEGIN  
		DECLARE @TempTable 	TABLE (RowNumber INT IDENTITY (1, 1) PRIMARY KEY CLUSTERED NOT NULL , ID INT NOT NULL);  
		DECLARE @TempID 	INT;  
  
		INSERT INTO @TempTable SELECT ID FROM mdm.tblModel ORDER BY ID DESC;  
  
		DECLARE @Counter INT = 1;  
		DECLARE @MaxCounter INT = (SELECT MAX(RowNumber) FROM @TempTable);  
		  
		WHILE @Counter <= @MaxCounter  
		BEGIN  
			SELECT @TempID = ID FROM @TempTable WHERE [RowNumber] = @Counter;  
			  
			EXEC mdm.udpCreateViews @TempID;  
  
			SET @Counter = @Counter +1;  
		END; --while  
		  
		DELETE FROM @TempTable  
		--DONT reset @counter since it's used below		  
		--Create Derived Hierachy Views  
		INSERT INTO @TempTable SELECT ID FROM mdm.tblDerivedHierarchy;  
		SELECT @MaxCounter =MAX(RowNumber) FROM @TempTable;  
		  
		WHILE @Counter <= @MaxCounter  
		BEGIN  
			SELECT @TempID = ID FROM @TempTable WHERE [RowNumber] = @Counter  
  
			EXEC mdm.udpCreateSystemDerivedHierarchyParentChildView @TempID;  
  
			SET @Counter = @Counter +1;  
  
		END; --while  
  
        -- Regenerate subscription views if there are any  
        IF EXISTS(SELECT * FROM [mdm].[tblSubscriptionView])  
        BEGIN  
            DECLARE @SubscriptionViewID       INT,   
                    @ViewEntity_ID            INT,  
                    @ViewModel_ID             INT,  
                    @DerivedHierarchy_ID      INT,  
                    @ViewFormat_ID            INT,  
                    @ModelVersion_ID          INT,  
                    @ModelVersionFlag_ID      INT,  
                    @SubscriptionViewName     sysname,  
                    @Levels                   SMALLINT,  
                    @IncludeSoftDeletedMembers BIT;  
  
            --Table variable we use to iterate through subscription views  
            DECLARE @subscriptionViews TABLE     
            (    
                  ID                  INT NOT NULL,      
                  Entity_ID           INT NULL,  
                  Model_ID            INT NOT NULL,  
                  DerivedHierarchy_ID INT NULL,  
                  ViewFormat_ID       INT NOT NULL,  
                  ModelVersion_ID     INT NULL,  
                  ModelVersionFlag_ID INT NULL,  
                  Name                sysname NOT NULL,  
                  Levels              SMALLINT NULL,  
                  IncludeSoftDeletedMembers BIT NOT NULL  
            );            
              
            --Fill out the temp table with the subscription view definitions  
            INSERT INTO @subscriptionViews  
            (  
                ID, Entity_ID, Model_ID, DerivedHierarchy_ID, ViewFormat_ID, ModelVersion_ID, ModelVersionFlag_ID, Name, Levels, IncludeSoftDeletedMembers  
            )  
            SELECT   
                ID,  
                Entity_ID,  
                Model_ID,  
                DerivedHierarchy_ID,  
                ViewFormat_ID,  
                ModelVersion_ID,  
                ModelVersionFlag_ID,  
                Name,  
                CONVERT(SMALLINT, Levels),  
                IncludeSoftDeletedMembers  
            FROM   
            [mdm].[tblSubscriptionView];  
  
            --Iterate through the subscription view definitions  
            WHILE EXISTS(SELECT 1 FROM @subscriptionViews) BEGIN  
  
                SELECT TOP 1  
                    @SubscriptionViewID = ID,  
                    @ViewEntity_ID = Entity_ID,  
                    @ViewModel_ID = Model_ID,  
                    @DerivedHierarchy_ID = DerivedHierarchy_ID,  
                    @ViewFormat_ID = ViewFormat_ID,  
                    @ModelVersion_ID = ModelVersion_ID,  
                    @ModelVersionFlag_ID = ModelVersionFlag_ID,  
                    @SubscriptionViewName = Name,  
                    @Levels = Levels,  
                    @IncludeSoftDeletedMembers = IncludeSoftDeletedMembers  
                FROM @subscriptionViews  
                ORDER BY ID;    
  
                --Call udpCreateSubscriptionViews to create each view  
                --The SPROCS udpCreateSubscriptionViews calls are smart enough to ALTER (instead of CREATE) if the view already exists  
                -- so there is no risk of us trying to recreate an existing view  
                EXEC [mdm].[udpCreateSubscriptionViews] @SubscriptionViewID, @ViewEntity_ID, @DerivedHierarchy_ID, @ModelVersion_ID, @ModelVersionFlag_ID, @ViewFormat_ID, @Levels, @SubscriptionViewName, @IncludeSoftDeletedMembers;  
  
                DELETE FROM @subscriptionViews WHERE ID = @SubscriptionViewID  
  
            END; -- WHILE  
        END; --IF EXISTS(SELECT * FROM [mdm].[tblSubscriptionView])  
  
	END; --if  
  
	SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpCreateAttributeViews]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    EXEC mdm.udpCreateAttributeViews 1, 1, 1, 1, NULL, 'TEST';  
    EXEC mdm.udpCreateAttributeViews 1, 2, 1, 1, NULL, 'TEST';  
    EXEC mdm.udpCreateAttributeViews 1, 3, 1, NULL, 9, 'TEST';  
    EXEC mdm.udpCreateAttributeViews 111111, 1; --invalid  
*/  
CREATE PROCEDURE [mdm].[udpCreateAttributeViews]   
(  
    @Entity_ID                 INT,  
    @MemberType_ID             TINYINT,  
    @Version_ID                 INT ,  
    @VersionFlag_ID             INT,  
    @SubscriptionViewName      SYSNAME,  
    @IncludeSoftDeletedMembers BIT,  
    @CorrelationID             UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE  
        @MemberType_Leaf                TINYINT = 1,  
        @MemberType_Consolidated        TINYINT = 2,  
        @MemberType_Collection          TINYINT = 3;  
  
    --Defer view generation if we are in the middle of an upgrade or demo-rebuild  
    IF APPLOCK_MODE(N'public', N'DeferViewGeneration', N'Session') = N'NoLock'   
    BEGIN  
  
        DECLARE @ViewName               SYSNAME,  
                @EntityTable            SYSNAME,  
                @HierarchyTable         SYSNAME,  
                @HierarchyParentTable   SYSNAME,  
                @CollectionTable        SYSNAME,  
                @Select                 NVARCHAR(MAX) = N'',  
                @From                   NVARCHAR(MAX) = N'',  
                @ViewColumn             nvarchar(120), --specifically made to be less than 128 for truncation reasons  
                @TableColumn            SYSNAME,  
                @DomainTable            SYSNAME,  
                @DomainEntity_ID        INT,  
                @AttributeType_ID       INT,  
                @MainTable              SYSNAME;  
              
        SELECT  
            @EntityTable = EntityTable,  
            @CollectionTable = CollectionTable,  
            @HierarchyTable = HierarchyTable,  
            @HierarchyParentTable = HierarchyParentTable,  
            @ViewName = @SubscriptionViewName  
        FROM mdm.tblEntity  
        WHERE   ID = @Entity_ID  
            -- Ensure that the specified member type is supported  
            AND CASE @MemberType_ID   
                    WHEN @MemberType_Leaf           THEN EntityTable -- EntityTable should never be null  
                    WHEN @MemberType_Consolidated   THEN HierarchyTable  
                    WHEN @MemberType_Collection     THEN CollectionTable  
                    END IS NOT NULL  
  
        IF @ViewName IS NULL --Ensure row actually exists  
        BEGIN  
            RAISERROR('MDSERR100010|The Parameters are not valid.', 16, 1);  
            RETURN(1);  
        END;  
          
        SELECT  
            @EntityTable = E.EntityTable,  
            @CollectionTable = E.CollectionTable,  
            @HierarchyTable = E.HierarchyTable,  
            @HierarchyParentTable = E.HierarchyParentTable,  
            @ViewName = @SubscriptionViewName  
        FROM mdm.tblEntity E   
        INNER JOIN mdm.tblModel M ON E.Model_ID = M.ID  
        WHERE E.ID = @Entity_ID;  
  
        DECLARE @ConflictingColumnName NVARCHAR(100);  
        --Get the Attributes for the Entity and then find the corresponding lookup table  
        DECLARE @TempTable TABLE(  
                ViewColumn          NVARCHAR(100) COLLATE database_default  
                ,TableColumn        SYSNAME COLLATE database_default  
                ,AttributeType_ID   INT  
                ,DomainEntity_ID    INT NULL  
                ,DomainTable        SYSNAME COLLATE database_default NULL  
                ,SortOrder          INT);  
        INSERT INTO @TempTable  
        SELECT  
            ViewColumn,  
            TableColumn,  
            AttributeType_ID,  
            DomainEntity_ID,  
            DomainTable,  
            SortOrder  
        FROM       
            mdm.udfEntityAttributesGetList(@Entity_ID, @MemberType_ID)   
        ORDER BY   
            SortOrder ASC;  
  
        SET @MainTable = CASE  
            WHEN @MemberType_ID = @MemberType_Leaf THEN @EntityTable--Leaf (EN)    
            WHEN @MemberType_ID = @MemberType_Collection THEN @CollectionTable --Collection (CN)   
            ELSE @HierarchyParentTable  --Consolidated (HP)   
            END;  
  
        WHILE EXISTS(SELECT 1 FROM @TempTable)   
        BEGIN  
          
            SELECT TOP 1   
                @ViewColumn = ViewColumn,  
                @TableColumn = TableColumn,  
                @AttributeType_ID = AttributeType_ID,  
                @DomainEntity_ID = DomainEntity_ID,  
                @DomainTable = DomainTable  
            FROM @TempTable  
            ORDER BY   
                SortOrder ASC;  
  
            IF @DomainEntity_ID IS NULL BEGIN   
                --Check for name validation, if there are some DBA which their _Code/_Name/_ID columns have conflicts with some FFA attribute names.            
                DECLARE @ViewColumnPrefix NVARCHAR(120) = CASE  
                    WHEN @ViewColumn LIKE N'%\_Code' ESCAPE N'\' THEN LEFT(@ViewColumn, LEN(@ViewColumn) - LEN(N'_Code'))  
                    WHEN @ViewColumn LIKE N'%\_Name' ESCAPE N'\' THEN LEFT(@ViewColumn, LEN(@ViewColumn) - LEN(N'_Name'))  
                    WHEN @ViewColumn LIKE N'%\_ID' ESCAPE N'\' THEN LEFT(@ViewColumn, LEN(@ViewColumn) - LEN(N'_ID'))  
                    ELSE NULL  
                    END;  
                IF (@ViewColumnPrefix IS NOT NULL)  
                BEGIN  
                    SELECT TOP 1 @ConflictingColumnName = Name   
                    FROM mdm.tblAttribute   
                    WHERE Entity_ID = @Entity_ID   
                        AND MemberType_ID = @MemberType_ID  
                        AND AttributeType_ID = 2 -- DBA  
                        AND Name = @ViewColumnPrefix;  
                    IF (@ConflictingColumnName IS NOT NULL)  
                    BEGIN        
                        RAISERROR('MDSERR100059|There are at least two attribute names in conflict in the existing or new subscription view. Free-form attribute names cannot start with an existing domain-based attribute name and end with "_Code", "_Name" or "_ID". Attribute names are: |%s|%s|', 16, 1, @ConflictingColumnName, @ViewColumn);  
                        RETURN;       
                    END  
                END  
                IF @ViewColumn = N'Owner_ID' AND @MemberType_ID = @MemberType_Collection   
                BEGIN --Collection  
                    SET @Select = CONCAT(@Select, N'  
    ,', QUOTENAME(@ViewColumn), N'.UserName AS [Owner_ID]');  
                    SET @From = CONCAT(@From, N'  
LEFT JOIN mdm.tblUser AS Owner_ID ON Owner_ID.ID = T.Owner_ID');  
                END ELSE   
                BEGIN  
                    SET @Select = CONCAT(@Select, N'  
    ,T.', QUOTENAME(@TableColumn), N' AS ', QUOTENAME(@ViewColumn));  
                END; --if  
  
            END ELSE   
            BEGIN  
                --Check for name validation, if there are some DBA which their _Code/_Name/_ID columns have conflicts with some FFA attribute names.    
                SELECT TOP 1 @ConflictingColumnName = Name   
                FROM mdm.tblAttribute   
                WHERE Entity_ID = @Entity_ID   
                    AND MemberType_ID = @MemberType_ID  
                    AND AttributeType_ID = 1 -- Freeform  
                    AND (  Name = @ViewColumn + N'_Code'   
                        OR Name = @ViewColumn + N'_Name'   
                        OR Name = @ViewColumn + N'_ID' );  
                IF (@ConflictingColumnName IS NOT NULL)  
                BEGIN        
                    RAISERROR('MDSERR100059|There are at least two attribute names in conflict in the existing or new subscription view. Free-form attribute names cannot start with an existing domain-based attribute name and end with "_Code", "_Name" or "_ID". Attribute names are: |%s|%s|', 16, 1, @ConflictingColumnName, @ViewColumn);  
                    RETURN;       
                END  
                SET @Select = CONCAT(@Select, N'  
    ,', QUOTENAME(@ViewColumn), N'.Code AS ', QUOTENAME(@ViewColumn + N'_Code'), N'  
    ,', QUOTENAME(@ViewColumn), N'.Name AS ', QUOTENAME(@ViewColumn + N'_Name'), N'  
    ,T.', QUOTENAME(@TableColumn), N' AS ', QUOTENAME(@ViewColumn + N'_ID'));  
                     
                SET @From = CONCAT(@From, N'  
LEFT JOIN mdm.', QUOTENAME(@DomainTable), N' AS ', QUOTENAME(@ViewColumn), N' ON ', QUOTENAME(@ViewColumn), N'.ID = T.', QUOTENAME(@TableColumn), N'  
    AND ', QUOTENAME(@ViewColumn), N'.Version_ID = T.Version_ID')  
  
                END; --if  
  
                DELETE FROM @TempTable WHERE ViewColumn = @ViewColumn;  
  
            END; --while  
  
            SET @Select = CONCAT(CASE   
                WHEN EXISTS(SELECT 1 FROM sys.views WHERE [name] = @ViewName AND [schema_id] = SCHEMA_ID('mdm')) THEN N'ALTER'  
                ELSE N'CREATE' END, N' VIEW mdm.', QUOTENAME(@ViewName), N'  
/*WITH ENCRYPTION*/  
AS SELECT   
     T.ID AS ID  
    ,T.MUID AS MUID   
    ,V.Name AS VersionName  
    ,V.Display_ID AS VersionNumber  
    ,V.ID AS Version_ID  
    ,DV.Name AS VersionFlag',  
                CASE WHEN @MemberType_ID = @MemberType_Consolidated THEN N'  
    ,H.Name as Hierarchy' END, @Select, N'  
    ,T.EnterDTM AS EnterDateTime  
    ,UE.UserName AS EnterUserName  
    ,(SELECT Display_ID FROM mdm.tblModelVersion WHERE ID = T.EnterVersionID) AS EnterVersionNumber  
    ,T.LastChgDTM AS LastChgDateTime  
    ,UC.UserName AS LastChgUserName  
    ,(SELECT Display_ID FROM mdm.tblModelVersion WHERE ID = T.LastChgVersionID) AS LastChgVersionNumber  
    ,LV.ListOption AS ValidationStatus',  
                CASE WHEN @IncludeSoftDeletedMembers = 1 THEN N'  
    ,LS.ListOption AS State' END, N'  
FROM mdm.', QUOTENAME(@MainTable), N' AS T  
INNER JOIN mdm.tblModelVersion AS V ON V.ID = T.Version_ID ',  
                CASE @MemberType_ID   
                    WHEN @MemberType_Consolidated THEN N'  
INNER JOIN mdm.tblHierarchy H ON H.ID = T.Hierarchy_ID'  
                    WHEN @MemberType_Collection THEN N'AND V.Status_ID <> 0'   
                    END,   
                @From,  
                CASE WHEN @IncludeSoftDeletedMembers = 1 THEN N'  
LEFT JOIN mdm.tblList LS ON LS.OptionID = T.Status_ID AND LS.ListCode = ''lstStatus'''  
                    END, N'  
LEFT JOIN mdm.tblUser UE ON T.EnterUserID = UE.ID  
LEFT JOIN mdm.tblUser UC ON T.LastChgUserID = UC.ID   
LEFT JOIN mdm.tblList LV ON LV.OptionID = T.ValidationStatus_ID AND LV.ListCode = ''lstValidationStatus''   
LEFT JOIN mdm.tblModelVersionFlag AS DV ON DV.ID =  V.VersionFlag_ID  
WHERE V.',      CASE   
                    WHEN (@Version_ID IS NOT NULL)     THEN CONCAT(N'ID = ', @Version_ID)  
                    WHEN (@VersionFlag_ID IS NOT NULL) THEN CONCAT(N'VersionFlag_ID = ', @VersionFlag_ID)  
                    END,   
                CASE WHEN @IncludeSoftDeletedMembers = 0 THEN N'  
    AND T.Status_ID = 1' END, -- otherwise all the members are included regardless of their Status_ID  
                    N';');  
  
            --PRINT(@Select);  
            EXEC sp_executesql @Select;  
  
    END; --if  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpCreateCollectionViews]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    EXEC mdm.udpCreateCollectionViews 1,1,1, 'test';  
    EXEC mdm.udpCreateCollectionViews 5111; --invalid  
  
*/  
CREATE PROCEDURE [mdm].[udpCreateCollectionViews]   
(  
    @Entity_ID			 INT,  
    @Version_ID          INT ,  
    @VersionFlag_ID      INT,  
    @SubscriptionViewName sysname,  
    @IncludeSoftDeletedMembers BIT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    --Defer view generation if we are in the middle of an upgrade or demo-rebuild  
    IF APPLOCK_MODE(N'public', N'DeferViewGeneration', N'Session') = N'NoLock' BEGIN  
  
        DECLARE @EntityTable  			sysname,  
                @HierarchyParentTable  	sysname,  
                @IsHierarchyEnabled      BIT,  
                @CollectionTable 		sysname,  
                @CollectionMemberTable	sysname,  
                @SQL					NVARCHAR(MAX),  
                @ViewName				sysname;  
  
        --Initialize the variables  
        SELECT  
            @EntityTable = EntityTable,  
            @HierarchyParentTable = HierarchyParentTable,  
            @IsHierarchyEnabled = CASE WHEN HierarchyParentTable IS NULL THEN 0 ELSE 1 END,  
            @CollectionTable = CollectionTable,  
            @CollectionMemberTable = CollectionMemberTable,  
            @ViewName = @SubscriptionViewName  
        FROM mdm.tblEntity  
        WHERE   ID = @Entity_ID  
            AND CollectionTable IS NOT NULL -- Only get entities that support collections  
  
        --Test for invalid parameters  
        IF @ViewName IS NULL -- Could mean that @Entity_ID and/or @SubscriptionViewName was invalid   
            OR (@Version_ID IS NOT NULL AND NOT EXISTS(SELECT ID FROM mdm.tblModelVersion WHERE ID = @Version_ID)) -- Invalid @Version_ID  
        BEGIN  
            RAISERROR('MDSERR100010|The Parameters are not valid.', 16, 1);  
            RETURN;  
        END; --if  
          
        SET @SQL = N'  
            /*WITH ENCRYPTION*/  
            AS SELECT  
                V.Name          AS VersionName,  
                V.Display_ID    AS VersionNumber,  
                DV.Name         AS VersionFlag,  
                CN.Code         AS Code,  
                CN.Name         AS Name,  
                CASE CM.ChildType_ID  
                    WHEN 1 THEN E.Code' +  
            CASE @IsHierarchyEnabled WHEN 1 THEN N'  
                    WHEN 2 THEN HP.Code' ELSE N'' END + N'  
                    WHEN 3 THEN CN2.Code  
                END             AS MemberCode,   
                CASE CM.ChildType_ID  
                    WHEN 1 THEN E.Name ' +  
            CASE @IsHierarchyEnabled WHEN 1 THEN N'  
                    WHEN 2 THEN HP.Name' ELSE N'' END + N'  
                    WHEN 3 THEN CN2.Name   
                END             AS MemberName,  
                CONVERT(DECIMAL(18,2), CM.Weight) AS Weight,  
                CM.SortOrder    AS SortOrder,  
                CN.EnterDTM     AS EnterDateTime  
                ,UE.UserName    AS EnterUserName  
                ,VE.Display_ID  AS EnterVersionNumber  
                ,CN.LastChgDTM AS LastChgDateTime  
                ,UC.UserName AS LastChgUserName  
                ,VC.Display_ID  AS LastChgVersionNumber' +  
                CASE WHEN @IncludeSoftDeletedMembers = 1 THEN N'  
                ,L.ListOption AS State' ELSE N'' END + N'  
            FROM   
                mdm.' + quotename(@CollectionTable) + N' AS CN  
            INNER JOIN mdm.' + quotename(@CollectionMemberTable) + N' AS CM   
                ON CN.ID = CM.Parent_CN_ID  
                AND CN.Version_ID = CM.Version_ID   
                AND CN.Status_ID = CM.Status_ID   
            INNER JOIN mdm.tblModelVersion V ON CN.Version_ID = V.ID '  
        --Restrict by Version or Version Flag  
        IF (@Version_ID IS NOT NULL)  
        BEGIN   
            SET @SQL = @SQL + N'   
                AND V.ID = ' + CAST(@Version_ID AS NVARCHAR(50))   
        END  
        ELSE IF (@VersionFlag_ID IS NOT NULL) BEGIN  
            SET @SQL = @SQL + N'   
                AND V.VersionFlag_ID = ' + CAST(@VersionFlag_ID AS NVARCHAR(50))   
        END  
  
        SET @SQL = @SQL + N'   
            LEFT JOIN mdm.tblUser UE ON CN.EnterUserID = UE.ID  
            LEFT JOIN mdm.tblUser UC ON CN.LastChgUserID = UC.ID   
            LEFT JOIN mdm.tblModelVersion VE ON CN.EnterVersionID = VE.ID  
            LEFT JOIN mdm.tblModelVersion VC ON CN.LastChgVersionID = VC.ID  
            LEFT JOIN mdm.tblModelVersionFlag AS DV ON DV.ID = V.VersionFlag_ID';  
  
        IF @IncludeSoftDeletedMembers = 0  
        BEGIN  
            SET @SQL += N'  
            LEFT JOIN mdm.' + quotename(@EntityTable) + N' AS E   
                ON CM.Child_EN_ID = E.ID   
                AND CM.Version_ID = E.Version_ID   
                AND E.Version_ID = CN.Version_ID  
                AND CM.Parent_CN_ID = CN.ID  
                AND CM.ChildType_ID = 1   
                AND E.Status_ID = 1' +  
                CASE @IsHierarchyEnabled WHEN 1 THEN N'    
            LEFT JOIN mdm.' + quotename(@HierarchyParentTable) + N' AS HP   
                ON CM.Child_HP_ID = HP.ID   
                AND CM.Version_ID = HP.Version_ID   
                AND HP.Version_ID = CN.Version_ID  
                AND CM.Parent_CN_ID = CN.ID   
                AND CM.ChildType_ID = 2   
                AND HP.Status_ID = 1' ELSE N'' END + N'  
            LEFT JOIN mdm.' + quotename(@CollectionTable) + N' AS CN2   
                ON CM.Child_CN_ID = CN2.ID    
                AND CM.Version_ID = CN2.Version_ID   
                AND CN2.Version_ID = CN.Version_ID   
                AND CM.Parent_CN_ID = CN.ID   
                AND CM.ChildType_ID = 3   
                AND CN2.Status_ID = 1  
            WHERE   
                CN.Status_ID = 1   
                AND (   E.ID IS NOT NULL' +   
                CASE @IsHierarchyEnabled WHEN 1 THEN N'   
                        OR HP.ID IS NOT NULL ' ELSE N'' END + N'   
                        OR CN2.ID IS NOT NULL);';  
        END  
        ELSE -- no Status_ID = 1 filtering  
        BEGIN  
            SET @SQL += N'  
            LEFT JOIN mdm.tblList L ON L.OptionID = CN.Status_ID AND L.ListCode = ''lstStatus''      
            LEFT JOIN mdm.' + quotename(@EntityTable) + N' AS E   
                ON CM.Child_EN_ID = E.ID   
                AND CM.Version_ID = E.Version_ID   
                AND E.Version_ID = CN.Version_ID  
                AND CM.Parent_CN_ID = CN.ID  
                AND CM.ChildType_ID = 1' +  
                CASE @IsHierarchyEnabled WHEN 1 THEN N'    
            LEFT JOIN mdm.' + quotename(@HierarchyParentTable) + N' AS HP   
                ON CM.Child_HP_ID = HP.ID   
                AND CM.Version_ID = HP.Version_ID   
                AND HP.Version_ID = CN.Version_ID  
                AND CM.Parent_CN_ID = CN.ID   
                AND CM.ChildType_ID = 2' ELSE N'' END + N'  
            LEFT JOIN mdm.' + quotename(@CollectionTable) + N' AS CN2   
                ON CM.Child_CN_ID = CN2.ID    
                AND CM.Version_ID = CN2.Version_ID   
                AND CN2.Version_ID = CN.Version_ID   
                AND CM.Parent_CN_ID = CN.ID   
                AND CM.ChildType_ID = 3   
            WHERE   
                    E.ID IS NOT NULL ' +   
                CASE @IsHierarchyEnabled WHEN 1 THEN N'   
                        OR HP.ID IS NOT NULL ' ELSE N'' END + N'   
                        OR CN2.ID IS NOT NULL;';  
        END;  
  
        SET @SQL = CASE   
            WHEN EXISTS(SELECT 1 FROM sys.views WHERE [name] = @ViewName AND [schema_id] = SCHEMA_ID('mdm')) THEN N'ALTER'  
            ELSE N'CREATE' END + N' VIEW mdm.' + quotename(@ViewName)  
            + @SQL;  
  
        --PRINT(@SQL);  
        EXEC sp_executesql @SQL;  
  
    END; --if  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpCreateDerivedHierarchyLevelView]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    EXEC mdm.udpCreateDerivedHierarchyLevelView 1,1,1,1,NULL,' TEST';  
      
*/  
 CREATE PROCEDURE [mdm].[udpCreateDerivedHierarchyLevelView]    
 (  
    @DerivedHierarchy_ID INT,   
    @Levels INT,   
    @Version_ID INT,   
    @VersionFlag_ID INT=NULL,   
    @SubscriptionViewName [sysname]  ,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
 )  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN   
    
    SET NOCOUNT ON;    
    
    --Defer view generation if we are in the middle of an upgrade or demo-rebuild    
    IF APPLOCK_MODE(N'public', N'DeferViewGeneration', N'Session') = N'NoLock' BEGIN    
    
        DECLARE @ViewName                       sysname,  
                @EntitySQL                      NVARCHAR(MAX),  
                @SQL                            NVARCHAR(MAX),  
                @From                           NVARCHAR(MAX),  
                @Where                          NVARCHAR(MAX),  
                @ColumnList                     NVARCHAR(MAX),  
                @LeafID                         NVARCHAR(MAX),  
                @LeafName                       NVARCHAR(MAX),  
                @LeafCode                       NVARCHAR(MAX),  
                @ColumnListSelect               NVARCHAR(MAX),  
                @e                              NVARCHAR(200),  
                @ColumnName                     NVARCHAR(500),  
                @PriorColumnName                NVARCHAR(500),  
                @TempLookupViewName             NVARCHAR(500),  
                @HierarchyName                  NVARCHAR(50),  
                @VersionName                    NVARCHAR(50),  
                @VersionNumber                  NVARCHAR(50),  
                @VersionFlagName                NVARCHAR(50),  
                @LeafEntityName                 NVARCHAR(MAX),  
                @LeafEntityIDString             NVARCHAR(50),  
                @ColumnAlias                    NVARCHAR(100),  
                @HierarchyItemType_Hierarchy    INT,  
                @ColumnCounter                  INT,  
                @LeafCounter                    INT,  
                @LeafCounterString              NVARCHAR(3),  
                @HierarchyCounter               INT,  
                @MaxLevel                       INT,  
                @HierarchyLevels                INT,  
                @IsBasicDerivedHierarchy        BIT,   
                @Model_ID                       INT;  
  
        --Initialize the variables    
        SELECT     
            @ViewName = @SubscriptionViewName,   
            @HierarchyName = Name,  
            @EntitySQL = CAST(N'' AS NVARCHAR(max)),    
            @SQL = CAST(N'' AS NVARCHAR(max)),    
            @From = CAST(N'' AS NVARCHAR(max)),   
            @Where = CAST(N'' AS NVARCHAR(max)),  
            @LeafID = CAST(N'' AS NVARCHAR(max)),  
            @LeafName = CAST(N'' AS NVARCHAR(max)),  
            @LeafCode = CAST(N'' AS NVARCHAR(max)),  
            @TempLookupViewName = CONCAT(N'viw_SYSTEM_', Model_ID, N'_', ID, N'_PARENTCHILD_DERIVED'),  
            @ColumnList	= CAST(N'' AS NVARCHAR(max)),  
            @ColumnListSelect= CAST(N'' AS NVARCHAR(max)),  
            @ColumnName = CAST(N'' AS NVARCHAR(500)),  
            @PriorColumnName = CAST(N'' AS NVARCHAR(500)),  
            @e = OBJECT_NAME(@@PROCID),  
            @HierarchyItemType_Hierarchy = 2,  
            @MaxLevel = 99,  
            @HierarchyLevels = 1,  
            @IsBasicDerivedHierarchy = 1,  
            @Model_ID = Model_ID            
        FROM mdm.tblDerivedHierarchy  
        WHERE ID = @DerivedHierarchy_ID;   
          
        SET @VersionName	 = N''  
        SET @VersionNumber	 = N''  
        SET @VersionFlagName = N''  
         
        --Validate @DerivedHierarchy_ID    
        IF (@DerivedHierarchy_ID IS NULL OR @DerivedHierarchy_ID = 0 OR  
            NOT EXISTS (SELECT 1 FROM mdm.tblDerivedHierarchy WHERE ID = @DerivedHierarchy_ID))  
        BEGIN    
            RAISERROR('MDSERR100006|The DerivedHierarchy ID is not valid.', 16, 1);  
            RETURN;   
        END;    
        
        IF @ViewName IS NULL --Ensure row actually exists   
        BEGIN  
            RAISERROR('MDSERR100010|The Parameters are not valid.', 16, 1);  
            RETURN(1);  
        END;   
        ELSE  
        BEGIN  
            --Start transaction, being careful to check if we are nested    
            DECLARE @TranCounter INT;     
            SET @TranCounter = @@TRANCOUNT;    
            IF @TranCounter > 0 SAVE TRANSACTION TX;    
            ELSE BEGIN TRANSACTION;    
            
            BEGIN TRY      
                -- Check if we have a specialized hierarchy - e.g recursive or explicit cap  
                IF EXISTS ( --test for recursive query  
                            SELECT 1   
                            FROM mdm.viw_SYSTEM_SCHEMA_HIERARCHY_DERIVED_LEVELS  
                            WHERE   Hierarchy_ID = @DerivedHierarchy_ID  
                                AND IsRecursive = 1  
                            --Test for explicit cap  
                            UNION ALL  
                            SELECT 1   
                            FROM mdm.tblDerivedHierarchyDetail HD2  
                            WHERE HD2.ForeignType_ID = @HierarchyItemType_Hierarchy  
                                AND HD2.DerivedHierarchy_ID = @DerivedHierarchy_ID)   
                BEGIN  
                    SET @IsBasicDerivedHierarchy = 0;  
                END;  
                      
                    -- Limit the columns for the view to 99 ( Applies to Specialized Hierarchies only)  
                    IF @Levels > @MaxLevel SET @Levels = @MaxLevel;  
  
                    SET @ColumnListSelect = N'  
                            L0.Child_ID AS [[@ColumnAlias]_ID],  
                            L0.ChildCode AS [[@ColumnAlias]_Code],  
                            L0.ChildName AS [[@ColumnAlias]_Name],';  
                      
                    IF (@IsBasicDerivedHierarchy = 0) BEGIN  
                            SET  @ColumnListSelect = N'  
                            L0.ChildType_ID AS [[@ColumnAlias]_Type_ID],  
                            L0.Entity_ID AS [[@ColumnAlias]_Entity_ID],' + @ColumnListSelect;  
                    END --IF  
                              
                    IF (@IsBasicDerivedHierarchy = 1) BEGIN          
                            -- Get the Entity Name for Top Level ParentCode = 'ROOT'  
                            SELECT TOP 1  
                                @ColumnAlias = COALESCE(dhd.DisplayName, CASE WHEN dhd.ForeignType_ID = 0 THEN e.Name ELSE e2.Name END),  
                                @HierarchyCounter = dhd.Level_ID  
                            FROM mdm.tblDerivedHierarchyDetail dhd   
                                LEFT JOIN mdm.tblEntity e ON dhd.Foreign_ID = e.ID  
                                LEFT JOIN mdm.tblAttribute a ON dhd.Foreign_ID = a.ID  
                                LEFT JOIN mdm.tblEntity e2 ON a.DomainEntity_ID = e2.ID  
                            WHERE  
                                dhd.DerivedHierarchy_ID = @DerivedHierarchy_ID AND  
                                dhd.IsVisible = 1  
                            ORDER BY dhd.Level_ID DESC;  
                              
                            -- Get the maximum visible levels in the Hierarchy  
                            SELECT @HierarchyLevels = COUNT(Level_ID)  
                            FROM mdm.tblDerivedHierarchyDetail D  
                            WHERE D.DerivedHierarchy_ID = @DerivedHierarchy_ID AND  
                                D.IsVisible = 1;  
  
                            IF (@ColumnAlias IS NULL)  
                            BEGIN  
                                RAISERROR('MDSERR100020|Cannot create derived levels subscription view. The derived hierarchy contains no levels.', 16, 1);  
                                RETURN;   
                            END  
                          
                            SET @ColumnListSelect = REPLACE(@ColumnListSelect, N'[@ColumnAlias]', @ColumnAlias);  
                              
                            -- Limit the columns for the view to the maximum visible level in the basic hierarchy  
                            IF @Levels > @HierarchyLevels SET @Levels = @HierarchyLevels;  
                              
                    END;  
                    ELSE BEGIN  
                        SET @ColumnListSelect = REPLACE(@ColumnListSelect, N'[@ColumnAlias]', 'L0');  
                    END;  
                      
                    SET @From = N'   
                        FROM mdm.' + @TempLookupViewName + N' L0  
                        INNER JOIN mdm.tblModelVersion AS V ON V.ID = L0.Version_ID  
                        LEFT JOIN mdm.tblModelVersionFlag AS VF on VF.ID = V.VersionFlag_ID'  
  
                    SET @Where = N'   
                        WHERE L0.ParentCode = ''ROOT''   
                          AND V.' +   
                                --Restrict by Version or Version Flag  
                                CASE   
                                    WHEN (@Version_ID IS NOT NULL)     THEN CONCAT(N'ID = ', @Version_ID)  
                                    WHEN (@VersionFlag_ID IS NOT NULL) THEN CONCAT(N'VersionFlag_ID = ', @VersionFlag_ID)  
                                    END  
  
                    SET @ColumnCounter = 1;  
          
                    -- Loop through the levels to build the columns   
                    WHILE @ColumnCounter < @Levels BEGIN  
                        SET @ColumnName = CAST( @ColumnCounter AS NVARCHAR(30));  
                        SET @PriorColumnName = CAST( (@ColumnCounter - 1) AS NVARCHAR(30));  
                        IF (@IsBasicDerivedHierarchy = 0) BEGIN-- Add ID for base entities.  
                             --only need for non standard derived hierarchies  
                            SET  @ColumnListSelect =  @ColumnListSelect + N'  
                            L[@ColumnName].ChildType_ID AS [[@ColumnAlias]_Type_ID],  
                            L[@ColumnName].Entity_ID AS [[@ColumnAlias]_Entity_ID],';  
                        END  
                            --all derived hierarchies have these columns  
                            SET @ColumnListSelect = @ColumnListSelect + N'  
                            L[@ColumnName].Child_ID AS [[@ColumnAlias]_ID],  
                            L[@ColumnName].ChildCode AS [[@ColumnAlias]_Code],  
                            L[@ColumnName].ChildName AS [[@ColumnAlias]_Name],';  
                      
                        SET @ColumnListSelect = Replace(@ColumnListSelect, '[@ColumnName]', @ColumnName);  
                          
                        IF (@IsBasicDerivedHierarchy = 1) BEGIN  
  
                            SET @ColumnAlias = NULL;  
                              
                            ---- Try to get the Entity Name for the current levels if it is visible  
                            SELECT TOP 1  
                                @ColumnAlias = COALESCE(dhd.DisplayName, CASE WHEN dhd.ForeignType_ID = 0 THEN e.Name ELSE e2.Name END),  
                                @HierarchyCounter = dhd.Level_ID  
                            FROM mdm.tblDerivedHierarchyDetail dhd   
                                LEFT JOIN mdm.tblEntity e ON dhd.Foreign_ID = e.ID  
                                LEFT JOIN mdm.tblAttribute a ON dhd.Foreign_ID = a.ID  
                                LEFT JOIN mdm.tblEntity e2 ON a.DomainEntity_ID = e2.ID  
                            WHERE  
                                dhd.DerivedHierarchy_ID = @DerivedHierarchy_ID AND  
                                dhd.IsVisible = 1 AND  
                                dhd.Level_ID < @HierarchyCounter  
                            ORDER BY dhd.Level_ID DESC;  
  
                            SET @ColumnListSelect = REPLACE(@ColumnListSelect, N'[@ColumnAlias]', @ColumnAlias);  
                                                          
                        END;  
                        ELSE BEGIN  
                            SET @ColumnListSelect = REPLACE(@ColumnListSelect, N'[@ColumnAlias]', N'L' + @ColumnName);  
                        END;  
                  
                        SET @From = @From + N'   
                            LEFT JOIN mdm.' + @TempLookupViewName + ' L[@ColumnName]  
                            ON  L[@ColumnName].Parent_ID = L[@PriorColumnName].Child_ID AND  
                                L[@ColumnName].ParentCode = L[@PriorColumnName].ChildCode AND  
                                (L[@ColumnName].ParentEntity_ID = L[@PriorColumnName].Entity_ID OR  
                                L[@ColumnName].Entity_ID = L[@PriorColumnName].NextEntity_ID) AND  
                                L[@ColumnName].Version_ID = L[@PriorColumnName].Version_ID'   
  
                        SET	@From = REPLACE(REPLACE(@From, 	'[@ColumnName]', @ColumnName), '[@PriorColumnName]', @PriorColumnName);  
                  
                        SET @ColumnCounter = @ColumnCounter + 1;  
                          
                    END;    
                    -- Remove the last comma  
                    SET @ColumnListSelect = SUBSTRING(@ColumnListSelect, 0, LEN(@ColumnListSelect));  
                      
                    --If this is a derived RECURSIVE or EXPLICIT CAP then add the EntityName_ID etc for leaf entities...  
                    IF @IsBasicDerivedHierarchy = 0 BEGIN  
                        SELECT @LeafEntityName = e.Name, @LeafEntityIDString = CAST(e.ID AS NVARCHAR(50))  
                        FROM mdm.tblEntity e  
                        INNER JOIN mdm.tblDerivedHierarchyDetail hd ON hd.Foreign_ID = e.ID  
                        WHERE hd.DerivedHierarchy_ID = @DerivedHierarchy_ID  
                          AND hd.Level_ID = 1;  
                            
                        SET @LeafID = N'  
                            COALESCE(NULL,';  
                        SET @LeafCode = @LeafID;  
                        SET @LeafName = @LeafID;  
                          
                        SET @LeafCounter = @Levels - 1;  
                        WHILE @LeafCounter>= 0 BEGIN  
                            SET @LeafCounterString = CONVERT(NVARCHAR(3),@LeafCounter);  
                            SET @LeafID += N'CASE WHEN L' + @LeafCounterString + N'.ChildType_ID = 1 AND L' + @LeafCounterString + N'.Entity_ID = ' + @LeafEntityIDString +	N' THEN L' + @LeafCounterString + N'.Child_ID ELSE NULL END'  
                            SET @LeafCode += N'CASE WHEN L' + @LeafCounterString + N'.ChildType_ID = 1 AND L' + @LeafCounterString + N'.Entity_ID = ' + @LeafEntityIDString +	N' 	THEN L' + @LeafCounterString + N'.ChildCode ELSE NULL END'  
                            SET @LeafName += N'CASE WHEN L' + @LeafCounterString + N'.ChildType_ID = 1 AND L' + @LeafCounterString + N'.Entity_ID = ' + @LeafEntityIDString +	N' 	THEN L' + @LeafCounterString + N'.ChildName ELSE NULL END'  
                            IF @LeafCounter <> 0 BEGIN  
                                SET @LeafID += N'  
                                       ,';  
                                SET @LeafCode += N'  
                                       ,';  
                                SET @LeafName += N'  
                                       ,';  
                            END;  
                              
                            SET @LeafCounter = @LeafCounter - 1;  
                        END;  
                        SET @LeafID += N') AS ' + QUOTENAME(@LeafEntityName + N'_ID') + N','  
                        SET @LeafCode += N') AS ' + QUOTENAME(@LeafEntityName + N'_Code') + N','  
                        SET @LeafName += N') AS ' + QUOTENAME(@LeafEntityName + N'_Name') + N','  
                              
                        SET @ColumnListSelect = @LeafID + @LeafCode + @LeafName + @ColumnListSelect;  
  
                        -- PRINT @ColumnListSelect;  
                    END;   
                    -- Build the SQL for the view data  
                    SELECT @SQL = N'SELECT V.Name AS VersionName,  
                                        V.Display_ID AS VersionNumber,   
                                        V.ID         AS Version_ID,  
                                        VF.Name AS VersionFlag,   
                                N' + QUOTENAME(@HierarchyName, N'''') + N' AS Hierarchy,   
                                N''ROOT'' AS [ROOT], ' +  
                                @ColumnListSelect +   
                                @From +  
                                @Where  
                              
                    SET @SQL = CASE   
                        WHEN EXISTS(SELECT 1 FROM sys.views WHERE [name] = @ViewName AND [schema_id] = SCHEMA_ID('mdm')) THEN N'ALTER '  
                        ELSE N'CREATE ' END + N'VIEW mdm.' + quotename(@ViewName) + N'  
                        AS '  
                        + @SQL;  
                          
                    -- PRINT @SQL;	  
                    EXEC sp_executesql @SQL;  
                      
                    --Commit only if we are not nested    
                    IF @TranCounter = 0 COMMIT TRANSACTION;    
    
            END TRY     
            --Compensate as necessary    
            BEGIN CATCH    
            
                -- Get error info.  
                DECLARE  
                    @ErrorMessage NVARCHAR(4000),  
                    @ErrorSeverity INT,  
                    @ErrorState INT,  
                    @ErrorNumber INT,  
                    @ErrorLine INT,  
                    @ErrorProcedure NVARCHAR(126);  
                EXEC mdm.udpGetErrorInfo  
                    @ErrorMessage = @ErrorMessage OUTPUT,  
                    @ErrorSeverity = @ErrorSeverity OUTPUT,  
                    @ErrorState = @ErrorState OUTPUT,  
                    @ErrorNumber = @ErrorNumber OUTPUT,  
                    @ErrorLine = @ErrorLine OUTPUT,  
                    @ErrorProcedure = @ErrorProcedure OUTPUT  
  
                SET @ErrorMessage = CONCAT(@ErrorMessage, N', @ErrorNumber = ', @ErrorNumber, N', @ErrorProcedure = "', @ErrorProcedure, N'", line ', @ErrorLine);  
                  
                IF @TranCounter = 0 ROLLBACK TRANSACTION;    
                ELSE IF XACT_STATE() <> -1 ROLLBACK TRANSACTION TX;    
            
                RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);    
            
            END CATCH;    
                          
        END;--if  
    END;    
    SET NOCOUNT OFF;    
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpCreateDerivedHierarchyParentChildView]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    EXEC mdm.udpCreateDerivedHierarchyParentChildView 1,1,1,'TEST';  
    EXEC mdm.udpCreateAllViews;  
*/  
CREATE PROCEDURE [mdm].[udpCreateDerivedHierarchyParentChildView]  
(  
    @DerivedHierarchy_ID    INT,  
    @Version_ID             INT,  
    @VersionFlag_ID         INT = NULL,  
    @SubscriptionViewName   SYSNAME,  
    @CorrelationID          UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability    
)    
WITH EXECUTE AS 'mds_schema_user'    
AS BEGIN    
    SET NOCOUNT ON;  
  
    --Defer view generation if we are in the middle of an upgrade or demo-rebuild    
    IF APPLOCK_MODE(N'public', N'DeferViewGeneration', N'Session') = N'NoLock'  
    BEGIN  
    
        DECLARE   
             @Model_ID       INT  
            ,@ViewLookupName SYSNAME;  
  
        SELECT  
            @Model_ID = Model_ID,  
            @ViewLookupName = CONCAT(N'viw_SYSTEM_', Model_ID, N'_', ID, N'_PARENTCHILD_DERIVED')  
        FROM mdm.tblDerivedHierarchy  
        WHERE ID = @DerivedHierarchy_ID;  
    
        IF     @Model_ID IS NULL --Invalid @DerivedHierarchy_ID    
            OR (@Version_ID IS NOT NULL     AND NOT EXISTS(SELECT ID FROM mdm.tblModelVersion       WHERE ID = @Version_ID)) --Invalid @Version_ID  
            OR (@VersionFlag_ID IS NOT NULL AND NOT EXISTS(SELECT ID FROM mdm.tblModelVersionFlag   WHERE ID = @VersionFlag_ID)) --Invalid @VersionFlag_ID  
            OR NULLIF(@SubscriptionViewName, N'') IS NULL --Must enter @SubscriptionViewName  
        BEGIN    
            RAISERROR('MDSERR100010|The Parameters are not valid.', 16, 1);  
            RETURN;  
        END    
  
        IF NOT EXISTS(SELECT 1 FROM mdm.tblDerivedHierarchyDetail WHERE DerivedHierarchy_ID = @DerivedHierarchy_ID)   
        BEGIN  
            -- Hierarchy has no levels, so nothing to do  
            RETURN;  
        END  
    
        DECLARE @SQL NVARCHAR(MAX) = CONCAT(CASE WHEN EXISTS(SELECT 1 FROM sys.views WHERE [name] = @SubscriptionViewName AND [schema_id] = SCHEMA_ID('mdm'))   
            THEN N'ALTER'  
            ELSE N'CREATE' END,   
            N' VIEW mdm.', QUOTENAME(@SubscriptionViewName), N'  
    /*WITH ENCRYPTION*/  
    AS  
    SELECT  
        V.Name          AS VersionName,  
        V.Display_ID    AS VersionNumber,  
        V.ID            AS Version_ID,  
        DV.Name         AS VersionFlag,  
        (SELECT [Name]  
            FROM mdm.tblDerivedHierarchy  
            WHERE ID = ', @DerivedHierarchy_ID, N') AS [Hierarchy],  
        ChildType_ID,  
        Child_ID,  
        ChildCode,  
        ChildName,  
        E.ID         AS Child_Entity_ID,  
        E.Name       AS Child_EntityName,  
        ParentType_ID,  
        Parent_ID,  
        ParentCode,  
        ParentName,  
        Epar.ID     AS Parent_Entity_ID,  
        Epar.Name   AS Parent_EntityName  
    FROM mdm.', QUOTENAME(@ViewLookupName), N' AS T  
    INNER JOIN mdm.[tblModelVersion] AS V  
    ON      V.ID = T.Version_ID');  
  
        --Restrict by Version or Version Flag    
        IF (@Version_ID IS NOT NULL)  
        BEGIN     
            SET @SQL += CONCAT(N'  
        AND V.ID = ', @Version_ID);  
        END    
        ELSE IF (@VersionFlag_ID IS NOT NULL)   
        BEGIN    
            SET @SQL += CONCAT(N'  
        AND V.VersionFlag_ID = ', @VersionFlag_ID);  
        END  
  
        SET @SQL += N'  
    LEFT JOIN mdm.[tblModelVersionFlag] AS DV  
    ON DV.ID = V.VersionFlag_ID  
    INNER JOIN mdm.[tblEntity] E  
    ON T.Entity_ID = E.ID  
    LEFT JOIN mdm.[tblEntity] Epar  
    ON T.ParentEntity_ID = Epar.ID;';  
  
        --PRINT @SQL;  
        EXEC sp_executesql @SQL;  
  
    END; --if  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpCreateDerivedHierarchyViews]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    EXEC mdm.udpCreateDerivedHierarchyViews 3;  
    EXEC mdm.udpCreateDerivedHierarchyViews 4;  
    EXEC mdm.udpCreateDerivedHierarchyViews 5;  
    SELECT * FROM mdm.tblModel;  
*/  
CREATE PROCEDURE [mdm].[udpCreateDerivedHierarchyViews]  
(  
    @Model_ID       INT,  
    @CorrelationID  UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON;  
  
    --Defer view generation if we are in the middle of an upgrade or demo-rebuild  
    IF APPLOCK_MODE(N'public', N'DeferViewGeneration', N'Session') = N'NoLock' BEGIN  
  
        DECLARE @TempID INT;  
        DECLARE @TempTable TABLE (RowNumber INT IDENTITY (1, 1) PRIMARY KEY CLUSTERED NOT NULL, ID INT NOT NULL);  
  
        INSERT INTO @TempTable(ID)  
        SELECT ID FROM mdm.tblDerivedHierarchy WHERE Model_ID = @Model_ID;  
  
        DECLARE @Counter INT = 1;  
        DECLARE @MaxCounter INT = (SELECT MAX(RowNumber) FROM @TempTable);  
  
        WHILE @Counter <= @MaxCounter  
        BEGIN  
            SELECT @TempID = ID FROM @TempTable WHERE [RowNumber] = @Counter;  
            EXEC mdm.udpCreateSystemDerivedHierarchyParentChildView @TempID;  
            SET @Counter += 1;  
        END; --while  
  
    END; --if  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpCreateHistoryViews]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
EXEC mdm.[udpCreateHistoryViews] 27, 1, 19, NULL, 'TEST1';  
EXEC mdm.[udpCreateHistoryViews] 27, 2, 19, NULL, 'TEST2';  
EXEC mdm.[udpCreateHistoryViews] 27, 3, 19, NULL, 'TEST3';  
  
SELECT * FROM mdm.TEST1  
SELECT * FROM mdm.TEST2  
SELECT * FROM mdm.TEST3  
  
*/  
CREATE PROCEDURE [mdm].[udpCreateHistoryViews]  
(  
    @Entity_ID                 INT,  
    @MemberType_ID             TINYINT,  
    @Version_ID                INT ,  
    @VersionFlag_ID            INT,  
    @SubscriptionViewName      SYSNAME,  
    @CorrelationID             UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE  
        @MemberType_Leaf                TINYINT = 1,  
        @MemberType_Consolidated        TINYINT = 2,  
        @MemberType_Collection          TINYINT = 3;  
  
    --Defer view generation if we are in the middle of an upgrade or demo-rebuild  
    IF APPLOCK_MODE(N'public', N'DeferViewGeneration', N'Session') = N'NoLock' BEGIN  
  
        DECLARE  
            @Select                 NVARCHAR(MAX) = N'',  
            @From                   NVARCHAR(MAX) = N'',  
            @ViewColumn             NVARCHAR(120), --specifically made to be less than 128 for truncation reasons  
            @TableColumn            SYSNAME,  
            @DomainTable            SYSNAME,  
            @DomainEntity_ID        INT,  
            @AttributeType_ID       INT,  
            @MainTable              SYSNAME,  
            @MemberIDColumn         SYSNAME;  
  
        SELECT  
            @MainTable =  
                CASE @MemberType_ID  
                    WHEN @MemberType_Leaf THEN EntityTable  
                    WHEN @MemberType_Collection THEN CollectionTable  
                    WHEN @MemberType_Consolidated THEN HierarchyParentTable  
                    ELSE NULL  
                END,  
            @MemberIDColumn =  
                CASE @MemberType_ID  
                    WHEN @MemberType_Leaf THEN 'EN_ID'  
                    WHEN @MemberType_Collection THEN 'CN_ID'  
                    WHEN @MemberType_Consolidated THEN 'HP_ID'  
                    ELSE NULL  
                END  
        FROM mdm.tblEntity  
        WHERE   ID = @Entity_ID  
  
        IF @MainTable IS NULL  
        BEGIN  
            RAISERROR('MDSERR100010|The Parameters are not valid.', 16, 1);  
            RETURN;  
        END;  
  
        SET @MainTable = CONVERT(SYSNAME, CONCAT(@MainTable, N'_HS'));  
  
        SET @Select +=  
            CASE @MemberType_ID  
                WHEN @MemberType_Leaf THEN N''  
                WHEN @MemberType_Collection THEN N''  
                ELSE N',H.Name as Hierarchy'  
            END;  
  
        DECLARE @ConflictingColumnName NVARCHAR(100);  
        --Get the Attributes for the Entity and then find the corresponding lookup table  
        DECLARE @TempTable TABLE(  
                ViewColumn          NVARCHAR(100) COLLATE DATABASE_DEFAULT  
                ,TableColumn        SYSNAME COLLATE DATABASE_DEFAULT  
                ,AttributeType_ID   INT  
                ,DomainEntity_ID    INT NULL  
                ,DomainTable        SYSNAME COLLATE DATABASE_DEFAULT NULL  
                ,SortOrder          INT);  
        INSERT INTO @TempTable  
        SELECT  
            ViewColumn,  
            TableColumn,  
            AttributeType_ID,  
            DomainEntity_ID,  
            DomainTable,  
            SortOrder  
        FROM  
            mdm.udfEntityAttributesGetList(@Entity_ID, @MemberType_ID)  
        WHERE ViewColumn != N'ChangeTrackingMask'  
        ORDER BY  
            SortOrder ASC;  
  
        WHILE EXISTS(SELECT 1 FROM @TempTable) BEGIN  
  
            SELECT TOP 1  
                @ViewColumn = ViewColumn,  
                @TableColumn = TableColumn,  
                @AttributeType_ID = AttributeType_ID,  
                @DomainEntity_ID = DomainEntity_ID,  
                @DomainTable = DomainTable  
            FROM @TempTable  
            ORDER BY  
                SortOrder ASC;  
  
            IF @DomainEntity_ID IS NULL  
            BEGIN  
                --Check for name validation, if there are some DBA which their _Code/_Name/_ID columns have conflicts with some FFA attribute names.  
                DECLARE @ViewColumnPrefix NVARCHAR(120) = CASE  
                    WHEN @ViewColumn LIKE N'%\_Code' ESCAPE N'\' THEN LEFT(@ViewColumn, LEN(@ViewColumn) - LEN(N'_Code'))  
                    WHEN @ViewColumn LIKE N'%\_Name' ESCAPE N'\' THEN LEFT(@ViewColumn, LEN(@ViewColumn) - LEN(N'_Name'))  
                    WHEN @ViewColumn LIKE N'%\_ID' ESCAPE N'\' THEN LEFT(@ViewColumn, LEN(@ViewColumn) - LEN(N'_ID'))  
                    ELSE NULL  
                    END;  
                IF (@ViewColumnPrefix IS NOT NULL)  
                BEGIN  
                    SELECT TOP 1 @ConflictingColumnName = Name  
                    FROM mdm.tblAttribute  
                    WHERE Entity_ID = @Entity_ID  
                        AND MemberType_ID = @MemberType_ID  
                        AND AttributeType_ID = 2 -- DBA  
                        AND Name = @ViewColumnPrefix;  
                    IF (@ConflictingColumnName IS NOT NULL)  
                    BEGIN  
                        RAISERROR('MDSERR100059|There are at least two attribute names in conflict in the existing or new subscription view. Free-form attribute names cannot start with an existing domain-based attribute name and end with "_Code", "_Name" or "_ID". Attribute names are: |%s|%s|', 16, 1, @ConflictingColumnName, @ViewColumn);  
                        RETURN;  
                    END  
                END  
                IF @ViewColumn = N'Owner_ID' AND @MemberType_ID = @MemberType_Collection BEGIN --Collection  
                    SET @Select = @Select + N'  
    ,' + QUOTENAME(@ViewColumn) + N'.UserName AS [Owner_ID]';  
                    SET @From = @From + N'  
LEFT JOIN mdm.tblUser AS Owner_ID  
    ON Owner_ID.ID = T.Owner_ID';  
                END ELSE BEGIN  
                    SET @Select = @Select + N'  
    ,T.' + QUOTENAME(@TableColumn) + N' AS ' + QUOTENAME(@ViewColumn);  
                END; --if  
  
            END ELSE BEGIN  
                --Check for name validation, if there are some DBA which their _Code/_Name/_ID columns have conflicts with some FFA attribute names.  
                SELECT TOP 1 @ConflictingColumnName = Name   
                FROM mdm.tblAttribute   
                WHERE tblAttribute.Entity_ID = @Entity_ID   
                    AND MemberType_ID = @MemberType_ID  
                    AND AttributeType_ID = 1   
                    AND (  Name = @ViewColumn + N'_Code'   
                        OR Name = @ViewColumn + N'_Name'   
                        OR Name = @ViewColumn + N'_ID' );  
                IF (@ConflictingColumnName IS NOT NULL)  
                BEGIN  
                    RAISERROR('MDSERR100059|There are at least two attribute names in conflict in the existing or new subscription view. Free-form attribute names cannot start with an existing domain-based attribute name and end with "_Code", "_Name" or "_ID". Attribute names are: |%s|%s|', 16, 1, @ConflictingColumnName, @ViewColumn);  
                    RETURN;  
                END  
                SET @Select = @Select + N'  
    ,COALESCE(' + QUOTENAME(@ViewColumn) + N'.Code, ' + QUOTENAME(@ViewColumn + N'_HS') + N'.Code) AS ' + QUOTENAME(@ViewColumn + N'_Code') + N'  
    ,COALESCE(' + QUOTENAME(@ViewColumn) + N'.Name, ' + QUOTENAME(@ViewColumn + N'_HS') + N'.Code) AS ' + QUOTENAME(@ViewColumn + N'_Name') + N'  
    ,T.' + QUOTENAME(@TableColumn) + ' AS ' + QUOTENAME(@ViewColumn + N'_ID');  
  
                SET @From = @From + N'  
LEFT JOIN mdm.' + QUOTENAME(@DomainTable) + N' AS ' + QUOTENAME(@ViewColumn) + N'  
    ON ' + QUOTENAME(@ViewColumn) + N'.ID = T.' + QUOTENAME(@TableColumn) + N' AND ' + QUOTENAME(@ViewColumn) + N'.Version_ID = T.Version_ID  
LEFT JOIN mdm.' + QUOTENAME(@DomainTable + N'_HS') + N' AS ' + QUOTENAME(@ViewColumn + N'_HS') + N'  
    ON ' + QUOTENAME(@ViewColumn + N'_HS') + N'.EN_ID = T.' + QUOTENAME(@TableColumn) + N' AND ' + QUOTENAME(@ViewColumn + N'_HS') + N'.Version_ID = T.Version_ID  AND (T.EnterDTM BETWEEN ' + QUOTENAME(@ViewColumn + N'_HS') + N'.EnterDTM  AND ' + QUOTENAME(@ViewColumn + N'_HS') + N'.LastChgDTM)';  
            END; --if  
  
            DELETE FROM @TempTable WHERE ViewColumn = @ViewColumn;  
  
        END; --while  
  
        SET @Select = CASE  
            WHEN EXISTS(SELECT 1 FROM sys.views WHERE [name] = @SubscriptionViewName AND [schema_id] = SCHEMA_ID('mdm')) THEN N'ALTER'  
            ELSE N'CREATE' END + N' VIEW mdm.' + QUOTENAME(@SubscriptionViewName) + N'  
/*WITH ENCRYPTION*/  
AS  
SELECT  
    T.ID AS RevisionID  
    ,T.' + @MemberIDColumn + ' AS ID  
    ,T.MUID AS MUID' + @Select + N'  
    ,T.EnterDTM AS EnterDateTime  
    ,UE.UserName AS EnterUserName  
    ,T.LastChgDTM AS LastChgDateTime  
    ,UC.UserName AS LastChgUserName  
    ,LS.ListOption AS State';  
        SET @Select = @Select + N'  
FROM mdm.' + QUOTENAME(@MainTable) + N' AS T'  
  
        IF @MemberType_ID = @MemberType_Consolidated  
        BEGIN  
            SET @Select += N'  
INNER JOIN mdm.tblHierarchy H  
    ON H.ID = T.Hierarchy_ID'  
        END  
  
        SET @Select += @From;  
  
        SET @Select += N'  
LEFT JOIN mdm.tblList LS  
    ON LS.OptionID = T.Status_ID AND LS.ListCode = ''lstStatus''';  
  
        SET @Select = @Select + N'  
LEFT JOIN mdm.tblUser UE  
    ON T.EnterUserID = UE.ID  
LEFT JOIN mdm.tblUser UC  
    ON T.LastChgUserID = UC.ID'  
            + CASE  
                WHEN (@Version_ID IS NOT NULL)     THEN CONCAT(N'  
WHERE T.Version_ID = ', @Version_ID)  
                WHEN (@VersionFlag_ID IS NOT NULL) THEN CONCAT(N'  
INNER JOIN mdm.tblModelVersion AS V  
    ON V.ID =  T.Version_ID  
WHERE V.VersionFlag_ID = ', @VersionFlag_ID)  
            END  
  
        SET @Select = @Select +N';';  
  
        --SELECT (@Select);  
        EXEC sp_executesql @Select;  
  
    END; --if  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpCreateLevelViews]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    EXEC mdm.udpCreateLevelViews 1, 1, 1, 1, null, 'test';  
    EXEC mdm.udpCreateLevelViews 1, 2, 1, 1, null, 'test';  
    EXEC mdm.udpCreateLevelViews 1, 3, 1, null, 1, 'test';;  
    EXEC mdm.udpCreateLevelViews 11111, 3; --invalid  
*/  
CREATE PROCEDURE [mdm].[udpCreateLevelViews]  
(  
    @Entity_ID INT,  
    @Levels    SMALLINT = NULL,  
    @Version_ID          INT ,  
    @VersionFlag_ID      INT = NULL,  
    @SubscriptionViewName sysname,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    --Defer view generation if we are in the middle of an upgrade or demo-rebuild  
    IF APPLOCK_MODE(N'public', N'DeferViewGeneration', N'Session') = N'NoLock' BEGIN  
  
        --Start transaction, being careful to check if we are nested  
        DECLARE @TranCounter INT;   
        SET @TranCounter = @@TRANCOUNT;  
        IF @TranCounter > 0 SAVE TRANSACTION TX;  
        ELSE BEGIN TRANSACTION;  
  
        BEGIN TRY  
  
            DECLARE @EntityTable    sysname,  
                    @ParentTable    sysname,  
                    @HierarchyTable sysname,  
                    @ViewNameBase   sysname,		--View name for the existing standard, base, view  
  
                    @SelectBase		NVARCHAR(MAX),	--SQL string that contains the base levels SELECT clause  
                    @SelectLeafID	NVARCHAR(MAX),  --SQL string that contains the leaf coalesce statements  
                    @SelectLeafCode NVARCHAR(MAX),  
                    @SelectLeafName NVARCHAR(MAX),     
                    @Join			NVARCHAR(MAX),	--SQL string that contains the JOIN clauses  
                    @Where			NVARCHAR(MAX),	--SQL string that contains the WHERE clause  
                    @strRJRLcode    NVARCHAR(MAX),	--SQL string to construct the CASE statement for the Code: right-justified repeating leaf views.  
                    @strRJRLname    NVARCHAR(MAX),	--SQL string to construct the CASE statement for the Name: right-justified repeating leaf views.  
  
                    @i				INT,			--Counter variable  
                    @j				INT,			--Counter variable  
                    @EN				NVARCHAR(25),  
                    @HP				NVARCHAR(25),  
                    @strCounter     NVARCHAR(23),  
                    @strCounterPrev NVARCHAR(23),  
                    @Alias			NVARCHAR(25);   --Alias to apply to the column   
  
            --Test for invalid parameters  
            IF (@Entity_ID IS NOT NULL AND NOT EXISTS(SELECT ID FROM mdm.tblEntity WHERE ID = @Entity_ID)) --Invalid @Entity_ID  
                OR (@Version_ID IS NOT NULL AND NOT EXISTS(SELECT ID FROM mdm.tblModelVersion WHERE ID = @Version_ID)) -- Invalid @Version_ID  
                OR (@SubscriptionViewName IS NULL)  
                OR (@Levels < 1)  
            BEGIN  
                RAISERROR('MDSERR100010|The Parameters are not valid.', 16, 1);  
                RETURN(1);  
            END; --if  
          
            --Initialize the variables	  
            SELECT     
                @EntityTable    = EntityTable,  
                @ParentTable    = HierarchyParentTable,  
                @HierarchyTable = HierarchyTable,  
                @ViewNameBase   = @SubscriptionViewName   
            FROM mdm.tblEntity   
            WHERE   ID = @Entity_ID   
                AND HierarchyTable IS NOT NULL;  
  
            IF @ViewNameBase IS NOT NULL BEGIN --Ensure row actually exists		  
  
                SELECT  
                    @SelectBase		= N'',  
                    @Join			= N'',  
                    @Where			= N' WHERE H0.Parent_HP_ID IS NULL AND H0.Status_ID = 1',  
                    @i				= 0;  
  
                IF @Levels IS NULL EXEC mdm.udpEntityLevelCount @Entity_ID, @Levels OUTPUT;  
                IF @Levels < 0 SET @Levels = 0   
                  
                  
  
                WHILE @i <= @Levels - 1 BEGIN  
  
                    SET @strCounter = CONVERT(NVARCHAR(23), @i);  
  
                    IF @i = 0 SET @strCounterPrev = @strCounter;  
                    ELSE SET @strCounterPrev = CONVERT(NVARCHAR(23), (@i-1));  
                        
                    IF @i = @Levels - 1 --Leaf  
                      SET @Alias = N'eaf';  
                    ELSE  
                      SET @Alias = @strCounter;  
                        
                    SET @EN = N'EN' + @strCounter;  
                    SET @HP = N'HP' + @strCounter;  
                     
                      
                              
                   SET @strRJRLcode = N'  
                        COALESCE( ' + @EN + N'.Code,' + @HP + N'.Code)' ;  
                    SET @strRJRLname = N'  
                        COALESCE( ' + @EN + N'.Name,' + @HP + N'.Name)';  
                --set the aliases  
                      
                    SET @SelectBase = @SelectBase + @strRJRLcode + N' AS [L' + @strCounter + N'_Code], ';  
                    SET @SelectBase = @SelectBase + @strRJRLname + N' AS [L' + @strCounter + N'_Name], ';  
                    IF @i > 0 BEGIN      
                        --Construct JOIN string  
                        SET @Join = @Join + N'  
                                LEFT JOIN mdm.' + quotename(@HierarchyTable) + N' H' + @strCounter + N'   
                                    ON H' + @strCounter + N'.Version_ID = H' + @strCounterPrev + N'.Version_ID  
                                    AND H' + @strCounter + N'.Hierarchy_ID = H' + @strCounterPrev + N'.Hierarchy_ID   
                                    AND H' + @strCounter + N'.Parent_HP_ID = H' + @strCounterPrev + N'.Child_HP_ID   
                                    AND H' + @strCounter + N'.Status_ID = H' + @strCounterPrev + N'.Status_ID  
                                LEFT JOIN mdm.' + quotename(@EntityTable) + N' EN' + @strCounter + N'  
                                    ON H' + @strCounter + N'.Version_ID = EN' + @strCounter + N'.Version_ID   
                                    AND H' + @strCounter + N'.ChildType_ID = 1 									  
                                    AND H' + @strCounter + N'.Child_EN_ID = EN' + @strCounter + N'.ID   
                                    AND H' + @strCounter + N'.Status_ID = EN' + @strCounter + N'.Status_ID   
                                    AND EN' + @strCounter + N'.Status_ID = 1   
                                LEFT JOIN mdm.' + quotename(@ParentTable) + N' HP' + @strCounter + N'   
                                    ON H' + @strCounter + N'.Version_ID = HP' + @strCounter + N'.Version_ID   
                                    AND H' + @strCounter + N'.ChildType_ID = 2 									  
                                    AND H' + @strCounter + N'.Child_HP_ID = HP' + @strCounter + N'.ID   
                                    AND H' + @strCounter + N'.Status_ID = HP' + @strCounter + N'.Status_ID   
                                    AND HP' + @strCounter + N'.Status_ID = 1 ';  
                    END; --if  
  
                    SET @i = @i + 1;  
                END; --while  
  
                --Create a coalesce statement to return the leaf.  Need to go in reverse level order  
                SET @i = @Levels - 1;  
                SET @SelectLeafID = N'  
                    COALESCE(NULL,';  
                SET @SelectLeafCode = @SelectLeafID;  
                SET @SelectLeafName = @SelectLeafID;  
                      
                WHILE @i >= 0 BEGIN  
                                  
                    SET @strCounter = CONVERT(NVARCHAR(23), @i);  
                    SET @SelectLeafID = @SelectLeafID + N'EN' + @strCounter + N'.ID';  
                    SET @SelectLeafCode = @SelectLeafCode + N'EN' + @strCounter + N'.Code';  
                    SET @SelectLeafName = @SelectLeafName + N'EN' + @strCounter + N'.Name';  
                    IF @i <> 0 BEGIN  
                        SET @SelectLeafID = @SelectLeafID + N',';  
                        SET @SelectLeafCode = @SelectLeafCode  + N',';  
                        SET @SelectLeafName = @SelectLeafName  + N',';  
                    END; --if  
                    SET @i = @i - 1;  
                END; -- WHILE  
                SET @SelectLeafID = @SelectLeafID + N') AS Leaf_ID,';  
                SET @SelectLeafCode = @SelectLeafCode + N') AS Leaf_Code,';  
                SET @SelectLeafName = @SelectLeafName + N') AS Leaf_Name,';  
                  
                SELECT  
                    @SelectBase = LEFT(@SelectBase, LEN(@SelectBase) - 1);  
                      
                  
                DECLARE @SQL	NVARCHAR(MAX),  
                        @SQL1	NVARCHAR(MAX),  
                        @SQL2	NVARCHAR(MAX);  
  
                SET @SQL1 = N'  
                    /*WITH ENCRYPTION*/  
                    AS SELECT   
                        H.Name			AS Hierarchy,  
                        V.Name			AS VersionName,  
                        V.Display_ID	AS VersionNumber,  
                        DV.Name			AS VersionFlag,  
                        ''ROOT''		AS [ROOT],';  
  
                SET @SQL2 = N'  
                    FROM mdm.' + quotename(@HierarchyTable) + N' H0   
                    INNER JOIN mdm.tblHierarchy H ON H.ID = H0.Hierarchy_ID   
                    LEFT JOIN mdm.' + quotename(@EntityTable) + N' EN0   
                        ON H0.Version_ID = EN0.Version_ID   
                        AND H0.ChildType_ID = 1 						  
                        AND H0.Child_EN_ID = EN0.ID   
                        AND H0.Status_ID = EN0.Status_ID   
                        AND EN0.Status_ID = 1   
                    LEFT JOIN mdm.' + quotename(@ParentTable) + N' HP0   
                        ON H0.Version_ID = HP0.Version_ID   
                        AND H0.ChildType_ID = 2 						  
                        AND H0.Child_HP_ID = HP0.ID   
                        AND H0.Status_ID = HP0.Status_ID   
                        AND HP0.Status_ID = 1   
                    INNER JOIN mdm.tblModelVersion V ON V.ID = H0.Version_ID '  
                      
                    --Restrict by Version or Version Flag  
                    IF (@Version_ID IS NOT NULL)  
                    BEGIN   
                        SET @SQL2 = @SQL2 + N'   
                            AND V.ID = ' + CAST(@Version_ID AS NVARCHAR(50))   
                    END  
                    ELSE IF (@VersionFlag_ID IS NOT NULL) BEGIN  
                        SET @SQL2 = @SQL2 + N'   
                            AND V.VersionFlag_ID = ' + CAST(@VersionFlag_ID AS NVARCHAR(50))   
                    END		  
                    SET @SQL2 = @SQL2 + N'   
                    LEFT JOIN mdm.tblModelVersionFlag AS DV ON DV.ID = V.VersionFlag_ID   
                        ' + @Join + N'  
                        ' + @Where + N';';  
  
                SET @SQL = CASE   
                    WHEN EXISTS(SELECT 1 FROM sys.views WHERE [name] = @ViewNameBase AND [schema_id] = SCHEMA_ID('mdm')) THEN N'ALTER'  
                    ELSE N'CREATE' END + N' VIEW mdm.' + quotename(@ViewNameBase)  
                    + @SQL1   
                    + @SelectLeafID  
                    + @SelectLeafCode  
                    + @SelectLeafName  
                    + @SelectBase   
                    + @SQL2;  
  
                --PRINT(@SQL);  
                EXEC sp_executesql @SQL;  
  
            END --if  
  
            --Commit only if we are not nested  
            IF @TranCounter = 0 COMMIT TRANSACTION;  
            RETURN(0);  
  
        END TRY  
        --Compensate as necessary  
        BEGIN CATCH  
  
            -- Get error info.  
            DECLARE  
                @ErrorMessage NVARCHAR(4000),  
                @ErrorSeverity INT,  
                @ErrorState INT,  
                @ErrorNumber INT,  
                @ErrorLine INT,  
                @ErrorProcedure NVARCHAR(126);  
            EXEC mdm.udpGetErrorInfo  
                @ErrorMessage = @ErrorMessage OUTPUT,  
                @ErrorSeverity = @ErrorSeverity OUTPUT,  
                @ErrorState = @ErrorState OUTPUT,  
                @ErrorNumber = @ErrorNumber OUTPUT,  
                @ErrorLine = @ErrorLine OUTPUT,  
                @ErrorProcedure = @ErrorProcedure OUTPUT  
  
            SET @ErrorMessage = CONCAT(@ErrorMessage, N', @ErrorNumber = ', @ErrorNumber, N', @ErrorProcedure = "', @ErrorProcedure, N'", line ', @ErrorLine);  
  
            IF @TranCounter = 0 ROLLBACK TRANSACTION;  
            ELSE IF XACT_STATE() <> -1 ROLLBACK TRANSACTION TX;  
  
            RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);  
  
            --On error, return NULL results  
            --SELECT @Return_ID = NULL;  
            RETURN(1);  
  
        END CATCH;  
  
    END; --if  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpCreateModelTables]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
EXEC mdm.udpCreateModelTables @Model_ID = 2;  
  
*/  
CREATE PROCEDURE [mdm].[udpCreateModelTables]  
(  
    @Model_ID    INT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON;  
  
    --Start transaction, being careful to check if we are nested  
    DECLARE @SQL                            NVARCHAR(MAX),  
            @ChangesetTable                 SYSNAME,  
            @TransactionTableName           SYSNAME,  
            @AnnotationTableName            SYSNAME,  
            @ValidationLogTableName         SYSNAME,  
  
            @TableOptions                   NVARCHAR(MAX) = N'',  
            @IndexOptions                   NVARCHAR(MAX) = N'';  
  
    --Set up table and view names  
    SET @ChangesetTable = CONCAT(N'tbl_', @Model_ID, N'_CS');  
    SET @TransactionTableName = mdm.udfGetTransactionTableName(@Model_ID);  
    SET @AnnotationTableName = mdm.udfGetTransactionAnnotationTableName(@Model_ID);  
    SET @ValidationLogTableName = mdm.udfGetValidationLogTableName(@Model_ID);  
    SET @TableOptions = mdm.udfGetTableOptions(1, @Model_ID);  
    SET @IndexOptions = mdm.udfGetIndexOptions(1, @Model_ID);  
  
    --Create the Workflow Instance (_CS) table  
    SET @SQL = CONCAT(N'  
    CREATE TABLE mdm.', QUOTENAME(@ChangesetTable), N'  
    (  
        Version_ID          INT NOT NULL,  
        ID                  INT IDENTITY(1, 1) NOT NULL,  
        Entity_ID           INT NOT NULL,  
  
        Name                NVARCHAR(250) NULL,  
        Description         NVARCHAR(500) NULL,  
        Status              TINYINT NOT NULL,  
  
        --Auditing  
        EnterDTM            DATETIME2(3) NOT NULL CONSTRAINT ', QUOTENAME(N'df_' + @ChangesetTable  + N'_EnterDTM'), N' DEFAULT GETUTCDATE(),  
        EnterUserID         INT NOT NULL,  
        LastChgDTM          DATETIME2(3) NOT NULL CONSTRAINT ', QUOTENAME(N'df_' + @ChangesetTable  + N'_LastChgDTM'), N' DEFAULT GETUTCDATE(),  
        LastChgUserID       INT NOT NULL,  
        MUID                UNIQUEIDENTIFIER NOT NULL CONSTRAINT ', QUOTENAME(N'df_' + @ChangesetTable + N'_MUID'), N' DEFAULT NEWID(),  
  
        --Create PRIMARY KEY constraint  
        CONSTRAINT ', QUOTENAME(N'pk_' + @ChangesetTable), N'  
            PRIMARY KEY CLUSTERED (Version_ID, ID)  
    )  
    ', @TableOptions, N';  
  
    CREATE NONCLUSTERED INDEX ', QUOTENAME(N'ix_' + @ChangesetTable + N'_Version_ID_Name'), N'  
        ON mdm.', QUOTENAME(@ChangesetTable), N'(Version_ID, Name)  
        ', @IndexOptions, N';  
  
    CREATE NONCLUSTERED INDEX ', QUOTENAME(N'ix_' + @ChangesetTable + N'_Version_ID_Entity_ID_EnterUserID'), N'  
        ON mdm.', QUOTENAME(@ChangesetTable), N'(Version_ID, Entity_ID, EnterUserID)  
        ', @IndexOptions, N';  
    ');  
  
    --PRINT @SQL;  
    EXEC sp_executesql @SQL;  
  
    --Create the transaction table  
    SET @SQL = CONCAT(N'  
    CREATE TABLE [mdm].', QUOTENAME(@TransactionTableName), N'  
    (  
        [Version_ID]                INT NOT NULL,  
        [ID]                        INT IDENTITY(1,1) NOT NULL,  
        [TransactionType_ID]        INT NOT NULL,  
        [OriginalTransaction_ID]    INT NULL,  
        [Hierarchy_ID]              INT NULL,  
        [Entity_ID]                 INT NULL,  
        [Attribute_ID]              INT NULL,  
        [Member_ID]                 INT NOT NULL,  
        [Member_MUID]               UNIQUEIDENTIFIER NOT NULL,  
        [MemberType_ID]             TINYINT NOT NULL,  
        [MemberCode]                NVARCHAR(250) NULL,  
        [OldValue]                  NVARCHAR(MAX) NULL,  
        [OldCode]                   NVARCHAR(MAX) NULL,  
        [NewValue]                  NVARCHAR(MAX) NULL,  
        [NewCode]                   NVARCHAR(MAX) NULL,  
        [Batch_ID]                  INT NULL,  
        [EnterDTM]                  DATETIME2(3) NOT NULL CONSTRAINT '+ QUOTENAME(N'df_' + @TransactionTableName + N'_EnterDTM'), N' DEFAULT GETUTCDATE(),  
        [EnterUserID]               INT NOT NULL,  
        [LastChgDTM]                DATETIME2(3) NOT NULL CONSTRAINT ', QUOTENAME(N'df_' + @TransactionTableName + N'_LastChgDTM'), N' DEFAULT GETUTCDATE(),  
        [LastChgUserID]             INT NOT NULL,  
  
        --Create PRIMARY KEY constraint  
        CONSTRAINT ', QUOTENAME(N'pk_' + @TransactionTableName), N'  
            PRIMARY KEY CLUSTERED (Version_ID, ID)  
    )', @TableOptions, N';  
  
    CREATE NONCLUSTERED INDEX ', QUOTENAME(N'ix_' + @TransactionTableName + N'_MemberType_ID'), N'  
        ON mdm.', QUOTENAME(@TransactionTableName), N'(MemberType_ID)  
        ', @IndexOptions, N';  
  
    CREATE NONCLUSTERED INDEX ', QUOTENAME(N'ix_' + @TransactionTableName + N'_Attribute_ID'), N'  
        ON mdm.', QUOTENAME(@TransactionTableName), N'(Attribute_ID)  
        ', @IndexOptions, N';  
  
    CREATE NONCLUSTERED INDEX ', QUOTENAME(N'ix_' + @TransactionTableName + N'_Entity_ID'), N'  
        ON mdm.', QUOTENAME(@TransactionTableName), N'(Entity_ID)  
        ', @IndexOptions, N';  
  
    CREATE NONCLUSTERED INDEX ', QUOTENAME(N'ix_' + @TransactionTableName + N'_Hierarchy_ID'), N'  
        ON mdm.', QUOTENAME(@TransactionTableName), N'(Hierarchy_ID)  
        ', @IndexOptions, N';  
  
    CREATE NONCLUSTERED INDEX ', QUOTENAME(N'ix_' + @TransactionTableName + N'_TransactionType_ID'), N'  
        ON mdm.', QUOTENAME(@TransactionTableName), N'(TransactionType_ID)  
        ', @IndexOptions, N';  
    ');  
    --PRINT @SQL;  
    EXEC sp_executesql @SQL;  
  
    --Create the annotation table  
    SET @SQL = CONCAT(N'  
    CREATE TABLE [mdm].', QUOTENAME(@AnnotationTableName), N'  
    (  
        [Version_ID]        INT NOT NULL,  
        [ID]                INT IDENTITY (1, 1) NOT NULL,  
        [Transaction_ID]    INT NOT NULL,  
        [Comment]           NVARCHAR(500) NULL,  
        [EnterUserID]       INT NOT NULL,  
        [EnterDTM]          DATETIME2(3) NOT NULL CONSTRAINT ', QUOTENAME(N'df_' + @AnnotationTableName + N'_EnterDTM'), N' DEFAULT GETUTCDATE(),  
        [LastChgDTM]        DATETIME2(3) NOT NULL CONSTRAINT ', QUOTENAME(N'df_' + @AnnotationTableName + N'_LastChgDTM'), N' DEFAULT GETUTCDATE(),  
        [LastChgUserID]     INT NOT NULL,  
  
        --Create PRIMARY KEY constraint  
        CONSTRAINT ', QUOTENAME(N'pk_' + @AnnotationTableName), N'  
            PRIMARY KEY CLUSTERED (Version_ID, ID),  
  
        --Create FOREIGN KEY constraints  
        CONSTRAINT ', QUOTENAME(N'fk_' + @AnnotationTableName + N'_' + @TransactionTableName + N'_Version_ID_Transaction_ID'), N'  
            FOREIGN KEY(Version_ID, Transaction_ID) REFERENCES [mdm].', QUOTENAME(@TransactionTableName), N' (Version_ID, ID)  
            ON UPDATE NO ACTION  
            ON DELETE CASCADE  
    )', @TableOptions, N';  
  
    CREATE NONCLUSTERED INDEX ', QUOTENAME(N'ix_' + @AnnotationTableName + N'_Version_ID_Transaction_ID'), N'  
        ON mdm.', QUOTENAME(@AnnotationTableName), N'(Version_ID, Transaction_ID)  
        ', @IndexOptions, N';  
    ');  
    EXEC sp_executesql @SQL;  
  
    --Create the validation log table  
    SET @SQL = CONCAT(N'  
    CREATE TABLE [mdm].', QUOTENAME(@ValidationLogTableName), N'  
    (  
        [ID]                    [INT] IDENTITY (1, 1)    NOT NULL,  
        [Status_ID]             [TINYINT]                NOT NULL,  
        [Version_ID]            [INT]                    NOT NULL,  
        [Hierarchy_ID]          [INT]                    NOT NULL,  
        [Entity_ID]             [INT]                    NOT NULL,  
        [Member_ID]             [INT]                    NOT NULL,  
        [Member_MUID]           [UNIQUEIDENTIFIER]       NOT NULL,  
        [MemberCode]            [NVARCHAR] (250)         NOT NULL,  
        [MemberType_ID]         [TINYINT]                NOT NULL,  
        [Description]           [NVARCHAR] (1000)        NOT NULL,  
        [BRBusinessRule_ID]     [INT]                    NOT NULL,  
        [BRItem_ID]             [INT]                    NOT NULL,  
        [NotificationStatus_ID] [INT]                    NOT NULL CONSTRAINT df_', @ValidationLogTableName, N'_NotificationStatus_ID DEFAULT 0,  
        [EnterDTM]              DATETIME2(3)             NOT NULL CONSTRAINT [df_', @ValidationLogTableName, N'_EnterDTM] DEFAULT GETUTCDATE(),  
        [EnterUserID]           [INT]                    NOT NULL,  
        [LastChgDTM]            DATETIME2(3)             NOT NULL CONSTRAINT [df_', @ValidationLogTableName, N'_LastChgDTM] DEFAULT GETUTCDATE(),  
        [LastChgUserID]         [INT]                    NOT NULL,  
        CONSTRAINT ck_', @ValidationLogTableName, N'_NotificationStatus_ID CHECK (NotificationStatus_ID BETWEEN 0 AND 5), --!  
        CONSTRAINT ck_', @ValidationLogTableName, N'_Status_ID CHECK (Status_ID BETWEEN 0 AND 3), --!  
        CONSTRAINT ck_', @ValidationLogTableName, N'_MemberType_ID CHECK (MemberType_ID BETWEEN 1 AND 5),  
        CONSTRAINT [pk_', @ValidationLogTableName, N'] PRIMARY KEY CLUSTERED (Version_ID, ID)  
    )', @TableOptions, N';  
  
    CREATE NONCLUSTERED INDEX [ix_', @ValidationLogTableName, N'_Version_ID_Entity_ID_Member_ID_MemberType_ID_BRBusinessRule_ID_BRItem_ID]  
    ON [mdm].', QUOTENAME(@ValidationLogTableName), N'([Version_ID] ASC, [Entity_ID] ASC, [Member_ID] ASC, [MemberType_ID] ASC, [BRBusinessRule_ID] ASC, [BRItem_ID] ASC)  
    ', @IndexOptions, N';');  
    EXEC sp_executesql @SQL;  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpCreateModelViews]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
EXEC mdm.udpCreateModelViews @Model_ID = 2;  
  
*/  
CREATE PROCEDURE [mdm].[udpCreateModelViews]  
    @Model_ID       INT  
AS  
BEGIN  
    SET NOCOUNT ON;  
    DECLARE @SQL                            NVARCHAR(MAX),  
            @TransactionViewName            SYSNAME,  
            @AnnotationViewName             SYSNAME,  
            @ValidationLogViewName          SYSNAME,  
            @UserValidationViewName         SYSNAME,  
            @TransactionTableName           SYSNAME,  
            @AnnotationTableName            SYSNAME,  
            @ValidationLogTableName         SYSNAME;  
  
    SET @TransactionViewName = mdm.udfGetTransactionViewName(@Model_ID);  
    SET @AnnotationViewName = mdm.udfGetTransactionAnnotationViewName(@Model_ID);  
    SET @ValidationLogViewName = mdm.udfGetValidationLogViewName(@Model_ID);  
    SET @UserValidationViewName = mdm.udfGetUserValidationViewName(@Model_ID);  
  
    SET @TransactionTableName = mdm.udfGetTransactionTableName(@Model_ID);  
    SET @AnnotationTableName = mdm.udfGetTransactionAnnotationTableName(@Model_ID);  
    SET @ValidationLogTableName = mdm.udfGetValidationLogTableName(@Model_ID);  
  
    --Delete Model Views.  
    EXEC mdm.udpDeleteViews @Model_ID, NULL, NULL;  
  
    --Create the transaction view  
    SET @SQL = CONCAT(N'  
        CREATE VIEW [mdm].', QUOTENAME(@TransactionViewName), N'  
        AS  
        SELECT  
            T.ID,  
            M.ID as Model_ID,  
            M.Name as Model_Name,  
            M.MUID as Model_MUID,  
            T.Version_ID as Version_ID,  
            MV.Name as Version_Name,  
            MV.MUID as Version_MUID,  
            T.TransactionType_ID as TransactionType_ID,  
            CASE WHEN H.Name IS NULL THEN N'''' ELSE H.Name END [Explicit Hierarchy],  
            T.Hierarchy_ID as [ExplicitHierarchy_ID],  
            H.MUID as [ExplicitHierarchy_MUID],  
            CASE WHEN E.Name IS NULL THEN N'''' ELSE E.Name END as Entity,  
            T.Entity_ID as Entity_ID,  
            E.MUID as Entity_MUID,  
            CASE WHEN A.Name IS NULL THEN N'''' ELSE A.Name END as Attribute,  
            T.Attribute_ID as Attribute_ID,  
            A.MUID as Attribute_MUID,  
            T.Member_ID as [Member_ID],  
            T.Member_MUID as [Member_MUID],  
            CASE WHEN T.MemberCode IS NULL THEN N'''' ELSE T.MemberCode END as [Member Code],  
            T.MemberType_ID AS MemberType_ID,  
            CASE WHEN T.OldCode IS NULL THEN N'''' ELSE T.OldCode END as [Prior Value],  
            CASE WHEN T.NewCode IS NULL THEN N'''' ELSE T.NewCode END as [New Value],  
            CASE WHEN T.EnterDTM IS NULL THEN N'''' ELSE T.EnterDTM END as [Date Time],  
            U.UserName as [User Name],  
            T.EnterUserID AS [User ID],  
            U.MUID as [User_MUID]  
        FROM  
                        mdm.', QUOTENAME(@TransactionTableName), N' T  
            LEFT JOIN   mdm.tblModelVersion MV ON T.Version_ID = MV.ID  
            LEFT JOIN   mdm.tblModel M ON M.ID = MV.Model_ID  
            LEFT JOIN   mdm.tblHierarchy H ON T.Hierarchy_ID = H.ID  
            LEFT JOIN   mdm.tblEntity E ON T.Entity_ID = E.ID  
            LEFT JOIN   mdm.tblAttribute A ON T.Attribute_ID = A.ID  
            LEFT JOIN   mdm.tblUser U ON T.EnterUserID = U.ID  
        ');  
    EXEC sp_executesql @SQL;  
  
    --Create the annotation view  
    SET @SQL = CONCAT(N'  
        CREATE VIEW [mdm].', QUOTENAME(@AnnotationViewName), N'  
        AS  
        SELECT  
            TA.ID,  
            T.ID AS [Transaction ID],  
            CASE WHEN TA.Comment IS NULL THEN N'''' ELSE TA.Comment END AS [User Comment],  
            CASE WHEN TA.EnterDTM IS NULL THEN N'''' ELSE TA.EnterDTM END as [Date Time],  
            U.UserName as [User Name],  
            U.ID AS [User ID],  
            U.MUID as [User_MUID],  
            CASE WHEN TA.LastChgDTM IS NULL THEN N'''' ELSE TA.LastChgDTM END as [LastChgDateTime],  
            U2.UserName as [LastChgUserName],  
            U2.ID AS [LastChgUserID],  
            U2.MUID as [LastChgUserMUID]  
        FROM  
            [mdm].', QUOTENAME(@AnnotationTableName), N' TA  
                INNER JOIN [mdm].', QUOTENAME(@TransactionTableName), N' T ON TA.Transaction_ID = T.ID  
                LEFT JOIN [mdm].[tblUser] U ON TA.EnterUserID = U.ID  
                LEFT JOIN [mdm].[tblUser] U2 ON TA.LastChgUserID = U2.ID  
        ');  
    EXEC sp_executesql @SQL;  
  
    --Create the validation log view  
    SET @SQL = CONCAT(N'  
        CREATE VIEW [mdm].', QUOTENAME(@ValidationLogViewName), N'  
        AS  
        SELECT  
             tAll.ID,    
            M.ID [Model_ID],    
            M.MUID [Model_MUID],    
            M.Name [Model_Name],    
            tAll.Version_ID,    
            V.MUID [Version_MUID],    
            V.Name [Version_Name],    
            tAll.Hierarchy_ID,    
            H.MUID [Hierarchy_MUID],    
            H.Name [Hierarchy_Name],    
            tAll.Entity_ID,    
            E.MUID [Entity_MUID],    
            E.Name [Entity_Name],    
            tAll.MemberType_ID,    
            tAll.Member_ID,    
            tAll.Member_MUID,    
            tAll.MemberCode,    
            BR.RuleConditionText [Description],    
            tAll.BRBusinessRule_ID,    
            BR.MUID [BRBusinessRule_MUID],    
            BR.Name [BRBusinessRule_Name],    
            tAll.BRItem_ID,    
            BRI.MUID [BRItem_MUID],    
            BRI.ItemText [BRItem_Name],    
            LR.Parent_ID [BRItem_Category],  
            tAll.EnterDTM,    
            U1.ID [EnterUserID],    
            U1.MUID [EnterUserMUID] ,    
            U1.UserName [EnterUserName],    
            tAll.LastChgDTM    [LastChgDTM],    
            U2.ID [LastChgUserID],    
            U2.MUID [LastChgUse_MUID],    
            U2.UserName [LastChgUserName],    
            tAll.NotificationStatus_ID  
        FROM  
            [mdm].', QUOTENAME(@ValidationLogTableName), N' tAll  
            INNER JOIN  
            (  
                SELECT  
                    Version_ID,  
                    Hierarchy_ID,  
                    Entity_ID,  
                    Member_ID,  
                    MemberType_ID,  
                    BRBusinessRule_ID,  
                    BRItem_ID,  
                    MAX(LastChgDTM) LastUpdated  
                FROM  
                    [mdm].', QUOTENAME(@ValidationLogTableName), N'  
                GROUP BY  
                    Version_ID,  
                    Hierarchy_ID,  
                    Entity_ID,  
                    Member_ID,  
                    MemberType_ID,  
                    BRBusinessRule_ID,  
                    BRItem_ID  
            ) tDistinct ON  
                    tAll.Version_ID = tDistinct.Version_ID AND  
                    tAll.Hierarchy_ID = tDistinct.Hierarchy_ID AND  
                    tAll.Entity_ID = tDistinct.Entity_ID AND  
                    tAll.Member_ID = tDistinct.Member_ID AND  
                    tAll.MemberType_ID = tDistinct.MemberType_ID AND  
                    tAll.BRBusinessRule_ID = tDistinct.BRBusinessRule_ID AND  
                    tAll.BRItem_ID = tDistinct.BRItem_ID AND  
                    tAll.LastChgDTM = tDistinct.LastUpdated AND  
                tAll.Status_ID = 1  
            LEFT JOIN mdm.tblBRBusinessRule BR ON BR.ID = tAll.BRBusinessRule_ID    
            LEFT JOIN mdm.tblBRItem BRI ON BRI.ID = tAll.BRItem_ID    
            LEFT JOIN mdm.tblBRItemTypeAppliesTo BRIAT ON BRI.BRItemAppliesTo_ID = BRIAT.ID  
            LEFT JOIN mdm.tblListRelationship LR ON BRIAT.ApplyTo_ID = LR.ID  
            LEFT JOIN mdm.tblModelVersion V ON V.ID = tAll.Version_ID    
            LEFT JOIN mdm.tblModel M ON M.ID = V.Model_ID    
            LEFT JOIN mdm.tblUser U1 ON U1.ID =  tAll.EnterUserID    
            LEFT JOIN mdm.tblUser U2 ON U2.ID =  tAll.LastChgUserID    
            LEFT JOIN mdm.tblEntity E ON E.ID = tAll.Entity_ID    
            LEFT JOIN mdm.tblHierarchy H ON H.ID = tAll.Hierarchy_ID;    
        ');  
    EXEC sp_executesql @SQL;  
  
    --Create the validation log view by user  
    SET @SQL = CONCAT(N'  
        CREATE VIEW [mdm].', QUOTENAME(@UserValidationViewName), N'  
        AS  
        SELECT  
            tLog.ID                                 ValidationIssue_ID,  
            tLog.Version_ID                         Version_ID,  
            tLog.Version_Name                       VersionName,  
            tLog.Model_ID                           Model_ID,  
            tLog.Model_Name                         ModelName,  
            tLog.Entity_ID                          Entity_ID,  
            tLog.Entity_Name                        EntityName,  
            tLog.Hierarchy_ID                       Hierarchy_ID,  
            ISNULL(tLog.Hierarchy_Name, N'''')        HierarchyName,  
            tLog.Member_ID                          Member_ID,  
            tLog.MemberCode                         MemberCode,  
            tLog.MemberType_ID                      MemberType_ID,  
            tLog.Description                        ConditionText,  
            tLog.BRItem_Name                        ActionText,  
            tLog.BRBusinessRule_ID                  BusinessRuleID,  
            tLog.BRBusinessRule_Name                BusinessRuleName,  
            N''''                                   PriorityRank,  
            CASE WHEN vBR.BusinessRule_NotificationGroupID IS NULL THEN vBR.BusinessRule_NotificationUserID ELSE ugu.[User_ID] END [User_ID],  
            CASE WHEN vBR.BusinessRule_NotificationGroupID IS NULL THEN vBR.BusinessRule_NotificationUserName ELSE ugu.[User_Name] END [UserName],  
            tLog.LastChgUserID                      LastChgUserID,  
            tLog.LastChgDTM                         DateCreated,  
            CAST(NULL AS DATETIME2(3))              DateDue,  
            tLog.NotificationStatus_ID              NotificationStatus_ID,  
            tNotify.Name                            NotificationStatus,  
            tRule.Property_Value                    Property_Value,  
            LR.Parent_ID                            BRItem_Category  
        FROM  
            [mdm].', QUOTENAME(@ValidationLogViewName), N' tLog  
            LEFT JOIN mdm.viw_SYSTEM_SCHEMA_BUSINESSRULE_PROPERTIES tRule  
                ON    tLog.BRBusinessRule_ID = tRule.BusinessRule_ID  
                AND   tLog.BRItem_ID = tRule.Item_ID  
            LEFT JOIN mdm.tblBRItemTypeAppliesTo BRIAT ON tRule.Item_AppliesTo_ID = BRIAT.ID  
            LEFT JOIN mdm.tblListRelationship LR ON BRIAT.ApplyTo_ID = LR.ID  
            LEFT JOIN mdm.viw_SYSTEM_SCHEMA_BUSINESSRULES vBR  
                ON vBR.BusinessRule_ID = tRule.BusinessRule_ID  
            LEFT JOIN (SELECT OptionID ID, ListOption Name FROM mdm.tblList WHERE ListName = N''NotificationStatus'') tNotify  
                ON tLog.NotificationStatus_ID = tNotify.ID  
            LEFT JOIN mdm.viw_SYSTEM_USERGROUP_USERS ugu  
                ON vBR.BusinessRule_NotificationGroupID = ugu.UserGroup_ID;  
        ');  
    EXEC sp_executesql @SQL;  
END
GO
/****** Object:  StoredProcedure [mdm].[udpCreateParentChildViews]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    EXEC mdm.udpCreateParentChildViews ;  
    EXEC mdm.udpCreateParentChildViews 3, 1, 1, null, 'test';  
    EXEC mdm.udpCreateParentChildViews 11111; --invalid  
    EXEC mdm.udpCreateAllViews;  
*/  
CREATE PROCEDURE [mdm].[udpCreateParentChildViews]   
(  
    @Entity_ID              INT,  
    @Version_ID             INT ,  
    @VersionFlag_ID         INT = NULL,  
    @SubscriptionViewName   sysname,  
    @CorrelationID          UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    --Defer view generation if we are in the middle of an upgrade or demo-rebuild  
    IF APPLOCK_MODE(N'public', N'DeferViewGeneration', N'Session') = N'NoLock' BEGIN  
  
        DECLARE @EntityTable			sysname,  
                @HierarchyParentTable   sysname,  
                @HierarchyTable			sysname,  
                @ViewName				sysname,  
                @SQL					NVARCHAR(MAX);  
          
        --Initialize the variables	  
        SELECT  
            @EntityTable = EntityTable,  
            @HierarchyParentTable = HierarchyParentTable,  
            @HierarchyTable = HierarchyTable,  
            @ViewName = @SubscriptionViewName  
        FROM mdm.tblEntity  
        WHERE   ID = @Entity_ID   
            AND HierarchyTable IS NOT NULL;  
  
        IF @ViewName IS NULL --Ensure row actually exists  
            OR (@Version_ID IS NOT NULL AND NOT EXISTS(SELECT ID FROM mdm.tblModelVersion WHERE ID = @Version_ID)) -- Invalid @Version_ID  
        BEGIN  
            RAISERROR('MDSERR100010|The Parameters are not valid.', 16, 1);  
            RETURN;  
        END  
  
        SET @SQL = CASE   
            WHEN EXISTS(SELECT 1 FROM sys.views WHERE [name] = @ViewName AND [schema_id] = SCHEMA_ID('mdm')) THEN N'ALTER'  
            ELSE N'CREATE' END + N' VIEW mdm.' + quotename(@ViewName) + N'  
            /*WITH ENCRYPTION*/ AS  
            SELECT  
                V.Name			AS VersionName,  
                V.Display_ID	AS VersionNumber,  
                DV.Name			AS VersionFlag,          
                H.Name			AS Hierarchy,          
                ISNULL(HPP.Code, ''ROOT'')	AS ParentCode, --!Should be NULL  
                ISNULL(HPP.Name, '''')		AS ParentName, --!Should be NULL  
                CASE            
                    WHEN HR.ChildType_ID = 1 THEN EN.Code           
                    ELSE HPC.Code         
                END				AS ChildCode,         
                CASE           
                    WHEN HR.ChildType_ID = 1 THEN EN.Name          
                    ELSE HPC.Name         
                END				AS ChildName,  
                HR.SortOrder	AS ChildSortOrder,  
                HR.LevelNumber	AS ChildLevelNumber,  
                HR.EnterDTM		AS EnterDateTime  
                ,(SELECT UserName FROM mdm.tblUser WHERE ID = HR.EnterUserID) AS EnterUserName  
                ,(SELECT Display_ID FROM mdm.tblModelVersion WHERE ID = HR.EnterVersionID) AS EnterVersionNumber  
                ,HR.LastChgDTM	AS LastChgDateTime  
                ,(SELECT UserName FROM mdm.tblUser WHERE ID = HR.LastChgUserID) AS LastChgUserName  
                ,(SELECT Display_ID FROM mdm.tblModelVersion WHERE ID = HR.LastChgVersionID) AS LastChgVersionNumber  
            FROM mdm.' + quotename(@HierarchyTable) + N' HR           
            INNER JOIN mdm.tblHierarchy H   
            ON HR.Hierarchy_ID = H.ID          
            INNER JOIN mdm.tblModelVersion V   
            ON HR.Version_ID = V.ID '  
                  
                  
            --Restrict by Version or Version Flag  
            IF (@Version_ID IS NOT NULL)  
            BEGIN   
                SET @SQL = @SQL + N'   
                    AND V.ID = ' + CAST(@Version_ID AS NVARCHAR(50))   
            END  
            ELSE IF (@VersionFlag_ID IS NOT NULL) BEGIN  
                SET @SQL = @SQL + N'   
                    AND V.VersionFlag_ID = ' + CAST(@VersionFlag_ID AS NVARCHAR(50))   
            END		  
                  
            SET @SQL = @SQL + N'   
            LEFT JOIN mdm.tblModelVersionFlag AS DV ON DV.ID = V.VersionFlag_ID '  
                  
                  
            SET @SQL = @SQL + N'  
            LEFT JOIN mdm.' + quotename(@HierarchyParentTable) + N' AS HPP   
            ON      HPP.ID = HR.Parent_HP_ID   
                AND HPP.Version_ID = HR.Version_ID   
                AND HPP.Hierarchy_ID = HR.Hierarchy_ID   
                AND HPP.Status_ID = HR.Status_ID    
            LEFT JOIN mdm.' + quotename(@EntityTable) + N' AS EN   
            ON      HR.Child_EN_ID = EN.ID            
                AND HR.Version_ID = EN.Version_ID   
                AND HR.ChildType_ID = 1   
                AND EN.Status_ID = 1   
            LEFT JOIN mdm.' + quotename(@HierarchyParentTable) + N' AS HPC   
            ON      HR.Child_HP_ID = HPC.ID  
                AND HR.Version_ID = HPC.Version_ID   
                AND HR.Hierarchy_ID = HPC.Hierarchy_ID   
                AND HR.ChildType_ID = 2   
                AND HPC.Status_ID = 1  
            WHERE   
                (EN.ID IS NOT NULL OR HPC.ID IS NOT NULL);';  
  
        --PRINT @SQL;  
        EXEC sp_executesql @SQL;  
  
    END; --if  
  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpCreateSubscriptionViews]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
        EXEC mdm.udpCreateSubscriptionViews 1,1,1,1, 'TEST'  
*/  
CREATE PROCEDURE [mdm].[udpCreateSubscriptionViews]  
(  
    @SubscriptionView_ID        INT = NULL,   
    @Entity_ID                  INT,  
    @DerivedHierarchy_ID        INT,  
    @ModelVersion_ID            INT,  
    @ModelVersionFlag_ID        INT,  
    @ViewFormat_ID              INT,  
    @Levels                     SMALLINT,  
    @SubscriptionViewName       sysname,  
    @IncludeSoftDeletedMembers  BIT,  
    @CorrelationID              UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE  
        @MemberType_Leaf                TINYINT = 1,  
        @MemberType_Consolidated        TINYINT = 2,  
        @MemberType_Collection          TINYINT = 3;  
  
    --Defer view generation if we are in the middle of an upgrade or demo-rebuild  
    IF APPLOCK_MODE(N'public', N'DeferViewGeneration', N'Session') = N'NoLock' BEGIN  
  
        -- Views for Entity  
        IF (@Entity_ID IS NOT NULL) BEGIN  
  
            /*********************************************  
                Available view formats for Entity are:  
                  
                1 - Leaf  
                2 - Consolidated  
                3 - Collection Attributes  
                4 - Collection  
                5 - Parent Child  
                6 - Levels  
                9 - LeafHistory  
                10 - ConsolidatedHistory  
                11 - CollectionHistory  
                12 - LeafType2  
                13 - ConsolidatedType2  
                14 - CollectionType2  
  
                Available view formats for Derived Hierarchy are:  
  
                7 - Parent Child  
                8 - Levels   
            *********************************************/  
  
            -- Leaf attributes  
            IF (@ViewFormat_ID = 1)  
            BEGIN  
                EXEC mdm.udpCreateAttributeViews @Entity_ID, @MemberType_Leaf, @ModelVersion_ID, @ModelVersionFlag_ID, @SubscriptionViewName, @IncludeSoftDeletedMembers; --Leaf  
            END  
            ELSE IF (@ViewFormat_ID = 2)  
            BEGIN  
                EXEC mdm.udpCreateAttributeViews @Entity_ID, @MemberType_Consolidated, @ModelVersion_ID, @ModelVersionFlag_ID, @SubscriptionViewName, @IncludeSoftDeletedMembers; --Consolidated  
            END  
            ELSE IF (@ViewFormat_ID = 3)  
            BEGIN  
                EXEC mdm.udpCreateAttributeViews @Entity_ID, @MemberType_Collection, @ModelVersion_ID, @ModelVersionFlag_ID, @SubscriptionViewName, @IncludeSoftDeletedMembers; --Collection  
            END  
            ELSE IF (@ViewFormat_ID = 4)  
            BEGIN  
                EXEC mdm.udpCreateCollectionViews @Entity_ID, @ModelVersion_ID, @ModelVersionFlag_ID, @SubscriptionViewName, @IncludeSoftDeletedMembers;   
            END  
            ELSE IF (@ViewFormat_ID = 5)  
            BEGIN  
               EXEC mdm.udpCreateParentChildViews @Entity_ID, @ModelVersion_ID, @ModelVersionFlag_ID, @SubscriptionViewName;  
            END  
            ELSE IF (@ViewFormat_ID = 6)  
            BEGIN  
                EXEC mdm.udpCreateLevelViews @Entity_ID, @Levels, @ModelVersion_ID, @ModelVersionFlag_ID, @SubscriptionViewName;  
            END  
            ELSE IF (@ViewFormat_ID = 9)  
            BEGIN  
                EXEC mdm.udpCreateHistoryViews @Entity_ID, @MemberType_Leaf, @ModelVersion_ID, @ModelVersionFlag_ID, @SubscriptionViewName;  
            END ELSE IF (@ViewFormat_ID = 10)  
            BEGIN  
                EXEC mdm.udpCreateHistoryViews @Entity_ID, @MemberType_Consolidated, @ModelVersion_ID, @ModelVersionFlag_ID, @SubscriptionViewName;  
            END  
            ELSE IF (@ViewFormat_ID = 11)  
            BEGIN  
                EXEC mdm.udpCreateHistoryViews @Entity_ID, @MemberType_Collection, @ModelVersion_ID, @ModelVersionFlag_ID, @SubscriptionViewName;  
            END  
            ELSE IF (@ViewFormat_ID = 12)  
            BEGIN  
                EXEC mdm.udpCreateType2Views @Entity_ID, @MemberType_Leaf, @ModelVersion_ID, @ModelVersionFlag_ID, @SubscriptionViewName;  
            END  
            ELSE IF (@ViewFormat_ID = 13)  
            BEGIN  
                EXEC mdm.udpCreateType2Views @Entity_ID, @MemberType_Consolidated, @ModelVersion_ID, @ModelVersionFlag_ID, @SubscriptionViewName;  
            END  
            ELSE  
            IF (@ViewFormat_ID = 14)  
            BEGIN  
                EXEC mdm.udpCreateType2Views @Entity_ID, @MemberType_Collection, @ModelVersion_ID, @ModelVersionFlag_ID, @SubscriptionViewName;  
            END  
            ELSE  
            BEGIN  
                RAISERROR('MDSERR100014|The View Format ID is not valid.', 16, 1);  
                RETURN;  
            END;  
        END   
        --Views for Derived Hierarchy  
        ELSE BEGIN  
            IF (@ViewFormat_ID = 7)  
            BEGIN  
                EXEC mdm.udpCreateDerivedHierarchyParentChildView @DerivedHierarchy_ID, @ModelVersion_ID, @ModelVersionFlag_ID, @SubscriptionViewName;  
            END  
            ELSE IF (@ViewFormat_ID = 8)  
            BEGIN  
                EXEC mdm.udpCreateDerivedHierarchyLevelView @DerivedHierarchy_ID, @Levels, @ModelVersion_ID, @ModelVersionFlag_ID, @SubscriptionViewName;  
            END  
            ELSE  
            BEGIN  
                RAISERROR('MDSERR100014|The View Format ID is not valid.', 16, 1);  
                RETURN;  
            END;  
        END  
          
    END; --if  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpCreateSystemAttributeViews]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    EXEC mdm.udpCreateSystemAttributeViews 1,1,0;  
*/  
CREATE PROCEDURE [mdm].[udpCreateSystemAttributeViews]  
(  
    @Entity_ID      INT,  
    @MemberType_ID  TINYINT,  
    @ViewType       TINYINT = 0, -- 0 EN, 1 PD, 2 HS  
    @CorrelationID  UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    --Defer view generation if we are in the middle of an upgrade or demo-rebuild  
    IF APPLOCK_MODE(N'public', N'DeferViewGeneration', N'Session') = N'NoLock' BEGIN  
  
        DECLARE @ViewName                   SYSNAME,  
                @EntityTable                SYSNAME,  
                @CollectionTable            SYSNAME,  
                @HierarchyParentTable       SYSNAME,  
                @DomainTable                SYSNAME,  
                @Select                     NVARCHAR(MAX),  
                @From                       NVARCHAR(MAX) = N'',  
                @TableColumn                SYSNAME,  
                @ViewColumn                 NVARCHAR(120), --specifically made to be less than 128 for truncation reasons  
                @ViewColumnQuoted           NVARCHAR(300),  
                @DomainEntity_ID            INT,  
                @AttributeType_ID           TINYINT,  
  
                @AttributeDataType_ID       TINYINT,  
                @AttributeDataType_Text     TINYINT = 1,  
                @AttributeDataType_Number   TINYINT = 2,  
                @AttributeDataType_DateTime TINYINT = 3,  
                @AttributeDataType_Link     TINYINT = 6,  
  
                --Member Types  
                @MemberType_Leaf            TINYINT = 1,  
                @MemberType_Consolidated    TINYINT = 2,  
                @MemberType_Collection      TINYINT = 3,  
  
                @ViewType_EN                TINYINT = 0,  
                @ViewType_PD                TINYINT = 1,  
                @ViewType_HS                TINYINT = 2;  
  
        --Initialize the variables  
        SELECT  
            @EntityTable = EntityTable,  
            @CollectionTable = CollectionTable,  
            @HierarchyParentTable = HierarchyParentTable,  
            @ViewName = mdm.udfViewNameGetByID(ID, @MemberType_ID, 0, @ViewType)  
        FROM mdm.tblEntity  
        WHERE ID = @Entity_ID;  
  
        IF @ViewName IS NOT NULL  
        BEGIN --Ensure row actually exists  
  
            --Get the Attributes for the Entity and then find the corresponding lookup table  
            DECLARE @TempTable TABLE(  
                 ViewColumn         NVARCHAR(120) COLLATE database_default  
                ,TableColumn        SYSNAME COLLATE database_default  
                ,AttributeType_ID   TINYINT  
                ,DataType_ID        TINYINT  
                ,DomainEntity_ID    INT  
                ,DomainTable        SYSNAME COLLATE database_default NULL  
                ,SortOrder          INT);  
            INSERT INTO @TempTable  
            SELECT  
                 A.Name AS ViewColumn,  
                TableColumn,  
                AttributeType_ID,  
                DataType_ID,  
                DomainEntity_ID,  
                E.EntityTable AS DomainTable,  
                SortOrder  
            FROM mdm.tblAttribute A  
            LEFT JOIN mdm.tblEntity E  
                ON A.DomainEntity_ID = E.ID  
            WHERE A.Entity_ID = @Entity_ID  
                AND A.MemberType_ID = @MemberType_ID  
                AND A.IsSystem = 0  
            ORDER BY  
                SortOrder ASC;  
  
            SET @Select =  
                CASE @MemberType_ID  
                    WHEN @MemberType_Leaf THEN   
                        CASE @ViewType  
                            WHEN @ViewType_EN THEN N'  
     T.ID  
    ,T.MUID  
    ,T.Version_ID  
    ,T.Name AS Name  
    ,T.Code AS Code  
    ,T.ValidationStatus_ID  
    ,T.ChangeTrackingMask  
    ,T.LastChgTS'  
                            WHEN @ViewType_PD THEN N'  
     T.CS_ID  
    ,T.ID AS PD_ID  
    ,T.Status_ID  
    ,T.EN_ID AS ID  
    ,T.MUID  
    ,T.Version_ID  
    ,NULLIF(T.Code, NCHAR(0) /* @SysNull_Text */) AS [Code]  
    ,CASE WHEN T.Code IS NULL THEN 0 ELSE 1 END AS [Code.IsChanged]  
    ,NULLIF(T.Name, NCHAR(0) /* @SysNull_Text */) AS [Name]  
    ,CASE WHEN T.Name IS NULL THEN 0 ELSE 1 END AS [Name.IsChanged]  
    ,T.Revision_ID AS LastChgTS'  
                            WHEN @ViewType_HS THEN N'  
     T.ID AS HS_ID  
    ,T.Status_ID  
    ,T.EN_ID AS ID  
    ,T.MUID  
    ,T.Version_ID  
    ,T.Name AS Name  
    ,T.Code AS Code  
    ,T.ID AS LastChgTS'  
                    END  
                    WHEN @MemberType_Consolidated THEN  
                        CASE @ViewType  
                            WHEN @ViewType_EN THEN N'  
     T.ID  
    ,T.MUID  
    ,T.Version_ID  
    ,T.Name AS Name  
    ,T.Code AS Code  
    ,T.ValidationStatus_ID  
    ,T.Hierarchy_ID AS Hierarchy_ID  
    ,T.ChangeTrackingMask  
    ,T.LastChgTS'  
                            WHEN @ViewType_HS THEN N'  
     T.ID AS HS_ID  
    ,T.Status_ID  
    ,T.HP_ID AS ID  
    ,T.MUID  
    ,T.Version_ID  
    ,T.Name AS Name  
    ,T.Code AS Code  
    ,T.Hierarchy_ID AS Hierarchy_ID  
    ,T.ID AS LastChgTS'  
                    END  
                    WHEN @MemberType_Collection THEN  
                        CASE @ViewType  
                            WHEN @ViewType_EN THEN N'  
     T.ID  
    ,T.MUID  
    ,T.Version_ID  
    ,T.Name AS Name  
    ,T.Code AS Code  
    ,T.ValidationStatus_ID  
    ,T.Description  
    ,COALESCE([Owner_ID].UserName, N'''') AS Owner_ID  
    ,T.LastChgTS'  
                            WHEN @ViewType_HS THEN N'  
     T.ID AS HS_ID  
    ,T.Status_ID  
    ,T.CN_ID AS ID  
    ,T.MUID  
    ,T.Version_ID  
    ,T.Name AS Name  
    ,T.Code AS Code  
    ,T.Description  
    ,COALESCE([Owner_ID].UserName, N'''') AS Owner_ID  
    ,T.ID AS LastChgTS'  
                        END  
                END;  
  
            SET @Select = @Select + N'  
    --Auditing columns (Creation)  
    ,T.EnterDTM  
    ,T.EnterUserID  
    ,eu.[UserName] AS EnterUserName  
    ,eu.MUID AS EnterUserMuid  
  
    --Auditing columns (Updates)  
    ,T.LastChgDTM  
    ,T.LastChgUserID  
    ,lcu.[UserName] AS LastChgUserName  
    ,lcu.MUID AS LastChgUserMuid  
  
    --Custom attributes';  
  
            SET @From += N'  
LEFT JOIN mdm.tblUser eu  
    ON T.EnterUserID = eu.ID  
LEFT JOIN mdm.tblUser lcu  
    ON T.LastChgUserID = lcu.ID';  
  
            IF @MemberType_ID = @MemberType_Collection  
            BEGIN  
                SET @From += N'  
LEFT JOIN mdm.tblUser AS Owner_ID   
    ON Owner_ID.ID = T.Owner_ID';  
            END  
  
            IF @MemberType_ID = @MemberType_Leaf AND @ViewType = @ViewType_PD  
            BEGIN  
                SET @From += N'  
LEFT JOIN mdm.' + @EntityTable + N' AS EN  
    ON T.EN_ID = EN.ID AND T.Version_ID = EN.Version_ID';  
            END  
  
            WHILE EXISTS(SELECT 1 FROM @TempTable)  
            BEGIN  
                SELECT TOP 1  
                    @ViewColumn = ViewColumn,  
                    @TableColumn = TableColumn,  
                    @AttributeType_ID = AttributeType_ID,  
                    @AttributeDataType_ID = DataType_ID,  
                    @DomainEntity_ID = DomainEntity_ID,  
                    @DomainTable = DomainTable  
                FROM @TempTable  
                ORDER BY SortOrder;  
  
                SET @ViewColumnQuoted = QUOTENAME(@ViewColumn);  
  
                IF @AttributeType_ID = 1  
                BEGIN --FFA  
                    IF @ViewType <> @ViewType_PD  
                    BEGIN  
                        SET @Select = @Select + N'  
    ,T.' + QUOTENAME(@TableColumn) + N' AS ' + @ViewColumnQuoted;  
                    END  
                    ELSE  
                    BEGIN  
                        SET @Select = @Select + CONCAT(N'  
            ,NULLIF(T.', QUOTENAME(@TableColumn), N', ',  
                            CASE  
                                WHEN @AttributeDataType_ID = @AttributeDataType_Text OR @AttributeDataType_ID = @AttributeDataType_Link THEN N'NCHAR(0) /* @SysNull_Text */'  
                                WHEN @AttributeDataType_ID = @AttributeDataType_Number THEN N'-98765432101234567890/* @SysNull_Number */'  
                                WHEN @AttributeDataType_ID = @AttributeDataType_DateTime THEN N'N''5555-11-22T12:34:56'' /* @SysNull_DateTime */'  
                            END, N') AS ', @ViewColumnQuoted, N'  
            ,CASE WHEN T.', QUOTENAME(@TableColumn), N' IS NULL THEN 0 ELSE 1 END AS ', QUOTENAME(@ViewColumn + '.IsChanged'))  
                    END  
                END  
                ELSE IF @AttributeType_ID = 2  
                BEGIN --DBA  
                    SET @Select += N'  
    ,' + @ViewColumnQuoted + N'.Code AS ' + @ViewColumnQuoted + N'  
    , T.' + QUOTENAME(@TableColumn) + N' AS ' + QUOTENAME(@ViewColumn + N'.ID') + N'  
    ,' + @ViewColumnQuoted + N'.MUID AS ' + QUOTENAME(@ViewColumn + N'.MUID') + N'  
    ,' + @ViewColumnQuoted + N'.Name AS ' + QUOTENAME(@ViewColumn + N'.Name');  
  
                    IF @ViewType = @ViewType_PD  
                    BEGIN  
                        SET @Select += N'  
    ,CASE WHEN T.' + QUOTENAME(@TableColumn) + N'IS NULL THEN 0 ELSE 1 END AS ' + QUOTENAME(@ViewColumn + N'.IsChanged');  
                    END  
  
                    SET @From += N'  
LEFT JOIN mdm.' + QUOTENAME(@DomainTable) + N' AS ' + @ViewColumnQuoted + N'  
    ON ' + @ViewColumnQuoted + N'.ID = T.' + QUOTENAME(@TableColumn) + N' AND ' + @ViewColumnQuoted + N'.Version_ID = T.Version_ID';  
                END  
                ELSE IF @AttributeType_ID = 4  
                BEGIN --File  
                    SET @Select += N'  
    ,' + @ViewColumnQuoted + N'.FileName AS ' + @ViewColumnQuoted + N'  
    ,T.' + QUOTENAME(@TableColumn) + N' AS ' + QUOTENAME(@ViewColumn + N'.ID');  
                    IF @ViewType = @ViewType_PD  
                    BEGIN  
                        SET @Select += N'  
    ,CASE WHEN T.' + QUOTENAME(@TableColumn) + N'IS NULL THEN 0 ELSE 1 END AS ' + QUOTENAME(@ViewColumn + N'.IsChanged');  
                    END  
  
                    SET @From += N'  
LEFT JOIN mdm.tblFile AS ' + @ViewColumnQuoted + N'  
    ON ' + @ViewColumnQuoted + N'.ID = T.' + QUOTENAME(@TableColumn);  
                END; --if  
  
                DELETE FROM @TempTable WHERE ViewColumn = @ViewColumn;  
            END; --while  
  
            SET @Select = CASE  
                WHEN EXISTS(SELECT 1 FROM sys.views WHERE [name] = @ViewName AND [schema_id] = SCHEMA_ID('mdm')) THEN N'ALTER '  
                ELSE N'  
CREATE ' END + N'VIEW mdm.' + QUOTENAME(@ViewName) + N'  
/*WITH ENCRYPTION*/ AS  
SELECT ' + @Select;  
  
            IF @MemberType_ID = @MemberType_Leaf BEGIN  
                SET @Select = @Select + N'  
FROM mdm.' +  
                CASE @ViewType  
                    WHEN @ViewType_EN THEN QUOTENAME(@EntityTable)  
                    WHEN @ViewType_PD THEN QUOTENAME(@EntityTable + N'_PD')  
                    WHEN @ViewType_HS THEN QUOTENAME(@EntityTable + N'_HS')  
                END + N' AS T';  
            END ELSE IF @MemberType_ID = @MemberType_Consolidated BEGIN  
                SET @Select = @Select + N'  
FROM mdm.' +  
                CASE @ViewType  
                    WHEN @ViewType_EN THEN QUOTENAME(@HierarchyParentTable)  
                    WHEN @ViewType_HS THEN QUOTENAME(@HierarchyParentTable + N'_HS')  
                END + N' AS T';  
  
            END ELSE IF @MemberType_ID = @MemberType_Collection BEGIN  
                SET @Select = @Select + N'  
FROM mdm.' +  
                CASE @ViewType  
                    WHEN @ViewType_EN THEN QUOTENAME(@CollectionTable)  
                    WHEN @ViewType_HS THEN QUOTENAME(@CollectionTable + N'_HS')  
                END + N' AS T';  
            END; --if  
  
            SET @Select += @From  
  
            IF @ViewType = @ViewType_EN  
            BEGIN  
                SET @Select += N'  
WHERE T.Status_ID = 1;';  
            END  
  
            --PRINT(@Select);  
            EXEC sp_executesql @Select;  
  
        END; --if  
  
    END; --if  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpCreateSystemDerivedHierarchyParentChildView]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    EXEC mdm.udpCreateSystemDerivedHierarchyParentChildView 1;  
    EXEC mdm.udpCreateSystemDerivedHierarchyParentChildView 2;  
    EXEC mdm.udpCreateSystemDerivedHierarchyParentChildView 5;  
    EXEC mdm.udpCreateSystemDerivedHierarchyParentChildView 10;  
    EXEC mdm.udpCreateAllViews;  
*/  
CREATE PROCEDURE [mdm].[udpCreateSystemDerivedHierarchyParentChildView]  
(  
    @DerivedHierarchy_ID    INT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    --Defer view generation if we are in the middle of an upgrade or demo-rebuild  
    IF NOT APPLOCK_MODE(N'public', N'DeferViewGeneration', N'Session') = N'NoLock'   
    BEGIN  
        RETURN;  
    END  
  
    DECLARE   
         @ViewName                      SYSNAME  
        ,@ViewExists                    BIT  
        ,@AnchorNullRecursions          BIT  
  
        -- tblDerivedHierarchyDetail.ForeignType_ID  
        ,@HierarchyItemType_Entity      TINYINT = 0  
        ,@HierarchyItemType_DBA         TINYINT = 1  
        ,@HierarchyItemType_Hierarchy   TINYINT = 2  
        ,@HierarchyItemType_ManyToMany  TINYINT = 5  
  
        ,@MemberType_Leaf               TINYINT = 1  
        ,@MemberType_Consolidated       TINYINT = 2  
        ;  
  
    SELECT  
        @ViewName = CONCAT(N'viw_SYSTEM_', Model_ID, N'_', ID, N'_PARENTCHILD_DERIVED'),  
        @AnchorNullRecursions =  AnchorNullRecursions  
    FROM mdm.tblDerivedHierarchy  
    WHERE ID = @DerivedHierarchy_ID;  
  
    IF @ViewName IS NULL --Ensure hierarchy row actually exists  
    BEGIN   
        RETURN;  
    END  
  
    SET @ViewExists = CASE WHEN EXISTS(SELECT 1 FROM sys.views WHERE [name] = @ViewName AND [schema_id] = SCHEMA_ID('mdm')) THEN 1 ELSE 0 END;  
  
    -- Get all of the hierarchy's levels  
    CREATE TABLE #Levels   
    (  
         Level_ID       INT PRIMARY KEY  
        ,Item_ID        INT NOT NULL  
        ,Item_MUID      UNIQUEIDENTIFIER NOT NULL  
        ,Item_Name      NVARCHAR(100) NOT NULL  
        ,ItemType_ID    TINYINT NOT NULL  
        ,IsVisible      BIT NOT NULL  
        ,IsRecursive    BIT NOT NULL  
        ,Entity_ID      INT NOT NULL  
        ,Entity_MUID    UNIQUEIDENTIFIER NOT NULL  
        ,EntityViewName SYSNAME NOT NULL  
        ,ManyToManyMappingEntityViewName SYSNAME NULL  
        ,ManyToManyChildAttribute_Name NVARCHAR(100) NULL  
    );  
    CREATE INDEX #ix_Levels_IsVisible ON #Levels(IsVisible);  
  
    INSERT INTO #Levels  
    SELECT   
         Level_ID  
        ,Foreign_ID  
        ,Foreign_MUID  
        ,Foreign_Name  
        ,ForeignType_ID  
        ,IsLevelVisible  
        ,IsRecursive  
        ,Entity_ID  
        ,Entity_MUID  
        ,mdm.udfViewNameGetByID(Entity_ID,  
            CASE ForeignType_ID   
                WHEN @HierarchyItemType_Hierarchy THEN 4 -- viw_SYSTEM_<MID>_<EID>_PARENTCHILD  
                ELSE 1                                   -- viw_SYSTEM_<MID>_<EID>_CHILDATTRIBUTES  
                END, 0, 0)  
        ,CASE WHEN ForeignType_ID = @HierarchyItemType_ManyToMany THEN mdm.udfViewNameGetByID(ForeignEntity_ID, 1, 0, 0) END ManyToManyMappingEntityViewName  
        ,ManyToManyChildAttribute_Name  
    FROM mdm.viw_SYSTEM_SCHEMA_HIERARCHY_DERIVED_LEVELS d  
    WHERE Hierarchy_ID = @DerivedHierarchy_ID  
  
    DECLARE  
         @SQL                 NVARCHAR(MAX)  
  
        ,@Level_ID               INT  
        ,@Item_ID                INT  
        ,@Item_MUID              UNIQUEIDENTIFIER  
        ,@Item_Name              NVARCHAR(100)  
        ,@ItemType_ID            TINYINT  
        ,@Entity_ID              INT  
        ,@Entity_MUID            UNIQUEIDENTIFIER  
        ,@IsRecursive            BIT  
        ,@EntityViewName         SYSNAME  
        ,@ManyToManyMappingEntityViewName   SYSNAME  
        ,@ManyToManyChildAttribute_Name     NVARCHAR(100)  
  
        ,@PriorVisibleLevel_ID          INT  
        ,@PriorItem_ID                  INT  
        ,@PriorItemType_ID              TINYINT  
        ,@PriorEntity_ID                INT  
        ,@PriorEntity_MUID              UNIQUEIDENTIFIER  
        ,@PriorIsRecursive              BIT  
        ,@PriorVisibleEntityViewName    SYSNAME  
        ,@PriorManyToManyMappingEntityViewName  SYSNAME  
        ,@PriorManyToManyChildAttribute_Name    NVARCHAR(100)  
  
        ,@NextLevel_ID              INT  
        ,@NextItem_ID               INT  
        ,@NextItem_ID_Clause        NVARCHAR(MAX)  --injection safe.  Only INT values appended into CASE statement  
        ,@NextItemType_ID           TINYINT  
        ,@NextItemType_ID_Clause    NVARCHAR(MAX)  --injection safe.  Only INT values appended into CASE statement  
        ,@NextEntity_ID             INT  
        ,@NextEntity_ID_Clause      NVARCHAR(MAX)  
        ,@NextEntity_MUID           UNIQUEIDENTIFIER  
        ,@NextEntity_MUID_Clause    NVARCHAR(MAX)  
  
        ,@DomainAttributeName       NVARCHAR(100)  
        ,@PriorDomainAttributeName  NVARCHAR(100)  
  
        ,@MaxLevel_ID               INT  
        ,@ChildTypeID_Clause        NVARCHAR(MAX) = N''  
        ,@ParentType_ID             INT  
        ,@DomainAttribute_ID_Clause NVARCHAR(1000)  
        ;  
  
    SELECT @MaxLevel_ID = MAX(Level_ID)  
    FROM #Levels  
  
    IF @MaxLevel_ID IS NULL  
    BEGIN  
        -- The hierarchy has no levels. Delete the view if it already exists.  
        IF @ViewExists = 1  
        BEGIN  
            SET @SQL = CONCAT(N'DROP VIEW mdm.', QUOTENAME(@ViewName), N';');  
            EXEC sp_executesql @SQL;  
        END;  
  
        RETURN;  
    END;  
  
    SET @SQL = CONCAT(CASE WHEN @ViewExists = 1 THEN N'ALTER' ELSE N'CREATE' END, N' VIEW mdm.' + QUOTENAME(@ViewName), N' AS');  
  
    SET @Level_ID = @MaxLevel_ID + 1;  
  
    -- Loop through all levels, from top to bottom, and create Union statements for each level.  
    WHILE EXISTS(SELECT 1 FROM #Levels WHERE Level_ID < @Level_ID AND IsVisible = 1)   
    BEGIN  
        SET @IsRecursive = 0;  
  
        --Get ID's  
        SELECT TOP 1  
             @Level_ID          = Level_ID  
            ,@Item_ID           = Item_ID  
            ,@Item_MUID         = Item_MUID  
            ,@Item_Name         = Item_Name  
            ,@ItemType_ID       = ItemType_ID  
            ,@IsRecursive       = IsRecursive  
            ,@Entity_ID         = Entity_ID  
            ,@Entity_MUID       = Entity_MUID  
            ,@EntityViewName    = EntityViewName  
            ,@ManyToManyMappingEntityViewName = ManyToManyMappingEntityViewName  
            ,@ManyToManyChildAttribute_Name = ManyToManyChildAttribute_Name  
        FROM #Levels   
        WHERE   Level_ID < @Level_ID  
            AND IsVisible = 1  
        ORDER BY Level_ID DESC;  
  
        -- Always use an ORDER BY when selecting TOP  
        SELECT TOP 1   
             @NextLevel_ID = Level_ID  
            ,@NextItem_ID = Item_ID  
            ,@NextItemType_ID = ItemType_ID  
            ,@NextEntity_ID   = Entity_ID  
            ,@NextEntity_MUID = Entity_MUID  
        FROM #Levels  
        WHERE   Level_ID < @Level_ID   
            AND IsVisible = 1  
        ORDER BY Level_ID DESC;  
  
        SET @NextLevel_ID = COALESCE(@NextLevel_ID, -1);  
  
        IF @ItemType_ID = @HierarchyItemType_Hierarchy   
        BEGIN  
            -- Get the next item type\id from the next visible level.  
            SELECT TOP 1  
                 @NextItem_ID = Item_ID  
                ,@NextItemType_ID = ItemType_ID  
                ,@NextEntity_ID   = Entity_ID  
                ,@NextEntity_MUID = Entity_MUID  
            FROM #Levels  
            WHERE   Level_ID < @NextLevel_ID   
                AND IsVisible = 1  
            ORDER BY Level_ID DESC  
        END  
  
        SET @NextItem_ID = ISNULL(@NextItem_ID, -1);  
        --SET @NextItemType_ID = ISNULL(@NextItemType_ID, -1);  
  
  
        --Get Attribute DBA Column Name  
        IF @ItemType_ID IN (@HierarchyItemType_DBA, @HierarchyItemType_ManyToMany)  
        BEGIN  
            SET @DomainAttributeName = @Item_Name;  
        END ELSE  
        BEGIN  
            SET @DomainAttributeName = N'Code';  
        END  
  
        --Get NextEntity_ID  
        IF @ItemType_ID = @HierarchyItemType_Hierarchy  
        BEGIN  
            SET @NextEntity_ID_Clause = CONCAT(  
   N'CASE ChildType_ID  
        WHEN ', @MemberType_Leaf, N'/*Leaf*/ THEN ', @NextEntity_ID, N'  
        WHEN ', @MemberType_Consolidated, N'/*Consolidated*/ THEN ', @Entity_ID, N'  
     END');  
            SET @NextEntity_MUID_Clause = CONCAT(  
   N'CASE ChildType_ID  
        WHEN ', @MemberType_Leaf, N'/*Leaf*/ THEN ''', @NextEntity_MUID, N'''  
        WHEN ', @MemberType_Consolidated, N'/*Consolidated*/ THEN ''', @Entity_MUID, N'''  
     END');  
        END ELSE   
        BEGIN  
            SET @NextEntity_ID_Clause = COALESCE(CAST(@NextEntity_ID AS NVARCHAR(100)), N'NULL');  
            SET @NextEntity_MUID_Clause = CONCAT(N'''', @NextEntity_MUID, N'''')  
        END; --if  
  
        SET @DomainAttribute_ID_Clause =  
            CASE  
                WHEN @ItemType_ID = @HierarchyItemType_Entity THEN N'-1'  
                WHEN @ItemType_ID IN (@HierarchyItemType_DBA, @HierarchyItemType_ManyToMany) THEN CAST(@Item_ID AS NVARCHAR(1000))  
                WHEN @ItemType_ID = @HierarchyItemType_Hierarchy THEN CONCAT(  
   N'CASE  
        WHEN ChildType_ID = ', @MemberType_Leaf, N'/*Leaf*/ THEN ', @NextItem_ID, N'  
        WHEN ChildType_ID = ', @MemberType_Consolidated, N'/*Consolidated*/ THEN ''''  
     END')  
            END;  
        SET @ChildTypeID_Clause =   
            CASE  
                WHEN @ItemType_ID = @HierarchyItemType_Hierarchy THEN N'ChildType_ID'  
                ELSE CONCAT(@HierarchyItemType_DBA, N'/*DBA*/')  
            END; --case  
        SET @ParentType_ID =   
            CASE  
                WHEN @ItemType_ID = @HierarchyItemType_Hierarchy THEN @HierarchyItemType_Hierarchy  
                ELSE @HierarchyItemType_DBA  
            END; --case  
        SET @NextItem_ID_Clause =   
            CASE  
                WHEN @ItemType_ID = @HierarchyItemType_Hierarchy THEN CONCAT(  
   N'CASE  
        WHEN ChildType_ID = ', @MemberType_Leaf, N'/*Leaf*/ THEN ', @NextItem_ID, N'  
        WHEN ChildType_ID = ', @MemberType_Consolidated, N'/*Consolidated*/ THEN ', @Item_ID, N'  
     END')  
                ELSE CAST(@NextItem_ID AS NVARCHAR(100))  
            END; --case  
        SET @NextItemType_ID_Clause =   
            CASE  
                WHEN @ItemType_ID = @HierarchyItemType_Hierarchy THEN CONCAT(  
   N'CASE  
        WHEN ChildType_ID = ', @MemberType_Leaf, N'/*Leaf*/ THEN ', @NextItemType_ID, N'  
        WHEN ChildType_ID = ', @MemberType_Consolidated, N'/*Consolidated*/ THEN ', @HierarchyItemType_Hierarchy, N'/*Hierarchy*/   
     END')  
                ELSE COALESCE(CAST(@NextItemType_ID AS NVARCHAR(10)), N'NULL')  
            END; --case  
  
        -- Topmost Level  
        IF @Level_ID = @MaxLevel_ID   
        BEGIN  
            SET @SQL += CONCAT(N'  
SELECT   
     ', CASE WHEN @ItemType_ID = @HierarchyItemType_Hierarchy THEN N'Parent_ID' ELSE '0' END, N' AS Parent_ID  
    ,', CASE WHEN @ItemType_ID = @HierarchyItemType_Hierarchy THEN CONCAT(N'CASE ChildType_ID WHEN ', @MemberType_Leaf, N'/*Leaf*/ THEN Child_EN_ID WHEN ', @MemberType_Consolidated, N'/*Consolidated*/ THEN Child_HP_ID END') ELSE N'ID' END + N' AS Child_ID  
    ,Version_ID AS Version_ID  
    ,', @DomainAttribute_ID_Clause, N' AS DomainAttribute_ID  
    ,1 AS ParentVisible  
    ,', @Entity_ID, N' AS Entity_ID  
    ,''', @Entity_MUID, N''' AS Entity_MUID  
    ,', @NextEntity_ID_Clause, N' AS NextEntity_ID  
    ,', @NextEntity_MUID_Clause, N' AS NextEntity_MUID  
    ,', @Item_ID, N' AS Item_ID  
    ,''', @Item_MUID, N''' AS Item_MUID  
    ,', @ItemType_ID, N' AS ItemType_ID  
    ,', CASE WHEN @ItemType_ID = @HierarchyItemType_Hierarchy THEN CONCAT(N'CASE WHEN T.Parent_ID <> 0 THEN ', @Item_ID, N' ELSE 0 END') ELSE N'0' END, N' AS ParentItem_ID  
    ,', CASE WHEN @ItemType_ID = @HierarchyItemType_Hierarchy THEN CONCAT(N'CASE WHEN T.Parent_ID <> 0 THEN ', @ItemType_ID, N' ELSE ', @HierarchyItemType_Entity, N'/*Entity*/ END') ELSE CONCAT(@HierarchyItemType_Entity, N'/*Entity*/') END, N' AS ParentItemType_ID  
    ,', CASE WHEN @ItemType_ID = @HierarchyItemType_Hierarchy THEN CONCAT(N'', @Entity_ID) ELSE N'NULL' END, N' AS ParentEntity_ID  
    ,', CASE WHEN @ItemType_ID = @HierarchyItemType_Hierarchy THEN CONCAT(N'''', @Entity_MUID, N'''') ELSE N'NULL' END, N' AS ParentEntity_MUID  
    ,', @NextItem_ID_Clause, N' AS NextItem_ID  
    ,', @NextItemType_ID_Clause, N' AS NextItemType_ID  
    ,', CASE WHEN @ItemType_ID = @HierarchyItemType_Hierarchy THEN N'Child_Code' ELSE N'Code' END, N' AS ChildCode  
    ,', CASE WHEN @ItemType_ID = @HierarchyItemType_Hierarchy THEN N'Child_Name' ELSE N'Name' END, N' AS ChildName  
    ,', CASE WHEN @ItemType_ID = @HierarchyItemType_Hierarchy THEN N'Parent_Code' ELSE N'N''ROOT''' END, N' AS ParentCode  
    ,', CASE WHEN @ItemType_ID = @HierarchyItemType_Hierarchy THEN N'Parent_Name' ELSE N'N''''' END, N' AS ParentName  
    ,', @ChildTypeID_Clause, N' AS ChildType_ID  
    ,', CASE WHEN @ItemType_ID = @HierarchyItemType_Hierarchy THEN CONVERT(NVARCHAR(10), @ParentType_ID) ELSE CONCAT(@HierarchyItemType_Hierarchy, N'/*Hierarchy*/') END, N' AS ParentType_ID  
    ,', @Level_ID, N' AS Level  
    ,', CASE WHEN @ItemType_ID = @HierarchyItemType_Hierarchy THEN N'CONVERT(SQL_VARIANT, T.Child_SortOrder)' ELSE N'T.Code' END, N' AS SortItem  
FROM mdm.', QUOTENAME(@EntityViewName), N' AS T ');  
  
            IF @ItemType_ID = @HierarchyItemType_Hierarchy   
            BEGIN  
                SET @SQL += CONCAT(N'  
WHERE T.Hierarchy_ID = ', @Item_ID);  
            END   
            ELSE IF @ItemType_ID = @HierarchyItemType_DBA AND @IsRecursive = 1 AND @AnchorNullRecursions = 1  
            BEGIN  
            --Rendering for anchored recursive hierarchies.  
                SET @SQL += CONCAT(N'  
WHERE T.', QUOTENAME(@DomainAttributeName),N' IS NULL');  
            END  
        END   
        ELSE BEGIN  
  
        -- All other levels below the top level  
            DECLARE   
                 @ParentVisible     BIT = CASE WHEN @Level_ID <> @PriorVisibleLevel_ID - 1 THEN 0 ELSE 1 END  
                ,@ViewAlias         NVARCHAR(50) = N'T'  
                ,@PriorViewAlias    NVARCHAR(50);   
  
            SET @SQL += CONCAT(N'  
UNION ALL  
SELECT  
    ', CASE WHEN @PriorItemType_ID = @HierarchyItemType_Hierarchy THEN CONCAT(N'CASE priorLevel.ChildType_ID WHEN ', @MemberType_Leaf, N'/*Leaf*/ THEN priorLevel.Child_EN_ID WHEN ', @MemberType_Consolidated, N'/*Consolidated*/ THEN priorLevel.Child_HP_ID END') ELSE N'priorLevel.ID' END, N' AS Parent_ID  
    ,T.ID AS Child_ID  
    ,T.Version_ID AS Version_ID  
    ,', CASE WHEN @PriorIsRecursive = 1 AND @ParentVisible = 1 THEN CONVERT(NVARCHAR(30), @PriorItem_ID) ELSE @DomainAttribute_ID_Clause END, N' AS DomainAttribute_ID  
    ,', @ParentVisible, N' AS ParentVisible  
    ,', @Entity_ID, N' AS Entity_ID  
    ,''', @Entity_MUID, N''' AS Entity_MUID  
    ,', @NextEntity_ID_Clause, N' AS NextEntity_ID  
    ,', @NextEntity_MUID_Clause, N' AS NextEntity_MUID  
    ,', @Item_ID, N' AS Item_ID  
    ,''', @Item_MUID, N''' AS Item_MUID  
    ,', @ItemType_ID, N' AS ItemType_ID  
    ,', @PriorItem_ID, N' AS ParentItem_ID  
    ,', @PriorItemType_ID, N' AS ParentItemType_ID  
    ,''', @PriorEntity_ID, N''' AS ParentEntity_ID  
    ,''', @PriorEntity_MUID, N''' AS ParentEntity_MUID  
    ,', @NextItem_ID_Clause, N' AS NextItem_ID  
    ,', @NextItemType_ID_Clause, N' AS NextItemType_ID  
    ,T.Code AS ChildCode  
    ,T.Name AS ChildName  
    ,priorLevel.', QUOTENAME(CASE WHEN @PriorItemType_ID = @HierarchyItemType_Hierarchy THEN N'Child_Code' ELSE N'Code' END), N' AS ParentCode  
    ,priorLevel.', QUOTENAME(CASE WHEN @PriorItemType_ID = @HierarchyItemType_Hierarchy THEN N'Child_Name' ELSE N'Name' END), N' AS ParentName  
    ,', @ChildTypeID_Clause, N' AS ChildType_ID  
    ,', @ParentType_ID, N' AS ParentType_ID  
    ,', @Level_ID, N' AS Level  
    ,', CASE WHEN @ItemType_ID = @HierarchyItemType_Hierarchy THEN N'CONVERT(SQL_VARIANT, T.Child_SortOrder)' ELSE N'T.Code' END, N' AS SortItem  
FROM mdm.', QUOTENAME(@EntityViewName), N' AS T'  
            );  
  
            --Check to see if Levels are skipped----------------  
            IF @ParentVisible = 0   
            BEGIN  
                ---Loop through all NonVisible Levels  
                --Get List of tables to join to if skipping levels  
                DECLARE   
                     @SkippedLevel_ID        INT = @Level_ID  
                    ,@PriorSkippedLevel_ID   INT  
                    ,@PriorSkippedLevelItemType_ID  TINYINT = NULL  
                    ,@MaxSkippedLevel_ID     INT = @PriorVisibleLevel_ID - 1  
                    ,@SkippedItem_ID         INT  
                    ,@SkippedItemType_ID     TINYINT  
                    ,@SkippedLevelsCount     INT = 0  
                    ,@SkippedEntityViewName  SYSNAME  
                    ,@SkippedDomainAttributeName NVARCHAR(100)  
                    ,@SkippedManyToManyMappingEntityViewName NVARCHAR(128)  
                    ,@SkippedManyToManyChildAttribute_Name NVARCHAR(100)  
                    ;  
  
                WHILE EXISTS(SELECT 1   
                             FROM #Levels  
                             WHERE Level_ID > @SkippedLevel_ID  
                                AND Level_ID <= @MaxSkippedLevel_ID)   
                BEGIN  
  
                    SELECT TOP 1  
                         @SkippedLevel_ID = Level_ID  
                        ,@SkippedItem_ID = Item_ID  
                        ,@SkippedItemType_ID = ItemType_ID  
                        ,@SkippedEntityViewName = EntityViewName  
                        ,@SkippedDomainAttributeName = Item_Name -- Note: No need to check item type. Hierarchy and Entity levels can only be on the top or bottom, which are always visible.  
                        ,@SkippedManyToManyMappingEntityViewName = ManyToManyMappingEntityViewName  
                        ,@SkippedManyToManyChildAttribute_Name = ManyToManyChildAttribute_Name  
                    FROM #Levels  
                    WHERE   Level_ID > @SkippedLevel_ID  
                        AND Level_ID <= @MaxSkippedLevel_ID  
                    ORDER BY Level_ID ASC;  
  
                    IF @SkippedItemType_ID = @HierarchyItemType_ManyToMany  
                    BEGIN  
                        SET @PriorViewAlias = @ViewAlias;  
                        SET @ViewAlias = CONCAT(N'hiddenLvl_', @SkippedLevel_ID, 'map');  
                        -- Note: Joining on Member ID (not Code) for faster perf by making use of the table primary key  
                        SET @SQL += CONCAT(N'  
INNER JOIN mdm.', QUOTENAME(@SkippedManyToManyMappingEntityViewName), N' AS ', QUOTENAME(@ViewAlias), N'  
ON      ', QUOTENAME(@PriorViewAlias), N'.ID = ', QUOTENAME(@ViewAlias), N'.', QUOTENAME(CONCAT(@SkippedManyToManyChildAttribute_Name, N'.ID')), N'  
    AND ', QUOTENAME(@PriorViewAlias), N'.Version_ID = ', QUOTENAME(@ViewAlias), N'.Version_ID')  
                    END  
  
                    SET @PriorViewAlias = @ViewAlias;  
                    SET @ViewAlias = CONCAT(N'hiddenLvl_', @SkippedLevel_ID);  
                    --Build Join Table List  
                    SET @SQL += CONCAT(N'  
INNER JOIN mdm.', QUOTENAME(@SkippedEntityViewName), N' AS ', QUOTENAME(@ViewAlias), N'  
ON      ', QUOTENAME(@PriorViewAlias), N'.', QUOTENAME(CONCAT(@SkippedDomainAttributeName, N'.ID')), N' = ', QUOTENAME(@ViewAlias), N'.ID  
    AND ', QUOTENAME(@PriorViewAlias), N'.Version_ID = ', QUOTENAME(@ViewAlias), N'.Version_ID');  
  
                    --If Last Table to Join then and the final table to join back to base  
                    IF @SkippedLevel_ID = @MaxSkippedLevel_ID   
                    BEGIN  
                        IF      COALESCE(@PriorSkippedLevelItemType_ID, @PriorItemType_ID) = @HierarchyItemType_ManyToMany   
                            AND (@PriorSkippedLevel_ID IS NULL OR @PriorSkippedLevel_ID <> @SkippedLevel_ID - 1) -- only add the mapping table here if the prior (M2M) level is not hidden  
                        BEGIN  
                            SET @PriorViewAlias = @ViewAlias;  
                            SET @ViewAlias = CONCAT(N'hiddenLvl_', @SkippedLevel_ID, 'map');  
                            SET @SQL += CONCAT(N'  
INNER JOIN mdm.', QUOTENAME(@PriorManyToManyMappingEntityViewName), N' AS ', QUOTENAME(@ViewAlias), N'  
ON      ', QUOTENAME(@PriorViewAlias), N'.ID = ', QUOTENAME(@ViewAlias), N'.', QUOTENAME(CONCAT(@PriorManyToManyChildAttribute_Name, N'.ID')), N'  
    AND ', QUOTENAME(@PriorViewAlias), N'.Version_ID = ', QUOTENAME(@ViewAlias), N'.Version_ID');  
                          
                        END  
  
                        SET @PriorViewAlias = @ViewAlias;  
                        SET @ViewAlias = N'priorLevel';  
                        SET @SQL += CONCAT(N'  
INNER JOIN mdm.', QUOTENAME(@PriorVisibleEntityViewName), N' AS ', QUOTENAME(@ViewAlias), N'  
ON      ', QUOTENAME(@PriorViewAlias), N'.', QUOTENAME(CONCAT(@PriorDomainAttributeName, N'.ID')), N' = ', QUOTENAME(@ViewAlias), N'.', QUOTENAME(CASE WHEN @PriorItemType_ID = @HierarchyItemType_Hierarchy THEN N'Child_ID' ELSE N'ID' END), N'  
    AND ', QUOTENAME(@PriorViewAlias), N'.Version_ID = ', QUOTENAME(@ViewAlias), N'.Version_ID',  
                        CASE WHEN @PriorItemType_ID = @HierarchyItemType_Hierarchy THEN CONCAT(N'  
    AND ', QUOTENAME(@ViewAlias), N'.ChildType_ID = ', @MemberType_Leaf, N'/*Leaf*/') END);  
                    END  
  
                    SET @PriorManyToManyMappingEntityViewName = @SkippedManyToManyMappingEntityViewName;  
                    SET @PriorManyToManyChildAttribute_Name = @SkippedManyToManyChildAttribute_Name;  
                    SET @PriorSkippedLevelItemType_ID = @SkippedItemType_ID;  
                    SET @PriorSkippedLevel_ID = @SkippedLevel_ID  
                END; --while  
                --End of Sub Loop of NonVisible Levels  
  
            END  
            ELSE BEGIN  
                --Visible Levels  
  
                IF @PriorItemType_ID = @HierarchyItemType_ManyToMany  
                BEGIN  
                    SET @PriorViewAlias = @ViewAlias;  
                    SET @ViewAlias = N'map';  
  
                    SET @SQL += CONCAT(N'  
INNER JOIN mdm.', QUOTENAME(@PriorManyToManyMappingEntityViewName), N' AS ', QUOTENAME(@ViewAlias), N'  
ON      ', QUOTENAME(@PriorViewAlias), N'.ID = ', QUOTENAME(@ViewAlias), N'.', QUOTENAME(CONCAT(@PriorManyToManyChildAttribute_Name, N'.ID')), N'  
    AND ', QUOTENAME(@PriorViewAlias), N'.Version_ID = ', QUOTENAME(@ViewAlias), N'.Version_ID')  
                  
                END  
  
                SET @PriorViewAlias = @ViewAlias;  
                SET @ViewAlias = N'priorLevel';  
  
                SET @SQL += CONCAT(N'  
INNER JOIN mdm.', QUOTENAME(@PriorVisibleEntityViewName), N' AS ', QUOTENAME(@ViewAlias), N'  
ON      ', QUOTENAME(@PriorViewAlias), N'.', QUOTENAME(CONCAT(@PriorDomainAttributeName, N'.ID')), N' = ', QUOTENAME(@ViewAlias), N'.', QUOTENAME(CASE WHEN @PriorItemType_ID = @HierarchyItemType_Hierarchy THEN N'Child_ID' ELSE N'ID' END), N'  
    AND ', QUOTENAME(@PriorViewAlias), N'.Version_ID = ', QUOTENAME(@ViewAlias), N'.Version_ID');  
  
                IF @PriorItemType_ID = @HierarchyItemType_Hierarchy   
                BEGIN  
                    SET @SQL += CONCAT(N'  
    AND ', QUOTENAME(@ViewAlias), N'.ChildType_ID = ', @MemberType_Leaf, N'/*Leaf*/  
WHERE ', QUOTENAME(@ViewAlias), N'.Hierarchy_ID = ', @PriorItem_ID);  
                END; --if  
            END; --if  
        END; --if  
  
        SELECT  
             @PriorVisibleLevel_ID = @Level_ID  
            ,@PriorItem_ID = @Item_ID  
            ,@PriorItemType_ID = @ItemType_ID  
            ,@PriorVisibleEntityViewName = @EntityViewName  
            ,@PriorDomainAttributeName = @DomainAttributeName  
            ,@PriorEntity_ID = @Entity_ID  
            ,@PriorEntity_MUID = @Entity_MUID  
            ,@PriorIsRecursive = @IsRecursive  
            ,@PriorManyToManyMappingEntityViewName = @ManyToManyMappingEntityViewName  
            ,@PriorManyToManyChildAttribute_Name = @ManyToManyChildAttribute_Name  
  
        IF @ItemType_ID = @HierarchyItemType_Hierarchy   
        BEGIN --Skip next Level after Hierarchy  
            -- Always use an ORDER BY when selecting TOP  
            SELECT TOP 1   
                 @Level_ID = Level_ID  
                ,@Item_ID = Item_ID  
                ,@PriorDomainAttributeName = Item_Name  
            FROM #Levels  
            WHERE   Level_ID < @Level_ID  
                AND IsVisible = 1  
            ORDER BY Level_ID DESC;  
  
            SET @PriorVisibleLevel_ID -= 1 -- Adjust the prior visible level var, so that the skipped level isn't treated as a hidden level.  
        END; --if  
  
    END; --while  
  
    --PRINT @SQL;  
    --PRINT SUBSTRING(@SQL,4001,8000)  
    EXEC sp_executesql @SQL;  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpCreateSystemEXPViews]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    --Create for All Entities  
    DECLARE @Entities TABLE(ID INT)  
    DECLARE @EntityID INT  
    INSERT INTO @Entities SELECT ID FROM mdm.tblEntity ORDER BY ID  
    WHILE(SELECT COUNT(*) FROM @Entities) <> 0  
    BEGIN  
        SELECT TOP 1 @EntityID = ID FROM @Entities  
        EXEC mdm.udpCreateSystemEXPViews @EntityID,1  
        EXEC mdm.udpCreateSystemEXPViews @EntityID,2  
        EXEC mdm.udpCreateSystemEXPViews @EntityID,3  
        DELETE FROM @Entities WHERE ID=@EntityID  
    END  
  
    --account  
    EXEC mdm.udpCreateSystemEXPViews 41,1;  
    EXEC mdm.udpCreateSystemEXPViews 7,2;  
    EXEC mdm.udpCreateSystemEXPViews 7,3;  
  
    exec mdm.udpcreateallviews  
  
    --vld Branch  
    SELECT top 100 * FROM mdm.viw_SYSTEM_8_41_CHILDATTRIBUTES_EXP WHERE Version_ID = 21 ORDER BY Code  
  
    -_Account  
    SELECT * FROM mdm.viw_SYSTEM_2_7_CHILDATTRIBUTES_EXP WHERE Version_ID=4 order by Code;  
    SELECT * FROM mdm.viw_SYSTEM_2_9_CHILDATTRIBUTES_EXP WHERE Version_ID=4 order by Code;  
      
    SELECT * FROM mdm.viw_SYSTEM_2_7_PARENTATTRIBUTES_EXP;  
    SELECT * FROM mdm.viw_SYSTEM_2_7_COLLECTIONATTRIBUTES_EXP;  
*/  
CREATE PROCEDURE [mdm].[udpCreateSystemEXPViews]   
(  
    @EntityID       INT,  
    @MemberTypeID   TINYINT,  
    @ViewType       TINYINT = 0, -- 0 EN, 2 HS  
    @CorrelationID  UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)   
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    --Defer view generation if we are in the middle of an upgrade or demo-rebuild  
    IF APPLOCK_MODE(N'public', N'DeferViewGeneration', N'Session') = N'NoLock' BEGIN  
  
        DECLARE @EntityViewName                 SYSNAME,  
                @ParentChildViewName            SYSNAME,  
                @CollectionParentChildViewName  SYSNAME,  
                @ViewName                       SYSNAME,  
                @SQL                            NVARCHAR(MAX),  
                @TruncateGuard                  NVARCHAR(MAX) = N'',  
                @MemberType_Leaf                TINYINT = 1,  
                @MemberType_Consolidated        TINYINT = 2,  
                @MemberType_Collection          TINYINT = 3,  
                @MemberType_ParentChild             TINYINT = 4,  
                @MemberType_CollectionParentChild   TINYINT = 5,  
                @ViewType_EN                    TINYINT = 0,  
                @ViewType_HS                    TINYINT = 2,  
                @IsHierarchyEnabled             BIT = 0,  
                @IsCollectionEnabled            BIT = 0;  
  
        SELECT  
             @IsHierarchyEnabled  = CASE WHEN HierarchyParentTable IS NULL THEN 0 ELSE 1 END  
            ,@IsCollectionEnabled = CASE WHEN CollectionTable      IS NULL THEN 0 ELSE 1 END  
        FROM tblEntity  
        WHERE ID = @EntityID;  
  
        --Check to see if you are trying to create Parent/Collection Attributes view on an entity that does not support it. If so exit.  
        IF     (@IsHierarchyEnabled  = 0 AND @MemberTypeID = @MemberType_Consolidated)  
            OR (@IsCollectionEnabled = 0 AND @MemberTypeID = @MemberType_Collection)  
        BEGIN  
            RETURN(0);  
        END;  
  
        --Get the view names  
        SELECT   
            @EntityViewName = mdm.udfViewNameGetByID(@EntityID, @MemberTypeID, 0, 0), -- ends with "_[CHILD|PARENT|COLLECTION]ATTRIBUTES"  
            @ParentChildViewName = mdm.udfViewNameGetByID(@EntityID, @MemberType_ParentChild,0, @ViewType), -- ends with "_PARENTCHILD"  
            @CollectionParentChildViewName = mdm.udfViewNameGetByID(@EntityID, @MemberType_CollectionParentChild,0, @ViewType), -- ends with "_COLLECTIONPARENTCHILD"  
            @ViewName = mdm.udfViewNameGetByID(@EntityID, @MemberTypeID, 1, @ViewType); -- ends with "_[CHILD|PARENT|COLLECTION]ATTRIBUTES_EXP"  
  
        SET @SQL = @TruncateGuard + N'  
            SELECT   
                 T.*';  
        IF @IsHierarchyEnabled = 1 AND @MemberTypeID IN (@MemberType_Leaf, @MemberType_Consolidated)  
        BEGIN  
            SET @SQL += N'  
                ,PDL.Status_ID AS [Parent_Status_ID]  
                ,PDL.Parent_Code AS [Parent_Code]  
                ,PDL.Parent_Name AS [Parent_Name]  
                ,PDL.Hierarchy_MUID AS [Parent_HierarchyMuid]  
                ,PDL.Hierarchy_Name AS [Parent_HierarchyName]  
                ,PDL.Hierarchy_ID AS [Parent_HierarchyId]  
                ,PDL.Child_SortOrder AS [Child_SortOrder]  
                ,PDL.[LastChgTS] AS [Parent_LastChgTS]  
  
                --Auditing columns (Creation)  
                ,PDL.[EnterDTM] AS [Parent_EnterDTM]  
                ,PDL.[EnterUserID] AS [Parent_EnterUserID]  
                ,PDL.[EnterUserName] AS [Parent_EnterUserName]  
                ,PDL.[EnterUserMuid] AS [Parent_EnterUserMuid]  
  
                --Auditing columns (Updates)  
                ,PDL.[LastChgDTM] AS [Parent_LastChgDTM]  
                ,PDL.[LastChgUserID] AS [Parent_LastChgUserID]  
                ,PDL.[LastChgUserName] AS [Parent_LastChgUserName]  
                ,PDL.[LastChgUserMuid] AS [Parent_LastChgUserMuid]'  
        END  
        ELSE  
        BEGIN  
            SET @SQL += N'  
                ,NULL AS [Parent_Status_ID]  
                ,NULL AS [Parent_Code]  
                ,NULL AS [Parent_Name]  
                ,NULL AS [Parent_HierarchyMuid]  
                ,NULL AS [Parent_HierarchyName]  
                ,NULL AS [Parent_HierarchyId]  
                ,NULL AS [Child_SortOrder]  
                ,NULL AS [Parent_LastChgTS]  
  
                --Auditing columns (Creation)  
                ,NULL AS [Parent_EnterDTM]  
                ,NULL AS [Parent_EnterUserID]  
                ,NULL AS [Parent_EnterUserName]  
                ,NULL AS [Parent_EnterUserMuid]  
  
                --Auditing columns (Updates)  
                ,NULL AS [Parent_LastChgDTM]  
                ,NULL AS [Parent_LastChgUserID]  
                ,NULL AS [Parent_LastChgUserName]  
                ,NULL AS [Parent_LastChgUserMuid]'  
        END  
  
        IF @IsCollectionEnabled = 1  
        BEGIN  
            SET @SQL += N'  
                ,CDL.Status_ID AS [Collection_Status_ID]  
                ,CDL.Parent_Code as Collection_Code  
                ,CDL.Parent_Name as Collection_Name  
                ,CDL.SortOrder AS Collection_SortOrder  
                ,CDL.[Weight] AS Collection_Weight  
                ,CDL.[LastChgTS] AS [Collection_LastChgTS]  
  
                --Auditing columns (Creation)  
                ,CDL.[EnterDTM] AS [Collection_EnterDTM]  
                ,CDL.[EnterUserID] AS [Collection_EnterUserID]  
                ,CDL.[EnterUserName] AS [Collection_EnterUserName]  
                ,CDL.[EnterUserMuid] AS [Collection_EnterUserMuid]  
  
                --Auditing columns (Updates)  
                ,CDL.[LastChgDTM] AS [Collection_LastChgDTM]  
                ,CDL.[LastChgUserID] AS [Collection_LastChgUserID]  
                ,CDL.[LastChgUserName] AS [Collection_LastChgUserName]  
                ,CDL.[LastChgUserMuid] AS [Collection_LastChgUserMuid]'  
        END  
        ELSE  
        BEGIN  
            SET @SQL += N'  
                ,NULL AS [Collection_Status_ID]  
                ,NULL AS Collection_Code  
                ,NULL AS Collection_Name  
                ,NULL AS Collection_SortOrder  
                ,NULL AS Collection_Weight  
                ,NULL AS [Collection_LastChgTS]  
  
                --Auditing columns (Creation)  
                ,NULL AS [Collection_EnterDTM]  
                ,NULL AS [Collection_EnterUserID]  
                ,NULL AS [Collection_EnterUserName]  
                ,NULL AS [Collection_EnterUserMuid]  
  
                --Auditing columns (Updates)  
                ,NULL AS [Collection_LastChgDTM]  
                ,NULL AS [Collection_LastChgUserID]  
                ,NULL AS [Collection_LastChgUserName]  
                ,NULL AS [Collection_LastChgUserMuid]'  
        END  
  
        SET @SQL += N'  
            FROM   
                mdm.' + QUOTENAME(@EntityViewName) + ' AS T';  
          
        IF @IsHierarchyEnabled = 1 AND @MemberTypeID IN (@MemberType_Leaf, @MemberType_Consolidated) BEGIN  
            SET @SQL += N'  
            OUTER APPLY (  
                SELECT *  
                FROM mdm.' + QUOTENAME(@ParentChildViewName) + N'  
                WHERE   
                    Version_ID = T.Version_ID AND   
                    T.ID = ' + CASE @MemberTypeID WHEN @MemberType_Leaf THEN + ' Child_EN_ID ' WHEN @MemberType_Consolidated THEN + ' Child_HP_ID ' WHEN @MemberType_Collection THEN + ' Child_EN_ID ' END + N' AND   
                    ChildType_ID = ' + CONVERT(NVARCHAR(30), @MemberTypeID) + N'  
                --FOR XML PATH (N''Parent''), ELEMENTS, TYPE  
            ) AS PDL --PDL(XmlColumn);'  
        END;  
  
        IF @IsCollectionEnabled = 1  
        BEGIN  
            SET @SQL += N'  
            LEFT JOIN mdm.' + QUOTENAME(@CollectionParentChildViewName) + N' CDL  
            ON   
                CDL.Version_ID = T.Version_ID AND   
                T.ID = ' + CASE @MemberTypeID WHEN @MemberType_Leaf THEN + ' CDL.Child_EN_ID ' WHEN @MemberType_Consolidated THEN + ' CDL.Child_HP_ID ' WHEN @MemberType_Collection THEN + ' CDL.Child_CN_ID ' END + N' AND   
                CDL.ChildType_ID = ' + CONVERT(NVARCHAR(30), @MemberTypeID) + N'  
                ';  
        END; --if  
  
        --Alter or create the view	  
        SET @SQL = CASE  
            WHEN EXISTS(SELECT 1 FROM sys.views WHERE [name] = @ViewName AND [schema_id] = SCHEMA_ID(N'mdm')) THEN N'ALTER'  
            ELSE N'CREATE'  
        END + N' VIEW mdm.' + QUOTENAME(@ViewName) + N'  
            /*WITH ENCRYPTION*/ AS'  
            + @SQL;  
  
        --PRINT @SQL;  
        EXEC sp_executesql @SQL;  
  
    END; --if  
  
    SET NOCOUNT OFF;  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpCreateSystemLevelViews]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
    EXEC udpCreateSystemLevelViews 1;  
    EXEC udpCreateSystemLevelViews 11111; --invalid  
*/  
CREATE PROCEDURE [mdm].[udpCreateSystemLevelViews]   
(  
    @Entity_ID	INT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    --Defer view generation if we are in the middle of an upgrade or demo-rebuild  
    IF APPLOCK_MODE(N'public', N'DeferViewGeneration', N'Session') = N'NoLock' BEGIN  
  
        DECLARE @EntityTable  			sysname,  
                @HierarchyParentTable  	sysname,  
                @HierarchyTable  		sysname,  
                @TempTableJoinString 	NVARCHAR(MAX),  
                @TempRootJoin 			NVARCHAR(MAX),  
                @TempSelectString 		NVARCHAR(MAX),  
                @TempWhereString 		NVARCHAR(MAX),  
                @SQL					NVARCHAR(MAX),  
                @TempCounter  			INT,  
                @TempCounterString      NVARCHAR(30),  
                @TempCounterStringPrevious NVARCHAR(30),  
                @TempValue 				INT,  
                @ViewName				sysname;  
  
        SELECT	  
            @EntityTable = EntityTable,  
            @HierarchyParentTable = HierarchyParentTable,  
            @HierarchyTable = HierarchyTable,  
            @ViewName = N'viw_SYSTEM_' + CONVERT(NVARCHAR(30), Model_ID) + N'_' + CONVERT(NVARCHAR(30), ID) + N'_LEVELS',  
            @TempCounter = 1,  
            @TempSelectString = N'',  
            @TempTableJoinString = N''  
        FROM mdm.tblEntity  
        WHERE   ID = @Entity_ID   
            AND HierarchyTable IS NOT NULL;  
  
        IF @ViewName IS NOT NULL BEGIN --Ensure row actually exists  
  
            WHILE @TempCounter < 12	BEGIN  
                SET @TempCounterString = CONVERT(NVARCHAR(30), @TempCounter);  
                SET @TempCounterStringPrevious = CONVERT(NVARCHAR(30), @TempCounter-1);  
                SET @TempSelectString += N'  
                    CASE   
                        WHEN EN' + @TempCounterString + N'.ID IS NOT NULL   
                        THEN EN' + @TempCounterString + N'.Code   
                        WHEN HP' + @TempCounterString + N'.ID IS NOT NULL THEN HP' + @TempCounterString + N'.Code   
                        ELSE NULL   
                    END AS L' + @TempCounterString + N','  
                SET @TempTableJoinString += N'  
                    LEFT JOIN mdm.' + quotename(@HierarchyTable) + N' H' + @TempCounterString + N'   
                        ON  H' + @TempCounterString + N'.Hierarchy_ID = H' + @TempCounterStringPrevious + N'.Hierarchy_ID  
                        AND H' + @TempCounterString + N'.Version_ID = H' + @TempCounterStringPrevious + N'.Version_ID  
                        AND H' + @TempCounterStringPrevious + N'.ChildType_ID = 2						  
                        AND H' + @TempCounterString + N'.Parent_HP_ID = H' + @TempCounterStringPrevious + N'.Child_HP_ID   
                        AND H' + @TempCounterString + N'.Status_ID = H' + @TempCounterStringPrevious + N'.Status_ID  
                    LEFT JOIN mdm.' + quotename(@EntityTable) + N' EN' + @TempCounterString + N'   
                        ON  H' + @TempCounterString + N'.ChildType_ID = 1 						  
                        AND H' + @TempCounterString + N'.Version_ID = EN' + @TempCounterString + N'.Version_ID  
                        AND H' + @TempCounterString + N'.Child_EN_ID = EN' + @TempCounterString + N'.ID   
                        AND H' + @TempCounterString + N'.Status_ID = EN' + @TempCounterString + N'.Status_ID  
                        AND EN' + @TempCounterString + N'.Status_ID = 1  
                    LEFT JOIN mdm.' + quotename(@HierarchyParentTable) + N' HP' + @TempCounterString + N'   
                        ON  H' + @TempCounterString + N'.ChildType_ID = 2 						  
                        AND H' + @TempCounterString + N'.Version_ID = HP' + @TempCounterString + N'.Version_ID  
                        AND H' + @TempCounterString + N'.Child_HP_ID = HP' + @TempCounterString + N'.ID   
                        AND H' + @TempCounterString + N'.Status_ID = HP' + @TempCounterString + N'.Status_ID   
                        AND HP' + @TempCounterString + N'.Status_ID = 1  
                    ';				  
                SET @TempCounter += 1;  
            END; --if  
                  
            SET @TempWhereString = N' WHERE H0.Parent_HP_ID IS NULL';  
  
            SET @TempSelectString = LEFT(@TempSelectString, LEN(@TempSelectString)-1);  
  
            SET @SQL = CASE   
                WHEN EXISTS(SELECT 1 FROM sys.views WHERE [name] = @ViewName AND [schema_id] = SCHEMA_ID('mdm')) THEN N'ALTER'  
                ELSE N'CREATE' END + N' VIEW mdm.' + quotename(@ViewName) + N'  
                /*WITH ENCRYPTION*/   
                AS SELECT  
                    H0.Version_ID,H.Name,H0.ID,''<ROOT>'' AS ROOT,   
                    CASE   
                        WHEN EN0.ID IS NOT NULL THEN EN0.Code   
                        ELSE HP0.Code   
                    END AS L0, --case  
                    ' + @TempSelectString + N'  
                FROM mdm.' + quotename(@HierarchyTable) + N' H0   
                INNER JOIN mdm.tblHierarchy AS H ON H.ID = H0.Hierarchy_ID   
                LEFT JOIN mdm.' + quotename(@EntityTable) + N' AS EN0 ON H0.Version_ID = EN0.Version_ID   
                    AND H0.ChildType_ID = 1   
                    AND H0.Child_EN_ID = EN0.ID   
                    AND H0.Status_ID = EN0.Status_ID   
                    AND EN0.Status_ID = 1   
                LEFT JOIN mdm.' + quotename(@HierarchyParentTable) + N' AS HP0 ON H0.Version_ID = HP0.Version_ID   
                    AND H0.ChildType_ID = 2   
                    AND H0.Child_HP_ID = HP0.ID   
                    AND H0.Status_ID = HP0.Status_ID   
                    AND HP0.Status_ID = 1   
                ' + @TempTableJoinString + N' ' + @TempWhereString + N';';  
  
            --PRINT(@SQL);  
            EXEC sp_executesql @SQL;  
  
        END; ---if  
  
    END; --if  
          
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpCreateSystemParentChildViews]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
    EXEC mdm.udpCreateSystemParentChildViews 8;  
    EXEC mdm.udpCreateSystemParentChildViews 31;  
    EXEC mdm.udpCreateSystemParentChildViews 11111; --invalid  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpCreateSystemParentChildViews]  
(  
    @Entity_ID      INT,  
    @ViewType       TINYINT = 0, -- 0 EN, 2 HS  
    @CorrelationID  UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    --Defer view generation if we are in the middle of an upgrade or demo-rebuild  
    IF APPLOCK_MODE(N'public', N'DeferViewGeneration', N'Session') = N'NoLock'  
    BEGIN  
        DECLARE @EntityTable            SYSNAME,  
                @HierarchyParentTable   SYSNAME,  
                @HierarchyTable         SYSNAME,  
                @CollectionTable        SYSNAME,  
                @CollectionMemberTable  SYSNAME,  
                @SQL                    NVARCHAR(MAX),  
                @TruncateGuard          NVARCHAR(MAX) = N'',  
                @CollectionViewName     SYSNAME,  
                @ViewName               SYSNAME,  
                @ViewType_EN            TINYINT = 0,  
                @ViewType_HS            TINYINT = 2,  
                @MemberType_ParentChild            TINYINT = 4,  
                @MemberType_CollectionParentChild  TINYINT = 5;  
  
        --Initialize the variables  
        SELECT  
                @EntityTable = QUOTENAME(EntityTable),  
                @HierarchyParentTable = QUOTENAME(HierarchyParentTable),  
                @HierarchyTable =  
                    CASE @ViewType  
                        WHEN @ViewType_EN THEN QUOTENAME(HierarchyTable)  
                        WHEN @ViewType_HS THEN QUOTENAME(HierarchyTable + N'_HS')  
                    END,  
                @CollectionTable = QUOTENAME(CollectionTable),  
                @CollectionMemberTable =  
                    CASE @ViewType  
                        WHEN @ViewType_EN THEN QUOTENAME(CollectionMemberTable)  
                        WHEN @ViewType_HS THEN QUOTENAME(CollectionMemberTable + N'_HS')  
                    END,  
                @ViewName = mdm.udfViewNameGetByID(ID, @MemberType_ParentChild, 0, @ViewType),  
                @CollectionViewName = mdm.udfViewNameGetByID(ID, @MemberType_CollectionParentChild, 0, @ViewType)  
        FROM mdm.tblEntity  
        WHERE ID = @Entity_ID;  
  
        -- Do not create parent child view if entity does not exist  
        IF @@ROWCOUNT = 0  
        BEGIN  
            RETURN;  
        END;  
  
        -- Create PARENTCHILD view  
        IF @ViewName IS NOT NULL  
        BEGIN  
            SET @SQL = CONCAT(@TruncateGuard, CASE  
                WHEN EXISTS(SELECT 1 FROM sys.views WHERE [name] = @ViewName AND [schema_id] = SCHEMA_ID('mdm')) THEN N'ALTER'  
                ELSE N'CREATE' END  
            , N' VIEW mdm.', @ViewName, N'  
                AS  
                SELECT  
                    HR.Version_ID,  
                    HR.Status_ID,  
                    ISNULL(HR.Parent_HP_ID,0) AS Parent_ID,  
                    HR.ChildType_ID,  
                    HR.Child_EN_ID,  
                    HR.Child_HP_ID,  
                    CASE HR.ChildType_ID WHEN 1 THEN HR.Child_EN_ID WHEN 2 THEN HR.Child_HP_ID END AS Child_ID,  
                    CASE  
                        WHEN HR.ChildType_ID = 1 THEN EN.ValidationStatus_ID  
                        ELSE HPC.ValidationStatus_ID  
                    END AS Child_ValidationStatus_ID,  
                    HR.Hierarchy_ID,  
                    H.MUID as Hierarchy_MUID,  
                    H.Name as Hierarchy_Name,  
                    ISNULL(HPP.Code,''ROOT'') AS Parent_Code,  
                    HPP.MUID AS Parent_MUID,  
                    ISNULL(HPP.Name,'''') AS Parent_Name,  
                    CASE  
                        WHEN HR.ChildType_ID = 1 THEN EN.Code  
                        ELSE HPC.Code  
                    END AS Child_Code,  
                    CASE  
                        WHEN HR.ChildType_ID = 1 THEN EN.MUID  
                        ELSE HPC.MUID  
                    END AS Child_MUID,  
                    CASE  
                        WHEN HR.ChildType_ID = 1 THEN EN.Name  
                        ELSE HPC.Name  
                    END AS Child_Name,  
                    HR.SortOrder AS Child_SortOrder,  
                    HR.LevelNumber AS Child_LevelNumber,  
  
                    ', CASE @ViewType WHEN 0 THEN N'CONVERT(BIGINT, HR.LastChgTS)' ELSE N'HR.ID' END, N' AS LastChgTS,  
                    --Auditing columns (Creation)  
                    HR.EnterDTM,  
                    HR.EnterUserID,  
                    eu.[UserName] AS EnterUserName,  
                    eu.MUID AS EnterUserMuid,  
  
                    --Auditing columns (Updates)  
                    HR.LastChgDTM,  
                    HR.LastChgUserID,  
                    lcu.[UserName] AS LastChgUserName,  
                    lcu.MUID AS LastChgUserMuid  
                FROM  
                    mdm.', @HierarchyTable, N' AS HR  
                    -- Changed from INNER JOIN for better performance  
                    LEFT JOIN mdm.tblUser eu ON HR.EnterUserID = eu.ID  
                    LEFT JOIN mdm.tblUser lcu ON HR.LastChgUserID = lcu.ID  
                    LEFT JOIN mdm.tblHierarchy H ON H.ID = HR.Hierarchy_ID  
                    LEFT JOIN mdm.', @HierarchyParentTable, N' AS HPP  
                        ON HPP.ID = HR.Parent_HP_ID  
                        AND HPP.Version_ID = HR.Version_ID  
                        AND HPP.Hierarchy_ID = HR.Hierarchy_ID  
                        AND HPP.Status_ID = HR.Status_ID  
                    LEFT JOIN mdm.', @EntityTable, N' AS EN  
                        ON HR.ChildType_ID = 1  
                        AND HR.Child_EN_ID = EN.ID  
                        AND HR.Version_ID = EN.Version_ID  
                        AND EN.Status_ID = 1  
                    LEFT JOIN mdm.', @HierarchyParentTable, N' AS HPC  
                        ON HR.ChildType_ID = 2  
                        AND HR.Child_HP_ID = HPC.ID  
                        AND HR.Version_ID = HPC.Version_ID  
                        AND HR.Hierarchy_ID = HPC.Hierarchy_ID  
                        AND HPC.Status_ID = 1  
                    WHERE  
                        (EN.ID IS NOT NULL OR HPC.ID IS NOT NULL)  
                        ', CASE @ViewType WHEN 0 THEN N'AND HR.Status_ID = 1' END);  
  
            --PRINT(@SQL);  
            EXEC sp_executesql @SQL  
        END;  
  
        --Create the CollectionParentChild view  
        IF @CollectionViewName IS NOT NULL  
        BEGIN  
            SET @SQL = CONCAT(@TruncateGuard, CASE  
                WHEN EXISTS(SELECT 1 FROM sys.views WHERE [name] = @CollectionViewName AND [schema_id] = SCHEMA_ID('mdm')) THEN N'ALTER'  
                ELSE N'CREATE' END,  
            N' VIEW mdm.', @CollectionViewName, N'  
            AS  
            SELECT  
                tCM.Version_ID,  
                tCM.Status_ID,  
                tCNN.Code Parent_Code,  
                tCNN.Name Parent_Name,  
                3 as ParentType_ID,  
                tCNN.ID as Parent_ID,  
                CASE tCM.ChildType_ID  
                    WHEN 1 THEN tEN.ID ',  
                CASE WHEN @HierarchyParentTable IS NOT NULL THEN N'  
                    WHEN 2 THEN tHP.ID' END, N'  
                    WHEN 3 THEN tCN.ID  
                END Member_ID,  
                tCM.ChildType_ID MemberType_ID,  
                CASE tCM.ChildType_ID  
                    WHEN 1 THEN 0 ',  
                CASE WHEN @HierarchyParentTable IS NOT NULL THEN N'  
                    WHEN 2 THEN tHP.Hierarchy_ID' END, N'  
                    WHEN 3 THEN tCN.ID  
                END Hierarchy_ID,  
                NULL as Hierarchy_MUID,  
                N'''' as Hierarchy_Name,  
                tCM.SortOrder,  
                CASE tCM.ChildType_ID  
                    WHEN 1 THEN tEN.Code',  
                CASE WHEN @HierarchyParentTable IS NOT NULL THEN N'  
                    WHEN 2 THEN tHP.Code' END, N'  
                    WHEN 3 THEN tCN.Code  
                END Code,  
                CASE tCM.ChildType_ID  
                    WHEN 1 THEN tEN.Name',  
                CASE WHEN @HierarchyParentTable IS NOT NULL THEN N'  
                    WHEN 2 THEN tHP.Name' END, N'  
                    WHEN 3 THEN tCN.Name  
                END Name,  
                CONVERT(DECIMAL(18, 2), tCM.Weight) AS Weight,  
                tCM.ChildType_ID,  
                tCM.Child_EN_ID,',  
                CASE WHEN @HierarchyParentTable IS NOT NULL THEN N'  
                tCM.Child_HP_ID,' END, N'  
                tCM.Child_CN_ID,  
                CASE tCM.ChildType_ID  
                    WHEN 1 THEN tCM.Child_EN_ID',  
                CASE WHEN @HierarchyParentTable IS NOT NULL THEN N'  
                    WHEN 2 THEN tCM.Child_HP_ID' END, N'  
                    WHEN 3 THEN tCM.Child_CN_ID  
                    END AS Child_ID,  
                CASE tCM.ChildType_ID  
                    WHEN 1 THEN 0',  
                CASE WHEN @HierarchyParentTable IS NOT NULL THEN N'  
                    WHEN 2 THEN tHP.Hierarchy_ID' END, N'  
                    WHEN 3 THEN tCN.ID  
                END NextHierarchy_ID,  
                CASE  
                    WHEN tCM.ChildType_ID = 3 THEN 2  
                    ELSE 0  
                END NextHierarchyType_ID,  
                ', CASE @ViewType WHEN 0 THEN N'CONVERT(BIGINT, tCM.LastChgTS)' ELSE N'tCM.ID' END, N' AS LastChgTS,  
                --Auditing columns (Creation)  
                tCM.EnterDTM,  
                tCM.EnterUserID,  
                eu.[UserName] AS EnterUserName,  
                eu.MUID AS EnterUserMuid,  
  
                --Auditing columns (Updates)  
                tCM.LastChgDTM,  
                tCM.LastChgUserID,  
                lcu.[UserName] AS LastChgUserName,  
                lcu.MUID AS LastChgUserMuid  
            FROM  
                mdm.', @CollectionMemberTable, N' AS tCM  
                -- Changed from INNER JOIN for better performance  
                LEFT JOIN mdm.tblUser eu ON tCM.EnterUserID = eu.ID  
                LEFT JOIN mdm.tblUser lcu ON tCM.LastChgUserID = lcu.ID  
                LEFT JOIN  mdm.', @CollectionTable, N' AS tCNN  
                    ON tCNN.ID = tCM.Parent_CN_ID  
                    AND tCNN.Version_ID = tCM.Version_ID  
                LEFT JOIN mdm.', @EntityTable, N' AS tEN  
                    ON tCM.ChildType_ID = 1  
                    AND tCM.Child_EN_ID = tEN.ID  
                    AND tCM.Version_ID = tEN.Version_ID  
                    AND tEN.Status_ID = 1',  
                    CASE WHEN @HierarchyParentTable IS NOT NULL THEN CONCAT(N'  
                LEFT JOIN mdm.', @HierarchyParentTable, N' AS tHP  
                    ON tCM.ChildType_ID = 2  
                    AND tCM.Child_HP_ID = tHP.ID  
                    AND tCM.Version_ID = tHP.Version_ID  
                    AND tHP.Status_ID = 1') END, N'  
                LEFT JOIN mdm.', @CollectionTable, N' AS tCN  
                    ON tCM.ChildType_ID = 3  
                    AND tCM.Child_CN_ID = tCN.ID  
                    AND tCM.Version_ID = tCN.Version_ID  
                    AND tCN.Status_ID = 1  
                WHERE  
                    tCNN.Status_ID = 1 AND -- Collection must be active  
                    (      tEN.ID IS NOT NULL',  
                    CASE WHEN @HierarchyParentTable IS NOT NULL THEN N'  
                        OR tHP.ID IS NOT NULL' END, N'  
                        OR tCN.ID IS NOT NULL)  
                    ', CASE @ViewType WHEN 0 THEN N'AND tCM.Status_ID = 1' END);  
  
            --PRINT(@SQL);  
            EXEC sp_executesql @SQL  
        END;  
  
    END; --if  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpCreateSystemViews]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    mdm.udpCreateSystemViews 1  
*/  
CREATE PROCEDURE [mdm].[udpCreateSystemViews]  
(  
    @Model_ID       INT,  
    @NewEntity_ID   INT = 0, --any non zero value results in only that entity being generated  
    @CorrelationID  UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON;  
  
    --Defer view generation if we are in the middle of an upgrade or demo-rebuild  
    IF APPLOCK_MODE(N'public', N'DeferViewGeneration', N'Session') = N'NoLock' BEGIN  
  
        DECLARE @Entity_ID              INT,  
                @Type_ID                INT,  
                @EntityName             sysname,  
                @IsCollectionEnabled    BIT,  
                @IsHierarchyEnabled     BIT,  
                @SQL                    NVARCHAR(MAX),  
  
                @MemberType_Leaf                TINYINT = 1,  
                @MemberType_Consolidated        TINYINT = 2,  
                @MemberType_Collection          TINYINT = 3;  
          
        DECLARE @TempTable TABLE   
        (  
             RowNumber              INT IDENTITY (1, 1) PRIMARY KEY CLUSTERED NOT NULL   
            ,ID                     INT NOT NULL  
            ,IsCollectionEnabled    BIT NOT NULL  
            ,IsHierarchyEnabled     BIT NOT NULL  
        );  
  
        SET @NewEntity_ID = COALESCE(@NewEntity_ID, 0);  
                      
        --Start transaction, being careful to check if we are nested	  
        DECLARE @TranCounter INT;   
        SET @TranCounter = @@TRANCOUNT;  
        IF @TranCounter > 0 SAVE TRANSACTION TX;  
        ELSE BEGIN TRANSACTION;  
          
        BEGIN TRY  
            INSERT INTO @TempTable   
            SELECT   
                 ID  
                ,CASE WHEN CollectionTable IS NULL THEN 0 ELSE 1 END IsCollectionEnabled  
                ,CASE WHEN HierarchyTable IS NULL THEN 0 ELSE 1 END IsHierarchyEnabled  
            FROM mdm.tblEntity   
            WHERE Model_ID = @Model_ID AND (@NewEntity_ID = 0 OR ID = @NewEntity_ID);  
  
            DECLARE @Counter INT = 1 ;  
            DECLARE @MaxCounter INT = (SELECT MAX(RowNumber) FROM @TempTable);  
  
            WHILE @Counter <= @MaxCounter  
                BEGIN  
  
                SELECT @Entity_ID = ID  
                    ,@IsCollectionEnabled = IsCollectionEnabled  
                    ,@IsHierarchyEnabled = IsHierarchyEnabled  
                FROM @TempTable   
                WHERE [RowNumber] = @Counter;  
  
                --Delete Entity Views.  
                EXEC mdm.udpDeleteViews @Model_ID, @Entity_ID, NULL;  
  
                --Leaf Views  
                EXEC mdm.udpCreateSystemAttributeViews @Entity_ID, @MemberType_Leaf, 0;  
                EXEC mdm.udpCreateSystemAttributeViews @Entity_ID, @MemberType_Leaf, 1;  
                EXEC mdm.udpCreateSystemAttributeViews @Entity_ID, @MemberType_Leaf, 2;  
  
                IF @IsHierarchyEnabled = 1   
                BEGIN  
                    --Consolidated Views  
                    EXEC mdm.udpCreateSystemAttributeViews @Entity_ID, @MemberType_Consolidated, 0;  
                    EXEC mdm.udpCreateSystemAttributeViews @Entity_ID, @MemberType_Consolidated, 2;  
                    EXEC mdm.udpCreateSystemLevelViews @Entity_ID; -- Consolidated  
                END  
  
                IF @IsCollectionEnabled = 1   
                BEGIN  
                    --Collection Views  
                    EXEC mdm.udpCreateSystemAttributeViews @Entity_ID, @MemberType_Collection, 0;  
                    EXEC mdm.udpCreateSystemAttributeViews @Entity_ID, @MemberType_Collection, 2;  
                END; --if  
  
                IF @IsHierarchyEnabled = 1 OR @IsCollectionEnabled = 1  
                BEGIN  
                    EXEC mdm.udpCreateSystemParentChildViews @Entity_ID, 0; -- Consolidated and Collection  
                    EXEC mdm.udpCreateSystemParentChildViews @Entity_ID, 2; -- Consolidated and Collection  
  
                    IF @IsHierarchyEnabled = 1   
                    BEGIN  
                        EXEC mdm.udpCreateSystemEXPViews @Entity_ID, @MemberType_Consolidated, 0;  
                        EXEC mdm.udpCreateSystemEXPViews @Entity_ID, @MemberType_Consolidated, 2;  
                    END;  
  
                    IF @IsCollectionEnabled = 1  
                    BEGIN  
                        EXEC mdm.udpCreateSystemEXPViews @Entity_ID, @MemberType_Collection, 0;  
                        EXEC mdm.udpCreateSystemEXPViews @Entity_ID, @MemberType_Collection, 2;  
                    END;  
                END;  
  
                --Leaf XML - must be after the consolidated views as it consumes them  
                EXEC mdm.udpCreateSystemEXPViews @Entity_ID, @MemberType_Leaf, 0;  
                EXEC mdm.udpCreateSystemEXPViews @Entity_ID, @MemberType_Leaf, 2;  
  
                SET @Counter = @Counter+1;  
  
            END; --while  
              
  
            --Commit only if we are not nested  
            IF @TranCounter = 0 COMMIT TRANSACTION;  
  
        END TRY  
        --Compensate as necessary  
        BEGIN CATCH  
  
            -- Get error info.  
            DECLARE  
                @ErrorMessage NVARCHAR(4000),  
                @ErrorSeverity INT,  
                @ErrorState INT,  
                @ErrorNumber INT,  
                @ErrorLine INT,  
                @ErrorProcedure NVARCHAR(126);  
            EXEC mdm.udpGetErrorInfo  
                @ErrorMessage = @ErrorMessage OUTPUT,  
                @ErrorSeverity = @ErrorSeverity OUTPUT,  
                @ErrorState = @ErrorState OUTPUT,  
                @ErrorNumber = @ErrorNumber OUTPUT,  
                @ErrorLine = @ErrorLine OUTPUT,  
                @ErrorProcedure = @ErrorProcedure OUTPUT  
  
            SET @ErrorMessage = CONCAT(@ErrorMessage, N', @ErrorNumber = ', @ErrorNumber, N', @ErrorProcedure = "', @ErrorProcedure, N'", line ', @ErrorLine);  
  
            IF @TranCounter = 0 ROLLBACK TRANSACTION;  
            ELSE IF XACT_STATE() <> -1 ROLLBACK TRANSACTION TX;  
  
            RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);  
  
        END CATCH;  
  
    END; --if  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpCreateType2Views]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
EXEC mdm.[udpCreateType2Views] 27, 1, 19, NULL, 'TEST1';  
EXEC mdm.[udpCreateType2Views] 27, 2, 19, NULL, 'TEST2';  
EXEC mdm.[udpCreateType2Views] 27, 3, 19, NULL, 'TEST3';  
  
SELECT * FROM mdm.TEST1  
SELECT * FROM mdm.TEST2  
SELECT * FROM mdm.TEST3  
  
*/  
CREATE PROCEDURE [mdm].[udpCreateType2Views]  
(  
    @Entity_ID                 INT,  
    @MemberType_ID             TINYINT,  
    @Version_ID                INT,  
    @VersionFlag_ID            INT,  
    @SubscriptionViewName      SYSNAME,  
    @CorrelationID             UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE  
        @MemberType_Leaf                TINYINT = 1,  
        @MemberType_Consolidated        TINYINT = 2,  
        @MemberType_Collection          TINYINT = 3;  
  
    --Defer view generation if we are in the middle of an upgrade or demo-rebuild  
    IF APPLOCK_MODE(N'public', N'DeferViewGeneration', N'Session') = N'NoLock' BEGIN  
  
        DECLARE  
            @SQL                    NVARCHAR(MAX) = N'',  
            @SelectMain             NVARCHAR(MAX) = N'',  
            @SelectHistory          NVARCHAR(MAX) = N'',  
            @FromMain               NVARCHAR(MAX) = N'',  
            @FromHistory            NVARCHAR(MAX) = N'',  
            @ViewColumn             NVARCHAR(120), --specifically made to be less than 128 for truncation reasons  
            @TableColumn            SYSNAME,  
            @DomainTable            SYSNAME,  
            @DomainEntity_ID        INT,  
            @AttributeType_ID       INT,  
            @MainTable              SYSNAME,  
            @HistoryTable           SYSNAME,  
            @MemberIDColumn         SYSNAME;  
  
        SELECT  
            @MainTable =  
                CASE @MemberType_ID  
                    WHEN @MemberType_Leaf THEN EntityTable  
                    WHEN @MemberType_Collection THEN CollectionTable  
                    WHEN @MemberType_Consolidated THEN HierarchyParentTable  
                    ELSE NULL  
                END,  
            @MemberIDColumn =  
                CASE @MemberType_ID  
                    WHEN @MemberType_Leaf THEN 'EN_ID'  
                    WHEN @MemberType_Collection THEN 'CN_ID'  
                    WHEN @MemberType_Consolidated THEN 'HP_ID'  
                    ELSE NULL  
                END  
        FROM mdm.tblEntity  
        WHERE   ID = @Entity_ID  
  
        IF @MainTable IS NULL  
        BEGIN  
            RAISERROR('MDSERR100010|The Parameters are not valid.', 16, 1);  
            RETURN;  
        END;  
  
        SET @HistoryTable = CONVERT(SYSNAME, CONCAT(@MainTable, N'_HS'));  
  
        SET @SelectMain +=  
            CASE @MemberType_ID  
                WHEN @MemberType_Leaf THEN N''  
                WHEN @MemberType_Collection THEN N''  
                ELSE N',H.Name as Hierarchy'  
            END;  
  
        SET @SelectHistory +=  
            CASE @MemberType_ID  
                WHEN @MemberType_Leaf THEN N''  
                WHEN @MemberType_Collection THEN N''  
                ELSE N',H.Name as Hierarchy'  
            END;  
  
        DECLARE @ConflictingColumnName NVARCHAR(100);  
        --Get the Attributes for the Entity and then find the corresponding lookup table  
        DECLARE @TempTable TABLE(  
                ViewColumn          NVARCHAR(100) COLLATE DATABASE_DEFAULT  
                ,TableColumn        SYSNAME COLLATE DATABASE_DEFAULT  
                ,AttributeType_ID   INT  
                ,DomainEntity_ID    INT NULL  
                ,DomainTable        SYSNAME COLLATE DATABASE_DEFAULT NULL  
                ,SortOrder          INT);  
        INSERT INTO @TempTable  
        SELECT  
            ViewColumn,  
            TableColumn,  
            AttributeType_ID,  
            DomainEntity_ID,  
            DomainTable,  
            SortOrder  
        FROM  
            mdm.udfEntityAttributesGetList(@Entity_ID, @MemberType_ID)  
        WHERE ViewColumn != N'ChangeTrackingMask'  
        ORDER BY  
            SortOrder ASC;  
  
        WHILE EXISTS(SELECT 1 FROM @TempTable) BEGIN  
  
            SELECT TOP 1  
                @ViewColumn = ViewColumn,  
                @TableColumn = TableColumn,  
                @AttributeType_ID = AttributeType_ID,  
                @DomainEntity_ID = DomainEntity_ID,  
                @DomainTable = DomainTable  
            FROM @TempTable  
            ORDER BY  
                SortOrder ASC;  
  
            IF @DomainEntity_ID IS NULL  
            BEGIN  
                --Check for name validation, if there are some DBA which their _Code/_Name/_ID columns have conflicts with some FFA attribute names.  
                DECLARE @ViewColumnPrefix NVARCHAR(120) = CASE  
                    WHEN @ViewColumn LIKE N'%\_Code' ESCAPE N'\' THEN LEFT(@ViewColumn, LEN(@ViewColumn) - LEN(N'_Code'))  
                    WHEN @ViewColumn LIKE N'%\_Name' ESCAPE N'\' THEN LEFT(@ViewColumn, LEN(@ViewColumn) - LEN(N'_Name'))  
                    WHEN @ViewColumn LIKE N'%\_ID' ESCAPE N'\' THEN LEFT(@ViewColumn, LEN(@ViewColumn) - LEN(N'_ID'))  
                    ELSE NULL  
                    END;  
                IF (@ViewColumnPrefix IS NOT NULL)  
                BEGIN  
                    SELECT TOP 1 @ConflictingColumnName = Name  
                    FROM mdm.tblAttribute  
                    WHERE Entity_ID = @Entity_ID  
                        AND MemberType_ID = @MemberType_ID  
                        AND AttributeType_ID = 2 -- DBA  
                        AND Name = @ViewColumnPrefix;  
                    IF (@ConflictingColumnName IS NOT NULL)  
                    BEGIN  
                        RAISERROR('MDSERR100059|There are at least two attribute names in conflict in the existing or new subscription view. Free-form attribute names cannot start with an existing domain-based attribute name and end with "_Code", "_Name" or "_ID". Attribute names are: |%s|%s|', 16, 1, @ConflictingColumnName, @ViewColumn);  
                        RETURN;  
                    END  
                END  
                IF @ViewColumn = N'Owner_ID' AND @MemberType_ID = @MemberType_Collection BEGIN --Collection  
                    SET @SelectMain = @SelectMain + N'  
    ,' + QUOTENAME(@ViewColumn) + N'.UserName AS [Owner_ID]';  
                    SET @SelectHistory = @SelectHistory + N'  
    ,' + QUOTENAME(@ViewColumn) + N'.UserName AS [Owner_ID]';  
                    SET @FromMain = @FromMain + N'  
LEFT JOIN mdm.tblUser AS Owner_ID  
    ON Owner_ID.ID = T.Owner_ID';  
                    SET @FromHistory = @FromHistory + N'  
LEFT JOIN mdm.tblUser AS Owner_ID  
    ON Owner_ID.ID = T.Owner_ID';  
                END ELSE BEGIN  
                    SET @SelectMain = @SelectMain + N'  
    ,T.' + QUOTENAME(@TableColumn) + N' AS ' + QUOTENAME(@ViewColumn);  
                    SET @SelectHistory = @SelectHistory + N'  
    ,T.' + QUOTENAME(@TableColumn) + N' AS ' + QUOTENAME(@ViewColumn);  
                END; --if  
  
            END ELSE BEGIN  
                --Check for name validation, if there are some DBA which their _Code/_Name/_ID columns have conflicts with some FFA attribute names.  
                SELECT TOP 1 @ConflictingColumnName = Name   
                    FROM mdm.tblAttribute   
                    WHERE Entity_ID = @Entity_ID   
                        AND MemberType_ID = @MemberType_ID  
                        AND AttributeType_ID = 1 -- Freeform  
                        AND (  Name = @ViewColumn + N'_Code'   
                            OR Name = @ViewColumn + N'_Name'   
                            OR Name = @ViewColumn + N'_ID' );  
                IF (@ConflictingColumnName IS NOT NULL)  
                BEGIN  
                    RAISERROR('MDSERR100059|There are at least two attribute names in conflict in the existing or new subscription view. Free-form attribute names cannot start with an existing domain-based attribute name and end with "_Code", "_Name" or "_ID". Attribute names are: |%s|%s|', 16, 1, @ConflictingColumnName, @ViewColumn);  
                    RETURN;  
                END  
                SET @SelectHistory = @SelectHistory + N'  
    ,COALESCE(' + QUOTENAME(@ViewColumn) + N'.Code, ' + QUOTENAME(@ViewColumn + N'_HS') + N'.Code) AS ' + QUOTENAME(@ViewColumn + N'_Code') + N'  
    ,COALESCE(' + QUOTENAME(@ViewColumn) + N'.Name, ' + QUOTENAME(@ViewColumn + N'_HS') + N'.Code) AS ' + QUOTENAME(@ViewColumn + N'_Name') + N'  
    ,T.' + QUOTENAME(@TableColumn) + ' AS ' + QUOTENAME(@ViewColumn + N'_ID');  
                SET @SelectMain = @SelectMain + N'  
    ,' + QUOTENAME(@ViewColumn) + N'.Code AS ' + QUOTENAME(@ViewColumn + N'_Code') + N'  
    ,' + QUOTENAME(@ViewColumn) + N'.Name AS ' + QUOTENAME(@ViewColumn + N'_Name') + N'  
    ,T.' + QUOTENAME(@TableColumn) + ' AS ' + QUOTENAME(@ViewColumn + N'_ID');  
  
                SET @FromHistory = @FromHistory + N'  
LEFT JOIN mdm.' + QUOTENAME(@DomainTable) + N' AS ' + QUOTENAME(@ViewColumn) + N'  
    ON ' + QUOTENAME(@ViewColumn) + N'.ID = T.' + QUOTENAME(@TableColumn) + N' AND ' + QUOTENAME(@ViewColumn) + N'.Version_ID = T.Version_ID  
LEFT JOIN mdm.' + QUOTENAME(@DomainTable + N'_HS') + N' AS ' + QUOTENAME(@ViewColumn + N'_HS') + N'  
    ON ' + QUOTENAME(@ViewColumn + N'_HS') + N'.EN_ID = T.' + QUOTENAME(@TableColumn) + N' AND ' + QUOTENAME(@ViewColumn + N'_HS') + N'.Version_ID = T.Version_ID  AND (T.EnterDTM BETWEEN ' + QUOTENAME(@ViewColumn + N'_HS') + N'.EnterDTM  AND ' + QUOTENAME(@ViewColumn + N'_HS') + N'.LastChgDTM)';  
                SET @FromMain = @FromMain + N'  
LEFT JOIN mdm.' + QUOTENAME(@DomainTable) + N' AS ' + QUOTENAME(@ViewColumn) + N'  
    ON ' + QUOTENAME(@ViewColumn) + N'.ID = T.' + QUOTENAME(@TableColumn) + N' AND ' + QUOTENAME(@ViewColumn) + N'.Version_ID = T.Version_ID';  
            END; --if  
  
            DELETE FROM @TempTable WHERE ViewColumn = @ViewColumn;  
  
        END; --while  
  
        SET @SQL = CASE  
            WHEN EXISTS(SELECT 1 FROM sys.views WHERE [name] = @SubscriptionViewName AND [schema_id] = SCHEMA_ID('mdm')) THEN N'ALTER'  
            ELSE N'CREATE' END + N' VIEW mdm.' + QUOTENAME(@SubscriptionViewName) + N'  
/*WITH ENCRYPTION*/  
AS  
SELECT  
    T.ID AS RevisionID  
    ,LS.ListOption AS State  
    ,T.' + @MemberIDColumn + ' AS ID  
    ,T.MUID AS MUID' + @SelectHistory + N'  
    ,T.EnterDTM AS EnterDateTime  
    ,UE.UserName AS EnterUserName  
    ,T.LastChgDTM AS LastChgDateTime  
    ,UC.UserName AS LastChgUserName';  
        SET @SQL += N'  
FROM mdm.' + QUOTENAME(@HistoryTable) + N' AS T'  
  
        IF @MemberType_ID = @MemberType_Consolidated  
        BEGIN  
            SET @SQL += N'  
INNER JOIN mdm.tblHierarchy H  
    ON H.ID = T.Hierarchy_ID'  
        END  
  
        SET @SQL +=  @FromHistory;  
  
        SET @SQL +=  N'  
LEFT JOIN mdm.tblList LS  
    ON LS.OptionID = T.Status_ID AND LS.ListCode = ''lstStatus''';  
  
        SET @SQL +=  N'  
LEFT JOIN mdm.tblUser UE  
    ON T.EnterUserID = UE.ID  
LEFT JOIN mdm.tblUser UC  
    ON T.LastChgUserID = UC.ID'  
            + CASE  
                    WHEN (@Version_ID IS NOT NULL)     THEN CONCAT(N'  
WHERE T.Version_ID = ', @Version_ID)  
                    WHEN (@VersionFlag_ID IS NOT NULL) THEN CONCAT(N'  
INNER JOIN mdm.tblModelVersion AS V  
    ON V.ID =  T.Version_ID  
WHERE V.VersionFlag_ID = ', @VersionFlag_ID)  
            END  
  
        SET @SQL +=  N'  
UNION ALL  
SELECT  
    T.LastChgTS AS RevisionID  
    ,LS.ListOption AS State  
    ,T.ID AS ID  
    ,T.MUID AS MUID' + @SelectMain + N'  
    ,T.LastChgDTM AS EnterDateTime  
    ,UC.UserName AS EnterUserName  
    ,N''9999-12-31 23:59:59.998'' AS LastChgDateTime  
    ,NULL AS LastChgUserName';  
        SET @SQL += N'  
FROM mdm.' + QUOTENAME(@MainTable) + N' AS T'  
  
        IF @MemberType_ID = @MemberType_Consolidated  
        BEGIN  
            SET @SQL += N'  
INNER JOIN mdm.tblHierarchy H  
    ON H.ID = T.Hierarchy_ID'  
        END  
  
        SET @SQL +=  @FromMain;  
  
        SET @SQL +=  N'  
LEFT JOIN mdm.tblList LS  
    ON LS.OptionID = T.Status_ID AND LS.ListCode = ''lstStatus''';  
  
        SET @SQL +=  N'  
LEFT JOIN mdm.tblUser UC  
    ON T.LastChgUserID = UC.ID'  
            + CASE  
                    WHEN (@Version_ID IS NOT NULL)     THEN CONCAT(N'  
WHERE T.Version_ID = ', @Version_ID)  
                    WHEN (@VersionFlag_ID IS NOT NULL) THEN CONCAT(N'  
INNER JOIN mdm.tblModelVersion AS V  
    ON V.ID =  T.Version_ID  
WHERE V.VersionFlag_ID = ', @VersionFlag_ID)  
            END  
  
            SET @SQL += N';';  
  
            SELECT (@SQL);  
            EXEC sp_executesql @SQL;  
    END; --if  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpCreateValidationNotificationQueue]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpCreateValidationNotificationQueue]  
(  
    @Notifications [mdm].[NotificationQueue] READONLY  
)  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE @Notif_ID               UNIQUEIDENTIFIER,  
            @NotificationType_ID    INT,  
            @Validation_ID          INT,  
            @VersionName            NVARCHAR(100),  
            @Version_MUID           UNIQUEIDENTIFIER,  
            @Version_ID             INT,  
            @ModelName              NVARCHAR(100),  
            @Model_MUID             UNIQUEIDENTIFIER,  
            @Model_ID               INT,  
            @EntityName             NVARCHAR(100),  
            @Entity_MUID            UNIQUEIDENTIFIER,  
            @Entity_ID              INT,  
            @Member_ID              INT,  
            @MemberCode             NVARCHAR(250),  
            @MemberType_ID          TINYINT,  
            @RuleConditionText      NVARCHAR(MAX),  
            @RuleActionText         NVARCHAR(MAX),  
            @RuleElseActionText     NVARCHAR(MAX),  
            @BRBusinessRule_ID      INT,  
            @PriorityRank           NVARCHAR(250),  
            @EnterDTM               DATETIME2(3),  
            @EnterUserID            INT,  
            @DueDTM                 DATETIME2(3),  
            @SentDTM                DATETIME2(3),  
            @Message                NVARCHAR(MAX);  
  
    DECLARE @NotificationIds TABLE(Notification_ID INT, NotificationUserID INT, NotificationGroupID INT);  
    DECLARE @tempNotifs mdm.[NotificationQueue];  
    INSERT INTO @tempNotifs  
    SELECT * -- Using "SELECT *" is usually a bad idea, but in this case it is more robust because both the source and destination table are of the same table type. If/when the type schema changes, this code will continue to work as-is. But if instead it were to specify the columns, this code could be broken.  
    FROM @Notifications;  
  
    WHILE EXISTS(SELECT TOP 1 ID FROM @tempNotifs)  
    BEGIN  
        SELECT TOP 1 @Notif_ID = ID, @NotificationType_ID = NotificationType_ID, @Validation_ID = NotificationSourceID, @Model_ID = Model_ID, @Version_ID = Version_ID, @Entity_ID = Entity_ID,  
            @Member_ID = Member_ID, @MemberCode = MemberCode, @MemberType_ID = MemberType_ID, @RuleConditionText = RuleConditionText, @RuleActionText = RuleActionText, @RuleElseActionText = RuleElseActionText,  
            @BRBusinessRule_ID = BRBusinessRule_ID, @PriorityRank = PriorityRank, @EnterDTM = EnterDTM, @EnterUserID = EnterUserID,  
            @DueDTM = DueDTM, @SentDTM = SentDTM FROM @tempNotifs;  
  
        DECLARE @NotificationUserID INT = (SELECT NotificationUserID FROM mdm.tblBRBusinessRule WHERE ID = @BRBusinessRule_ID);  
        DECLARE @NotificationGroupID INT = (SELECT NotificationGroupID FROM mdm.tblBRBusinessRule WHERE ID = @BRBusinessRule_ID);  
  
        SELECT @ModelName = Name, @Model_MUID = MUID FROM mdm.tblModel WHERE ID = @Model_ID  
        SELECT @VersionName = Name, @Version_MUID = MUID FROM mdm.tblModelVersion WHERE ID = @Version_ID;  
        SELECT @EntityName = Name, @Entity_MUID = MUID FROM mdm.tblEntity WHERE ID = @Entity_ID;  
  
        DECLARE @toUTCMinutes INT = DATEDIFF(MINUTE,GETDATE(),GETUTCDATE());  
        DECLARE @sign CHAR(1) = NULL;  
        IF (@toUTCMinutes > 0) SET @sign = '+';  
        DECLARE @toUTC NVARCHAR(20) = CONCAT('UTC',@sign,@toUTCMinutes/60,':', @toUTCMinutes%60);  
  
        SET @Message = CONCAT(N'  
            <notification>  
              <id>', @Validation_ID, N'</id>  
              <model>', (SELECT @ModelName FOR XML PATH('')), N'</model>  
              <model_muid>', @Model_MUID, N'</model_muid>  
              <version>', (SELECT @VersionName FOR XML PATH('')), N'</version>  
              <version_muid>' , @Version_MUID, N'</version_muid>  
              <entity>', (SELECT @EntityName FOR XML PATH('')), N'</entity>  
              <entity_muid>', @Entity_MUID, N'</entity_muid>  
              <member_code>', (SELECT @MemberCode FOR XML PATH('')), N'</member_code>                
              <member_type_id>', @MemberType_ID, N'</member_type_id>  
              <condition_text>', (SELECT @RuleConditionText FOR XML PATH('')), N'</condition_text>  
              <action_text>', (SELECT @RuleActionText FOR XML PATH('')), N'</action_text>  
              <elseaction_text>', (SELECT @RuleElseActionText FOR XML PATH('')), N'</elseaction_text>  
              <priority>', @PriorityRank, N'</priority>  
              <issued>', (SELECT CONVERT(NVARCHAR,GETDATE()) FOR XML PATH('')), N'</issued>  
            </notification>');  
  
        INSERT INTO mdm.tblNotificationQueue(  
            [NotificationType_ID],  
            [Version_ID],  
            [Model_ID],  
            [Entity_ID],  
            [Member_ID],  
            [MemberType_ID],  
            [Message],  
            [BRBusinessRule_ID],  
            [PriorityRank],  
            [EnterDTM],  
            [EnterUserID],  
            [DueDTM],  
            [SentDTM]  
        ) VALUES (  
            @NotificationType_ID,  
            @Version_ID,  
            @Model_ID,  
            @Entity_ID,  
            @Member_ID,  
            @MemberType_ID,  
            @Message,  
            @BRBusinessRule_ID,  
            @PriorityRank,  
            @EnterDTM,  
            @EnterUserID,  
            @DueDTM,  
            @SentDTM);  
  
        DECLARE @insertedID INT = @@IDENTITY;  
        INSERT INTO @NotificationIds VALUES(@insertedID, @NotificationUserID, @NotificationGroupID);  
  
    DELETE FROM @tempNotifs WHERE ID = @Notif_ID;  
    END  
  
    -- Write rows to tblNotificationUser, one row per validation issue per user that will be notified.  
    INSERT INTO mdm.tblNotificationUsers  
    (  
        Notification_ID  
        ,User_ID  
    )  
    SELECT  
        n.Notification_ID  
        ,COALESCE(u.ID, ug.User_ID)  
    FROM @NotificationIds n  
        LEFT JOIN mdm.tblUser u ON n.NotificationUserID = u.ID  
        LEFT JOIN mdm.viw_SYSTEM_USERGROUP_USERS ug ON n.NotificationGroupID = ug.UserGroup_ID;  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpCreateViews]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    EXEC mdm.udpCreateViews 1;  
    EXEC mdm.udpCreateAllViews;  
  
    --Test in context of upgrade/demo data build	  
    EXEC sp_getapplock @Resource=N'DeferViewGeneration', @LockMode='Exclusive', @LockOwner='Session', @LockTimeout=0;  
    EXEC mdm.udpCreateViews 1;  
    EXEC sp_releaseapplock @Resource = N'DeferViewGeneration', @LockOwner='Session';  
*/  
CREATE PROCEDURE [mdm].[udpCreateViews]  
(  
    @Model_ID       INT,  
    @NewEntity_ID   INT = 0,  --any non zero means a new entity was added and we don't need to rebuild all of the views  
    @CorrelationID  UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON;  
  
    --Defer view generation if we are in the middle of an upgrade or demo-rebuild  
    IF APPLOCK_MODE(N'public', N'DeferViewGeneration', N'Session') = N'NoLock' BEGIN  
  
        --Start transaction, being careful to check if we are nested  
        DECLARE @TranCounter INT;   
        SET @TranCounter = @@TRANCOUNT;  
        IF @TranCounter > 0 SAVE TRANSACTION TX;  
        ELSE BEGIN TRANSACTION;  
  
        BEGIN TRY  
  
            --deletion of existing procs is handled in udpCreateSystemViews so we don't need to call it here.  
  
            IF @NewEntity_ID = 0  
            BEGIN  
                -- Create model level views  
                EXEC mdm.udpCreateModelViews @Model_ID;  
            END  
  
            --Create enttiy level views  
            EXEC mdm.udpCreateSystemViews @Model_ID ,@NewEntity_ID  
  
            --Create derived hierarchy views  
            EXEC mdm.udpCreateDerivedHierarchyViews @Model_ID   
  
            --Commit only if we are not nested  
            IF @TranCounter = 0 COMMIT TRANSACTION;  
  
        END TRY  
        --Compensate as necessary  
        BEGIN CATCH  
  
            -- Get error info.  
            DECLARE  
                @ErrorMessage NVARCHAR(4000),  
                @ErrorSeverity INT,  
                @ErrorState INT,  
                @ErrorNumber INT,  
                @ErrorLine INT,  
                @ErrorProcedure NVARCHAR(126);  
            EXEC mdm.udpGetErrorInfo  
                @ErrorMessage = @ErrorMessage OUTPUT,  
                @ErrorSeverity = @ErrorSeverity OUTPUT,  
                @ErrorState = @ErrorState OUTPUT,  
                @ErrorNumber = @ErrorNumber OUTPUT,  
                @ErrorLine = @ErrorLine OUTPUT,  
                @ErrorProcedure = @ErrorProcedure OUTPUT  
  
            SET @ErrorMessage = CONCAT(@ErrorMessage, N', @ErrorNumber = ', @ErrorNumber, N', @ErrorProcedure = "', @ErrorProcedure, N'", line ', @ErrorLine);  
  
            IF @TranCounter = 0 ROLLBACK TRANSACTION;  
            ELSE IF XACT_STATE() <> -1 ROLLBACK TRANSACTION TX;  
  
            RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);  
  
        END CATCH;  
  
    END; --if  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpDataQualityOperationsGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpDataQualityOperationsGet]  
	@CreatedBefore DATETIME2 = NULL,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
AS BEGIN  
	SET NOCOUNT ON;  
	  
        SELECT CreateDTM, OperationId, SerializedOperation  
        FROM [mdm].[tblDataQualityOperationsState]  
        WHERE (@CreatedBefore IS NULL) OR (CreateDTM <= @CreatedBefore)  
  
	SET NOCOUNT OFF;  
END;
GO
/****** Object:  StoredProcedure [mdm].[udpDataQualityResultsGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpDataQualityResultsGet]  
    @DatabaseName sysname,  
    @SchemaName sysname,  
    @TableName sysname,  
    @StartRow INT,  
    @PageSize INT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
AS BEGIN  
    SET NOCOUNT ON;  
      
    -- Constant identifier column name  
    DECLARE @IdentifierColumn NVARCHAR(MAX)  
    SET @IdentifierColumn = 'CCD284C6-39DA-4192-81C9-E1FBBCCFEBE5'  
  
    DECLARE @LastRow INT  
    DECLARE @SQL NVARCHAR(MAX) -- Used to dynamic sql  
  
    DECLARE @FullTableName SYSNAME  
    SET @FullTableName = QUOTENAME(@DatabaseName) + N'.' + QUOTENAME(@SchemaName) + N'.' + QUOTENAME(@TableName)  
  
    SET @SQL = N'  
    IF NOT EXISTS (SELECT 1 FROM ' + QUOTENAME(@DatabaseName) + N'.sys.columns WHERE object_id = OBJECT_ID(''' + @FullTableName + N''') AND [name] = ''' + @IdentifierColumn + N''')  
    BEGIN  
        -- If this is the first run since DQS returned results, add an identifier column to assist  
        -- in batching  
            ALTER TABLE ' + @FullTableName + N'  
            ADD ' + QUOTENAME(@IdentifierColumn) + N' INT IDENTITY(1,1) PRIMARY KEY  
    END  
    '  
    EXEC sp_executesql @SQL  
  
    SET @LastRow = @StartRow + @PageSize  
  
    SET @SQL = N'  
        SELECT *  
        FROM ' + @FullTableName + N'  
        WHERE ' + QUOTENAME(@IdentifierColumn) + N' BETWEEN ' + CONVERT(NVARCHAR(MAX), @StartRow) + N' AND ' +  CONVERT(NVARCHAR(MAX), @LastRow)   
  
    EXEC sp_executesql @SQL  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpDBUpgradeHistorySave]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
	Inserts a record into the tblDBUpgradeHistory  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpDBUpgradeHistorySave]  
(  
	@DBVersion			INT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
	SET NOCOUNT ON  
  
	--Insert the Data  
	INSERT INTO [mdm].[tblDBUpgradeHistory]  
	(  
		[DBVersion]  
	)  
	VALUES  
	(  
		@DBVersion  
	)  
  
	RETURN (SCOPE_IDENTITY())  
  
	SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpDefragmentation]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
/*  
  Rebuild or Reorganize the index with more than 5% fragment  
  http://msdn.microsoft.com/en-us/library/ms189858.aspx  
*/  
CREATE PROCEDURE [mdm].[udpDefragmentation]  
(  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
AS BEGIN  
    DECLARE @schema SYSNAME,  
            @table SYSNAME,  
            @index SYSNAME,  
            @onlineOption SYSNAME = N'OFF',  
            @fragPrecent DECIMAL,  
            @sql NVARCHAR(MAX);  
    IF mdm.udfIsEnterpriseEdition() = 1  
    BEGIN  
        SET @onlineOption = N'ON';  
    END  
    DECLARE fragmentIndexes CURSOR FOR  
    SELECT OBJECT_SCHEMA_NAME(a.[object_id]), OBJECT_NAME(a.[object_id]), name, avg_fragmentation_in_percent  
    FROM sys.dm_db_index_physical_stats (DB_ID(), null, NULL, NULL, NULL) AS a  
        JOIN sys.indexes AS b ON a.[object_id] = b.[object_id] AND a.index_id = b.index_id  
    WHERE avg_fragmentation_in_percent >= 5  
    ORDER BY avg_fragmentation_in_percent DESC;  
  
    OPEN fragmentIndexes;  
    FETCH NEXT FROM fragmentIndexes INTO @schema, @table, @index, @fragPrecent;  
  
    WHILE @@FETCH_STATUS = 0  
    BEGIN  
        IF @fragPrecent<= 30.0  
        BEGIN  
            SET @sql = N'ALTER INDEX ' + QUOTENAME(@index) + N' ON ' + QUOTENAME(@schema) + '.' + QUOTENAME(@table) + N' REORGANIZE';  
            -- PRINT @sql  
            EXEC (@sql);  
        END  
        ELSE  
        BEGIN  
            SET @sql = N'ALTER INDEX ' + QUOTENAME(@index) + N' ON ' + QUOTENAME(@schema) + '.' + QUOTENAME(@table) + N' REBUILD WITH (ONLINE = '+ @onlineOption + N')';  
            -- PRINT @sql  
            EXEC (@sql);  
        END  
        FETCH NEXT FROM fragmentIndexes INTO @schema, @table, @index, @fragPrecent;  
    END  
    CLOSE fragmentIndexes;  
    DEALLOCATE fragmentIndexes;  
END
GO
/****** Object:  StoredProcedure [mdm].[udpDeletedMembersPurge]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*    
==============================================================================    
 Copyright (c) Microsoft Corporation. All Rights Reserved.    
==============================================================================    
  
Purges (hard-deletes) already deactivated (soft-deleted) members of the specified model version.  
   
EXEC mdm.udpDeletedMembersPurge @ModelName = N'Product', @VersionName = N'Version 1'     
    
*/  
CREATE PROCEDURE [mdm].[udpDeletedMembersPurge]  
(  
    @User_ID        INT = NULL, -- Optional. If provided, an error will be thrown if the user does not have versions functional permission or is not a model admin.  
    @ModelName      NVARCHAR(50) = NULL,      -- Either Name or MUID (or both) must be provided for Model  
    @Model_MUID     UNIQUEIDENTIFIER = NULL,  
    @VersionName    NVARCHAR(50) = NULL,     -- Either Name or MUID (or both) must be provided for Version  
    @Version_MUID   UNIQUEIDENTIFIER = NULL,  
    @EntityName     NVARCHAR(50) = NULL,     -- Entity is optional. When not provided, all entities pertaining to the specified model version will be purged.  
    @Entity_MUID    UNIQUEIDENTIFIER = NULL,  
    @CorrelationID  UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)    
WITH EXECUTE AS 'mds_schema_user'    
AS     
BEGIN    
    SET NOCOUNT ON;    
  
    DECLARE  
        @Model_ID                       INT,  
        @Version_ID                     INT,  
        @Entity_ID                      INT,  
        @TranCounter                    INT,  
        @SQL                            NVARCHAR(MAX),  
        @DeletedStatus                  TINYINT = 2,  
        @CurrentEntityID                INT,  
        @CurrentEntityTable             SYSNAME,  
        @CurrentHierarchyParentTable    SYSNAME,  
        @CurrentHierarchyTable          SYSNAME,  
        @CurrentCollectionMemberTable   SYSNAME,  
        @CurrentCollectionTable         SYSNAME,  
        @IsCollectionEnabled            BIT,  
        @IsHierarchyEnabled             BIT,  
  
        @ViewFormat_Collection             TINYINT = 3,  
        @ViewFormat_CollectionMembership   TINYINT = 4,  
          
        @MemberType_Leaf            TINYINT = 1,  
        @MemberType_Consolidated    TINYINT = 2,  
        @MemberType_Collection      TINYINT = 3;  
  
    SELECT   
         @Version_MUID = NULLIF(@Version_MUID, 0x0)  
        ,@VersionName = NULLIF(LTRIM(RTRIM(@VersionName)), N'')  
        ,@Entity_MUID = NULLIF(@Entity_MUID, 0x0)  
        ,@EntityName = NULLIF(LTRIM(RTRIM(@EntityName)), N'');  
  
    -- Get @Model_ID  
    SET @Model_ID = mdm.udfModelGetIDByName(@Model_MUID, @ModelName);  
  
    -- Get @Entity_ID  
    IF @Entity_MUID IS NOT NULL OR @EntityName IS NOT NULL  
    BEGIN  
        SELECT @Entity_ID = ID  
        FROM mdm.tblEntity  
        WHERE   Model_ID = @Model_ID  
            AND (@Entity_MUID IS NULL OR @Entity_MUID = MUID)  
            AND (@EntityName IS NULL OR @EntityName = Name)  
  
        IF @Entity_ID IS NULL  
        BEGIN  
            RAISERROR('MDSERR300008|The supplied entity is not valid.', 16, 1);  
            RETURN;  
        END;  
    END  
  
    IF @User_ID IS NOT NULL  
    BEGIN  
        -- Ensure the user has the appropriate functional permission  
        DECLARE   
             @FunctionalPrivilege_Explorer  TINYINT = 1  
            ,@FunctionalPrivilege_Versions  TINYINT = 2;  
        IF mdm.udfSecurityUserFunctionIsAllowed(@User_ID,   
            CASE WHEN @Entity_ID IS NULL   
                THEN @FunctionalPrivilege_Versions -- Need Versions permission to filter an entire model version  
                ELSE @FunctionalPrivilege_Explorer -- Only need Explorer permission to filter a single entity within a model version  
                END) = 0    
        BEGIN    
            RAISERROR('MDSERR120002|The user does not have permission to perform this operation.', 16, 1);    
            RETURN;    
        END   
          
        DECLARE   
             @Permission        TINYINT = NULL  
            ,@Permission_Deny   TINYINT = 1  
            ,@Permission_Admin  TINYINT = 5  
  
        IF @Model_ID IS NOT NULL  
        BEGIN  
  
            IF @Entity_ID IS NOT NULL  
            BEGIN   
                -- Ensure the user has Admin permission on the entity  
                SELECT @Permission = Privilege_ID   
                FROM mdm.viw_SYSTEM_SECURITY_USER_ENTITY  
                WHERE   ID = @Entity_ID  
                    AND User_ID = @User_ID  
            END ELSE  
            BEGIN   
                -- Ensure the user has Admin permission on the model  
                SELECT @Permission = Privilege_ID   
                FROM mdm.viw_SYSTEM_SECURITY_USER_MODEL  
                WHERE   ID = @Model_ID  
                    AND User_ID = @User_ID  
            END  
  
            IF COALESCE(@Permission, @Permission_Deny) <> @Permission_Admin  
            BEGIN  
                SET @Model_ID = NULL;  
            END  
        END  
    END  
  
    IF @Model_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR120003|The user does not have permission or the object ID is not valid.', 16, 1);  
        RETURN;  
    END;  
  
    -- Get @Version_ID  
    IF @VersionName IS NOT NULL OR @Version_MUID IS NOT NULL  
    BEGIN  
        SELECT @Version_ID = ID  
        FROM mdm.tblModelVersion  
        WHERE Model_ID = @Model_ID  
            AND (@Version_MUID IS NULL OR @Version_MUID = MUID)  
            AND (@VersionName IS NULL OR @VersionName = Name)  
    END  
  
    IF @Version_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR300006|The supplied version is not valid.', 16, 1);  
        RETURN;  
    END;  
  
    -- Populate Entity, Hierarchy Parent, and Hierarchy Relationship Table Names.  
    CREATE TABLE #EntityTableNames    
    (    
        ID                      INT,  
        EntityTable             SYSNAME,  
        HierarchyParentTable    SYSNAME NULL,  
        HierarchyTable          SYSNAME NULL,  
        CollectionMemberTable   SYSNAME NULL,  
        CollectionTable         SYSNAME NULL  
    );  
  
    INSERT INTO #EntityTableNames  
    (  
        ID, EntityTable, HierarchyParentTable, HierarchyTable, CollectionMemberTable, CollectionTable  
    )  
    SELECT ID, EntityTable, HierarchyParentTable, HierarchyTable, CollectionMemberTable, CollectionTable  
    FROM mdm.tblEntity  
    WHERE   Model_ID = @Model_ID  
        AND (@Entity_ID IS NULL OR ID = @Entity_ID);  
  
       
    -- Verify the entity is not a sync target.  
    DECLARE @TargetEntityName NVARCHAR(50) = NULL;  
    SELECT TOP 1   
        @TargetEntityName = e.Name  
    FROM mdm.tblSyncRelationship sr  
    INNER JOIN mdm.tblEntity e  
    ON sr.TargetEntity_ID = e.ID  
    WHERE   e.Model_ID = @Model_ID  
        AND sr.TargetVersion_ID = @Version_ID  
  
    IF @TargetEntityName IS NOT NULL  
    BEGIN  
        DECLARE @ErrorMsg NVARCHAR(MAX) = CONCAT('MDSERR200221|Members cannot be purged from the model version. It contains at least one entity that is the target of a sync relationship. First: "{0}"|', @TargetEntityName);  
        SET @ErrorMsg = REPLACE(@ErrorMsg, '%', '%%')-- escape out format specifier  
        RAISERROR(@ErrorMsg, 16, 1);  
        RETURN;  
    END  
  
    --Start transaction, being careful to check if we are nested    
    SET @TranCounter = @@TRANCOUNT;  
        
    IF @TranCounter > 0 SAVE TRANSACTION TX;    
    ELSE BEGIN TRANSACTION;  
   
    BEGIN TRY   
  
        CREATE TABLE #FileIDsToDelete  
        (  
            ID  INT  
        );  
  
        DECLARE @EntitiesWithCollectionTablesToDrop mdm.IdList;  
  
        -- Purge members.  
        WHILE EXISTS(SELECT 1 FROM #EntityTableNames)   
        BEGIN        
            SELECT TOP 1         
                @CurrentEntityID = ID,  
                @CurrentEntityTable = EntityTable,  
                @CurrentHierarchyParentTable = HierarchyParentTable,  
                @CurrentHierarchyTable = HierarchyTable,  
                @CurrentCollectionMemberTable = CollectionMemberTable,  
                @CurrentCollectionTable = CollectionTable,  
                @IsCollectionEnabled = CASE WHEN CollectionTable IS NULL THEN 0 ELSE 1 END,  
                @IsHierarchyEnabled  = CASE WHEN HierarchyTable  IS NULL THEN 0 ELSE 1 END  
            FROM #EntityTableNames        
            ORDER BY ID;    
       
            -- Get the IDs of the Files referenced by the members being purged  
            SET @SQL = mdm.udfFileIDReferencesGetSQL(@CurrentEntityID, NULL, NULL, 1);  
            IF LEN(@SQL) > 0  
            BEGIN  
                SET @SQL = CONCAT(N'INSERT INTO #FileIDsToDelete(ID)  
', @SQL)  
                --PRINT @SQL  
                EXEC sp_executesql @SQL;  
            END  
                          
            IF @IsCollectionEnabled = 1   
            BEGIN   
                -- Purge members from collection tables.  
                SET @SQL = CONCAT(N'  
DECLARE @MemberIds TABLE(ID INT PRIMARY KEY, Revision_ID BIGINT);  
DECLARE @RevisionIds TABLE(ID BIGINT PRIMARY KEY)  
  
-- Collection membership table  
DELETE mdm.', QUOTENAME(@CurrentCollectionMemberTable), N'  
OUTPUT deleted.ID, CONVERT(BIGINT, deleted.LastChgTS) INTO @MemberIds(ID, Revision_ID)  
WHERE   Version_ID = @Version_ID  
    AND Status_ID = ', @DeletedStatus, N';  
  
INSERT INTO @RevisionIds(ID)   
SELECT Revision_ID FROM @MemberIds  
  
-- Collection membership history table  
DELETE hs  
OUTPUT deleted.ID INTO @RevisionIds(ID)  
FROM mdm.', QUOTENAME(@CurrentCollectionMemberTable + N'_HS'), N' hs  
INNER JOIN @MemberIds m  
ON      hs.Version_ID = @Version_ID   
    AND hs.CM_ID = m.ID  
  
  
-- Collection membership annotation table  
DELETE an  
FROM mdm.', QUOTENAME(@CurrentCollectionMemberTable + N'_AN'), N' an  
INNER JOIN @RevisionIds r  
ON      an.Version_ID = @Version_ID  
    AND an.Revision_ID = r.ID  
  
DELETE @MemberIds  
DELETE @RevisionIds;  
  
-- Collection table  
DELETE mdm.', QUOTENAME(@CurrentCollectionTable), N'  
OUTPUT deleted.ID, CONVERT(BIGINT, deleted.LastChgTS) INTO @MemberIds(ID, Revision_ID)  
WHERE   Version_ID = @Version_ID  
    AND Status_ID = ', @DeletedStatus, N'  
  
INSERT INTO @RevisionIds(ID)   
SELECT Revision_ID FROM @MemberIds  
  
-- Collection history table  
DELETE hs  
OUTPUT deleted.ID INTO @RevisionIds(ID)  
FROM mdm.', QUOTENAME(@CurrentCollectionTable + N'_HS'), N' hs  
INNER JOIN @MemberIds m  
ON      hs.Version_ID = @Version_ID   
    AND hs.CN_ID = m.ID  
  
-- Collection annotation table  
DELETE an  
FROM mdm.', QUOTENAME(@CurrentCollectionTable + N'_AN'), N' an  
INNER JOIN @RevisionIds r  
ON      an.Version_ID = @Version_ID  
    AND an.Revision_ID = r.ID  
  
  
  
-- Model transaction table (will cascade delete to model annotation table)  
DELETE tr  
FROM mdm.tbl_', @Model_ID, N'_TR tr  
INNER JOIN @MemberIds m  
ON tr.Member_ID = m.ID  
WHERE   tr.Version_ID = @Version_ID  
    AND tr.Entity_ID = @CurrentEntityID  
    AND tr.MemberType_ID = ', @MemberType_Collection, N'  
  
IF      NOT EXISTS(SELECT 1 FROM mdm.', QUOTENAME(@CurrentCollectionTable), N')  
    AND NOT EXISTS(SELECT 1 FROM mdm.', QUOTENAME(@CurrentCollectionMemberTable), N')  
BEGIN  
    SET @DropTables = 1;  
END'  
                    );  
  
                DECLARE @DropTables BIT = 0;  
                EXEC sp_executesql @SQL, N'@Version_ID INT, @CurrentEntityID INT, @DropTables BIT OUTPUT', @Version_ID, @CurrentEntityID, @DropTables OUTPUT;  
                -- If the collection tables contain no members, drop them.  
                IF @DropTables = 1  
                BEGIN  
                    INSERT INTO @EntitiesWithCollectionTablesToDrop  
                    VALUES (@CurrentEntityID)  
                END  
            END; --IF    
  
            IF @IsHierarchyEnabled = 1   
            BEGIN   
                -- If there is a hierarchy, purge the Hierarchy Relationship tables.  
                SET @SQL = CONCAT(N'  
DECLARE @MemberIds TABLE(ID INT PRIMARY KEY, Revision_ID BIGINT);  
DECLARE @RevisionIds TABLE(ID BIGINT PRIMARY KEY)  
  
-- Hierarchy relationship table  
DELETE mdm.', QUOTENAME(@CurrentHierarchyTable), N'  
OUTPUT deleted.ID, CONVERT(BIGINT, deleted.LastChgTS) INTO @MemberIds(ID, Revision_ID)  
WHERE   Version_ID = @Version_ID  
    AND Status_ID = ', @DeletedStatus, N';  
  
INSERT INTO @RevisionIds(ID)   
SELECT Revision_ID FROM @MemberIds  
  
-- Hierarchy relationship history table  
DELETE hs  
OUTPUT deleted.ID INTO @RevisionIds(ID)  
FROM mdm.', QUOTENAME(@CurrentHierarchyTable + N'_HS'), N' hs  
INNER JOIN @MemberIds m  
ON      hs.Version_ID = @Version_ID   
    AND hs.HR_ID = m.ID  
  
-- Hierarchy relationship annotation table  
DELETE an  
FROM mdm.', QUOTENAME(@CurrentHierarchyTable + N'_AN'), N' an  
INNER JOIN @RevisionIds r  
ON      an.Version_ID = @Version_ID  
    AND an.Revision_ID = r.ID  
  
  
-- Consolidated member security.    
DELETE sra  
FROM mdm.tblSecurityRoleAccessMember sra    
INNER JOIN mdm.', QUOTENAME(@CurrentHierarchyParentTable), N' hp  
ON      sra.Version_ID = hp.Version_ID  
    AND sra.Member_ID = hp.ID   
    AND sra.Entity_ID = @CurrentEntityID  
    AND sra.MemberType_ID = ', @MemberType_Consolidated, N'  
WHERE   hp.Version_ID = @Version_ID  
    AND hp.Status_ID = ', @DeletedStatus, N';   
  
DELETE @MemberIds;  
DELETE @RevisionIds;  
  
-- Consolidated table  
DELETE mdm.', QUOTENAME(@CurrentHierarchyParentTable), N'   
OUTPUT deleted.ID, CONVERT(BIGINT, deleted.LastChgTS) INTO @MemberIds(ID, Revision_ID)  
WHERE   Version_ID = @Version_ID   
    AND Status_ID = ', @DeletedStatus, N';  
  
INSERT INTO @RevisionIds(ID)   
SELECT Revision_ID FROM @MemberIds  
  
-- Consolidated history table  
DELETE hs  
OUTPUT deleted.ID INTO @RevisionIds(ID)  
FROM mdm.', QUOTENAME(@CurrentHierarchyParentTable + N'_HS'), N' hs  
INNER JOIN @MemberIds m  
ON      hs.Version_ID = @Version_ID   
    AND hs.HP_ID = m.ID  
  
-- Consolidated member annotation table  
DELETE an  
FROM mdm.', QUOTENAME(@CurrentHierarchyParentTable + N'_AN'), N' an  
INNER JOIN @RevisionIds r  
ON      an.Version_ID = @Version_ID  
    AND an.Revision_ID = r.ID  
  
  
-- Model transaction table (will cascade delete to model annotation table)  
DELETE tr  
FROM mdm.tbl_', @Model_ID, N'_TR tr  
INNER JOIN @MemberIds m  
ON tr.Member_ID = m.ID  
WHERE   tr.Version_ID = @Version_ID  
    AND tr.Entity_ID = @CurrentEntityID  
    AND tr.MemberType_ID = ', @MemberType_Consolidated);  
  
                EXEC sp_executesql @SQL, N'@Version_ID INT, @CurrentEntityID INT', @Version_ID, @CurrentEntityID;  
            END;  
  
            SET @SQL = CONCAT(N'   
-- Leaf member security  
DELETE sra   
FROM mdm.tblSecurityRoleAccessMember sra    
INNER JOIN mdm.', QUOTENAME(@CurrentEntityTable), N' en   
ON      sra.Member_ID = en.ID   
    AND sra.Entity_ID = @CurrentEntityID  
    AND sra.MemberType_ID = ', @MemberType_Leaf, N'  
    AND en.Version_ID = @Version_ID  
WHERE en.Status_ID = ', @DeletedStatus, N';  
  
DECLARE @MemberIds TABLE(ID INT PRIMARY KEY, Revision_ID BIGINT);  
DECLARE @RevisionIds TABLE(ID BIGINT PRIMARY KEY)  
  
-- Leaf table (will cascade delete to PD table and MS table)  
DELETE mdm.', QUOTENAME(@CurrentEntityTable), N'   
OUTPUT deleted.ID, CONVERT(BIGINT, deleted.LastChgTS) INTO @MemberIds(ID, Revision_ID)  
WHERE   Version_ID = @Version_ID   
    AND Status_ID = ', @DeletedStatus, N';  
  
INSERT INTO @RevisionIds(ID)   
SELECT Revision_ID FROM @MemberIds  
  
-- Leaf history table  
DELETE hs  
OUTPUT deleted.ID INTO @RevisionIds(ID)  
FROM mdm.', QUOTENAME(@CurrentEntityTable + N'_HS'), N' hs  
INNER JOIN @MemberIds m  
ON      hs.Version_ID = @Version_ID   
    AND hs.EN_ID = m.ID  
  
-- Leaf member annotation table  
DELETE an  
FROM mdm.', QUOTENAME(@CurrentEntityTable + N'_AN'), N' an  
INNER JOIN @RevisionIds r  
ON      an.Version_ID = @Version_ID  
    AND an.Revision_ID = r.ID  
  
-- Model transaction table (will cascade delete to model annotation table)  
DELETE tr  
FROM mdm.tbl_', @Model_ID, N'_TR tr  
INNER JOIN @MemberIds m  
ON tr.Member_ID = m.ID  
WHERE   tr.Version_ID = @Version_ID  
    AND tr.Entity_ID = @CurrentEntityID  
    AND tr.MemberType_ID = ', @MemberType_Leaf);   
  
            EXEC sp_executesql @SQL, N'@Version_ID INT, @CurrentEntityID INT', @Version_ID, @CurrentEntityID;  
  
  
            DELETE FROM #EntityTableNames  
            WHERE ID = @CurrentEntityID;  
        END; -- WHILE  
  
        -- Don't remove empty collection tables if a collections subscription view exists  
        DELETE ei   
        FROM @EntitiesWithCollectionTablesToDrop ei  
        INNER JOIN mdm.tblSubscriptionView sv  
        ON ei.ID = sv.Entity_ID  
        WHERE sv.ViewFormat_ID IN (@ViewFormat_Collection, @ViewFormat_CollectionMembership)  
          
        IF EXISTS (SELECT 1 FROM @EntitiesWithCollectionTablesToDrop)  
        BEGIN  
            EXEC mdm.udpCollectionTablesDrop @EntitiesWithCollectionTablesToDrop  
        END;  
  
        -- Delete orphaned rows from tblFile  
        IF EXISTS (SELECT 1 FROM #FileIDsToDelete)  
        BEGIN  
            DECLARE @File_ID mdm.IdList;  
            INSERT INTO @File_ID  
            SELECT ID FROM #FileIDsToDelete  
  
            EXEC mdm.udpFilesDelete @File_ID = @File_ID, @CorrelationID = @CorrelationID  
        END  
  
        --Commit only if we are not nested    
        IF @TranCounter = 0 COMMIT TRANSACTION;   
    END TRY  
        
    BEGIN CATCH    
        -- Get error info.  
        DECLARE  
            @ErrorMessage NVARCHAR(4000),  
            @ErrorSeverity INT,  
            @ErrorState INT,  
            @ErrorNumber INT,  
            @ErrorLine INT,  
            @ErrorProcedure NVARCHAR(126);  
        EXEC mdm.udpGetErrorInfo  
            @ErrorMessage = @ErrorMessage OUTPUT,  
            @ErrorSeverity = @ErrorSeverity OUTPUT,  
            @ErrorState = @ErrorState OUTPUT,  
            @ErrorNumber = @ErrorNumber OUTPUT,  
            @ErrorLine = @ErrorLine OUTPUT,  
            @ErrorProcedure = @ErrorProcedure OUTPUT  
  
        SET @ErrorMessage = CONCAT(@ErrorMessage, N', @ErrorNumber = ', @ErrorNumber, N', @ErrorProcedure = "', @ErrorProcedure, N'", line ', @ErrorLine);  
    
        IF @TranCounter = 0     
            ROLLBACK TRANSACTION;    
        ELSE IF XACT_STATE() <> -1     
            ROLLBACK TRANSACTION TX;    
                
        RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);    
        RETURN(1);    
            
    END CATCH    
  
    SET NOCOUNT OFF;    
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpDeleteModelTablesAndViews]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================      
  
EXEC mdm.udpDeleteModelTablesAndViews @Model_ID = 2;  
  
*/  
CREATE PROCEDURE [mdm].[udpDeleteModelTablesAndViews]  
(  
    @Model_ID	INT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON;  
  
    --Start transaction, being careful to check if we are nested  
    DECLARE @TranCounter                INT,  
            @SQL                        NVARCHAR(MAX),  
            @ChangesetTable             SYSNAME,  
            @TransactionTableName       SYSNAME,  
            @AnnotationTableName        SYSNAME,  
            @TransactionViewName        SYSNAME,  
            @AnnotationViewName         SYSNAME,  
            @ValidationLogTableName     SYSNAME,  
            @ValidationLogViewName      SYSNAME,  
            @UserValidationViewName     SYSNAME;  
  
    --Set up table and view names  
    SET @ChangesetTable = CONCAT(N'tbl_', @Model_ID, N'_CS');  
    SET @TransactionTableName = mdm.udfGetTransactionTableName(@Model_ID);  
    SET @AnnotationTableName = mdm.udfGetTransactionAnnotationTableName(@Model_ID);  
    SET @TransactionViewName = mdm.udfGetTransactionViewName(@Model_ID);  
    SET @AnnotationViewName = mdm.udfGetTransactionAnnotationViewName(@Model_ID);  
    SET @ValidationLogTableName = mdm.udfGetValidationLogTableName(@Model_ID);  
    SET @ValidationLogViewName = mdm.udfGetValidationLogViewName(@Model_ID);  
    SET @UserValidationViewName = mdm.udfGetUserValidationViewName(@Model_ID);  
  
    --Create the transaction table  
    SET @SQL = CONCAT(N'  
    DROP TABLE [mdm].', QUOTENAME(@ChangesetTable), N';  
    DROP VIEW [mdm].', QUOTENAME(@AnnotationViewName), N';  
    DROP VIEW [mdm].', QUOTENAME(@TransactionViewName), N';  
    DROP TABLE [mdm].', QUOTENAME(@AnnotationTableName), N';  
    DROP TABLE [mdm].', QUOTENAME(@TransactionTableName), N';  
    DROP VIEW [mdm].', QUOTENAME(@UserValidationViewName), N'  
    DROP VIEW [mdm].', QUOTENAME(@ValidationLogViewName), N';  
    DROP TABLE [mdm].', QUOTENAME(@ValidationLogTableName), N';');  
    EXEC sp_executesql @SQL;  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpDeleteViews]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    EXEC mdm.udpDeleteViews 1;  
    EXEC mdm.udpDeleteViews 2;  
    EXEC mdm.udpDeleteViews 3;  
    EXEC mdm.udpDeleteViews 4;  
    EXEC mdm.udpDeleteViews 5;  
  
    EXEC mdm.udpCreateAllViews;  
*/  
CREATE PROCEDURE [mdm].[udpDeleteViews]  
(  
    @Model_ID               INT,  
    @Entity_ID              INT,  
    @DerivedHierarchy_ID    INT,  
    @ItemType_ID            TINYINT = 1, --1=ALL; 2=Collection views; 3=Hierarchy views  
    @CorrelationID          UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE @SQL        NVARCHAR(MAX),  
            @ViewName   SYSNAME;  
  
    SET @ItemType_ID = ISNULL(@ItemType_ID, 1);  
  
    DECLARE @ViewTable TABLE(RowNumber INT IDENTITY (1, 1) PRIMARY KEY CLUSTERED NOT NULL , ViewName SYSNAME COLLATE database_default);  
    INSERT INTO @ViewTable EXEC mdm.udpViewNamesGetByID @Model_ID, @Entity_ID, @DerivedHierarchy_ID, @ItemType_ID;  
  
    SET @SQL = CAST(N'' AS NVARCHAR(MAX));  
    DECLARE @Counter INT = 1;   
    DECLARE @MaxCounter INT = (SELECT MAX(RowNumber) FROM @ViewTable);  
          
    WHILE @Counter <= @MaxCounter  
    BEGIN  
        SELECT @ViewName = ViewName FROM @ViewTable WHERE [RowNumber] = @Counter;  
        SET @SQL = @SQL + N'  
            IF (SELECT OBJECT_ID(N''mdm.' + QUOTENAME(@ViewName) +''',''V'' )) IS NOT NULL  
                DROP VIEW mdm.' + QUOTENAME(@ViewName) + N';'  
        SET @Counter = @Counter +1;  
    END; --while  
  
    --PRINT(@SQL);  
    EXEC sp_executesql @SQL;  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpDerivedHierarchyDelete]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
EXEC mdm.udpDerivedHierarchyDelete 1  
select * from mdm.tblDerivedHierarchy  
*/  
CREATE PROCEDURE [mdm].[udpDerivedHierarchyDelete]  
(  
   @ID       INT = NULL,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON  
  
    DECLARE @ModelName      NVARCHAR(50),  
            @Model_ID       INT,  
            @ViewName       sysname,  
            @SQL			NVARCHAR(MAX),  
            @HierarchyMUID	UNIQUEIDENTIFIER;  
  
    SELECT   
         @Model_ID = dh.Model_ID   
        ,@HierarchyMUID = dh.MUID   
        ,@ModelName = m.Name  
    FROM mdm.tblDerivedHierarchy dh  
    LEFT JOIN mdm.tblModel m  
    ON dh.Model_ID = m.ID  
    WHERE dh.ID = @ID;  
  
    -- Remove any attribute filters that are referencing a level pertaining to the deleted hierarchy.  
    UPDATE a  
    SET   
         FilterParentAttribute_ID = NULL  
        ,FilterHierarchyDetail_ID = NULL  
    FROM mdm.tblAttribute a  
    INNER JOIN mdm.tblDerivedHierarchyDetail dhd  
    ON a.FilterHierarchyDetail_ID = dhd.ID  
    WHERE dhd.DerivedHierarchy_ID = @ID  
  
    --Delete the subscription views associated with the derived hierarchy  
    EXEC mdm.udpSubscriptionViewsDelete   
        @Model_ID               = NULL,  
        @Version_ID             = NULL,  
        @Entity_ID              = NULL,  
        @DerivedHierarchy_ID    = @ID;  
  
  
    --Delete any security assignments  
    DECLARE	@Object_ID	INT  
    SELECT	@Object_ID = mdm.udfSecurityObjectIDGetByCode(N'HIRDER')  
    EXEC mdm.udpSecurityPrivilegesDelete NULL, NULL, @Object_ID, @ID  
    DELETE FROM mdm.tblSecurityRoleAccessMember WHERE HierarchyType_ID = 1 AND Hierarchy_ID = @ID   
  
    --Delete the system view  
    SET @ViewName = CONCAT(N'viw_SYSTEM_', @Model_ID, N'_', @ID, N'_PARENTCHILD_DERIVED')  
    IF EXISTS(SELECT 1 FROM sys.views WHERE [name] = @ViewName AND [schema_id] = SCHEMA_ID('mdm'))  
    BEGIN  
        SET @SQL = CONCAT(N'DROP VIEW [mdm].', quotename(@ViewName), N';');  
        EXEC sp_executesql @SQL;  
    END  
  
  
    DELETE FROM mdm.tblDerivedHierarchyDetail WHERE DerivedHierarchy_ID = @ID  
    DELETE FROM mdm.tblDerivedHierarchy WHERE ID = @ID  
  
    --Put a msg onto the SB queue to process member security   
    --for all entities in All versions in the model to be safe - revisit  
    EXEC mdm.udpSecurityMemberProcessRebuildModel @Model_ID = @Model_ID, @ProcessNow=0;  
  
    IF @@ERROR <> 0  
    BEGIN  
        RAISERROR('MDSERR200060|The derived hierarchy level cannot be deleted. A database error occurred.', 16, 1);  
        RETURN       
    END  
  
    -- Send the message  
	EXEC mdm.udpPerformanceQueueSave;  
  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpDerivedHierarchyDetailDelete]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
mdm.udpDerivedHierarchyDetailDelete 'edmAdmin', NULL, 1  
SELECT * FROM mdm.tblDerivedHierarchy  
*/  
CREATE PROCEDURE [mdm].[udpDerivedHierarchyDetailDelete]  
(  
    @ID             INT = NULL,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON  
  
    DECLARE @DerivedHierarchy_ID INT,  
            @Level_ID INT,  
            @LevelDiff INT,  
            @Ret INT;  
  
    BEGIN TRY  
        SELECT   
            @DerivedHierarchy_ID = dt.DerivedHierarchy_ID,  
            @Level_ID = dt.Level_ID,  
            @LevelDiff = (SELECT MAX(Level_ID) FROM mdm.tblDerivedHierarchyDetail WHERE DerivedHierarchy_ID = dt.DerivedHierarchy_ID) - dt.Level_ID  
        FROM mdm.tblDerivedHierarchyDetail dt  
        INNER JOIN [mdm].tblDerivedHierarchy dh ON dh.ID = dt.DerivedHierarchy_ID  
        WHERE dt.ID = @ID  
  
        --Verify that the Derived Hierarchy ID is retrieved, meaning we also have a valid Level ID  
        IF @DerivedHierarchy_ID IS NULL  
        BEGIN  
            RAISERROR('MDSERR200058|The derived hierarchy level cannot be deleted. The derived hierarchy level ID is not valid.', 16, 1);  
        END;  
  
        --Verify deleting the topmost level.  
        IF @LevelDiff > 0  
        BEGIN  
            RAISERROR('MDSERR200059|The derived hierarchy level cannot be deleted. Only the top level can be deleted.', 16, 1);  
        END;  
          
        --Verify there is no security set on any levels of the derived hierarchy.  
        IF EXISTS (SELECT ID FROM mdm.tblSecurityRoleAccessMember WHERE DerivedHierarchy_ID = @DerivedHierarchy_ID)    
        BEGIN    
            RAISERROR('MDSERR200078|Derived Hierarchy level cannot be deleted. The derived hierarchy has secured members.', 16, 1);  
        END  
  
        --Verify no subscription views exists.  
        EXEC mdm.udpSubscriptionViewCheck @DerivedHierarchy_ID = @DerivedHierarchy_ID, @ViewFormat_ID = 8 /*Levels*/, @Return_ID = @Ret output  
        IF @Ret > 0  
            BEGIN  
                RAISERROR('MDSERR200049|The derived hierarchy was not deleted because a subscription view exists.  To delete the hierarchy, you must first delete all subscription views associated with this derived hierarchy.', 16, 1);  
            END;  
        ELSE  
        BEGIN  
            EXEC mdm.udpSubscriptionViewCheck @DerivedHierarchy_ID = @DerivedHierarchy_ID, @ViewFormat_ID = 7 /*ParentChild*/, @Return_ID = @Ret output  
            IF @Ret > 0  
            BEGIN  
                RAISERROR('MDSERR200049|The derived hierarchy was not deleted because a subscription view exists.  To delete the hierarchy, you must first delete all subscription views associated with this derived hierarchy.', 16, 1);  
            END;  
        END  
  
        -- Remove any attribute filters that are referencing the level.  
        UPDATE mdm.tblAttribute  
        SET  FilterParentAttribute_ID = NULL  
            ,FilterHierarchyDetail_ID = NULL  
        WHERE FilterHierarchyDetail_ID = @ID  
  
        -- Ensure the level beneath the level being deleted (which will become the new topmost level) is visible.  
        UPDATE mdm.tblDerivedHierarchyDetail  
        SET  IsVisible = 1  
            ,LastChgDTM = GETUTCDATE()  
        WHERE   DerivedHierarchy_ID = @DerivedHierarchy_ID  
            AND Level_ID = @Level_ID - 1  
            AND IsVisible = 0;  
  
        --Delete the detail record  
        DELETE FROM mdm.tblDerivedHierarchyDetail WHERE ID = @ID  
  
        -- Recreate the system viw_SYSTEM_[MID]_[HID]_PARENTCHILD_DERIVED view  
        EXEC mdm.udpCreateSystemDerivedHierarchyParentChildView @DerivedHierarchy_ID = @DerivedHierarchy_ID  
  
        -- Note that it is not necessary to call udpSecurityMemberProcessRebuildModel to re-compute member security because the hierarchy being modified is not used for member security (as verified above).  
    END TRY  
  
    BEGIN CATCH  
        -- Get error info.  
        DECLARE  
            @ErrorMessage NVARCHAR(4000),  
            @ErrorSeverity INT,  
            @ErrorState INT,  
            @ErrorNumber INT,  
            @ErrorLine INT,  
            @ErrorProcedure NVARCHAR(126);  
        EXEC mdm.udpGetErrorInfo  
            @ErrorMessage = @ErrorMessage OUTPUT,  
            @ErrorSeverity = @ErrorSeverity OUTPUT,  
            @ErrorState = @ErrorState OUTPUT,  
            @ErrorNumber = @ErrorNumber OUTPUT,  
            @ErrorLine = @ErrorLine OUTPUT,  
            @ErrorProcedure = @ErrorProcedure OUTPUT  
  
        SET @ErrorMessage = CONCAT(@ErrorMessage, N', @ErrorNumber = ', @ErrorNumber, N', @ErrorProcedure = "', @ErrorProcedure, N'", line ', @ErrorLine);  
  
        RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);  
        RETURN;      
    END CATCH;  
  
    -- Send the message  
	EXEC mdm.udpPerformanceQueueSave;  
  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpDerivedHierarchyDetailSave]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
mdm.udpDerivedHierarchyDetailSave 1,.....  
*/  
CREATE PROCEDURE [mdm].[udpDerivedHierarchyDetailSave]  
(  
    @User_ID                INT,  
    @Model_ID               INT, -- caller should validate  
    @Version_ID             INT = NULL, -- used for audit info. When NULL, the highest value for the model will be used  
    @DerivedHierarchy_ID    INT, -- caller should validate  
    @MUID                   UNIQUEIDENTIFIER = NULL,  
    @Name                   NVARCHAR(100),  
    @Foreign_ID             INT, -- caller should validate  
    @ForeignType_ID         TINYINT,      
    @ManyToManyChildAttribute_ID    INT = NULL, -- caller should validate  
    @DisplayName            NVARCHAR(100),  
    @IsVisible              BIT,  
    @EditMode               TINYINT = 0, --0: Create, 1: Update, 4: Clone, defaults to Create  
    @IsMemberSecurityApplied BIT = NULL, -- If NULL, will be looked up.  
    @Return_ID              INT = NULL OUTPUT,  
    @Return_MUID            UNIQUEIDENTIFIER = NULL OUTPUT,  
    @CorrelationID          UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
  
)  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON  
      
    DECLARE   
         @GuidEmpty         UNIQUEIDENTIFIER = CAST(0x0 AS UNIQUEIDENTIFIER)  
  
        ,@HierarchyItemType_Entity              TINYINT = 0  
        ,@HierarchyItemType_DBA                 TINYINT = 1  
        ,@HierarchyItemType_Hierarchy           TINYINT = 2  
        --,@HierarchyItemType_ConsolidatedDBA     TINYINT = 3 -- Not used  
        ,@HierarchyItemType_ManyToMany          TINYINT = 5  
  
        ,@MemberType_Leaf           TINYINT = 1  
        ,@MemberType_Consolidated   TINYINT = 2  
  
        -- This pseudo-constant is for use in string concatenation operations to prevent string truncation. When concatenating two or more strings,  
        -- if none of the strings is an NVARCHAR(MAX) or an NVARCHAR constant that is longer than 4,000 characters, then the resulting string   
        -- will be silently truncated to 4,000 characters. Concatenating with this empty NVARCHAR(MAX), is sufficient to prevent truncation.  
        -- See http://connect.microsoft.com/SQLServer/feedback/details/283368/nvarchar-max-concatenation-yields-silent-truncation.  
        ,@TruncationGuard                NVARCHAR(MAX) = N''  
        ,@ExistingLevel_MUID             UNIQUEIDENTIFIER = NULL  
        ,@ExistingLevel_ID               INT = NULL  
        ,@ExistingLevel_IsRecursive      BIT = 0  
  
        ,@EditMode_Create                TINYINT = 0  
        ,@EditMode_Update                TINYINT = 1  
        ,@EditMode_Clone                 TINYINT = 4  
  
        ,@LevelNumber                    INT = NULL  
  
    SELECT    
        @DerivedHierarchy_ID = NULLIF(@DerivedHierarchy_ID, 0),  
        @Foreign_ID = NULLIF(@Foreign_ID, 0),  
        @ManyToManyChildAttribute_ID = NULLIF(@ManyToManyChildAttribute_ID, 0),  
        @MUID = NULLIF(@MUID, @GuidEmpty),  
        @Name = NULLIF(LTRIM(RTRIM(@Name)), N'');  
  
    --Test for invalid EditMode  
    IF @EditMode IS NULL OR @EditMode NOT IN (@EditMode_Create, @EditMode_Update, @EditMode_Clone)  
    BEGIN  
        --On error, return NULL results  
        RAISERROR('MDSERR100010|The Parameters are not valid.', 16, 1);  
        RETURN;  
    END; --if  
  
    IF @IsMemberSecurityApplied IS NULL  
    BEGIN  
        SET @IsMemberSecurityApplied = CASE WHEN EXISTS (SELECT 1  FROM mdm.tblSecurityRoleAccessMember WHERE DerivedHierarchy_ID = @DerivedHierarchy_ID)   
            THEN 1 ELSE 0 END  
    END  
      
    --If we are in the Update or Clone mode get the missing pieces of the identifier  
    IF @EditMode IN (@EditMode_Update, @EditMode_Clone)  
    BEGIN  
        --Only use the name if neither MUID nor ID are available. This is important because we don't want  
        --to look up by name if the name is what the user is trying to update.  
        IF @MUID IS NULL  
        BEGIN  
            SELECT TOP 1  
                @ExistingLevel_ID = ID,  
                @ExistingLevel_MUID = MUID,  
                @LevelNumber = Level_ID,  
                @ExistingLevel_IsRecursive = IsRecursive  
            FROM mdm.viw_SYSTEM_SCHEMA_HIERARCHY_DERIVED_LEVELS  
            WHERE   Name = @Name  
                AND Hierarchy_ID = @DerivedHierarchy_ID  
        END  
        --Use the derived hierarchy level ID and MUID to look up the full identifier  
        ELSE  
        BEGIN  
            SELECT  
                @ExistingLevel_ID =  ID,   
                @ExistingLevel_MUID = MUID,  
                @LevelNumber = Level_ID,  
                @ExistingLevel_IsRecursive = IsRecursive  
            FROM mdm.viw_SYSTEM_SCHEMA_HIERARCHY_DERIVED_LEVELS  
            WHERE   MUID = @MUID  
                AND Hierarchy_ID = @DerivedHierarchy_ID  
        END  
  
        --If we are in the Clone mode we need to figure out whether we are creating or updating a derived hierarchy level  
        IF @EditMode = @EditMode_Clone  
        BEGIN  
            --If there is no existing derived hierarchy level then set the edit mode to Create  
            IF @ExistingLevel_ID IS NULL  
            BEGIN  
                SET @EditMode = @EditMode_Create;  
            END  
            --If there is an existing derived hierarchy level then set the edit mode to Update  
            ELSE  
            BEGIN  
                SET @EditMode = @EditMode_Update;  
                SET @MUID = @ExistingLevel_MUID;  
            END  
        END  
        --If we are in Update mode and could not find a matching existing derived hierarchy level we need to raise an error and quit now  
        ELSE IF @EditMode = @EditMode_Update  
        BEGIN  
            IF @ExistingLevel_ID IS NULL  
            BEGIN  
                --On error, return NULL results  
                SELECT @Return_ID = NULL, @Return_MUID = NULL;  
                RAISERROR('MDSERR200055|The derived hierarchy level cannot be saved. The derived hierarchy level ID is not valid.', 16, 1);  
                RETURN;  
            END ELSE  
            BEGIN  
                SET @MUID = @ExistingLevel_MUID;  
  
                --Perform validations for a recursive level.   
                --A recursive level must be visible.  
                IF @ExistingLevel_IsRecursive = 1 AND @IsVisible = 0  
                BEGIN  
                    --On error, return NULL results  
                    SELECT @Return_ID = NULL, @Return_MUID = NULL;  
                    RAISERROR('MDSERR200080|The derived hierarchy level cannot be hidden because it defines a recursive relationship.', 16, 1);  
                    RETURN;  
                END  
            END  
        END  
    END      
  
    --If the edit mode is Create. This code also needs to execute if the user sent in EditMode clone which ended up becoming Create (hence the IF instead of ELSE IF)  
    IF @EditMode = @EditMode_Create  
    BEGIN  
        --If MUID is not null then we need to ensure it does not already exist (since this is a create)  
        IF @MUID IS NOT NULL AND EXISTS(SELECT 1 FROM mdm.tblDerivedHierarchy WHERE MUID = @MUID)  
        BEGIN  
            --On error, return NULL results  
            SELECT @Return_ID = NULL, @Return_MUID = NULL;  
            RAISERROR('MDSERR110007|The ID is not valid.', 16, 1);  
            RETURN;  
        END  
  
        --These checks are only applicable for new derived hierarchy levels  
        --Perform validations for the compatibility of this level within a derived hierarchy   
        --that has a recursive relationship at any level.  
        IF EXISTS(  
                    SELECT 1  
                    FROM mdm.viw_SYSTEM_SCHEMA_HIERARCHY_DERIVED_LEVELS  
                    WHERE   Hierarchy_ID = @DerivedHierarchy_ID  
                        AND IsRecursive = 1  
                )  
        BEGIN  
  
            IF (@IsMemberSecurityApplied = 1)  
            BEGIN  
                RAISERROR('MDSERR200113|The derived hierarchy level cannot be saved. A level cannot be added on top of a recursive level when the hierarchy has member permissions assigned.', 16, 1);  
                RETURN;  
            END  
  
            --Cannot add an explicit hierarchy level to a recursive derived hierarchy.  
            IF @ForeignType_ID = @HierarchyItemType_Hierarchy  
            BEGIN  
                --On error, return NULL results  
                SELECT @Return_ID = NULL, @Return_MUID = NULL;  
                RAISERROR('MDSERR200082|The derived hierarchy level cannot be saved.  An explicit hierarchy level is not supported in a recursive derived hierarchy.', 16, 1);  
                RETURN;  
            END  
        END  
    END  
  
    IF COALESCE(@Foreign_ID, -1) <= 0   
    BEGIN  
        --On error, return NULL results  
        SELECT @Return_ID = NULL, @Return_MUID = NULL;  
        RAISERROR('MDSERR200063|The derived hierarchy level cannot be saved. The Foreign ID is not valid.', 16, 1);  
        RETURN;  
    END;  
              
    --Validate ForeignType ID  
    IF (@ForeignType_ID IS NULL)  
    BEGIN  
        RAISERROR('MDSERR100008|The ForeignType_ID is required.', 16, 1);  
        RETURN;    
    END;  
  
    -- Validate ManyToManyChildAttribute  
    IF @ForeignType_ID = @HierarchyItemType_ManyToMany  
    BEGIN  
        IF @ManyToManyChildAttribute_ID = @Foreign_ID  
        BEGIN  
            RAISERROR('MDSERR100062|The ManyToManyChildAttributeId cannot reference the same attribute as ForeignId.', 16, 1);  
            RETURN;    
        END  
    END ELSE   
    BEGIN  
        -- It is not a many-to-many level, so ensure the @ManyToManyChildAttribute_ID is null.  
        SET @ManyToManyChildAttribute_ID = NULL;  
    END  
      
    IF @Version_ID IS NULL  
    BEGIN  
        --Get the Latest Version  
        SELECT @Version_ID = MAX(mv.ID)  
        FROM mdm.tblModelVersion mv   
        INNER JOIN mdm.tblDerivedHierarchy dh  
        ON mv.Model_ID = dh.Model_ID   
            AND dh.ID = @DerivedHierarchy_ID  
    END  
      
    --Check the name of the derived hierarchy level for duplicates  
    IF EXISTS   
    (  
        SELECT 1 FROM   
        mdm.tblDerivedHierarchyDetail  
        WHERE   
            @Name = Name AND   
            (@MUID IS NULL OR MUID <> @MUID) AND  
            DerivedHierarchy_ID = @DerivedHierarchy_ID  
    )  
    BEGIN  
        --On error, return NULL results  
        SELECT @Return_ID = NULL, @Return_MUID = NULL;  
        RAISERROR('MDSERR110003|The name already exists. Type a different name.', 16, 1);  
        RETURN;  
    END  
  
        
    BEGIN TRY    
        IF @EditMode = @EditMode_Update  
        --Update  
        BEGIN    
            -- Update existing level.  
            IF @IsVisible = 0  
            BEGIN  
                -- Cannot hide a level if the hierarchy is used for member security.  
                If @IsMemberSecurityApplied = 1  
                BEGIN  
                    RAISERROR('MDSERR200075|The derived hierarchy level cannot be hidden. The derived hierarchy has secured members.', 16, 1);  
                    RETURN  
                END;  
  
                -- Cannot hide top or bottom level  
                DECLARE @MaxLevel INT = (SELECT MAX(Level_ID) FROM mdm.tblDerivedHierarchyDetail WHERE DerivedHierarchy_ID = @DerivedHierarchy_ID);  
                IF @LevelNumber IN (1, @MaxLevel)  
                BEGIN  
                    RAISERROR('MDSERR200099|The top or bottom level of a derived hierarchy cannot be hidden.', 16, 1);  
                    RETURN  
                END;  
  
                -- Cannot hide a level whose parent level is recursive  
                IF EXISTS(  
                    SELECT 1   
                    FROM mdm.tblDerivedHierarchyDetail child  
                    INNER JOIN mdm.tblAttribute cDba  
                    ON child.Foreign_ID = cDba.ID  
                    INNER JOIN mdm.tblDerivedHierarchyDetail parent  
                    ON      child.Level_ID = parent.Level_ID - 1  
                        AND child.DerivedHierarchy_ID = parent.DerivedHierarchy_ID  
                        AND parent.ForeignType_ID = @HierarchyItemType_DBA  
                    INNER JOIN mdm.tblAttribute pDba  
                    ON parent.Foreign_ID = pDba.ID  
                    WHERE   child.DerivedHierarchy_ID = @DerivedHierarchy_ID  
                        AND child.ID = @ExistingLevel_ID  
                        AND child.ForeignType_ID = @HierarchyItemType_DBA  
                        AND cDba.DomainEntity_ID = pDba.DomainEntity_ID  
                )  
                BEGIN  
                    RAISERROR('MDSERR200077|The derived hierarchy level cannot be hidden. It is part of a recursive relationship.', 16, 1);  
                    RETURN  
                END;  
  
                -- Cannot hide a level that is being used as part of an attribute filter  
                DECLARE   
                     @FilterEntityName NVARCHAR(50) = NULL  
                    ,@FilterAttributeName NVARCHAR(100) = NULL;  
                SELECT TOP 1   
                     @FilterEntityName = e.Name  
                    ,@FilterAttributeName = a.Name  
                FROM mdm.tblAttribute a  
                LEFT JOIN mdm.tblEntity e  
                ON a.Entity_ID = e.ID  
                WHERE a.FilterHierarchyDetail_ID = @ExistingLevel_ID  
                IF @FilterAttributeName IS NOT NULL  
                BEGIN  
                    DECLARE @Message NVARCHAR(MAX) = CONCAT('MDSERR200126|The derived hierarchy level cannot be hidden. It is being used to filter attribute "{0}" in entity "{1}".|', REPLACE(@FilterAttributeName, N'|', N''), N'|', REPLACE(@FilterEntityName, N'|', N''));  
                    SET @Message = REPLACE(@Message, '%', '%%')-- escape out format specifier  
                    RAISERROR(@Message, 16, 1);  
                    RETURN  
                END  
            END  
  
            UPDATE mdm.tblDerivedHierarchyDetail     
            SET  
                 Name = COALESCE(@Name, [Name])    
                ,DisplayName = COALESCE(@DisplayName, [DisplayName])    
                ,IsVisible = COALESCE(@IsVisible,[IsVisible])    
                ,LastChgDTM = GETUTCDATE()    
                ,LastChgUserID = @User_ID    
                ,LastChgVersionID = @Version_ID    
            WHERE    
                ID = @ExistingLevel_ID    
        
            --Populate output parameters    
            SELECT @Return_ID = @ExistingLevel_ID    
            SELECT @Return_MUID = @ExistingLevel_MUID;  
        END    
        ELSE    
        --Create  
        BEGIN    
            --Level Add Check.  We need to make sure the save request is compatible with the current top level of the hierarchy.    
            --The new level can only be added to the top.    
            DECLARE   
                 @NextLevelNumber INT  
                ,@ForeignParent_ID  INT  
  
            EXEC mdm.udpDerivedHierarchyLevelAddCheck @DerivedHierarchy_ID, @Foreign_ID, @ForeignType_ID, @ManyToManyChildAttribute_ID, @NextLevelNumber OUT, @ForeignParent_ID OUT    
                    
            IF @NextLevelNumber = 0    
            BEGIN    
                RAISERROR('MDSERR200056|The derived hierarchy level cannot be saved. The level being saved is not compatible with the current top level.', 16, 1);  
            END;    
                  
            -- If adding an explicit hierarchy and member security has been applied return error.  
            IF (@IsMemberSecurityApplied = 1 AND @ForeignType_ID = @HierarchyItemType_Hierarchy)  
            BEGIN  
                RAISERROR('MDSERR200076|A derived hierarchy level with explicit cap cannot be added. The derived hierarchy has secured members.', 16, 1);  
                RETURN  
            END  
  
-- TODO: If the level is ManyToMany and recursive (both parent and child DBAs reference the same entity), check for circular relationship.  
  
            -- If the level is recursive, check for pre-existing circular relationships.  
            IF @ForeignType_ID = @HierarchyItemType_DBA  
            BEGIN  
                -- Get attribute info  
                DECLARE   
                     @AttributeColumnName   sysname  
                    ,@Entity_ID             INT  
                    ,@DomainEntity_ID       INT;  
                SELECT  
                     @Entity_ID = Entity_ID  
                    ,@DomainEntity_ID = DomainEntity_ID  
                    ,@AttributeColumnName = TableColumn  
                FROM mdm.tblAttribute  
                WHERE ID = @Foreign_ID  
  
                -- If the attribute's entity is the same as its domain entity, then the level would be recursive. Ensure there are no pre-existing circular relationships.  
                IF @Entity_ID = @DomainEntity_ID  
                BEGIN  
                    DECLARE  
                         @MemberTableName   sysname = (SELECT EntityTable FROM mdm.tblEntity WHERE ID = @Entity_ID)  
                        ,@ErrorMsg          NVARCHAR(MAX)  
                        ,@SQL               NVARCHAR(MAX);  
  
                    SET @SQL = @TruncationGuard + N'  
                    SET @ErrorMsg = N'''';  
                    WITH parentAssignmentsCte AS  
                    (  
                        SELECT DISTINCT  
                                Code AS ChildCode  
                            ,ID AS ChildID  
                            ,' + @AttributeColumnName + N' AS ParentID  
                        FROM mdm.' + @MemberTableName + N'  
                        WHERE ' + @AttributeColumnName + N' IS NOT NULL -- Exclude null parents for efficiency. A member with a null parent cannot be part of a circular relationship.  
                    )  
  
                    -- Recursively find all member ancestors, checking for circular relationships.  
                    ,ancestorsCte AS  
                    (  
                        SELECT  
                             ChildCode AS MemberCode  
                            ,ChildID AS MemberID  
                            ,ParentID AS AncestorID  
                            ,0 AS RecursionLevel  
                            ,CASE WHEN ChildID = ParentID THEN 1 ELSE 0 END AS IsCircular -- If a member is its own parent, then it is part of a circular relationship.  
                        FROM parentAssignmentsCte  
  
                        UNION ALL  
  
                        -- Recursively find all ancestors of the members.  
                        SELECT  
                             cte.MemberCode  
                            ,cte.MemberID  
                            ,p.ParentID AS AncestorID  
                            ,cte.RecursionLevel + 1  
                            ,CASE WHEN cte.MemberID = p.ParentID THEN 1 ELSE 0 END AS IsCircular -- If a member is its own ancestor, then it is part of a circular relationship.  
                        FROM ancestorsCte cte  
                        INNER JOIN parentAssignmentsCte p  
                        ON cte.AncestorID = p.ChildID  
                        WHERE   cte.RecursionLevel < 99 -- Protects against "The statement terminated. The maximum recursion 100 has been exhausted before statement completion" error.  
                            AND cte.IsCircular = 0 -- Stop when a circular relationship is found.  
                    )  
                  
                    -- Get the MemberCodes that participate in circular relationships.  
                    ,circularRelationshipsCte AS  
                    (  
                        SELECT DISTINCT MemberCode  
                        FROM ancestorsCte  
                        WHERE IsCircular = 1  
                    )  
                    SELECT   
                        @ErrorMsg += N'', '' + MemberCode  
                    FROM circularRelationshipsCte;  
                    ';  
                    --PRINT @SQL  
                    EXEC sp_executesql @SQL, N'@ErrorMsg NVARCHAR(MAX) OUTPUT', @ErrorMsg OUTPUT;  
                    IF LEN(@ErrorMsg) > 0  
                    BEGIN  
                        SET @ErrorMsg = N'MDSERR100058|A recursive derived hierarchy level cannot be added. Members with the following codes participate in circular relationships: {0}.|'  
                            + REPLACE(SUBSTRING(@ErrorMsg, 2, LEN(@ErrorMsg)), N'|', N'');-- Remove the leading comma, remove separator char  
                        SET @ErrorMsg = REPLACE(@ErrorMsg, '%', '%%')-- escape out format specifier  
                        RAISERROR(@ErrorMsg, 16, 1);  
                        RETURN;  
                    END; -- Error found  
                END; -- Level is recursive  
            END; -- Level is DBA-based (not explicit hierarchy)  
  
            --Accept an explicit MUID (for clone operations) or generate a new one    
            SET @Return_MUID = COALESCE(@MUID, NEWID());    
    
            INSERT INTO mdm.tblDerivedHierarchyDetail    
                ([DerivedHierarchy_ID]    
                ,[ForeignParent_ID]    
                ,[Foreign_ID]    
                ,[ForeignType_ID]    
                ,[ManyToManyChildAttribute_ID]  
                ,[Level_ID]    
                ,[Name]    
                ,[MUID]    
                ,[DisplayName]    
                ,[IsVisible]    
                ,[EnterDTM]    
                ,[EnterUserID]    
                ,[EnterVersionID]    
                ,[LastChgDTM]    
                ,[LastChgUserID]    
                ,[LastChgVersionID])    
                    
            SELECT     
                 @DerivedHierarchy_ID    
                ,@ForeignParent_ID    
                ,@Foreign_ID    
                ,@ForeignType_ID    
                ,@ManyToManyChildAttribute_ID  
                ,@NextLevelNumber    
                ,@Name    
                ,@Return_MUID    
                ,@DisplayName    
                ,@IsVisible    
                ,GETUTCDATE()    
                ,@User_ID    
                ,@Version_ID    
                ,GETUTCDATE()    
                ,@User_ID    
                ,@Version_ID    
    
            SELECT @Return_ID = SCOPE_IDENTITY()    
        END    
  
        -- If the hierarchy is being used for member security, then put a message onto the service broker queue to process member security for the whole model.  
        IF @IsMemberSecurityApplied = 1  
        BEGIN  
            EXEC mdm.udpSecurityMemberProcessRebuildModel @Model_ID = @Model_ID, @ProcessNow=0;  
        END;  
    END TRY    
    BEGIN CATCH    
        -- Get error info.  
        DECLARE  
            @ErrorMessage NVARCHAR(4000),  
            @ErrorSeverity INT,  
            @ErrorState INT,  
            @ErrorNumber INT,  
            @ErrorLine INT,  
            @ErrorProcedure NVARCHAR(126);  
        EXEC mdm.udpGetErrorInfo  
            @ErrorMessage = @ErrorMessage OUTPUT,  
            @ErrorSeverity = @ErrorSeverity OUTPUT,  
            @ErrorState = @ErrorState OUTPUT,  
            @ErrorNumber = @ErrorNumber OUTPUT,  
            @ErrorLine = @ErrorLine OUTPUT,  
            @ErrorProcedure = @ErrorProcedure OUTPUT  
  
        SET @ErrorMessage = CONCAT(@ErrorMessage, N', @ErrorNumber = ', @ErrorNumber, N', @ErrorProcedure = "', @ErrorProcedure, N'", line ', @ErrorLine);  
  
        RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);  
        RETURN;      
    END CATCH;    
  
    -- Send the message  
	EXEC mdm.udpPerformanceQueueSave;  
    
    SET NOCOUNT OFF    
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpDerivedHierarchyGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpDerivedHierarchyGet]  
(  
     @User_ID       INT  
  
    ,@Model_MUID    UNIQUEIDENTIFIER = NULL  
    ,@Model_Name    NVARCHAR(50) = NULL  
    ,@Model_ID      INT = NULL -- set internally only  
  
    ,@HierarchyTable mdm.Identifier READONLY-- caller should ensure table does not include rows where both MUID and Name are blank  
  
    ,@ResultOption TINYINT -- None = 0, Identifiers = 1, Details = 2.   
   
    ,@IncludeParentIdentifiers  BIT = 1 -- Return results sets for parent Model and Entity identifiers. Set to 0 when getting attributes as part of a parent object (because the parent identifiers will already have been looked up).  
    ,@Debug                     BIT = 0  
    ,@CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
  
    SET NOCOUNT ON  
  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), ': begin udpDerivedHierarchyGet')  
  
    DECLARE   
         @ResultOption_Identifiers  TINYINT = 1  
        ,@ResultOption_Details      TINYINT = 2  
  
    -- Get model ID  
    IF @Model_ID IS NULL -- If the ID was already provided, don't bother looking it up again  
        AND (@Model_Name IS NOT NULL OR @Model_MUID IS NOT NULL)  
    BEGIN  
        IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), ': lookup @Model_ID')  
        SELECT   
             @Model_ID = ID  
            ,@Model_MUID = MUID  
            ,@Model_Name = Name  
        FROM mdm.tblModel  
        WHERE   MUID = ISNULL(@Model_MUID, MUID)  
            AND Name = ISNULL(@Model_Name, Name)  
  
        SET @Model_ID = COALESCE(@Model_ID, 0)  
    END  
  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), ': getting selected derived hierarchies from criteria')  
    DECLARE @SelectedHierarchy TABLE   
    (  
         ID                 INT PRIMARY KEY  
        ,Model_ID           INT  
        ,Privilege_ID       TINYINT  
        ,AccessPermission   TINYINT  
    )  
  
    INSERT INTO @SelectedHierarchy  
    SELECT  
         h.ID  
        ,h.Model_ID  
        ,acl.Privilege_ID  
        ,acl.AccessPermission  
    FROM mdm.tblDerivedHierarchy h  
    INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_HIERARCHY_DERIVED acl  
    ON h.ID = acl.ID  
    WHERE   acl.User_ID = @User_ID  
        AND h.Model_ID = ISNULL(@Model_ID, h.Model_ID)  
  
    IF EXISTS(SELECT 1 FROM @HierarchyTable)  
    BEGIN  
        IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), ': removing rows that do not match the table filter')  
        -- Remove rows that don't match the filter  
        DELETE sh  
        FROM @SelectedHierarchy sh  
        INNER JOIN mdm.tblDerivedHierarchy h  
        ON sh.ID = h.ID  
        LEFT JOIN @HierarchyTable ht   
        ON      h.MUID = ISNULL(ht.MUID, h.MUID)  
            AND h.Name = ISNULL(ht.Name, h.Name)  
        WHERE (ht.MUID IS NULL AND ht.Name IS NULL)  
    END  
  
    IF @IncludeParentIdentifiers = 1  
    BEGIN  
        IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), ': returning parent identifiers')  
        -- Return model Identifier(s)  
        IF @Model_ID IS NOT NULL  
        BEGIN  
            IF @Model_Name IS NULL OR @Model_MUID IS NULL  
            BEGIN  
                SELECT   
                     @Model_MUID = MUID  
                    ,@Model_Name = Name  
                FROM mdm.tblModel  
                WHERE ID = @Model_ID  
            END  
  
            -- A single model was specified, and its info has already been looked up, so simply return it  
            SELECT   
                 @Model_MUID    AS Model_MUID  
                ,@Model_Name    AS Model_Name  
                ,@Model_ID      AS Model_ID  
        END ELSE  
        BEGIN  
            SELECT DISTINCT  
                 m.MUID AS Model_MUID  
                ,m.Name AS Model_Name  
                ,m.ID   AS Model_ID  
            FROM @SelectedHierarchy h  
            INNER JOIN mdm.tblModel m  
            ON h.Model_ID = m.ID  
        END  
    END  
  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), ': returning derived hierarchy info')  
    SELECT  
         h.Hierarchy_MUID  
        ,h.Hierarchy_Name  
        ,h.Hierarchy_ID  
        ,sh.Privilege_ID  
        ,sh.AccessPermission  
  
        ,sh.Model_ID  
        ,h.Hierarchy_AnchorNullRecursions AS AnchorNullRecursions  
  
        ,h.EnteredUser_DTM  
        ,h.EnteredUser_MUID  
        ,h.EnteredUser_UserName  
        ,h.EnteredUser_ID  
        ,h.LastChgUser_DTM  
        ,h.LastChgUser_MUID  
        ,h.LastChgUser_UserName  
        ,h.LastChgUser_ID  
    FROM @SelectedHierarchy sh  
    INNER JOIN mdm.viw_SYSTEM_SCHEMA_HIERARCHY_DERIVED h  
    ON sh.ID = h.Hierarchy_ID  
    ORDER BY   
         h.Model_ID  
        ,h.Hierarchy_Name  
  
    IF @ResultOption = @ResultOption_Details  
    BEGIN  
        DECLARE @HierarchyLevelTable mdm.Identifier;  
        EXEC mdm.udpDerivedHierarchyLevelGet  
             @User_ID = @User_ID  
            ,@Model_ID = @Model_ID  
            ,@Model_MUID = @Model_MUID  
            ,@Model_Name = @Model_Name  
            ,@HierarchyTable = @HierarchyTable  
            ,@HierarchyLevelTable = @HierarchyLevelTable  
            ,@IncludeParentIdentifiers = 0 -- parent Ids already returned  
            ,@Debug = @Debug  
            ,@CorrelationID = @CorrelationID  
    END   
  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), ': end udpDerivedHierarchyGet')  
  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpDerivedHierarchyLevelAddCheck]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    SELECT mdm.udfDerivedHierarchyLevelAddCheck(1, 1515, 1);  
*/  
CREATE PROCEDURE [mdm].[udpDerivedHierarchyLevelAddCheck]  
(  
    @DerivedHierarchy_ID  INT,  
    @Foreign_ID  INT,  
    @ForeignType_ID  INT,  
    @ManyToManyChildAttribute_ID  INT,  
    @NextLevelNumber INT OUTPUT,    -- 0 = Incompatible level info; >0 = The new top most level.  
    @TopLevelForeign_ID INT OUTPUT,  -- The top-level foreign Id that will be used to set the foreign parent Id.  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)   
/*WITH*/  
AS BEGIN  
    DECLARE   
         @TopLevel_ID                           INT  
        ,@TopLevelForeignType_ID                TINYINT  
        ,@TopLevelManyToManyChildAttribute_ID   INT  
        ,@TopLevelEntity_ID                     INT  
  
        /************************************************/  
        /*@ForeignType_ID is Common.HierarchyItemType   */  
        /************************************************/  
        ,@HierarchyItemType_Entity              TINYINT = 0  
        ,@HierarchyItemType_DBA                 TINYINT = 1  
        ,@HierarchyItemType_Hierarchy           TINYINT = 2  
        --,@HierarchyItemType_ConsolidatedDBA     TINYINT = 3 -- Not used  
        ,@HierarchyItemType_ManyToMany          TINYINT = 5  
          
        ,@MemberType_Leaf                       TINYINT = 1;  
      
    -- Get the current top level so we can validate it against the requested Foreign_ID and ForeignType_ID.  
    SELECT TOP 1   
         @TopLevelForeign_ID = Foreign_ID  
        ,@TopLevelForeignType_ID = ForeignType_ID  
        ,@TopLevelManyToManyChildAttribute_ID = ManyToManyChildAttribute_ID  
        ,@TopLevelEntity_ID = Entity_ID  
        ,@TopLevel_ID = Level_ID  
    FROM mdm.viw_SYSTEM_SCHEMA_HIERARCHY_DERIVED_LEVELS  
    WHERE Hierarchy_ID = @DerivedHierarchy_ID  
    ORDER BY Level_ID DESC  
  
    --Initialize next level to 0, the error state.  
    SET @NextLevelNumber = 0;  
  
    IF @TopLevelForeignType_ID IS NULL -- No levels added yet  
    BEGIN  
        -- The first level must be an entity and must be in the model of the derived hierarchy.  
        IF EXISTS(SELECT 1 FROM mdm.tblEntity e   
                INNER JOIN mdm.tblDerivedHierarchy dh   
                ON      e.ID = @Foreign_ID   
                    AND dh.ID = @DerivedHierarchy_ID   
                    AND e.Model_ID = dh.Model_ID)  
        BEGIN  
            SET @NextLevelNumber = 1;  
        END;  
    END  
  
    ELSE IF @TopLevelForeignType_ID IN (@HierarchyItemType_Entity, @HierarchyItemType_DBA, @HierarchyItemType_ManyToMany)  
    BEGIN  
        -- The next level can be either a DBA, Hierarchy, or ManyToMany  
        IF     (@ForeignType_ID = @HierarchyItemType_DBA   
                AND EXISTS(SELECT 1   
                            FROM mdm.tblAttribute   
                            WHERE   ID = @Foreign_ID   
                                AND Entity_ID = @TopLevelEntity_ID   
                                AND MemberType_ID = @MemberType_Leaf   
                                AND DomainEntity_ID IS NOT NULL  
                        ))  
            OR (@ForeignType_ID = @HierarchyItemType_Hierarchy   
                AND EXISTS(SELECT 1   
                            FROM mdm.tblHierarchy   
                            WHERE   ID = @Foreign_ID   
                                AND Entity_ID = @TopLevelEntity_ID  
                        ))  
            OR (@ForeignType_ID = @HierarchyItemType_ManyToMany  
                AND EXISTS(SELECT 1   
                            FROM mdm.tblAttribute  
                            WHERE   ID = @ManyToManyChildAttribute_ID  
                                AND DomainEntity_ID = @TopLevelEntity_ID -- The @ManyToManyChildAttribute_ID must be a DBA on a mapping entity that references the top level entity  
                                AND MemberType_ID = @MemberType_Leaf  
                        ))  
        BEGIN  
            SET @NextLevelNumber = @TopLevel_ID + 1;  
        END;  
    END  
  
    ELSE IF @TopLevelForeignType_ID = @HierarchyItemType_Hierarchy  
    BEGIN  
        -- If the current top level is a Hierarchy then no other levels can be added.  
        SET @NextLevelNumber = 0;  
    END  
  
END; --fn
GO
/****** Object:  StoredProcedure [mdm].[udpDerivedHierarchyLevelGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpDerivedHierarchyLevelGet]  
(  
     @User_ID       INT  
  
    ,@Model_MUID    UNIQUEIDENTIFIER = NULL  
    ,@Model_Name    NVARCHAR(50) = NULL  
    ,@Model_ID      INT = NULL -- set internally only  
  
    ,@HierarchyTable mdm.Identifier READONLY-- caller should ensure table does not include rows where both MUID and Name are blank  
    ,@HierarchyLevelTable mdm.Identifier READONLY-- caller should ensure table does not include rows where both MUID and Name are blank  
  
    ,@IncludeParentIdentifiers  BIT = 1 -- Return results sets for parent Model and Entity identifiers. Set to 0 when getting attributes as part of a parent object (because the parent identifiers will already have been looked up).  
    ,@Debug                     BIT = 0  
    ,@CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
  
    SET NOCOUNT ON  
  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), ': begin udpDerivedHierarchyLevelGet')  
  
    -- Get model ID  
    IF @Model_ID IS NULL -- If the ID was already provided, don't bother looking it up again  
        AND (@Model_Name IS NOT NULL OR @Model_MUID IS NOT NULL)  
    BEGIN  
        IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), ': lookup @Model_ID')  
        SELECT   
             @Model_ID = ID  
            ,@Model_MUID = MUID  
            ,@Model_Name = Name  
        FROM mdm.tblModel  
        WHERE   MUID = ISNULL(@Model_MUID, MUID)  
            AND Name = ISNULL(@Model_Name, Name)  
  
        SET @Model_ID = COALESCE(@Model_ID, 0)  
    END  
  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), ': getting selected derived hierarchy levels from criteria')  
    DECLARE @SelectedLevel TABLE   
    (  
         ID             INT PRIMARY KEY  
        ,Hierarchy_ID   INT  
    )  
  
    INSERT INTO @SelectedLevel  
    SELECT  
         l.ID  
        ,l.Hierarchy_ID  
    FROM mdm.viw_SYSTEM_SCHEMA_HIERARCHY_DERIVED_LEVELS l  
    INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_HIERARCHY_DERIVED acl  
    ON l.Hierarchy_ID = acl.ID  
    WHERE   acl.User_ID = @User_ID  
        AND l.Model_ID = ISNULL(@Model_ID, l.Model_ID)  
  
    IF EXISTS(SELECT 1 FROM @HierarchyTable)  
    BEGIN  
        -- Remove rows that don't match the hierarchy filter  
        IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), ': removing rows that do not match the hierarchy table filter')  
        DELETE l  
        FROM @SelectedLevel l  
        INNER JOIN mdm.tblDerivedHierarchy h  
        ON l.Hierarchy_ID = h.ID  
        LEFT JOIN @HierarchyTable ht   
        ON      h.MUID = ISNULL(ht.MUID, h.MUID)  
            AND h.Name = ISNULL(ht.Name, h.Name)  
        WHERE (ht.MUID IS NULL AND ht.Name IS NULL)  
    END  
    IF EXISTS(SELECT 1 FROM @HierarchyLevelTable)  
    BEGIN  
        -- Remove rows that don't match the hierarchy level filter  
        IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), ': removing rows that do not match the hierarchy level table filter')  
        DELETE l  
        FROM @SelectedLevel l  
        INNER JOIN mdm.tblDerivedHierarchyDetail hl  
        ON l.Hierarchy_ID = hl.DerivedHierarchy_ID  
        LEFT JOIN @HierarchyLevelTable hlt   
        ON      hl.MUID = ISNULL(hlt.MUID, hl.MUID)  
            AND hl.Name = ISNULL(hlt.Name, hl.Name)  
        WHERE (hlt.MUID IS NULL AND hlt.Name IS NULL)  
    END  
  
    IF @IncludeParentIdentifiers = 1  
    BEGIN  
        IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), ': returning parent identifiers')  
        -- Return model Identifier(s)  
        IF @Model_ID IS NOT NULL  
        BEGIN  
            IF @Model_Name IS NULL OR @Model_MUID IS NULL  
            BEGIN  
                SELECT   
                     @Model_MUID = MUID  
                    ,@Model_Name = Name  
                FROM mdm.tblModel  
                WHERE ID = @Model_ID  
            END  
  
            -- A single model was specified, and its info has already been looked up, so simply return it  
            SELECT   
                 @Model_MUID    AS Model_MUID  
                ,@Model_Name    AS Model_Name  
                ,@Model_ID      AS Model_ID  
        END ELSE  
        BEGIN  
            SELECT DISTINCT  
                 m.MUID AS Model_MUID  
                ,m.Name AS Model_Name  
                ,m.ID   AS Model_ID  
            FROM @SelectedLevel l  
            INNER JOIN mdm.tblDerivedHierarchy dh  
            ON l.Hierarchy_ID = dh.ID  
            INNER JOIN mdm.tblModel m  
            ON dh.Model_ID = m.ID  
        END  
  
        -- Return derived hierarchy Identifier(s)  
        SELECT DISTINCT  
             dh.Model_ID    AS Model_ID  
            ,dh.MUID        AS Hierarchy_MUID  
            ,dh.Name        AS Hierarchy_Name  
            ,dh.ID          AS Hierarchy_ID  
        FROM @SelectedLevel l  
        INNER JOIN mdm.tblDerivedHierarchy dh  
        ON l.Hierarchy_ID = dh.ID  
    END  
  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), ': returning derived hierarchy level info')  
    SELECT  
         l.MUID AS HierarchyLevel_MUID  
        ,l.Name AS HierarchyLevel_Name  
        ,l.ID   AS HierarchyLevel_ID  
  
        ,l.Hierarchy_ID  
  
        ,l.DisplayName  
        ,l.Entity_MUID  
        ,l.Entity_Name  
        ,l.Entity_ID  
        ,NULLIF(l.ForeignEntity_MUID, 0x0)  AS ForeignEntity_MUID  
        ,NULLIF(l.ForeignEntity_Name, N'')  AS ForeignEntity_Name  
        ,NULLIF(l.ForeignEntity_ID, 0)      AS ForeignEntity_ID  
        ,l.Foreign_MUID  
        ,l.Foreign_Name  
        ,l.Foreign_ID  
        ,l.ForeignType_ID  
        ,CONVERT(BIT, l.IsRecursive) IsRecursive  
        ,l.IsLevelVisible  
        ,l.LevelNumber  
        ,NULLIF(l.ManyToManyChildAttribute_MUID, 0x0)   AS ManyToManyChildAttribute_MUID  
        ,NULLIF(l.ManyToManyChildAttribute_Name, N'')   AS ManyToManyChildAttribute_Name  
        ,NULLIF(l.ManyToManyChildAttribute_ID, 0)       AS ManyToManyChildAttribute_ID  
        ,l.MemberType_ID  
  
        -- Audit info  
        ,l.Detail_EnteredUser_DTM AS EnteredUser_DTM  
        ,l.Detail_EnteredUser_MUID AS EnteredUser_MUID  
        ,l.Detail_EnteredUser_UserName AS EnteredUser_UserName  
        ,l.Detail_EnteredUser_ID AS EnteredUser_ID  
        ,l.Detail_LastChgUser_DTM AS LastChgUser_DTM  
        ,l.Detail_LastChgUser_MUID AS LastChgUser_MUID  
        ,l.Detail_LastChgUser_UserName AS LastChgUser_UserName  
        ,l.Detail_LastChgUser_ID AS LastChgUser_ID  
    FROM @SelectedLevel sl  
    INNER JOIN mdm.viw_SYSTEM_SCHEMA_HIERARCHY_DERIVED_LEVELS l  
    ON sl.ID = l.ID  
    ORDER BY   
         l.Model_ID  
        ,l.Hierarchy_ID  
        ,l.Level_ID  
  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), ': end udpDerivedHierarchyLevelGet')  
  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpDerivedHierarchyParentSave]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
Changes the derived hierarchy parent of the given leaf members to the given parent.  
The given hierarchy level's type must be either DBA or Many-to-Many (M2M).  
  
*/  
CREATE PROCEDURE [mdm].[udpDerivedHierarchyParentSave]  
(  
     @User_ID               INT  
    ,@ModelName             NVARCHAR(50) = NULL  
    ,@ModelMuid             UNIQUEIDENTIFIER = NULL  
    ,@VersionName           NVARCHAR(50) = NULL  
    ,@VersionMuid           UNIQUEIDENTIFIER = NULL  
    ,@DerivedHierarchyName  NVARCHAR(50) = NULL  
    ,@DerivedHierarchyMuid  UNIQUEIDENTIFIER = NULL  
    ,@LevelNumber           INT  
    ,@NewParentID           UNIQUEIDENTIFIER  
    ,@OldParentChildIds     mdm.ParentChildId READONLY -- old parent id is only required for M2M levels. It is ignored for DBA levels  
    ,@CorrelationID         UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE  
         @Model_ID                      INT  
        ,@Version_ID                    INT  
        ,@DerivedHierarchy_ID           INT  
        ,@Entity_ID                     INT  
        ,@ParentEntity_ID               INT  
        ,@ParentEntityTableName         SYSNAME  
        ,@ParentAttribute_ID            INT  
        ,@ParentAttributeName           SYSNAME  
        ,@ManyToManyChildAttribute_ID   INT  
        ,@ManyToManyChildAttributeName  SYSNAME  
        ,@LevelType                     TINYINT  
        ,@NewParentCode                 NVARCHAR(250)  
        ,@Members                       mdm.MemberSaveList  
        ,@MemberAttributes              mdm.MemberAttributeValues  
        ,@SaveMode                      TINYINT  
  
        ,@MemberType_Leaf               TINYINT = 1  
  
        ,@ForeignType_DBA               TINYINT = 1  
        ,@ForeignType_ManyToMany        TINYINT = 5  
  
        ,@Permission_Deny               INT = 1  
  
        ,@SaveMode_Create               TINYINT = 1  
        ,@SaveMode_Merge                TINYINT = 2  
        ,@SaveMode_Update               TINYINT = 3  
  
        ,@TransactionBehavior_AllOrNothingByBatch   TINYINT = 2  
  
        ,@SQL                           NVARCHAR(MAX)  
        ,@GuidEmpty                     UNIQUEIDENTIFIER = CAST(0x0 AS UNIQUEIDENTIFIER)  
        ;  
  
    SELECT  
         @ModelMuid = NULLIF(@ModelMuid, @GuidEmpty)  
        ,@ModelName = NULLIF(@ModelName, N'')  
        ,@VersionMuid = NULLIF(@VersionMuid, @GuidEmpty)  
        ,@VersionName = NULLIF(@VersionName, N'')  
        ,@DerivedHierarchyMuid = NULLIF(@DerivedHierarchyMuid, @GuidEmpty)  
        ,@DerivedHierarchyName = NULLIF(@DerivedHierarchyName, N'')  
        ,@NewParentID = NULLIF(LTRIM(RTRIM(@NewParentID)), N'');  
  
    SELECT @Model_ID = m.ID  
    FROM mdm.tblModel m  
    INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_MODEL s  
    ON      m.ID = s.ID  
        AND COALESCE(s.Privilege_ID, @Permission_Deny) <> @Permission_Deny  
        AND s.User_ID = @User_ID  
    WHERE   (@ModelMuid IS NOT NULL OR @ModelName IS NOT NULL) -- At least one Identifier param must be provided.  
        AND (@ModelMuid IS NULL OR @ModelMuid = m.MUID)  
        AND (@ModelName IS NULL OR @ModelName = m.Name)  
  
    IF @Model_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR300005|The supplied model is not valid.', 16, 1);  
        RETURN;  
    END  
  
    SELECT @Version_ID = ID  
    FROM mdm.tblModelVersion  
    WHERE  
        (@VersionMuid IS NOT NULL OR @VersionName IS NOT NULL) -- At least one Identifier param must be provided.  
    AND (@VersionMuid IS NULL OR @VersionMuid = MUID)  
    AND (@VersionName IS NULL OR @VersionName = Name)  
    AND Model_ID = @Model_ID  
    IF @Version_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR300006|The supplied version is not valid.', 16, 1);  
        RETURN;  
    END;  
  
    SELECT @DerivedHierarchy_ID = ID  
    FROM mdm.tblDerivedHierarchy  
    WHERE   Model_ID = @Model_ID  
        AND (@DerivedHierarchyMuid IS NOT NULL OR @DerivedHierarchyName IS NOT NULL)  
        AND (@DerivedHierarchyMuid IS NULL OR @DerivedHierarchyMuid = MUID)  
        AND (@DerivedHierarchyName IS NULL OR @DerivedHierarchyName = Name)  
  
    IF @DerivedHierarchy_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR300007|The supplied derived hierarchy is not valid.', 16, 1);  
        RETURN;  
    END  
  
    -- Lookup Hierarchy level (level type, entity name, parent attribute name)  
    SELECT   
         @LevelType                     = l.ForeignType_ID   
        ,@ParentAttribute_ID            = l.Foreign_ID  
        ,@ParentAttributeName           = l.Foreign_Name  
        ,@ManyToManyChildAttribute_ID   = l.ManyToManyChildAttribute_ID  
        ,@ManyToManyChildAttributeName  = l.ManyToManyChildAttribute_Name  
        ,@Entity_ID                     = l.ForeignEntity_ID   
        ,@ParentEntity_ID               = l.Entity_ID  
        ,@ParentEntityTableName         = pe.EntityTable  
    FROM mdm.viw_SYSTEM_SCHEMA_HIERARCHY_DERIVED_LEVELS l  
    LEFT JOIN mdm.tblEntity pe  
    ON l.Entity_ID = pe.ID  
    WHERE   l.Hierarchy_ID = @DerivedHierarchy_ID  
        AND l.LevelNumber = @LevelNumber  
  
    IF @LevelType IS NULL OR @LevelType NOT IN (@ForeignType_DBA, @ForeignType_ManyToMany)  
    BEGIN  
        RAISERROR('MDSERR300038|The supplied derived hierarchy level is not valid.', 16, 1);  
        RETURN;  
    END  
  
    IF EXISTS(SELECT 1 FROM @OldParentChildIds WHERE ChildId IS NULL OR ChildId = @GuidEmpty)  
    BEGIN  
        RAISERROR('MDSERR300040|Child ID is required.', 16, 1);  
        RETURN;  
    END   
  
    IF @NewParentID IS NOT NULL  
    BEGIN  
        -- Lookup parent code  
        SET @SQL = CONCAT(N'  
SELECT TOP 1 @NewParentCode = Code  
FROM mdm.', QUOTENAME(@ParentEntityTableName), N'  
WHERE   Version_ID = @Version_ID  
    AND MUID = @NewParentID  
')  
  
        EXEC sp_executesql @SQL, N'@Version_ID INT, @NewParentID UNIQUEIDENTIFIER, @NewParentCode NVARCHAR(250) OUTPUT', @Version_ID, @NewParentID, @NewParentCode OUTPUT;  
  
        IF @NewParentCode IS NULL  
        BEGIN  
            RAISERROR('MDSERR300041|The provided parent ID is not valid.', 16, 1);  
            RETURN;  
        END  
  
    END  
  
    IF @LevelType = @ForeignType_DBA  
    BEGIN  
        -- Simple case for basic one-to-many relationship, just overwrite the existing member attribute with the new parent (ignore old parent)  
        SET @SaveMode = @SaveMode_Update;  
  
        INSERT INTO @Members(RowID, MemberMUID)  
        SELECT   
             CONVERT(INT, ROW_NUMBER() OVER(ORDER BY (SELECT NULL/*order doesn't matter*/)))  
            ,ChildId  
        FROM @OldParentChildIds  
  
        INSERT INTO @MemberAttributes(MemberRowID, AttributeID, AttributeValue)  
        SELECT  
             RowID  
            ,@ParentAttribute_ID  
            ,@NewParentCode  
        FROM @Members  
  
    END ELSE  
    BEGIN  
        -- M2M level, need to change the mapping entity  
        DECLARE   
             @MappingViewName           SYSNAME = mdm.udfViewNameGet(@Model_ID, @Entity_ID, @MemberType_Leaf, 0, 0)  
            ,@CodeGenEnabled            BIT = CASE WHEN EXISTS(SELECT 1 FROM mdm.tblCodeGenInfo cg WHERE EntityId = @Entity_ID) THEN 1 ELSE 0 END  
  
        -- Lookup the mapping entity rows to update or insert  
        CREATE TABLE #MappingRows  
        (  
             RowNumber          INT IDENTITY(1,1) PRIMARY KEY  
            ,MappingMemberId    UNIQUEIDENTIFIER  
            ,MappingMemberCode  NVARCHAR(250) COLLATE DATABASE_DEFAULT  
            ,ChildId            UNIQUEIDENTIFIER  
            ,ChildCode          NVARCHAR(250) COLLATE DATABASE_DEFAULT -- only populated for new mapping table rows  
            ,ParentId           UNIQUEIDENTIFIER  
        )  
        CREATE INDEX #ix_MappingRows_ParentId_ChildId_MappingMemberId ON #MappingRows(ParentId, ChildId, MappingMemberId);  
  
        INSERT INTO #MappingRows (ChildId, ParentId)  
        SELECT   
             ChildId  
            ,NULLIF(ParentId, @GuidEmpty)  
        FROM @OldParentChildIds  
  
        SET @SQL = CONCAT(N'  
-- Look for existing rows to be updated  
UPDATE mr  
SET MappingMemberId = v.MUID  
FROM #MappingRows mr  
INNER JOIN mdm.', QUOTENAME(@MappingViewName), N' v  
ON      mr.ChildId = v.', QUOTENAME(@ManyToManyChildAttributeName + N'.MUID'), N'  
    AND (   mr.ParentId IS NULL AND v.', QUOTENAME(@ParentAttributeName + N'.MUID'), N' IS NULL  
         OR mr.ParentId = v.', QUOTENAME(@ParentAttributeName + N'.MUID'), N')  
WHERE v.Version_ID = @Version_ID');  
        EXEC sp_executesql @SQL, N'@Version_ID INT', @Version_ID;  
  
        -- Throw error for any rows with non-empty parent ID that wasn't found  
        DECLARE   
             @NotFoundChildId UNIQUEIDENTIFIER  
            ,@NotFoundParentId UNIQUEIDENTIFIER  
        SELECT TOP 1   
             @NotFoundChildId = ChildId  
            ,@NotFoundParentId = ParentId  
        FROM #MappingRows   
        WHERE   ParentId IS NOT NULL   
            AND MappingMemberId IS NULL  
  
        IF @NotFoundParentId IS NOT NULL  
        BEGIN  
            DECLARE @ErrorMessage NVARCHAR(MAX) = CONCAT('MDSERR300039|Could not find a mapping relationship between parent {0} and child {1}.|', @NotFoundParentId, N'|', @NotFoundChildId);  
            RAISERROR(@ErrorMessage, 16, 1)  
            RETURN;  
        END  
  
        DECLARE   
             @AddingMembers     BIT = CASE WHEN EXISTS(SELECT 1 FROM #MappingRows WHERE MappingMemberId IS NULL) THEN 1 ELSE 0 END  
            ,@UpdatingMembers   BIT = CASE WHEN EXISTS(SELECT 1 FROM #MappingRows WHERE MappingMemberId IS NOT NULL) THEN 1 ELSE 0 END  
          
        SET @SaveMode = CASE  
            WHEN    @AddingMembers = 1   
                AND @UpdatingMembers = 1 THEN   @SaveMode_Merge  
            WHEN @AddingMembers = 1 THEN        @SaveMode_Create  
            ELSE                                @SaveMode_Update  
            END;  
  
        IF @AddingMembers = 1  
        BEGIN  
            IF @CodeGenEnabled = 0  
                BEGIN  
                UPDATE #MappingRows  
                SET MappingMemberCode = CONVERT(NVARCHAR(250), NEWID())-- use a Guid as the Code for the new member of the mapping entity, to ensure uniqueness  
                WHERE MappingMemberId IS NULL  
            END  
  
            -- Lookup child member Code for the new mapping rows.  
            SELECT @SQL = CONCAT(N'  
UPDATE mr  
SET ChildCode = c.Code  
FROM #MappingRows mr  
INNER JOIN mdm. ', QUOTENAME(e.EntityTable), N' c  
ON      mr.ChildId = c.MUID  
    AND c.Version_ID = @Version_ID  
WHERE mr.MappingMemberId IS NULL -- new row  
            ')  
            FROM mdm.tblEntity e  
            INNER JOIN mdm.tblAttribute a  
            ON e.ID = a.DomainEntity_ID  
            WHERE a.ID = @ManyToManyChildAttribute_ID;  
              
            EXEC sp_executesql @SQL, N'@Version_ID INT', @Version_ID;  
  
            IF EXISTS(SELECT 1 FROM #MappingRows   
                      WHERE MappingMemberId IS NULL  
                        AND ChildCode IS NULL)  
            BEGIN  
                RAISERROR('MDSERR300042|The provided child ID is not valid.', 16, 1);  
                RETURN;  
            END  
  
            INSERT INTO @MemberAttributes(MemberRowID, AttributeID, AttributeValue)  
            SELECT  
                 RowNumber  
                ,@ManyToManyChildAttribute_ID  
                ,ChildCode  
            FROM #MappingRows  
            WHERE MappingMemberId IS NULL  
        END  
  
  
        INSERT INTO @Members(RowID, MemberMUID, MemberCode)  
        SELECT   
             RowNumber  
            ,MappingMemberId  
            ,MappingMemberCode  
        FROM #MappingRows  
  
        INSERT INTO @MemberAttributes(MemberRowID, AttributeID, AttributeValue)  
        SELECT  
             RowNumber  
            ,@ParentAttribute_ID  
            ,@NewParentCode  
        FROM #MappingRows  
  
    END  
  
    EXEC mdm.udpEntityMembersSave  
         @User_ID = @User_ID  
        ,@Model_ID = @Model_ID  
        ,@Entity_ID = @Entity_ID  
        ,@Version_ID = @Version_ID  
        ,@MemberType_ID = @MemberType_Leaf  
        ,@Members = @Members  
        ,@MemberAttributes = @MemberAttributes  
        ,@SaveMode = @SaveMode  
        ,@TransactionBehavior = @TransactionBehavior_AllOrNothingByBatch -- If any of the given member changes has an error, ignore all changes to all members (not just those with errors) in this batch. I.e, abort the whole batch if any errors are found.  
        ,@LogFlag = 1  
        ,@DoInheritanceRuleCheck = 1  
        ,@CorrelationID = @CorrelationID  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpDerivedHierarchySave]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
--Create derived hierarchy  
exec mdm.udpDerivedHierarchySave @User_ID = 1, @Model_ID = 5, @Name = 'DHTest', @EditMode = 0;  
  
--Update  
exec mdm.udpDerivedHierarchySave @User_ID = 1, @Model_ID = 5, @ID = 10, @Name = 'NewName', @EditMode = 1;  
select * from mdm.tblDerivedHierarchy  
*/  
CREATE PROCEDURE [mdm].[udpDerivedHierarchySave]  
(  
    @User_ID                INT,  
    @Model_ID               INT, -- caller should validate  
    @Version_ID             INT = NULL, -- used for audit info. When NULL, the highest value for the model will be used  
    @MUID                   UNIQUEIDENTIFIER = NULL,  
    @Name                   NVARCHAR(50) = NULL,  
    @AnchorNullRecursions   BIT = 1,  
    @EditMode               TINYINT = 0, --0: Create, 1: Update, 4: Clone, defaults to Create  
    @Return_ID	            INT = NULL OUTPUT,  
    @Return_MUID            UNIQUEIDENTIFIER = NULL OUTPUT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON  
  
    DECLARE   
            @GuidEmpty  UNIQUEIDENTIFIER = CAST(0x0 AS UNIQUEIDENTIFIER),  
            @ExistingDerivedHierarchy_MUID  UNIQUEIDENTIFIER = NULL,  
            @ExistingDerivedHierarchy_ID    INT = NULL,  
            @ExistingDerivedHierarchy_Name  NVARCHAR(MAX),  
            @ExistingDerivedHierarchy_AnchorNullRecursions BIT,  
            @EditMode_Create                TINYINT = 0,  
            @EditMode_Update                TINYINT = 1,  
            @EditMode_Clone                 TINYINT = 4;  
      
    SELECT  @Model_ID = NULLIF(@Model_ID, 0),  
            @MUID = NULLIF(@MUID, @GuidEmpty),  
            @Name = NULLIF(LTRIM(RTRIM(@Name)), N'');  
  
    SELECT @Return_ID = NULL, @Return_MUID = NULL;  
  
    --Test for invalid EditMode  
    IF @EditMode IS NULL OR @EditMode NOT IN (@EditMode_Create, @EditMode_Update, @EditMode_Clone)  
    BEGIN  
        RAISERROR('MDSERR100010|The Parameters are not valid.', 16, 1);  
        RETURN;  
    END; --if  
  
      
    --If we are in the Update or Clone mode get the missing pieces of the identifier  
    IF @EditMode IN (@EditMode_Update, @EditMode_Clone)  
    BEGIN  
        --Only use the name if the MUID is not available. This is important because we don't want  
        --to look up by name if the name is what the user is trying to update.  
        IF @MUID IS NULL  
        BEGIN  
            SELECT TOP 1  
                @ExistingDerivedHierarchy_ID = ID,  
                @ExistingDerivedHierarchy_MUID = MUID,  
                @ExistingDerivedHierarchy_Name = Name,  
                @ExistingDerivedHierarchy_AnchorNullRecursions = AnchorNullRecursions  
            FROM mdm.tblDerivedHierarchy   
            WHERE   
                Name = @Name AND  
                Model_ID = @Model_ID;  
        END  
        --Use the derived hierarchy ID and MUID to look up the full identifier  
        ELSE  
        BEGIN  
            SELECT  
                @ExistingDerivedHierarchy_ID =  ID,   
                @ExistingDerivedHierarchy_MUID = MUID,  
                @ExistingDerivedHierarchy_Name = Name,  
                @ExistingDerivedHierarchy_AnchorNullRecursions = AnchorNullRecursions  
            FROM mdm.tblDerivedHierarchy   
            WHERE  
                MUID = @MUID AND  
                Model_ID = @Model_ID;  
        END  
  
        --If we are in the Clone mode we need to figure out whether we are creating or updating a derived hierarchy  
        IF @EditMode = @EditMode_Clone  
        BEGIN  
            --If there is no existing derived hierarchy then set the edit mode to Create  
            IF @ExistingDerivedHierarchy_MUID IS NULL AND @ExistingDerivedHierarchy_ID IS NULL  
            BEGIN  
                SET @EditMode = @EditMode_Create;  
            END  
            --If there is an existing derived hierarchy then set the edit mode to Update  
            ELSE  
            BEGIN  
                SET @EditMode = @EditMode_Update;  
                SET @MUID = @ExistingDerivedHierarchy_MUID;  
            END  
        END  
        --If we are in Update mode and could not find a matching existing derived hierarchy we need to raise an error and quit now  
        ELSE IF @EditMode = @EditMode_Update  
        BEGIN  
  
            IF (@AnchorNullRecursions = 0)  
            BEGIN  
                If (EXISTS (SELECT 1 FROM mdm.tblSecurityRoleAccessMember WHERE DerivedHierarchy_ID = @ExistingDerivedHierarchy_ID))  
                BEGIN    
                    RAISERROR('MDSERR200112|Cannot un-anchor null recursions on the derived hierarchy. The hierarchy has member security permissions assigned.', 16, 1);  
                    RETURN;  
                END   
            END  
  
            IF @ExistingDerivedHierarchy_ID IS NULL OR @ExistingDerivedHierarchy_MUID IS NULL  
            BEGIN  
                --On error, return NULL results  
                SELECT @Return_ID = NULL, @Return_MUID = NULL;  
                RAISERROR('MDSERR110007|The ID is not valid.', 16, 1);  
                RETURN;  
            END  
            ELSE  
            BEGIN  
                SET @MUID = @ExistingDerivedHierarchy_MUID;  
            END  
        END  
    END  
  
    --If the edit mode is Create. This code also needs to execute if the user sent in EditMode clone which ended up becoming Create (hence the IF instead of ELSE IF)  
    IF @EditMode = @EditMode_Create  
    BEGIN  
        --If MUID is not null then we need to ensure it does not already exist (since this is a create)  
        IF @MUID IS NOT NULL AND EXISTS(SELECT 1 FROM mdm.tblDerivedHierarchy WHERE MUID = @MUID)  
        BEGIN  
            --On error, return NULL results  
            SELECT @Return_ID = NULL, @Return_MUID = NULL;  
            RAISERROR('MDSERR110007|The ID is not valid.', 16, 1);  
            RETURN;  
        END  
    END  
  
      
    --Check the name of the derived hierarchy for duplicates  
    IF EXISTS   
    (  
        SELECT 1   
        FROM mdm.tblDerivedHierarchy   
        WHERE   
            @Name = Name AND   
            (@MUID IS NULL OR MUID <> @MUID) AND  
            Model_ID = @Model_ID  
    )  
    BEGIN  
        --On error, return NULL results  
        SELECT @Return_ID = NULL, @Return_MUID = NULL;  
        RAISERROR('MDSERR110003|The name already exists. Type a different name.', 16, 1);  
        RETURN;  
    END  
  
    BEGIN TRY  
  
        IF @Version_ID IS NULL  
        BEGIN  
            --Get the Latest Version  
            SET @Version_ID = (SELECT MAX(ID) FROM mdm.tblModelVersion WHERE Model_ID = @Model_ID)  
        END  
  
        IF @EditMode = @EditMode_Update  
        --Update  
        BEGIN  
            --Don't do anything if nothing is being updated (such as in a clone scenario).   
            --The cost of updating a derived hierarchy (regenerate all model views) is just too high  
            --TODO: Figure out if we can get away with regenerating fewer views  
            IF @ExistingDerivedHierarchy_Name <> @Name OR @ExistingDerivedHierarchy_AnchorNullRecursions <> @AnchorNullRecursions  
            BEGIN  
                UPDATE mdm.tblDerivedHierarchy              
                SET  
                    Name = ISNULL(@Name,Name),  
                    AnchorNullRecursions = @AnchorNullRecursions,  
                    LastChgDTM = GETUTCDATE(),  
                    LastChgUserID = @User_ID,  
                    LastChgVersionID = @Version_ID  
                WHERE  
                    ID = @ExistingDerivedHierarchy_ID;                   
  
                --Re Gen All Views  
                EXEC mdm.udpCreateViews @Model_ID = @Model_ID, @CorrelationID = @CorrelationID;  
  
                -- Regenerate subscription views if there are any  
                EXEC mdm.udpCreateAllSubscriptionViews @Model_ID = @Model_ID, @CorrelationID = @CorrelationID;  
            END  
  
            --Populate output parameters  
            SELECT @Return_ID = @ExistingDerivedHierarchy_ID;  
            SELECT @Return_MUID = @ExistingDerivedHierarchy_MUID;  
        END ELSE  
        --Create  
        BEGIN  
            --Accept an explicit MUID (for clone operations) or generate a new one  
            SET @Return_MUID = COALESCE(@MUID, NEWID());  
  
            INSERT INTO mdm.tblDerivedHierarchy   
            (  
                [Model_ID]  
                ,[Name]  
                ,[AnchorNullRecursions]  
                ,[MUID]  
                ,[EnterDTM]  
                ,[EnterUserID]  
                ,[EnterVersionID]  
                ,[LastChgDTM]  
                ,[LastChgUserID]  
                ,[LastChgVersionID]  
            )  
            SELECT   
                @Model_ID,  
                ISNULL(@Name,N''),  
                @AnchorNullRecursions,  
                @Return_MUID,  
                GETUTCDATE(),  
                @User_ID,  
                @Version_ID,  
                GETUTCDATE(),  
                @User_ID,  
                @Version_ID  
  
            SELECT @Return_ID = SCOPE_IDENTITY()  
        END  
  
    END TRY  
  
    --Compensate as necessary  
    BEGIN CATCH  
  
        -- Get error info.  
        DECLARE  
            @ErrorMessage NVARCHAR(4000),  
            @ErrorSeverity INT,  
            @ErrorState INT,  
            @ErrorNumber INT,  
            @ErrorLine INT,  
            @ErrorProcedure NVARCHAR(126);  
        EXEC mdm.udpGetErrorInfo  
            @ErrorMessage = @ErrorMessage OUTPUT,  
            @ErrorSeverity = @ErrorSeverity OUTPUT,  
            @ErrorState = @ErrorState OUTPUT,  
            @ErrorNumber = @ErrorNumber OUTPUT,  
            @ErrorLine = @ErrorLine OUTPUT,  
            @ErrorProcedure = @ErrorProcedure OUTPUT  
  
        SET @ErrorMessage = CONCAT(@ErrorMessage, N', @ErrorNumber = ', @ErrorNumber, N', @ErrorProcedure = "', @ErrorProcedure, N'", line ', @ErrorLine);  
  
        RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);  
  
        --On error, return NULL results  
        SELECT @Return_ID = NULL, @Return_MUID = NULL;  
        RETURN;  
  
    END CATCH;  
  
    -- Send the message  
	EXEC mdm.udpPerformanceQueueSave;  
  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpEntityDelete]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    EXEC mdm.udpEntityDelete 1;  
    select * from mdm.tblEntity;  
*/  
CREATE PROCEDURE [mdm].[udpEntityDelete]  
(  
    @Entity_ID      INT,  
    @CreateViewsInd BIT = NULL, --1=Create,0=DoNot Create. Typically only set to 0 when deleting the parent model.  
    @CorrelationID  UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON;  
  
    --Start transaction, being careful to check if we are nested  
    DECLARE @TranCounter INT;  
    SET @TranCounter = @@TRANCOUNT;  
    IF @TranCounter > 0 SAVE TRANSACTION TX;  
    ELSE BEGIN TRANSACTION;  
  
    BEGIN TRY  
  
        DECLARE  
             @SQL                       NVARCHAR(MAX)  
            ,@Model_ID                  INT  
            ,@Entity_MUID               UNIQUEIDENTIFIER  
            ,@TransactionTableName      SYSNAME  
            ,@ValidationLogTableName    SYSNAME  
            ,@ChangesetTableName        SYSNAME  
  
            ,@MemberType_Leaf           TINYINT = 1  
            ,@MemberType_Consolidated   TINYINT = 2  
            ,@MemberType_Collection     TINYINT = 3  
  
            ,@AttributeType_File        TINYINT = 4;  
  
        SET @CreateViewsInd = ISNULL(@CreateViewsInd, 1);  
  
        -- Remove any sync relationships for which the deleted entity is source.  
        DECLARE  
             @TargetVersion_ID  INT  
            ,@TargetEntity_ID   INT  
        CREATE TABLE #SyncRelationshipsToDelete  
        (  
             TargetVersion_ID   INT  
            ,TargetEntity_ID    INT  
        );  
        CREATE UNIQUE CLUSTERED INDEX #pk_SyncRelationshipsToDelete ON #SyncRelationshipsToDelete(TargetVersion_ID, TargetEntity_ID);  
        INSERT INTO #SyncRelationshipsToDelete  
        (  
             TargetVersion_ID  
            ,TargetEntity_ID  
        )  
        SELECT  
             sr.TargetVersion_ID  
            ,sr.TargetEntity_ID  
        FROM mdm.tblSyncRelationship sr  
        WHERE SourceEntity_ID = @Entity_ID;  
  
        WHILE EXISTS(SELECT 1 FROM #SyncRelationshipsToDelete)  
        BEGIN  
            SELECT TOP 1  
                 @TargetVersion_ID  = TargetVersion_ID  
                ,@TargetEntity_ID   = TargetEntity_ID  
            FROM #SyncRelationshipsToDelete  
  
            EXEC mdm.udpSyncRelationshipDelete  
                 @User_ID = 0 -- Unused when @IsVersionOrEntityDelete = 1  
                ,@TargetVersion_ID = @TargetVersion_ID  
                ,@TargetEntity_ID = @TargetEntity_ID  
                ,@IsVersionOrEntityDelete = 1  
                ,@CorrelationID = @CorrelationID  
  
            DELETE FROM #SyncRelationshipsToDelete  
            WHERE   TargetVersion_ID  = @TargetVersion_ID  
                AND TargetEntity_ID = @TargetEntity_ID  
        END;  
  
        -- Remove any sync relationships for which deleted entity is target.  
        -- Can directly delete from tblSyncRelationship. No need to call udpSyncRelationshipDelete since the applicable EN table and tblAttribute rows are being deleted.  
        DELETE mdm.tblSyncRelationship  
        WHERE TargetEntity_ID = @Entity_ID  
  
        -- Get list of Files that are referenced by File attributes values in the entity. These will be deleted after the entity tables are deleted.  
        CREATE TABLE #FileIDsToDelete  
        (  
            ID INT NOT NULL  
        )  
        -- Get the IDs of the Files referenced by the members being purged  
        SET @SQL = mdm.udfFileIDReferencesGetSQL(@Entity_ID, NULL, NULL, 0);  
        IF LEN(@SQL) > 0  
        BEGIN  
            SET @SQL = CONCAT(N'INSERT INTO #FileIDsToDelete(ID)  
', @SQL)  
            --PRINT @SQL  
            EXEC sp_executesql @SQL;  
        END  
  
        SELECT  
            @Model_ID = Model_ID,  
            @Entity_MUID = MUID  
        FROM mdm.tblEntity  
        WHERE ID = @Entity_ID;  
  
        --Get the transaction and annotation table names  
        SET @TransactionTableName = mdm.udfGetTransactionTableName(@Model_ID);  
        SET @ValidationLogTableName = mdm.udfGetValidationLogTableName(@Model_ID);  
        SET @ChangesetTableName = CONCAT(N'tbl_', @Model_ID, N'_CS');  
  
  
        --Delete the views  
        EXEC mdm.udpEntityStagingDeleteErrorDetailViews @Entity_ID;  
        EXEC mdm.udpDeleteViews @Model_ID, @Entity_ID, NULL;  
  
        --Delete all the entity related data  
        DECLARE    @Object_ID    INT;  
        SET @Object_ID = mdm.udfSecurityObjectIDGetByCode(N'DIMENT');  
  
  
        --Delete the subscription views associated with the entity  
        EXEC mdm.udpSubscriptionViewsDelete  
            @Model_ID               = NULL,  
            @Version_ID             = NULL,  
            @Entity_ID                = @Entity_ID,  
            @DerivedHierarchy_ID    = NULL;  
  
        --Delete the security maps  
        --EXEC mdm.udpHierarchyMapDelete @Entity_ID = @Entity_ID;  
        --DELETE hmq  
        --FROM mdm.tblHierarchyMapQueue hmq  
        --INNER JOIN mdm.tblHierarchy h  
        --    ON h.ID = hmq.Hierarchy_ID  
        --    AND hmq.HierarchyType_ID = 0 -- explicit hierarchies only  
        --    AND h.Entity_ID =@Entity_ID  
  
        DELETE FROM mdm.tblSecurityRoleAccessMember WHERE Entity_ID =@Entity_ID;  
  
        DECLARE @TempTable TABLE (  
             RowNumber      INT IDENTITY (1, 1) PRIMARY KEY CLUSTERED NOT NULL  
            ,Attribute_ID   INT NOT NULL);  
  
        --Delete the transaction table. The transaction annotation table will be cascade deleted.  
        SET @SQL = CONCAT(N'  
            DELETE [mdm].', QUOTENAME(@TransactionTableName), N'  
            WHERE Entity_ID = @Entity_ID;');  
        EXEC sp_executesql @SQL, N'@Entity_ID INT', @Entity_ID;  
  
        --Delete the related validation log  
        SET @SQL = CONCAT(N'  
            DELETE [mdm].', QUOTENAME(@ValidationLogTableName), N'  
            WHERE Entity_ID = @Entity_ID;');  
        EXEC sp_executesql @SQL, N'@Entity_ID INT', @Entity_ID;  
  
        --Delete the related changesets  
        SET @SQL = CONCAT(N'  
            DELETE [mdm].', QUOTENAME(@ChangesetTableName), N'  
            WHERE Entity_ID = @Entity_ID;');  
        EXEC sp_executesql @SQL, N'@Entity_ID INT', @Entity_ID;  
  
        --Get all related Domain Entity into temp table  
        INSERT INTO @TempTable  
        SELECT ID  
        FROM mdm.tblAttribute  
        WHERE   DomainEntity_ID = @Entity_ID  
            AND Entity_ID <> @Entity_ID -- ignore self-referencing attribute;  
  
        DECLARE  
             @TempAttribute_ID  INT  
            ,@Counter           INT = 1  
            ,@MaxCounter        INT = (SELECT MAX(RowNumber) FROM @TempTable);  
  
        --Delete all related data for the Entity being referenced by the Domain Entity records  
        -- and delete the domain Entity attribute record  
        WHILE @Counter <= @MaxCounter  
        BEGIN  
            SELECT  
                 @TempAttribute_ID = Attribute_ID  
            FROM @TempTable  
            WHERE [RowNumber] = @Counter ;  
  
            EXEC mdm.udpAttributeDelete @Attribute_ID = @TempAttribute_ID, @CreateViewsInd = @CreateViewsInd  
  
            SET @Counter += 1  
  
        END; --while  
  
        --Delete related meta data tables referencing the Entity including staging tables.  
        EXEC mdm.udpEntityMetaTablesDelete @Entity_ID;  
  
        DECLARE @DeletedChildObjects TABLE  
        (  
             MUID       UNIQUEIDENTIFIER PRIMARY KEY  
            ,Object_Type NVARCHAR(50)  
        );  
  
        --Delete indexes on the Entity  
        DELETE FROM mdm.tblIndex  
        OUTPUT deleted.MUID, N'Index'  
        INTO @DeletedChildObjects  
        WHERE Entity_ID = @Entity_ID;  
  
        --Delete the hierarchy referencing the Entity  
        DELETE FROM mdm.tblHierarchy  
        OUTPUT deleted.MUID, N'Hierarchy'  
        INTO @DeletedChildObjects  
        WHERE Entity_ID = @Entity_ID;  
  
        --Delete the tblAttributeGroupDetail records before we can delete  
        --the tblAttributeGroup records  
        DELETE FROM mdm.tblAttributeGroupDetail  
        FROM mdm.tblAttributeGroupDetail gt  
                INNER JOIN mdm.tblAttributeGroup g  
                 ON gt.AttributeGroup_ID = g.ID  
                WHERE g.Entity_ID = @Entity_ID;  
  
        --Delete the tblAttributeGroup records that reference the Entity  
        DELETE FROM mdm.tblAttributeGroup  
        OUTPUT deleted.MUID, N'AttributeGroup'  
        INTO @DeletedChildObjects  
        WHERE Entity_ID = @Entity_ID;  
  
        --Delete the security around all the attributes in this entity  
        DECLARE @Att_Object_ID INT = mdm.udfSecurityObjectIDGetByCode(N'DIMATT');  
        DELETE sra  
        FROM mdm.tblSecurityRoleAccess sra  
        INNER JOIN mdm.tblAttribute att  
        ON sra.Object_ID = @Att_Object_ID AND  
           sra.Securable_ID = att.ID AND  
           att.Entity_ID = @Entity_ID;  
  
        --Delete the attribute for the entity  
        DELETE FROM mdm.tblAttribute  
        OUTPUT deleted.MUID, N'Attribute'  
        INTO @DeletedChildObjects  
        WHERE Entity_ID = @Entity_ID;  
  
        --Delete Entity Based Staging Stored Procedures.  
        --Delete all types (0). Delete Leaf staging SProc. Then, if the entity supports hierarchies then delete Parent and Relation staging SProcs.  
        Exec mdm.udpEntityStagingDeleteStoredProcedures @Entity_ID, 0  
  
        --Delete the record(s) for the entity from staging batch table.  
        DELETE FROM mdm.tblStgBatch WHERE Entity_ID = @Entity_ID;  
  
        --Delete code generation information  
        DELETE FROM mdm.tblCodeGenInfo WHERE EntityId = @Entity_ID;  
  
        DELETE FROM mdm.tblEntity WHERE ID = @Entity_ID;  
        EXEC mdm.udpSecurityPrivilegesDelete NULL, NULL, @Object_ID, @Entity_ID;  
  
        --Delete associated user-defined metadata if the entity doesn't belong to a system model (metadata).  
        IF EXISTS(SELECT 1 FROM mdm.tblModel WHERE ID = @Model_ID) BEGIN  
            DECLARE  
                 @DeletedMuid UNIQUEIDENTIFIER  
                ,@Object_Type NVARCHAR(50);  
  
            -- Delete the child object metadata.  
            WHILE EXISTS (SELECT 1 FROM @DeletedChildObjects)  
            BEGIN  
                SELECT TOP 1  
                     @DeletedMuid = MUID  
                    ,@Object_Type = Object_Type  
                FROM @DeletedChildObjects;  
  
                DELETE FROM @DeletedChildObjects WHERE MUID = @DeletedMuid;  
            END;  
        END; -- if  
  
        -- Delete orphaned Files that were referenced by the entity  
        IF EXISTS (SELECT 1 FROM #FileIDsToDelete)  
        BEGIN  
  
            DECLARE @File_ID mdm.IdList;  
            INSERT INTO @File_ID  
            SELECT ID  
            FROM #FileIDsToDelete  
  
            EXEC mdm.udpFilesDelete @File_ID = @File_ID, @CorrelationID = @CorrelationID  
        END  
  
        --Commit only if we are not nested  
        IF @TranCounter = 0 COMMIT TRANSACTION;  
  
        -- Send the message  
	    EXEC mdm.udpPerformanceQueueSave;  
  
        RETURN(0);  
  
    END TRY  
    --Compensate as necessary  
    BEGIN CATCH  
  
        -- Get error info.  
        DECLARE  
            @ErrorMessage NVARCHAR(4000),  
            @ErrorSeverity INT,  
            @ErrorState INT,  
            @ErrorNumber INT,  
            @ErrorLine INT,  
            @ErrorProcedure NVARCHAR(126);  
        EXEC mdm.udpGetErrorInfo  
            @ErrorMessage = @ErrorMessage OUTPUT,  
            @ErrorSeverity = @ErrorSeverity OUTPUT,  
            @ErrorState = @ErrorState OUTPUT,  
            @ErrorNumber = @ErrorNumber OUTPUT,  
            @ErrorLine = @ErrorLine OUTPUT,  
            @ErrorProcedure = @ErrorProcedure OUTPUT  
  
        SET @ErrorMessage = CONCAT(@ErrorMessage, N', @ErrorNumber = ', @ErrorNumber, N', @ErrorProcedure = "', @ErrorProcedure, N'", line ', @ErrorLine);  
  
        IF @TranCounter = 0 ROLLBACK TRANSACTION;  
        ELSE IF XACT_STATE() <> -1 ROLLBACK TRANSACTION TX;  
  
        RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);  
  
        --On error, return NULL results  
        --SELECT @Return_ID = NULL;  
        RETURN(1);  
  
    END CATCH;  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpEntityGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpEntityGet]  
(  
     @User_ID       INT  
  
    ,@Model_MUID    UNIQUEIDENTIFIER = NULL  
    ,@Model_Name    NVARCHAR(50) = NULL  
    ,@Model_ID      INT = NULL -- set internally only  
  
    ,@Entity_MUID   UNIQUEIDENTIFIER = NULL  
    ,@Entity_Name   NVARCHAR(50) = NULL  
  
    -- Only used when getting details  
    ,@Index_MUID    UNIQUEIDENTIFIER = NULL  
    ,@Index_Name    NVARCHAR(50) = NULL  
  
    ,@HierarchyTable mdm.Identifier READONLY  
  
    ,@MemberType_ID TINYINT = NULL  
  
    ,@AttributeGroup_MUID   UNIQUEIDENTIFIER = NULL  
    ,@AttributeGroup_Name   NVARCHAR(50) = NULL  
  
    ,@Attribute_MUID   UNIQUEIDENTIFIER = NULL  
    ,@Attribute_Name   NVARCHAR(100) = NULL  
  
    ,@ResultOption TINYINT -- None = 0, Identifiers = 1, Details = 2.   
   
    ,@IncludeParentIdentifiers  BIT = 1 -- Return results sets for parent Model and Entity identifiers. Set to 0 when getting attributes as part of a parent object (because the parent identifiers will already have been looked up).  
    ,@Debug                     BIT = 0  
    ,@CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
  
    SET NOCOUNT ON  
  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), ': begin udpEntityGet')  
    DECLARE   
         @ResultOption_Identifiers  TINYINT = 1  
        ,@ResultOption_Details      TINYINT = 2  
  
    -- Get model ID  
    IF @Model_ID IS NULL -- If the ID was already provided, don't bother looking it up again  
        AND (@Model_Name IS NOT NULL OR @Model_MUID IS NOT NULL)  
    BEGIN  
        SELECT   
             @Model_ID = ID  
            ,@Model_MUID = MUID  
            ,@Model_Name = Name  
        FROM mdm.tblModel  
        WHERE   MUID = ISNULL(@Model_MUID, MUID)  
            AND Name = ISNULL(@Model_Name, Name)  
  
        SET @Model_ID = COALESCE(@Model_ID, 0)  
    END  
  
    -- Get entity ID  
    DECLARE @Entity_ID INT;  
    IF @Entity_Name IS NOT NULL OR @Entity_MUID IS NOT NULL  
    BEGIN  
        SELECT  
             @Model_ID = Model_ID  
            ,@Entity_ID = ID  
            ,@Entity_MUID = MUID  
            ,@Entity_Name = Name  
        FROM mdm.tblEntity  
        WHERE   MUID = ISNULL(@Entity_MUID, MUID)  
            AND Name = ISNULL(@Entity_Name, Name)  
            AND Model_ID = ISNULL(@Model_ID, Model_ID) -- If a model filter is specified, use it  
  
        SET @Entity_ID = COALESCE(@Entity_ID, 0)  
    END  
  
    DECLARE @SelectedEntity TABLE   
    (  
         ID                 INT PRIMARY KEY  
        ,Model_ID           INT  
        ,Privilege_ID       TINYINT  
        ,AccessPermission   TINYINT  
        ,IsSyncTarget       BIT  
    )  
  
    INSERT INTO @SelectedEntity  
    SELECT  
         e.ID  
        ,e.Model_ID  
        ,acl.Privilege_ID  
        ,acl.AccessPermission  
        ,acl.IsSyncTarget  
    FROM mdm.tblEntity e  
    INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_ENTITY acl  
    ON e.ID = acl.ID  
    WHERE   acl.User_ID = @User_ID  
        AND e.Model_ID = ISNULL(@Model_ID, e.Model_ID)  
        AND e.ID = ISNULL(@Entity_ID, e.ID)  
        AND acl.Privilege_ID <> 1 -- Deny  
  
    IF @IncludeParentIdentifiers = 1  
    BEGIN  
        -- Return model Identifier(s)  
        IF @Model_ID IS NOT NULL  
        BEGIN  
            IF @Model_Name IS NULL OR @Model_MUID IS NULL  
            BEGIN  
                SELECT   
                     @Model_MUID = MUID  
                    ,@Model_Name = Name  
                FROM mdm.tblModel  
                WHERE ID = @Model_ID  
            END  
  
            -- A single model was specified, and its info has already been looked up, so simply return it  
            SELECT   
                 @Model_MUID    AS Model_MUID  
                ,@Model_Name    AS Model_Name  
                ,@Model_ID      AS Model_ID  
        END ELSE  
        BEGIN  
            SELECT DISTINCT  
                 m.MUID AS Model_MUID  
                ,m.Name AS Model_Name  
                ,m.ID   AS Model_ID  
            FROM @SelectedEntity e  
            INNER JOIN mdm.tblModel m  
            ON e.Model_ID = m.ID  
        END  
    END  
  
    SELECT  
         e.MUID AS Entity_MUID  
        ,e.Name AS Entity_Name  
        ,e.ID   AS Entity_ID  
        ,se.Privilege_ID  
        ,se.AccessPermission  
  
        ,se.Model_ID  
        ,e.CodeGenerationSeed  
        ,e.DataCompression  
        ,e.Description  
        ,e.IsBase  
        ,CONVERT(BIT, e.IsCodeGenerationEnabled) AS IsCodeGenerationEnabled  
        ,CONVERT(BIT, CASE WHEN e.CollectionTable IS NULL THEN 0 ELSE 1 END) AS IsCollectionEnabled  
        ,CONVERT(BIT, CASE WHEN e.HierarchyTable IS NULL THEN 0 ELSE 1 END) AS IsHierarchyEnabled  
        ,se.IsSyncTarget  
        ,e.RequireApproval  
        ,e.StagingBase  
        ,e.TransactionLogType  
  
        ,e.EnteredUser_DTM  
        ,e.EnteredUser_MUID  
        ,e.EnteredUser_UserName  
        ,e.EnteredUser_ID  
        ,e.LastChgUser_DTM  
        ,e.LastChgUser_MUID  
        ,e.LastChgUser_UserName  
        ,e.LastChgUser_ID  
    FROM @SelectedEntity se  
    INNER JOIN mdm.viw_SYSTEM_SCHEMA_ENTITY e  
    ON se.ID = e.Entity_ID  
    ORDER BY e.Model_ID, e.Name   
  
    IF @ResultOption = @ResultOption_Details  
    BEGIN  
        EXEC mdm.udpExplicitHierarchyGet  
             @User_ID = @User_ID  
            ,@Model_ID = @Model_ID  
            ,@Model_MUID = @Model_MUID  
            ,@Model_Name = @Model_Name  
            ,@Entity_ID = @Entity_ID  
            ,@Entity_MUID = @Entity_MUID  
            ,@Entity_Name = @Entity_Name  
            ,@HierarchyTable = @HierarchyTable  
            ,@IncludeParentIdentifiers = 0 -- parent Ids already returned  
            ,@Debug = @Debug  
            ,@CorrelationID = @CorrelationID  
  
        EXEC mdm.udpMemberTypeGet  
             @User_ID = @User_ID  
            ,@Model_MUID = @Model_MUID  
            ,@Model_Name = @Model_Name  
            ,@Model_ID = @Model_ID  
            ,@Entity_ID = @Entity_ID  
            ,@Entity_MUID = @Entity_MUID  
            ,@Entity_Name = @Entity_Name  
            ,@MemberType_ID = @MemberType_ID  
            ,@AttributeGroup_MUID = @AttributeGroup_MUID  
            ,@AttributeGroup_Name = @AttributeGroup_Name  
            ,@Attribute_MUID = @Attribute_MUID  
            ,@Attribute_Name = @Attribute_Name  
            ,@ResultOption = @ResultOption_Details  
            ,@IncludeParentIdentifiers = 0 -- parent Ids already returned  
            ,@OmitAttributes = 1 -- Attributes will be returned by a subsequent call  
            ,@Debug = @Debug  
            ,@CorrelationID = @CorrelationID  
  
        EXEC mdm.udpIndexGet  
             @User_ID = @User_ID  
            ,@Model_ID = @Model_ID  
            ,@Model_MUID = @Model_MUID  
            ,@Model_Name = @Model_Name  
            ,@Entity_ID = @Entity_ID  
            ,@Entity_MUID = @Entity_MUID  
            ,@Entity_Name = @Entity_Name  
            ,@Index_MUID = @Index_MUID  
            ,@Index_Name = @Index_Name  
            ,@ResultOption = @ResultOption_Details  
            ,@IncludeParentIdentifiers = 0 -- parent Ids already returned  
            ,@OmitAttributes = 1 -- Attributes will be returned by a subsequent call  
            ,@Debug = @Debug  
            ,@CorrelationID = @CorrelationID  
  
        EXEC mdm.udpAttributeGet  
             @User_ID = @User_ID  
            ,@Model_ID = @Model_ID  
            ,@Model_MUID = @Model_MUID  
            ,@Model_Name = @Model_Name  
            ,@Entity_ID = @Entity_ID  
            ,@Entity_MUID = @Entity_MUID  
            ,@Entity_Name = @Entity_Name  
            ,@MemberType_ID = @MemberType_ID  
            ,@AttributeGroup_MUID = @AttributeGroup_MUID  
            ,@AttributeGroup_Name = @AttributeGroup_Name  
            ,@Attribute_MUID = @Attribute_MUID  
            ,@Attribute_Name = @Attribute_Name  
            ,@IncludeParentIdentifiers = 0 -- parent Ids already returned  
            ,@Debug = @Debug  
            ,@CorrelationID = @CorrelationID  
    END   
  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), ': end udpEntityGet')  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpEntityHierarchyDelete]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    EXEC mdm.udpEntityHierarchyDelete 1, 4, 15;  
    SELECT * FROM mdm.tblAttribute;  
*/  
CREATE PROCEDURE [mdm].[udpEntityHierarchyDelete]  
(  
    @User_ID      INT,  
    @Hierarchy_ID INT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
AS BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE @Entity_ID INT = (SELECT Entity_ID from mdm.tblHierarchy WHERE ID = @Hierarchy_ID);  
  
    IF @Entity_ID IS NULL  
    BEGIN  
        RETURN  
    END  
    --Start transaction, being careful to check if we are nested  
    DECLARE @TranCounter INT;  
    SET @TranCounter = @@TRANCOUNT;  
    IF @TranCounter > 0 SAVE TRANSACTION TX;  
    ELSE BEGIN TRANSACTION;  
  
    BEGIN TRY  
  
        DECLARE @HierarchyParentTable       SYSNAME,  
                @HierarchyParentSecurityTable   SYSNAME,  
                @HierarchyParentHistoryTable    SYSNAME,  
                @HierarchyParentAnnotationTable SYSNAME,  
                @HierarchyTable             SYSNAME,  
                @HierarchyHistoryTable      SYSNAME,  
                @HierarchyAnnotationTable   SYSNAME,  
                @CollectionMemberTable      SYSNAME,  
                @CollectionMemberHistoryTable   SYSNAME,  
                @StagingConsolidatedTable   SYSNAME,  
                @StagingRelationshipTable   SYSNAME,  
                @StagingBase                NVARCHAR(MAX),  
                @SQL                        NVARCHAR(MAX),  
                @Version_ID                 INT,  
                @ConstraintName             SYSNAME,  
                @TempID                     INT,  
                @TempTableName              SYSNAME,  
                @HierarchyMUID              UNIQUEIDENTIFIER,  
                @Model_ID                   INT,  
                @ConsolidatedAndRelationship    INT = 3,  
                @TransactionTableName       SYSNAME,  
  
                @MemberType_Leaf                    TINYINT = 1,  
                @MemberType_Consolidated            TINYINT = 2,  
                @MemberType_Collection              TINYINT = 3,  
                @MemberType_ParentChild             TINYINT = 4,  
                @MemberType_CollectionParentChild   TINYINT = 5,  
  
                @HierarchyType_Explicit    TINYINT = 0;  
  
        DECLARE    @TableFKConstraints      TABLE  
                (   [ID] [INT] IDENTITY (1, 1) Primary KEY CLUSTERED NOT NULL,  
                    TableName               SYSNAME,  
                    ConstraintName          SYSNAME);  
  
        --Get the latest version  
        SELECT @Version_ID = MAX(mv.ID)  
        FROM mdm.tblModelVersion AS mv  
        INNER JOIN mdm.tblEntity AS e ON (e.Model_ID = mv.Model_ID)  
        WHERE e.ID = @Entity_ID;  
  
        --Get the table name  
        SELECT  
            @HierarchyParentTable = HierarchyParentTable,  
            @HierarchyTable = HierarchyTable,  
            @CollectionMemberTable = CollectionMemberTable,  
            @StagingConsolidatedTable = StagingConsolidatedName,  
            @StagingRelationshipTable = StagingRelationshipName,  
            @StagingBase = StagingBase,  
            @Model_ID = Model_ID  
        FROM mdm.tblEntity  
        WHERE ID = @Entity_ID;  
  
        SELECT @HierarchyParentSecurityTable = CONCAT(@HierarchyParentTable, N'_MS'),  
            @HierarchyParentHistoryTable = CONCAT(@HierarchyParentTable, N'_HS'),  
            @HierarchyParentAnnotationTable = CONCAT(@HierarchyParentTable, N'_AN'),  
            @HierarchyHistoryTable = CONCAT(@HierarchyTable, N'_HS'),  
            @HierarchyAnnotationTable = CONCAT(@HierarchyTable, N'_AN'),  
            @CollectionMemberHistoryTable = CONCAT(@CollectionMemberTable, N'_HS');  
  
        --Get the transaction and annotation table names  
        SET @TransactionTableName = mdm.udfGetTransactionTableName(@Model_ID);  
  
        --delete any transactions and annotations  
        SET @SQL = CONCAT(N'  
            DELETE [mdm].', QUOTENAME(@TransactionTableName), N'  
            WHERE Hierarchy_ID = @Hierarchy_ID;');  
        EXEC sp_executesql @SQL, N'@Hierarchy_ID INT',  @Hierarchy_ID;  
  
        --Get the MUID  
        SELECT @HierarchyMUID = MUID from mdm.tblHierarchy WHERE ID = @Hierarchy_ID;  
  
        --Delete any member security assignments (object security assignments not allowed on explicit hierarchies)  
        DELETE FROM mdm.tblSecurityRoleAccessMember WHERE HierarchyType_ID = @HierarchyType_Explicit AND Hierarchy_ID = @Hierarchy_ID;  
  
  
        --If the entity has collections, then delete the consolidated members from any collections that contain them.  
        IF @CollectionMemberTable IS NOT NULL  
        BEGIN  
            SET @SQL = CONCAT(N'  
  
               DELETE FROM mdm.', QUOTENAME(@CollectionMemberTable), N'  
                WHERE ID IN (  
                    SELECT CMT.ID FROM mdm.', QUOTENAME(@CollectionMemberTable), N' AS CMT  
                    WHERE EXISTS (  
                        SELECT 1 FROM mdm.', QUOTENAME(@HierarchyTable), N' AS HRT  
                        WHERE HRT.Hierarchy_ID = @Hierarchy_ID  
                            AND CMT.ChildType_ID = HRT.ChildType_ID  
                            AND (CMT.ChildType_ID = 2 AND CMT.Child_HP_ID = HRT.Child_HP_ID))  
                    );')  
  
            EXEC sp_executesql @SQL, N'@Hierarchy_ID INT', @Hierarchy_ID;  
  
        END;  
  
        --Check to see if this is the last hierarchy for entity if so delete tables, views, and update mdm.tblEntity and CM table  
        --Per check above we know the hierarchy belongs to the entity.  
        IF (SELECT COUNT(*) FROM mdm.tblHierarchy WHERE Entity_ID = @Entity_ID) = 1  
        BEGIN  
  
                --Drop the FK from the HP - Really only need the one to the MS table but going to drop them all  
                INSERT INTO @TableFKConstraints  
                            SELECT  SCHEMA_NAME(schema_id) + '.[' + OBJECT_NAME(parent_object_id)+ ']',  
                                    s.[name]  
                            FROM sys.foreign_keys s  
                            WHERE referenced_object_id = OBJECT_ID('mdm.' + '[' + @HierarchyParentTable + ']');  
                -- Delete all the constraints first  
                DECLARE @Counter INT = 1 ;  
                DECLARE @MaxCounter INT = (SELECT MAX(ID) FROM @TableFKConstraints);  
                SET @Counter =1;  
                SET @SQL = '';  
                WHILE @Counter <= @MaxCounter  
                BEGIN  
                    SELECT @TempID = ID, @TempTableName = TableName, @ConstraintName = ConstraintName  
                        FROM @TableFKConstraints WHERE ID = @Counter;  
  
                    SET @SQL = CONCAT(@SQL, N'ALTER TABLE ', @TempTableName,  
                                N' DROP CONSTRAINT ', @ConstraintName, N';')  
  
                    SET @Counter = @Counter +1;  
                END  
                EXEC sp_executesql @SQL;  
  
                --Drop tables  
                SET @SQL = CONCAT(N'  
                    DROP TABLE mdm.', QUOTENAME(@HierarchyAnnotationTable), N';  
                    DROP TABLE mdm.', QUOTENAME(@HierarchyHistoryTable), N';  
                    DROP TABLE mdm.', QUOTENAME(@HierarchyTable), N';  
                    DROP TABLE mdm.', QUOTENAME(@HierarchyParentSecurityTable), N';  
                    DROP TABLE mdm.', QUOTENAME(@HierarchyParentAnnotationTable), N';  
                    DROP TABLE mdm.', QUOTENAME(@HierarchyParentHistoryTable), N';  
                    DROP TABLE mdm.', QUOTENAME(@HierarchyParentTable), N';');  
                EXEC sp_executesql @SQL;  
  
                --Update CM table  
                IF @CollectionMemberTable IS NOT NULL  
                BEGIN  
                   SET @SQL = CONCAT(N'  
                    DROP INDEX mdm.', QUOTENAME(@CollectionMemberTable), '.[ix_', @CollectionMemberTable, N'_Version_ID_Child_HP_ID];  
                    ALTER TABLE mdm.', QUOTENAME(@CollectionMemberTable), ' DROP CONSTRAINT [ck_', @CollectionMemberTable, N'_ChildType_ID];  
                    ALTER TABLE mdm.', QUOTENAME(@CollectionMemberTable), ' DROP COLUMN Child_HP_ID;  
                    ALTER TABLE mdm.', QUOTENAME(@CollectionMemberTable), ' ADD CONSTRAINT [ck_', @CollectionMemberTable, N'_ChildType_ID] CHECK ([ChildType_ID]=(1) AND [Child_EN_ID] IS NOT NULL AND [Child_CN_ID] IS NULL OR [ChildType_ID]=(3) AND [Child_CN_ID] IS NOT NULL AND [Child_EN_ID] IS NULL) ;  
                    ALTER TABLE mdm.', QUOTENAME(@CollectionMemberHistoryTable), ' DROP COLUMN Child_HP_ID;');  
  
                    EXEC sp_executesql @SQL;  
                END  
  
                --If @StagingBase is specified, drop entity based staging tables and delete staging Sprocs.  
                IF COALESCE(@StagingBase, N'') <> N'' BEGIN  
  
                    SET @SQL = CONCAT(N'  
                        DROP TABLE stg.', QUOTENAME(@StagingConsolidatedTable), N';  
                        DROP TABLE stg.', QUOTENAME(@StagingRelationshipTable), N';');  
  
                    EXEC sp_executesql @SQL;  
  
                    --Delete Staging Sprocs  
                    Exec mdm.udpEntityStagingDeleteStoredProcedures @Entity_ID, @ConsolidatedAndRelationship -- Drop consolidated and relationship Sprocs.  
  
                END; --IF  
  
                --Delete views  
                EXEC mdm.udpDeleteViews @Model_ID, @Entity_ID, NULL, 3;  
  
                --Delete attributes  
                DELETE FROM mdm.tblAttribute WHERE Entity_ID = @Entity_ID AND MemberType_ID IN (@MemberType_Consolidated, @MemberType_ParentChild);  
  
                --Update entity  
                UPDATE  
                    mdm.tblEntity  
                SET  
                    --Unassign table names  
                    HierarchyTable = NULL,  
                    HierarchyParentTable = NULL,  
                    --Audit changes  
                    LastChgDTM = GETUTCDATE(),  
                    LastChgUserID = @User_ID,  
                    LastChgVersionID = @Version_ID  
                WHERE  
                    ID = @Entity_ID;  
  
                --Recreate leaf staging SProc when HP table is deleted.  
                Exec mdm.udpEntityStagingCreateLeafStoredProcedure @Entity_ID = @Entity_ID;  
  
                --Recreate views for the hierarchy-free entity  
                EXEC mdm.udpCreateViews @Model_ID = @Model_ID, @NewEntity_ID = @Entity_ID;  
                EXEC mdm.udpEntityStagingCreateErrorDetailViews @Entity_ID = @Entity_ID;  
  
                --Put a msg onto the SB queue to process member security  
                EXEC mdm.udpSecurityMemberQueueSave  
                    @User_ID    = NULL,-- update member security for all users  
                    @Version_ID = @Version_ID,  
                    @Entity_ID  = @Entity_ID;  
  
        END ELSE BEGIN  
  
            -- Delete the consolidated members from the HP and HR tables.  
            SET @SQL = CONCAT(N'  
            DELETE FROM mdm.', QUOTENAME(@HierarchyTable), N'  
                WHERE Hierarchy_ID = @Hierarchy_ID;  
            DELETE FROM mdm.', QUOTENAME(@HierarchyParentTable), N'  
                WHERE Hierarchy_ID = @Hierarchy_ID;');  
  
            EXEC sp_executesql @SQL, N'@Hierarchy_ID INT', @Hierarchy_ID;  
        END; --if  
  
        --Delete the hierarchy record  
        DELETE FROM mdm.tblHierarchy WHERE ID = @Hierarchy_ID;  
  
        --Commit only if we are not nested  
        IF @TranCounter = 0 COMMIT TRANSACTION;  
  
        -- Send the message  
    	EXEC mdm.udpPerformanceQueueSave;  
  
        RETURN(0);  
  
    END TRY  
    --Compensate as necessary  
    BEGIN CATCH  
  
        -- Get error info.  
        DECLARE  
            @ErrorMessage NVARCHAR(4000),  
            @ErrorSeverity INT,  
            @ErrorState INT,  
            @ErrorNumber INT,  
            @ErrorLine INT,  
            @ErrorProcedure NVARCHAR(126);  
        EXEC mdm.udpGetErrorInfo  
            @ErrorMessage = @ErrorMessage OUTPUT,  
            @ErrorSeverity = @ErrorSeverity OUTPUT,  
            @ErrorState = @ErrorState OUTPUT,  
            @ErrorNumber = @ErrorNumber OUTPUT,  
            @ErrorLine = @ErrorLine OUTPUT,  
            @ErrorProcedure = @ErrorProcedure OUTPUT  
  
        SET @ErrorMessage = CONCAT(@ErrorMessage, N', @ErrorNumber = ', @ErrorNumber, N', @ErrorProcedure = "', @ErrorProcedure, N'", line ', @ErrorLine);  
  
        IF @TranCounter = 0 ROLLBACK TRANSACTION;  
        ELSE IF XACT_STATE() <> -1 ROLLBACK TRANSACTION TX;  
  
        RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);  
  
        --On error, return NULL results  
        SELECT NULL AS HierarchyCount;  
        RETURN(1);  
  
    END CATCH;  
  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpEntityHierarchySave]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    --Create new hierarchy  
    DECLARE @Return_ID INT, @Return_MUID UNIQUEIDENTIFIER, @Type INT;  
    EXEC mdm.udpEntityHierarchySave @User_ID = 1, @Model_ID = 5, @Entity_ID = 15, @HierarchyName = N'test2', @IsMandatory = 1, @EditMode = 0, @Return_ID = @Return_ID OUTPUT, @Return_MUID = @Return_MUID OUTPUT;  
    SELECT @Return_ID, @Return_MUID;  
    SELECT * FROM mdm.tblHierarchy WHERE ID = @Return_ID;  
  
    --Update existing hierarchy  
    DECLARE @Return_ID INT, @Return_MUID UNIQUEIDENTIFIER, @Type INT;  
    EXEC mdm.udpEntityHierarchySave @User_ID = 1, @Model_ID = 5, @Entity_ID = 15, @Hierarchy_ID = 1, @HierarchyName = N'test5', @IsMandatory = 1, @EditMode = 0, @Return_ID = @Return_ID OUTPUT, @Return_MUID = @Return_MUID OUTPUT;  
    SELECT @Return_ID, @Return_MUID;  
    SELECT * FROM mdm.tblHierarchy WHERE ID = @Return_ID;  
*/  
CREATE PROCEDURE [mdm].[udpEntityHierarchySave]  
(  
    @User_ID            INT,  
    @Model_ID           INT, -- caller should validate  
    @Entity_ID          INT, -- caller should validate  
    @Version_ID         INT = NULL, -- used for audit info  
    @Hierarchy_MUID     UNIQUEIDENTIFIER = NULL,  
    @HierarchyName      NVARCHAR(100),  
    @IsMandatory        BIT,  
    @EditMode           TINYINT = 0, --0: Create, 1: Update, 4: Clone, defaults to Create  
    @RecreateLeafStagingProc BIT = 1, -- In can be useful, for efficiency, to turn this off for batch metadata changes  
    @Return_ID          INT = NULL OUTPUT,  
    @Return_MUID        UNIQUEIDENTIFIER = NULL OUTPUT, --Also an input parameter for clone operations  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
AS BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE  
        @SQL                        NVARCHAR(MAX),  
        @IsCollectionEnabled        BIT = 0,  
        @IsHierarchyEnabled         BIT = 0,  
        @EntityTable                SYSNAME,  
        @HierarchyParentTable       SYSNAME,  
        @HierarchyParentHistoryTable    SYSNAME,  
        @HierarchyParentAnnotationTable SYSNAME,  
        @HierarchyTable             SYSNAME,  
        @HierarchyHistoryTable      SYSNAME,  
        @HierarchyAnnotationTable   SYSNAME,  
        @CollectionMemberTable      SYSNAME,  
        @CollectionMemberHistoryTable   SYSNAME,  
        @StagingConsolidatedTable   SYSNAME,  
        @StagingRelationshipTable   SYSNAME,  
        @StagingBase                NVARCHAR(MAX),  
        @SecurityTable              SYSNAME,  
        @CurrentDTM                 DATETIME2(3),  
        @Status_Active              TINYINT = 1,  
        @GuidEmpty                  UNIQUEIDENTIFIER = CAST(0x0 AS UNIQUEIDENTIFIER),  
        @EditMode_Create            TINYINT = 0,  
        @EditMode_Update            TINYINT = 1,  
        @EditMode_Clone             TINYINT = 4,  
        @ExistingHierarchy_MUID     UNIQUEIDENTIFIER = NULL,  
        @ExistingHierarchy_ID       INT = NULL,  
        @ObjectType_Model           INT = 1,  
        @IsModelAdmin               INT = NULL,  
        @DataCompression            TINYINT,  
        @TableOptions               NVARCHAR(MAX) = N'',  
        @IndexOptions               NVARCHAR(MAX) = N'',  
        @StagingTableOptions        NVARCHAR(MAX) = N'',  
        @StagingIndexOptions        NVARCHAR(MAX) = N'',  
        @TruncationGuard            NVARCHAR(MAX) = N'';  
  
    SELECT @Return_ID = NULL, @Return_MUID = NULL;  
  
    IF Len(@HierarchyName) > 50 -- Check to see if the HierarchyName exceeds the length limit (50).  
    BEGIN  
        RAISERROR('MDSERR200088|The explicit hierarchy cannot be saved. The explicit hierarchy name cannot be more than 50 characters.', 16, 1);  
        RETURN;  
    END;  
  
    --Test for invalid EditMode  
    IF @EditMode IS NULL OR @EditMode NOT IN (@EditMode_Create, @EditMode_Update, @EditMode_Clone)  
    BEGIN  
        --On error, return NULL results  
        SELECT @Return_ID = NULL, @Return_MUID = NULL;  
        RAISERROR('MDSERR100010|The Parameters are not valid.', 16, 1);  
        RETURN;  
    END; --if  
  
    --Initialize output parameters and local variables  
    SELECT  
        @Return_ID = NULL,  
        @CurrentDTM = GETUTCDATE(),  
        @Model_ID = NULLIF(@Model_ID, 0),  
        @Entity_ID = NULLIF(@Entity_ID, 0),  
        @Hierarchy_MUID = NULLIF(@Hierarchy_MUID, @GuidEmpty),  
        @HierarchyName = NULLIF(LTRIM(RTRIM(@HierarchyName)), N'');  
  
    --Load up the entity info  
    SELECT @DataCompression = DataCompression  
    FROM mdm.tblEntity  
    WHERE ID = @Entity_ID  
  
    --Raise an error if we are missing the entity ID  
    IF @DataCompression IS NULL --Missing Entity identifier  
    BEGIN  
        RAISERROR('MDSERR200011|The explicit hierarchy cannot be saved. The entity ID is not valid.', 16, 1);  
        RETURN;  
    END;  
  
    --If we are in the Update or Clone mode get the missing pieces of the identifier  
    IF @EditMode IN (@EditMode_Update, @EditMode_Clone)  
    BEGIN  
        --Only use the name if neither MUID nor ID are available. This is important because we don't want  
        --to look up by name if the name is what the user is trying to update.  
        IF  @Hierarchy_MUID IS NULL  
        BEGIN  
            SELECT TOP 1  
                @ExistingHierarchy_ID =  ID,  
                @ExistingHierarchy_MUID = MUID  
            FROM mdm.tblHierarchy  
            WHERE  
                Name = @HierarchyName AND  
                Entity_ID = @Entity_ID;  
        END  
        --Use the Hierarchy ID and MUID to look up the full identifier  
        ELSE  
        BEGIN  
            SELECT  
            @ExistingHierarchy_ID =  ID,  
            @ExistingHierarchy_MUID = MUID  
            FROM mdm.tblHierarchy  
            WHERE  
                MUID = @Hierarchy_MUID AND  
                Entity_ID = @Entity_ID;  
        END  
  
        --If we are in the Clone mode we need to figure out whether we are creating or updating a hierarchy  
        IF @EditMode = @EditMode_Clone  
        BEGIN  
            --If there is no existing hierarchy then set the edit mode to Create  
            IF @ExistingHierarchy_MUID IS NULL AND @ExistingHierarchy_ID IS NULL  
            BEGIN  
                SET @EditMode = @EditMode_Create;  
            END  
            --If there is an existing hierarchy then set the edit mode to Update  
            ELSE  
            BEGIN  
                SET @EditMode = @EditMode_Update;  
                SET @Hierarchy_MUID = @ExistingHierarchy_MUID;  
            END  
        END  
        --If we are in Update mode and could not find a matching existing hierarchy we need to raise an error and quit now  
        ELSE IF @EditMode = @EditMode_Update  
        BEGIN  
            IF @ExistingHierarchy_ID IS NULL OR @ExistingHierarchy_MUID IS NULL  
            BEGIN  
                --On error, return NULL results  
                SELECT @Return_ID = NULL, @Return_MUID = NULL;  
                RAISERROR('MDSERR110007|The ID is not valid.', 16, 1);  
                RETURN;  
            END  
            ELSE  
            BEGIN  
                SET @Hierarchy_MUID = @ExistingHierarchy_MUID;  
            END;  
        END  
    END  
  
    --If the edit mode is Create. This code also needs to execute if the user sent in EditMode clone which ended up becoming Create (hence the IF instead of ELSE IF)  
    IF @EditMode = @EditMode_Create  
    BEGIN  
        --If @Hierarchy_MUID is not null then we need to ensure it does not already exist (since this is a create)  
        IF @Hierarchy_MUID IS NOT NULL AND EXISTS(SELECT * FROM mdm.tblHierarchy WHERE MUID = @Hierarchy_MUID)  
        BEGIN  
            --On error, return NULL results  
            SELECT @Return_ID = NULL, @Return_MUID = NULL;  
            RAISERROR('MDSERR110007|The ID is not valid.', 16, 1);  
            RETURN;  
        END  
    END  
  
    --Set the staging table names  
    SELECT  
        @Model_ID = Model_ID,  
        @IsCollectionEnabled = CASE WHEN CollectionTable IS NULL THEN 0 ELSE 1 END,  
        @IsHierarchyEnabled  = CASE WHEN HierarchyTable  IS NULL THEN 0 ELSE 1 END,  
        @EntityTable = EntityTable,  
        @CollectionMemberTable = CollectionMemberTable,  
        @StagingConsolidatedTable = StagingConsolidatedName,  
        @StagingRelationshipTable = StagingRelationshipName,  
        @StagingBase = StagingBase  
    FROM mdm.tblEntity  
    WHERE ID = @Entity_ID;  
  
    --Test for invalid parameters  
    IF @Model_ID IS NULL --Invalid @Entity_ID (via invalid @Model_ID)  
    BEGIN  
        SELECT @Return_ID = NULL, @Return_MUID = NULL;  
        RAISERROR('MDSERR100010|The Parameters are not valid.', 16, 1);  
        RETURN;  
    END; --if  
  
    --Check the name of the hierarchy for duplicates  
    IF EXISTS  
    (  
        SELECT 1 FROM  
        mdm.tblHierarchy  
        WHERE  
            @HierarchyName = Name AND  
            (@Hierarchy_MUID IS NULL OR MUID <> @Hierarchy_MUID) AND  
            Entity_ID = @Entity_ID  
    )  
    BEGIN  
        --On error, return NULL results  
        SELECT @Return_ID = NULL, @Return_MUID = NULL;  
        RAISERROR('MDSERR110003|The name already exists. Type a different name.', 16, 1);  
        RETURN;  
    END  
  
    --Start transaction, being careful to check if we are nested  
    DECLARE @TranCounter INT;  
    SET @TranCounter = @@TRANCOUNT;  
    IF @TranCounter > 0 SAVE TRANSACTION TX;  
    ELSE BEGIN TRANSACTION;  
  
    BEGIN TRY  
  
        --If Entity does not currently have hierarchies, create the necessary tables  
        IF @IsHierarchyEnabled = 0  
        BEGIN  
  
            SET @TableOptions = mdm.udfGetTableOptions(@DataCompression, @Model_ID);  
            SET @IndexOptions = mdm.udfGetIndexOptions(@DataCompression, @Model_ID);  
            SET @StagingTableOptions = mdm.udfGetTableOptions(@DataCompression, NULL);  
            SET @StagingIndexOptions = mdm.udfGetIndexOptions(@DataCompression, NULL);  
  
            --Generate table names  
            WITH cte(prefix) AS (SELECT N'tbl_' + CONVERT(SYSNAME, @Model_ID) + N'_' + CONVERT(SYSNAME, @Entity_ID))  
            SELECT  
                @HierarchyTable = prefix + N'_HR',  
                @HierarchyHistoryTable = prefix + N'_HR_HS',  
                @HierarchyAnnotationTable = prefix + N'_HR_AN',  
                @HierarchyParentTable = prefix + N'_HP',  
                @HierarchyParentHistoryTable = prefix + N'_HP_HS',  
                @HierarchyParentAnnotationTable = prefix + N'_HP_AN',  
                @CollectionMemberHistoryTable = prefix + N'_CM_HS',  
                @SecurityTable = prefix +  N'_HP_MS'  
            FROM cte;  
  
            -- Set the entity's hierarchy table names.  
            UPDATE mdm.tblEntity SET  
                --Assign table names  
                HierarchyTable = @HierarchyTable,  
                HierarchyParentTable = @HierarchyParentTable,  
                --Ensure changes are audited  
                LastChgDTM = @CurrentDTM,  
                LastChgUserID = @User_ID,  
                LastChgVersionID = @Version_ID  
            WHERE ID = @Entity_ID;  
  
            --Create the Hierarchy Parent table (HP)  
            SET @SQL =  @TruncationGuard + N'  
                CREATE TABLE mdm.' + QUOTENAME(@HierarchyParentTable) + N'  
                (  
                    --Identity  
                    Version_ID          INT NOT NULL,  
                    ID                  INT IDENTITY (1, 1) NOT NULL,  
                    --Status  
                    Status_ID           TINYINT NOT NULL CONSTRAINT ' + QUOTENAME(N'df_' + @HierarchyParentTable  + N'_Status_ID') + N' DEFAULT ' + CONVERT(NVARCHAR, @Status_Active) + N',  
                    ValidationStatus_ID TINYINT NOT NULL CONSTRAINT ' + QUOTENAME(N'df_' + @HierarchyParentTable  + N'_ValidationStatus_ID') + N' DEFAULT 0,  
  
                    --Data  
                    [Name]              NVARCHAR(250) NULL,  
                    Code                NVARCHAR(250) NOT NULL,  
                    Hierarchy_ID        INT NOT NULL,  
  
                    --Change Tracking  
                    ChangeTrackingMask  INT NOT NULL CONSTRAINT ' + QUOTENAME(N'df_' + @HierarchyParentTable  + N'_ChangeTrackingMask') + N' DEFAULT 0,  
  
                    --Auditing  
                    EnterDTM            DATETIME2(3) NOT NULL CONSTRAINT ' + QUOTENAME(N'df_' + @HierarchyParentTable  + N'_EnterDTM') + N' DEFAULT GETUTCDATE(),  
                    EnterUserID         INT NOT NULL,  
                    EnterVersionID      INT NOT NULL,  
                    LastChgDTM          DATETIME2(3) NOT NULL CONSTRAINT ' + QUOTENAME(N'df_' + @HierarchyParentTable  + N'_LastChgDTM') + N' DEFAULT GETUTCDATE(),  
                    LastChgUserID       INT NOT NULL,  
                    LastChgVersionID    INT NOT NULL,  
                    LastChgTS           ROWVERSION NOT NULL,  
                    AsOf_ID             INT NULL,  
                    MUID                UNIQUEIDENTIFIER NOT NULL CONSTRAINT ' + QUOTENAME(N'df_' + @HierarchyParentTable + N'_MUID') + N' DEFAULT NEWID(),  
  
                    --Create PRIMARY KEY constraint  
                    CONSTRAINT ' + QUOTENAME(N'pk_' + @HierarchyParentTable  + N'') + N'  
                        PRIMARY KEY CLUSTERED (Version_ID, ID),  
  
                    --Create FOREIGN KEY contraints  
                    CONSTRAINT ' + QUOTENAME(N'fk_' + @HierarchyParentTable  + N'_tblHierarchy_Hierarchy_ID') + N'  
                        FOREIGN KEY (Hierarchy_ID) REFERENCES mdm.tblHierarchy(ID)  
                        ON UPDATE NO ACTION  
                        ON DELETE CASCADE  
  
                    -- Note: the values of the Status_ID column should fall between 1 and 2. The ValidationStatus_ID column should be between 0 and 5. However,  
                    -- we do not enforce this via db constraint because it would slow down table writes and only trusted MDS sproc code should be writing to those columns.  
                )  
                ' + @TableOptions + N';  
                ';  
  
            SET @SQL = CONCAT(@SQL, N'  
                --Ensure uniqueness of [Code] for active members.  
                CREATE UNIQUE NONCLUSTERED INDEX ', QUOTENAME(N'ux_' + @HierarchyParentTable + N'_Version_ID_Code_Active'), N'  
                    ON mdm.', QUOTENAME(@HierarchyParentTable), N'(Version_ID, Code)  
                    WHERE Status_ID = ', @Status_Active, N'  
                    ', @IndexOptions, N';  
  
                --Index [Name] for performance  
                CREATE NONCLUSTERED INDEX ', QUOTENAME(N'ix_' + @HierarchyParentTable + N'_Version_ID_Name'), N'  
                    ON mdm.', QUOTENAME(@HierarchyParentTable), N'(Version_ID, Name)  
                    ', @IndexOptions, N';  
  
                --Ensure uniqueness of [MUID]  
                CREATE UNIQUE NONCLUSTERED INDEX ', QUOTENAME(N'ux_' + @HierarchyParentTable + N'_Version_ID_MUID'), N'  
                    ON mdm.', QUOTENAME(@HierarchyParentTable), N'(Version_ID, MUID)  
                    ', @IndexOptions, N';  
  
                --Index Status_ID and ValidationStatus_ID for performance (queried together in udpVersionValidationStatusGet)  
                CREATE NONCLUSTERED INDEX ', QUOTENAME(N'ix_' + @HierarchyParentTable + N'_Version_ID_Status_ID_ValidationStatus_ID'), N'  
                    ON mdm.', QUOTENAME(@HierarchyParentTable), N'(Version_ID, Status_ID, ValidationStatus_ID)  
                    ', @IndexOptions, N';  
  
                --Add an index on Hierarchy_ID corresponding to the FK  
                CREATE NONCLUSTERED INDEX ', QUOTENAME(N'ix_' + @HierarchyParentTable + N'_Hierarchy_ID'), N'  
                    ON mdm.', QUOTENAME(@HierarchyParentTable), N'(Hierarchy_ID)  
                    ', @IndexOptions, N';  
  
                --Required for VersionCopy operations  
                CREATE NONCLUSTERED INDEX ', QUOTENAME(N'ix_' + @HierarchyParentTable + N'_Version_ID_AsOf_ID_Status_ID'), N'  
                    ON mdm.', QUOTENAME(@HierarchyParentTable), N'(Version_ID, AsOf_ID, Status_ID)  
                    INCLUDE ([ID])  
                    WHERE [AsOf_ID] IS NOT NULL  
                    ', @IndexOptions, N';  
  
                --Create the history (_HP_HS) table  
                CREATE TABLE mdm.', QUOTENAME(@HierarchyParentHistoryTable), N'  
                (  
                    --Identity  
                    Version_ID          INT NOT NULL,  
                    ID                  BIGINT NOT NULL,  
  
                    HP_ID               INT NOT NULL,  
  
                    --Status  
                    Status_ID           TINYINT NOT NULL,  
  
                    --Data  
                    [Name]              NVARCHAR(250) NULL,  
                    Code                NVARCHAR(250) NOT NULL,  
                    Hierarchy_ID        INT NOT NULL,  
  
                    --Auditing  
                    EnterDTM            DATETIME2(3) NOT NULL,  
                    EnterUserID         INT NOT NULL,  
                    LastChgDTM          DATETIME2(3) NOT NULL,  
                    LastChgUserID       INT NOT NULL,  
                    MUID                UNIQUEIDENTIFIER NOT NULL,  
  
                    --Create PRIMARY KEY constraint  
                    CONSTRAINT ', QUOTENAME(N'pk_' + @HierarchyParentHistoryTable + N''), N'  
                        PRIMARY KEY CLUSTERED (Version_ID, ID)  
  
                    --Cannot have foreign key (Version_ID, HP_ID) on HP table, because HS table is used in OUTPUT clause  
                )  
                ', @TableOptions, N';  
  
                -- Required by udpEntityMemberHistoriesGet and type2 view  
                CREATE NONCLUSTERED INDEX ', QUOTENAME(N'ix_' + @HierarchyParentHistoryTable + N'_Version_ID_HP_ID'), N'  
                    ON mdm.', QUOTENAME(@HierarchyParentHistoryTable), N'(Version_ID, HP_ID, EnterDTM, LastChgDTM)  
                    ', @IndexOptions, N';  
  
                --Create the Annotation (_HP_AN) table  
                CREATE TABLE mdm.', QUOTENAME(@HierarchyParentAnnotationTable), N'  
                (  
                    Version_ID          INT NOT NULL,  
                    ID                  INT IDENTITY(1, 1) NOT NULL,  
  
                    Revision_ID         BIGINT NOT NULL,  
  
                    [Comment]           [NVARCHAR](500) NULL,  
  
                    --Auditing  
                    EnterDTM            DATETIME2(3) NOT NULL CONSTRAINT ', QUOTENAME(N'df_' + @HierarchyParentAnnotationTable + N'_EnterDTM'), N' DEFAULT GETUTCDATE(),  
                    EnterUserID         INT NOT NULL,  
                    LastChgDTM          DATETIME2(3) NOT NULL CONSTRAINT ', QUOTENAME(N'df_' + @HierarchyParentAnnotationTable + N'_LastChgDTM'), N' DEFAULT GETUTCDATE(),  
                    LastChgUserID       INT NOT NULL,  
                    LastChgTS           ROWVERSION NOT NULL,  
  
                    --Create PRIMARY KEY constraint  
                    CONSTRAINT ', QUOTENAME(N'pk_' + @HierarchyParentAnnotationTable), N'  
                        PRIMARY KEY CLUSTERED (Version_ID, ID)  
                )  
                ', @TableOptions, N';  
  
                -- Required for udpEntityMemberAnnotationsGet operations  
                CREATE NONCLUSTERED INDEX ', QUOTENAME(N'ix_' + @HierarchyParentAnnotationTable +  N'_Version_ID_Revision_ID'), N'  
                    ON mdm.', QUOTENAME(@HierarchyParentAnnotationTable), N'(Version_ID, Revision_ID)  
                    ', @IndexOptions, N';  
  
                --Create the Member Security (HP_MS) table  
                --There is no IDENTITY() column since this table gets bulk- deleted & inserted frequently  
                CREATE TABLE mdm.', QUOTENAME(@SecurityTable), N'  
                (  
                    Version_ID          INT NOT NULL,  
                    User_ID             INT NOT NULL,  
                    ID                  INT NOT NULL,  
                    AccessPermission    TINYINT NOT NULL,  
  
                    --Create PRIMARY KEY constraint  
                    CONSTRAINT ', QUOTENAME(N'pk_' + @SecurityTable), N'  
                        PRIMARY KEY CLUSTERED (Version_ID, User_ID, ID),  
  
                    --Create FOREIGN KEY constraints  
                    CONSTRAINT ', QUOTENAME(N'fk_' + @SecurityTable + N'_' + @HierarchyParentTable + '_Version_ID_ID'), N'  
                        FOREIGN KEY (Version_ID, ID) REFERENCES mdm.' + @HierarchyParentTable + '(Version_ID, ID)  
                        ON UPDATE NO ACTION  
                        ON DELETE CASCADE  
                )  
                ', @TableOptions, N'  
  
                -- Create index for the FK, to improve perf of cascaded deletes from HP table.  
                CREATE NONCLUSTERED INDEX ', QUOTENAME(N'ix_' + @SecurityTable + N'_Version_ID_ID'), N'  
                    ON mdm.', QUOTENAME(@SecurityTable), N'(Version_ID, ID)  
                    ', @IndexOptions, N';  
                ');  
  
            --Execute the dynamic SQL  
            --PRINT(@SQL);  
            EXEC sp_executesql @SQL;  
  
            --If @StagingConsolidatedTable is specified create the Consolidated Staging table (_Consolidated) in Staging (stg) Schema  
            IF COALESCE(@StagingConsolidatedTable, N'') <> N''  
            BEGIN  
                EXEC mdm.udpEntityStagingCreateConsolidatedTable  
                     @StagingTableName = @StagingConsolidatedTable  
                    ,@TableOptions = @StagingTableOptions  
                    ,@IndexOptions = @StagingIndexOptions;  
  
  
                EXEC mdm.udpEntityStagingCreateConsolidatedStoredProcedure @Entity_ID  
  
            END; --IF  
  
            --Create the Hierarchy Relationship table (HR)  
            SET @SQL = N'  
                CREATE TABLE mdm.' + QUOTENAME(@HierarchyTable) + N'  
                (  
                    --Identity  
                    Version_ID          INT NOT NULL,  
                    ID                  INT IDENTITY(1, 1) NOT NULL,  
  
                    --Status  
                    Status_ID           TINYINT NOT NULL CONSTRAINT ' + QUOTENAME(N'df_' + @HierarchyTable + N'_Status_ID') + N' DEFAULT ' + CONVERT(NVARCHAR, @Status_Active) + N',  
                    ValidationStatus_ID TINYINT NOT NULL CONSTRAINT ' + QUOTENAME(N'df_' + @HierarchyTable + N'_ValidationStatus_ID') + N' DEFAULT 0,  
  
                    --Pointers  
                    Hierarchy_ID        INT NOT NULL,  
                    Parent_HP_ID        INT NULL, --Root is NULL  
                    ChildType_ID        TINYINT NOT NULL,  
                    Child_EN_ID         INT NULL, --Only used when ChildType_ID = 1 (EN)  
                    Child_HP_ID         INT NULL, --Only used when ChildType_ID = 2 (HP)  
  
                    --Data  
                    SortOrder           INT NOT NULL,  
                    LevelNumber         SMALLINT NOT NULL CONSTRAINT ' + QUOTENAME(N'df_' + @HierarchyTable + N'_LevelNumber_ID') + N' DEFAULT -1,  
  
                    --Auditing  
                    EnterDTM            DATETIME2(3) NOT NULL CONSTRAINT ' + QUOTENAME(N'df_' + @HierarchyTable + N'_EnterDTM') + N' DEFAULT GETUTCDATE(),  
                    EnterUserID         INT NOT NULL,  
                    EnterVersionID      INT NOT NULL,  
                    LastChgDTM          DATETIME2(3) NOT NULL CONSTRAINT ' + QUOTENAME(N'df_' + @HierarchyTable + N'_LastChgDTM') + N' DEFAULT GETUTCDATE(),  
                    LastChgUserID       INT NOT NULL,  
                    LastChgVersionID    INT NOT NULL,  
                    LastChgTS           ROWVERSION NOT NULL,  
                    AsOf_ID             INT NULL,  
                    MUID                UNIQUEIDENTIFIER NOT NULL CONSTRAINT ' + QUOTENAME(N'df_' + @HierarchyTable + N'_MUID') + N' DEFAULT NEWID(),  
  
                    --Create PRIMARY KEY constraint  
                    CONSTRAINT ' + QUOTENAME(N'pk_' + @HierarchyTable) + N'  
                        PRIMARY KEY NONCLUSTERED (Version_ID, ID)  
                        ' + @IndexOptions + N',  
  
                    --Create FOREIGN KEY constraints  
                    CONSTRAINT ' + QUOTENAME(N'fk_' + @HierarchyTable + N'_tblHierarchy_Hierarchy_ID') + N'  
                        FOREIGN KEY (Hierarchy_ID) REFERENCES mdm.tblHierarchy(ID)  
                        ON UPDATE NO ACTION  
                        ON DELETE CASCADE,  
                    CONSTRAINT ' + QUOTENAME(N'fk_' + @HierarchyTable + N'_' + @HierarchyParentTable + N'_Parent_HP_ID') + N'  
                        FOREIGN KEY (Version_ID, Parent_HP_ID) REFERENCES mdm.' + QUOTENAME(@HierarchyParentTable) + N'(Version_ID, ID)  
                        ON UPDATE NO ACTION  
                        ON DELETE NO ACTION, --Cannot use DELETE SET NULL since Version_ID is NOT NULLable  
                    CONSTRAINT ' + QUOTENAME(N'fk_' + @HierarchyTable + N'_' + @EntityTable + N'_Child_EN_ID') + N'  
                        FOREIGN KEY (Version_ID, Child_EN_ID) REFERENCES mdm.' + QUOTENAME(@EntityTable) + N'(Version_ID, ID)  
                        ON UPDATE NO ACTION  
                        ON DELETE CASCADE,  
                    CONSTRAINT ' + QUOTENAME(N'fk_' + @HierarchyTable + N'_' + @HierarchyParentTable + N'_Child_HP_ID') + N'  
                        FOREIGN KEY (Version_ID, Child_HP_ID) REFERENCES mdm.' + QUOTENAME(@HierarchyParentTable) + N'(Version_ID, ID)  
                        ON UPDATE NO ACTION  
                        ON DELETE NO ACTION, --Cannot use DELETE CASCADE due to chance of cycles  
  
                    --Create CHECK constraints  
                    -- Note: the values of the Status_ID column should fall between 1 and 2. The ValidationStatus_ID column should be between 0 and 5. However,  
                    -- we do not enforce this via db constraint because it would slow down table writes and only trusted MDS sproc code should be writing to those columns.  
                    CONSTRAINT ' + QUOTENAME(N'ck_' + @HierarchyTable + N'_ChildType_ID') + N'  
                        CHECK (    (ChildType_ID = 1 AND Child_EN_ID IS NOT NULL AND Child_HP_ID IS NULL) OR  
                                (ChildType_ID = 2 AND Child_HP_ID IS NOT NULL AND Child_EN_ID IS NULL)),  
                    CONSTRAINT ' + QUOTENAME(N'ck_' + @HierarchyTable + N'_Parent_HP_ID_Child_HP_ID') + N'  
                        CHECK (NOT (ChildType_ID = 2 AND Parent_HP_ID = Child_HP_ID)) --Prevent self-reference  
                )  
                ' + @TableOptions + N';  
                ';  
  
            --Direct assignment of expression > 4000 nchars seems to truncate string. Workaround is to concatenate.  
            SET @SQL = @SQL + N'  
                --Ensure uniqueness of keyset  
                CREATE UNIQUE CLUSTERED INDEX ' + QUOTENAME(N'ux_' + @HierarchyTable + N'_Version_ID_Hierarchy_ID_ChildType_ID_Child_HP_ID_Child_EN_ID') + N'  
                    ON mdm.' + QUOTENAME(@HierarchyTable) + N'(Version_ID, Hierarchy_ID, ChildType_ID, Child_HP_ID, Child_EN_ID)  
                    ' + @IndexOptions + N';  
  
                --Required for mdm.udpMembersStatusSet to avoid the deadlock when delete entity members  
                CREATE NONCLUSTERED INDEX ' + QUOTENAME(N'ix_' + @HierarchyTable  + N'_Version_ID_Child_EN_ID') + N'  
                    ON mdm.' + QUOTENAME(@HierarchyTable) + N'([Version_ID],[Child_EN_ID])  
                    ' + @IndexOptions + N';  
  
                --Required for faster hierarchy moves  
                CREATE NONCLUSTERED INDEX ' + QUOTENAME(N'ix_' + @HierarchyTable  + N'_Version_ID_Hierarchy_ID_Parent_HP_ID') + N'  
                    ON mdm.' + QUOTENAME(@HierarchyTable) + N'([Version_ID],[Hierarchy_ID],[Parent_HP_ID])  
                    ' + @IndexOptions + N';  
  
                --Index Status_ID for performance  
                CREATE NONCLUSTERED INDEX ' + QUOTENAME(N'ix_' + @HierarchyTable + N'_Version_ID_Status_ID') + N'  
                    ON mdm.' + QUOTENAME(@HierarchyTable) + N'(Version_ID, Status_ID)  
                    ' + @IndexOptions + N';  
  
                --Create the History (_HR_HS) table  
                CREATE TABLE mdm.' + QUOTENAME(@HierarchyHistoryTable) + N'  
                (  
                    --Identity  
                    Version_ID          INT NOT NULL,  
                    ID                  BIGINT NOT NULL,  
  
                    HR_ID               INT NOT NULL,  
  
                    --Status  
                    Status_ID           TINYINT NOT NULL,  
  
                    --Pointers  
                    Hierarchy_ID        INT NOT NULL,  
                    Parent_HP_ID        INT NULL, --Root is NULL  
                    ChildType_ID        TINYINT NOT NULL,  
                    Child_EN_ID         INT NULL, --Only used when ChildType_ID = 1 (EN)  
                    Child_HP_ID         INT NULL, --Only used when ChildType_ID = 2 (HP)  
  
                    --Data  
                    SortOrder           INT NOT NULL,  
                    LevelNumber         SMALLINT NOT NULL,  
  
                    --Auditing  
                    EnterDTM            DATETIME2(3) NOT NULL,  
                    EnterUserID         INT NOT NULL,  
                    LastChgDTM          DATETIME2(3) NOT NULL,  
                    LastChgUserID       INT NOT NULL,  
                    MUID                UNIQUEIDENTIFIER NOT NULL,  
  
                    --Create PRIMARY KEY constraint  
                    CONSTRAINT ' + QUOTENAME(N'pk_' + @HierarchyHistoryTable) + N'  
                        PRIMARY KEY CLUSTERED (Version_ID, ID)  
  
                    --Cannot have foreign key (Version_ID, HR_ID) on HR table, because HS table is used in OUTPUT clause  
                )  
                ' + @TableOptions + N';  
  
                --Required for udpEntityMemberHistoriesGet operations  
                CREATE NONCLUSTERED INDEX ' + QUOTENAME(N'ix_' + @HierarchyHistoryTable + N'_Version_ID_HR_ID') + N'  
                    ON mdm.' + QUOTENAME(@HierarchyHistoryTable) + N'(Version_ID, HR_ID)  
                    ' + @IndexOptions + N';  
  
                --Create the Annotation (_HR_AN) table  
                CREATE TABLE mdm.' + QUOTENAME(@HierarchyAnnotationTable) + N'  
                (  
                    Version_ID          INT NOT NULL,  
                    ID                  INT IDENTITY(1, 1) NOT NULL,  
  
                    Revision_ID         BIGINT NOT NULL,  
  
                    [Comment]           [NVARCHAR](500) NULL,  
  
                    --Auditing  
                    EnterDTM            DATETIME2(3) NOT NULL CONSTRAINT ' + QUOTENAME(N'df_' + @HierarchyAnnotationTable  + N'_EnterDTM') + N' DEFAULT GETUTCDATE(),  
                    EnterUserID         INT NOT NULL,  
                    LastChgDTM          DATETIME2(3) NOT NULL CONSTRAINT ' + QUOTENAME(N'df_' + @HierarchyAnnotationTable  + N'_LastChgDTM') + N' DEFAULT GETUTCDATE(),  
                    LastChgUserID       INT NOT NULL,  
                    LastChgTS           ROWVERSION NOT NULL,  
  
                    --Create PRIMARY KEY constraint  
                    CONSTRAINT ' + QUOTENAME(N'pk_' + @HierarchyAnnotationTable) + N'  
                        PRIMARY KEY CLUSTERED (Version_ID, ID)  
                )  
                ' + @TableOptions + N';  
  
                --Required for udpEntityMemberAnnotationsGet operations  
                CREATE NONCLUSTERED INDEX ' + QUOTENAME(N'ix_' + @HierarchyAnnotationTable + N'_Version_ID_Revision_ID') + N'  
                    ON mdm.' + QUOTENAME(@HierarchyAnnotationTable) + N'(Version_ID, Revision_ID)  
                    ' + @IndexOptions + N';  
                ';  
  
            --Execute the dynamic SQL  
            --PRINT(@SQL);  
            EXEC sp_executesql @SQL;  
  
            --If @StagingRelationshipTable is specified create the Hierarchy Relationship Staging table (_Relationship) in Staging (stg) Schema  
            IF COALESCE(@StagingRelationshipTable, N'') <> N'' BEGIN  
                SET @SQL =  N'  
                    CREATE TABLE [stg].' + QUOTENAME(@StagingRelationshipTable) + N'  
                    (  
                        --Identity  
                        ID                  INT IDENTITY (1, 1) NOT NULL,  
  
                        --Import Specific  
                        RelationshipType    TINYINT NOT NULL,  
  
                        --Status  
                        ImportStatus_ID     TINYINT NOT NULL,  
  
                        --Info  
                        Batch_ID            INT NULL,  
                        BatchTag            NVARCHAR(50) NOT NULL,  
  
                        --Error Code  
                        ErrorCode           INT NOT NULL CONSTRAINT ' + QUOTENAME(N'df_' + @StagingRelationshipTable  + N'_ErrorCode') + N' DEFAULT 0,  
                        HierarchyName       NVARCHAR(250) NOT NULL,  
                        ParentCode          NVARCHAR(250) NOT NULL,  
                        ChildCode           NVARCHAR(250) NOT NULL,  
                        SortOrder           INT,  
  
                        --Create PRIMARY KEY constraint  
                        CONSTRAINT ' + QUOTENAME(N'pk_' + @StagingRelationshipTable) + N'  
                            PRIMARY KEY CLUSTERED (ID),  
  
                        --Create CHECK constraints  
                        CONSTRAINT ' + QUOTENAME(N'ck_' + @StagingRelationshipTable + N'_RelationshipType') + N'  
                            CHECK (RelationshipType BETWEEN 1 AND 2),  
                        CONSTRAINT ' + QUOTENAME(N'ck_' + @StagingRelationshipTable + N'_ImportStatus_ID') + N'  
                            CHECK (ImportStatus_ID BETWEEN 0 and 3)  
                    )  
                    ' + @StagingTableOptions + N';  
  
                    --Index [Batch_ID_ImportStatus_ID_RelationshipType] for performance  
                    CREATE NONCLUSTERED INDEX ' + QUOTENAME(N'ix_' + @StagingRelationshipTable + N'_Batch_ID_ImportStatus_ID_RelationshipType') + N'  
                        ON [stg].' + QUOTENAME(@StagingRelationshipTable) + N'(Batch_ID, ImportStatus_ID, RelationshipType)  
                        INCLUDE([ID], [ErrorCode])  
                        ' + @StagingIndexOptions + N';  
  
                    --Index [BatchTag_ImportStatus_ID] for performance  
                    CREATE NONCLUSTERED INDEX ' + QUOTENAME(N'ix_' + @StagingRelationshipTable + N'_BatchTag_ImportStatus_ID') + N'  
                        ON [stg].' + QUOTENAME(@StagingRelationshipTable) + N'(BatchTag, ImportStatus_ID)  
                        INCLUDE([ID], [Batch_ID])  
                        ' + @StagingIndexOptions + N';'  
  
                EXEC sp_executesql @SQL;  
  
                EXEC mdm.udpEntityStagingCreateRelationshipStoredProcedure @Entity_ID;  
  
            END; --IF  
  
            IF @IsCollectionEnabled = 1  
            BEGIN  
                -- Collections are supported and this's the first time we add EH to this entity, so need to add a column to the collection membership table to allow collections to contain consolidated members.  
                SET @SQL = N'  
                -- Add the Child_HP_ID column.  
                ALTER TABLE mdm.' + QUOTENAME(@CollectionMemberTable) + N'  
                ADD Child_HP_ID         INT NULL; --Used when the child is of type HP (ChildType_ID = 2)  
  
                ALTER TABLE mdm.' + QUOTENAME(@CollectionMemberHistoryTable) + N'  
                ADD Child_HP_ID         INT NULL; --Used when the child is of type HP (ChildType_ID = 2)  
  
                -- Add a FK contraint to the HP table.  
                ALTER TABLE mdm.' + QUOTENAME(@CollectionMemberTable) + N'  
                ADD CONSTRAINT ' + QUOTENAME(N'fk_' + @CollectionMemberTable + N'_' + @HierarchyParentTable + N'_Child_HP_ID') + N'  
                        FOREIGN KEY ([Version_ID], [Child_HP_ID]) REFERENCES mdm.' + QUOTENAME(@HierarchyParentTable) + N'([Version_ID], [ID])  
                        ON DELETE CASCADE;  
                ';  
                --Execute the dynamic SQL  
                --PRINT(@SQL);  
                EXEC sp_executesql @SQL;  
  
                SET @SQL = N'  
                -- Drop and recreate the ChildType_ID constraint so that it includes the Child_HP_ID column.  
                ALTER TABLE mdm.' + QUOTENAME(@CollectionMemberTable) + N'  
                DROP CONSTRAINT ' + QUOTENAME(N'ck_' + @CollectionMemberTable + N'_ChildType_ID') + N';  
                ALTER TABLE mdm.' + QUOTENAME(@CollectionMemberTable) + N'  
                ADD CONSTRAINT ' + QUOTENAME(N'ck_' + @CollectionMemberTable + N'_ChildType_ID') + N'  
                    CHECK ( (ChildType_ID = 1 AND Child_EN_ID IS NOT NULL AND Child_HP_ID IS NULL AND Child_CN_ID IS NULL) OR  
                            (ChildType_ID = 2 AND Child_HP_ID IS NOT NULL AND Child_EN_ID IS NULL AND Child_CN_ID IS NULL) OR  
                            (ChildType_ID = 3 AND Child_CN_ID IS NOT NULL AND Child_EN_ID IS NULL AND Child_HP_ID IS NULL));  
  
                CREATE NONCLUSTERED INDEX ' + QUOTENAME(N'ix_' + @CollectionMemberTable + N'_Version_ID_Child_HP_ID') + N'  
                ON mdm.' + QUOTENAME(@CollectionMemberTable) + N'(Version_ID, Child_HP_ID)  
                WHERE [Child_HP_ID] IS NOT NULL  
                ' + @IndexOptions + N';'  
                EXEC sp_executesql @SQL  
            END;  
  
            --Document the columns we have just physically created:  
  
            --HierarchyParent (HP)  
            INSERT INTO mdm.tblAttribute (Entity_ID,SortOrder,DomainEntity_ID,AttributeType_ID,MemberType_ID,IsSystem,IsReadOnly,IsCode,IsName,[Name],DisplayName,TableColumn,DisplayWidth,DataType_ID,DataTypeInformation,InputMask_ID,EnterUserID,EnterVersionID,LastChgUserID,LastChgVersionID)  
            VALUES  
             (@Entity_ID,1,NULL,3,2,1,1,0,0, N'ID', N'ID', N'ID',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
            ,(@Entity_ID,2,NULL,3,2,1,1,0,0, N'Version_ID', N'Version_ID', N'Version_ID',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
            ,(@Entity_ID,4,NULL,3,2,1,1,0,0, N'Status_ID', N'Status_ID', N'Status_ID',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
            ,(@Entity_ID,5,NULL,3,2,1,1,0,0, N'ValidationStatus_ID', N'ValidationStatus_ID', N'ValidationStatus_ID',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
            ,(@Entity_ID,6,NULL,3,2,1,1,0,0, N'EnterDTM', N'EnterDTM', N'EnterDTM',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
            ,(@Entity_ID,7,NULL,3,2,1,1,0,0, N'EnterUserID', N'EnterUserID', N'EnterUserID',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
            ,(@Entity_ID,8,NULL,3,2,1,1,0,0, N'EnterVersionID', N'EnterVersionID', N'EnterVersionID',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
            ,(@Entity_ID,9,NULL,3,2,1,1,0,0, N'LastChgDTM', N'LastChgDTM', N'LastChgDTM',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
            ,(@Entity_ID,10,NULL,3,2,1,1,0,0, N'LastChgUserID', N'LastChgUserID', N'LastChgUserID',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
            ,(@Entity_ID,11,NULL,3,2,1,1,0,0, N'LastChgVersionID', N'LastChgVersionID', N'LastChgVersionID',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
            ,(@Entity_ID,12,NULL,3,2,1,1,0,0, N'LastChgTS', N'LastChgTS', N'LastChgTS',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
            ,(@Entity_ID,13,NULL,3,2,1,1,0,0, N'Hierarchy_ID', N'Hierarchy_ID', N'Hierarchy_ID',0,1,100,1,@User_ID,@Version_ID,@User_ID,@Version_ID)  
            ,(@Entity_ID,14,NULL,1,2,1,0,0,1, N'Name', N'Name', N'Name',250,1,250,1,@User_ID,@Version_ID,@User_ID,@Version_ID)  
            ,(@Entity_ID,15,NULL,1,2,1,0,1,0, N'Code', N'Code', N'Code',250,1,250,1,@User_ID,@Version_ID,@User_ID,@Version_ID)  
            ,(@Entity_ID,16,NULL,3,2,1,1,0,0, N'MUID', N'MUID', N'MUID',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
            ,(@Entity_ID,17,NULL,3,2,1,1,0,0, N'AsOf_ID', N'AsOf_ID', N'AsOf_ID',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
            ,(@Entity_ID,18,NULL,3,2,1,0,0,0, N'ChangeTrackingMask', N'ChangeTrackingMask', N'ChangeTrackingMask',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
            ;  
  
            --Hierarchy (HR)  
            INSERT INTO mdm.tblAttribute (Entity_ID,SortOrder,DomainEntity_ID,AttributeType_ID,MemberType_ID,IsSystem,IsReadOnly,[Name],DisplayName,TableColumn,DisplayWidth,DataType_ID,DataTypeInformation,InputMask_ID,EnterUserID,EnterVersionID,LastChgUserID,LastChgVersionID)  
            VALUES  
             (@Entity_ID, 1,NULL,3,4,1,1, N'ID', N'ID', N'ID',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
            ,(@Entity_ID, 2,NULL,3,4,1,1, N'Version_ID', N'Version_ID', N'Version_ID',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
            ,(@Entity_ID, 3,NULL,3,4,1,1, N'Status_ID', N'Status_ID', N'Status_ID',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
            ,(@Entity_ID, 4,NULL,3,4,1,1, N'ValidationStatus_ID', N'ValidationStatus_ID', N'ValidationStatus_ID',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
            ,(@Entity_ID, 5,NULL,3,4,1,1, N'EnterDTM', N'EnterDTM', N'EnterDTM',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
            ,(@Entity_ID, 6,NULL,3,4,1,1, N'EnterUserID', N'EnterUserID', N'EnterUserID',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
            ,(@Entity_ID, 7,NULL,3,4,1,1, N'EnterVersionID', N'EnterVersionID', N'EnterVersionID',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
            ,(@Entity_ID, 8,NULL,3,4,1,1, N'LastChgDTM', N'LastChgDTM', N'LastChgDTM',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
            ,(@Entity_ID, 9,NULL,3,4,1,1, N'LastChgUserID', N'LastChgUserID', N'LastChgUserID',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
            ,(@Entity_ID, 10,NULL,3,4,1,1, N'LastChgVersionID', N'LastChgVersionID', N'LastChgVersionID',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
            ,(@Entity_ID, 11,NULL,3,4,1,1, N'LastChgTS', N'LastChgTS', N'LastChgTS',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
            ,(@Entity_ID, 12,NULL,3,4,1,1, N'Hierarchy_ID', N'Hierarchy_ID', N'Hierarchy_ID',0,1,100,1,@User_ID,@Version_ID,@User_ID,@Version_ID)  
            ,(@Entity_ID, 13,NULL,3,4,1,1, N'Parent_HP_ID', N'Parent_HP_ID', N'Parent_HP_ID',0,1,100,1,@User_ID,@Version_ID,@User_ID,@Version_ID)  
            ,(@Entity_ID, 14,NULL,3,4,1,1, N'Child_EN_ID', N'Child_EN_ID', N'Child_EN_ID',0,1,100,1,@User_ID,@Version_ID,@User_ID,@Version_ID)  
            ,(@Entity_ID, 15,NULL,3,4,1,1, N'Child_HP_ID', N'Child_HP_ID', N'Child_HP_ID',0,1,100,1,@User_ID,@Version_ID,@User_ID,@Version_ID)  
            ,(@Entity_ID, 16,NULL,3,4,1,1, N'ChildType_ID', N'ChildType_ID', N'ChildType_ID',0,1,100,1,@User_ID,@Version_ID,@User_ID,@Version_ID)  
            ,(@Entity_ID, 17,NULL,3,4,1,1, N'SortOrder', N'SortOrder', N'SortOrder',0,1,NULL,1,@User_ID,@Version_ID,@User_ID,@Version_ID)  
            ,(@Entity_ID, 18,NULL,1,4,1,1, N'LevelNumber', N'LevelNumber', N'LevelNumber',0,2,NULL,1,@User_ID,@Version_ID,@User_ID,@Version_ID)  
            ,(@Entity_ID, 20,NULL,3,4,1,1, N'MUID', N'MUID', N'MUID',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
            ,(@Entity_ID, 21,NULL,3,4,1,1, N'AsOf_ID', N'AsOf_ID', N'AsOf_ID',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
            ;  
        END; --if  
  
        SELECT @HierarchyTable = HierarchyTable FROM mdm.tblEntity WHERE ID = @Entity_ID;  
  
        --Update/Insert Hierarchy details  
        IF @EditMode = @EditMode_Update  
        BEGIN  
  
            --Update details in Hierarchy table  
            UPDATE mdm.tblHierarchy SET  
                [Name] = ISNULL(@HierarchyName, [Name]),  
                IsMandatory = ISNULL(@IsMandatory, IsMandatory),  
                LastChgDTM = @CurrentDTM,  
                LastChgUserID = @User_ID,  
                LastChgVersionID = @Version_ID  
            WHERE  
                ID = @ExistingHierarchy_ID;  
  
            --Populate output parameters  
            SET @Return_MUID = @ExistingHierarchy_MUID;  
  
            --Add all leaf nodes if mandatory  
            IF @IsMandatory = 1  
            BEGIN  
  
                SET @SQL = N'  
                DECLARE @TempTable TABLE (ID INT NOT NULL, Version_ID INT NOT NULL);  
                DECLARE @TempID AS INT, @Version_ID AS INT;  
  
                INSERT INTO @TempTable (ID, Version_ID)  
                SELECT  
                    ID,  
                    Version_ID  
                FROM  
                    mdm.' + QUOTENAME(@EntityTable) + N' AS EN  
                WHERE  
                    EN.Status_ID = 1 AND  
                    EN.ID NOT IN  
                    (  
                        SELECT Child_EN_ID  
                        FROM mdm.' + QUOTENAME(@HierarchyTable) + N' AS HR  
                        WHERE  
                            HR.ChildType_ID = 1 AND  
                            HR.Status_ID = 1 AND  
                            HR.Hierarchy_ID = @Hierarchy_ID  
                    )  
                 ORDER BY ID ASC;  
  
                WHILE EXISTS(SELECT 1 FROM @TempTable) BEGIN  
  
                    SELECT TOP 1 @TempID = ID, @Version_ID = Version_ID FROM @TempTable  ORDER BY ID;  
  
                    EXEC mdm.udpHierarchyCreate @User_ID, @Version_ID, @Entity_ID, @Hierarchy_ID, 0, @TempID, 1;  
  
                    DELETE FROM @TempTable WHERE ID = @TempID AND Version_ID = @Version_ID;  
  
                END; --while';  
  
                --Execute the dynamic SQL  
                --PRINT(@SQL):  
                EXEC sp_executesql @SQL,  
                N'@User_ID INT, @Entity_ID INT, @Hierarchy_ID INT',  
                @User_ID, @Entity_ID, @ExistingHierarchy_ID;  
  
            END; --if  
  
        END  
        ELSE  
        BEGIN --New Hierarchy  
  
            -- Validate @Name  
            IF NULLIF(@HierarchyName, N'') IS NULL  
            BEGIN  
                RAISERROR('MDSERR100003|The Name is not valid.', 16, 1);  
                RETURN;  
            END;  
  
            --Accept an explicit MUID (for clone operations) or generate a new one  
            SET @Return_MUID = ISNULL(@Hierarchy_MUID, NEWID());  
  
            --Insert details into Hierarchy table  
            INSERT INTO mdm.tblHierarchy  
            (  
                 Entity_ID  
                ,[Name]  
                ,IsMandatory  
                ,MUID  
                ,EnterDTM  
                ,EnterUserID  
                ,EnterVersionID  
                ,LastChgDTM  
                ,LastChgUserID  
                ,LastChgVersionID  
            )  
            VALUES  
            (  
                @Entity_ID,  
                LEFT(@HierarchyName, 50),  
                @IsMandatory,  
                @Return_MUID,  
                @CurrentDTM,  
                @User_ID,  
                @Version_ID,  
                @CurrentDTM,  
                @User_ID,  
                @Version_ID  
            );  
  
            --Save the identity value  
            SET @ExistingHierarchy_ID = SCOPE_IDENTITY();  
  
            /*  
            Copy all the members into the hierarchy if it is a mandatory hierarchy (in case the entity was created  
            without a Hierarchy and then one was added) or another Hierarchy was just added.  
            */  
            IF @IsMandatory = 1 BEGIN  
  
                SELECT @SQL = N'  
                INSERT INTO mdm.' + QUOTENAME(@HierarchyTable) + N'  
                (  
                    Version_ID,  
                    Status_ID,  
                    ValidationStatus_ID,  
                    Hierarchy_ID,  
                    Parent_HP_ID,  
                    ChildType_ID,  
                    Child_EN_ID,  
                    SortOrder,  
                    EnterUserID,  
                    EnterVersionID,  
                    LastChgUserID,  
                    LastChgVersionID  
                )  
                SELECT  
                    E.Version_ID,  
                    1,  
                    0,  
                    @Hierarchy_ID,  
                    NULL,    --Parent_HP_ID  
                    1,       --ChildType_ID = EN  
                    E.ID,    --Child_EN_ID  
                    E.ID,    --SortOrder  
                    @User_ID,  
                    @Version_ID,  
                    @User_ID,  
                    @Version_ID  
                FROM mdm.' + QUOTENAME(@EntityTable) + N' AS E  
                INNER JOIN mdm.tblModelVersion AS V  
                    ON E.Version_ID = V.ID  
                WHERE V.Status_ID <> 3;';  
  
                --Execute the dynamic SQL  
                --PRINT(@SQL);  
                EXEC sp_executesql @SQL,  
                    N'@User_ID INT, @Version_ID INT, @Hierarchy_ID INT',  
                    @User_ID, @Version_ID, @ExistingHierarchy_ID;  
  
            END; --if  
        END; --if  
  
        --Recreate the views  
        EXEC mdm.udpCreateViews @Model_ID = @Model_ID;  
        EXEC mdm.udpEntityStagingCreateErrorDetailViews @Entity_ID = @Entity_ID;  
  
        --Recreate leaf staging SProc when HP and CM tables are added.  
        IF @IsHierarchyEnabled = 0 -- if hierarchies were not already enabled ...  
            AND @RecreateLeafStagingProc = 1  
        BEGIN  
            EXEC mdm.udpEntityStagingCreateLeafStoredProcedure @Entity_ID;  
        END  
  
        --Return values  
        SET @Return_ID = @ExistingHierarchy_ID;  
  
        --Commit only if we are not nested  
        IF @TranCounter = 0 COMMIT TRANSACTION;  
  
        -- Send the message  
	    EXEC mdm.udpPerformanceQueueSave;  
  
        RETURN(0);  
  
    END TRY  
    --Compensate as necessary  
    BEGIN CATCH  
  
        -- Get error info.  
        DECLARE  
            @ErrorMessage NVARCHAR(4000),  
            @ErrorSeverity INT,  
            @ErrorState INT,  
            @ErrorNumber INT,  
            @ErrorLine INT,  
            @ErrorProcedure NVARCHAR(126);  
        EXEC mdm.udpGetErrorInfo  
            @ErrorMessage = @ErrorMessage OUTPUT,  
            @ErrorSeverity = @ErrorSeverity OUTPUT,  
            @ErrorState = @ErrorState OUTPUT,  
            @ErrorNumber = @ErrorNumber OUTPUT,  
            @ErrorLine = @ErrorLine OUTPUT,  
            @ErrorProcedure = @ErrorProcedure OUTPUT  
  
        SET @ErrorMessage = CONCAT(@ErrorMessage, N', @ErrorNumber = ', @ErrorNumber, N', @ErrorProcedure = "', @ErrorProcedure, N'", line ', @ErrorLine);  
  
        IF @TranCounter = 0 ROLLBACK TRANSACTION;  
        ELSE IF XACT_STATE() <> -1 ROLLBACK TRANSACTION TX;  
  
        RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);  
  
        SELECT @Return_ID = NULL, @Return_MUID = NULL;  
        RETURN;  
  
    END CATCH;  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpEntityLevelCount]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    DECLARE @i INT;  
    EXEC mdm.udpEntityLevelCount 6, @i OUTPUT;  
    SELECT @i;  
*/  
CREATE PROCEDURE [mdm].[udpEntityLevelCount]  
(  
    @Entity_ID      INT,  
    @Levels         SMALLINT OUTPUT,  
    @CorrelationID  UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
AS BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE @SQL            NVARCHAR(MAX) ,  
            @HierarchyTable NVARCHAR(258);  
  
    SET @Levels = CAST(-1 AS SMALLINT);  
  
    SELECT @HierarchyTable = HierarchyTable  
    FROM [mdm].tblEntity WHERE ID = @Entity_ID;  
         
    IF @HierarchyTable IS NULL RETURN;  
  
    SET @SQL = N'SELECT @Levels = ISNULL((SELECT MAX(LevelNumber) FROM mdm.' + quotename(@HierarchyTable) + N'), 0);';  
    EXEC sp_executesql @SQL, N'@Levels INT OUTPUT', @Levels OUTPUT;  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpEntityMemberAnnotationDelete]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
This can be called to delete Annotations  
EXEC mdm.udpEntityMemberAnnotationDelete @User_ID = 1, @Model_Name = N'Product', @Entity_Name = N'Product', @Version_Name = N'Version 1', @MemberType_ID= 1, @Annotation_ID = 1;  
*/  
CREATE PROCEDURE [mdm].[udpEntityMemberAnnotationDelete]  
(  
    @User_ID        INT,  
    @Model_Name     NVARCHAR(50) = NULL,  
    @Model_MUID     UNIQUEIDENTIFIER = NULL,  
    @Entity_Name    NVARCHAR(50) = NULL,  
    @Entity_MUID    UNIQUEIDENTIFIER= NULL,  
    @Version_Name   NVARCHAR(50) = NULL,  
    @Version_MUID   UNIQUEIDENTIFIER = NULL,  
    @MemberType_ID  TINYINT,  
    @Annotation_ID  INT,  
    @CorrelationID  UNIQUEIDENTIFIER = NULL -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    DECLARE @GuidEmpty              UNIQUEIDENTIFIER = CAST(0x0 AS UNIQUEIDENTIFIER),  
            @Model_ID               INT,  
            @Entity_ID              INT,  
            @Version_ID             INT,  
            @Owner_ID               INT,  
            @AnnotationTableName    SYSNAME,  
            @SQL                    NVARCHAR(MAX);  
  
   SELECT   
        @Model_MUID = NULLIF(@Model_MUID, @GuidEmpty),  
        @Model_Name = NULLIF(LTRIM(RTRIM(@Model_Name)), N''),  
        @Entity_MUID = NULLIF(@Entity_MUID, @GuidEmpty),  
        @Entity_Name = NULLIF(LTRIM(RTRIM(@Entity_Name)), N''),  
        @Version_MUID = NULLIF(@Version_MUID, @GuidEmpty),  
        @Version_Name = NULLIF(LTRIM(RTRIM(@Version_Name)), N'');  
  
    IF @User_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR100009|The User ID is not valid.', 16, 1);  
        RETURN;  
    END  
  
    IF @MemberType_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR210021|MemberType ID is not valid.', 16, 1);  
        RETURN;  
    END  
  
    IF @Annotation_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR310032|Annotation ID are not valid.', 16, 1);  
        RETURN;  
    END  
  
    EXEC mdm.udpInformationLookupModel @User_ID = @User_ID, @Model_MUID = @Model_MUID, @Model_Name = @Model_Name, @ID = @Model_ID OUTPUT ;  
    IF @Model_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR300005|The supplied model is not valid.', 16, 1);  
        RETURN;  
    END;  
  
    SELECT @Version_ID = ID  
    FROM mdm.tblModelVersion   
    WHERE  
            (@Version_MUID IS NOT NULL OR @Version_Name IS NOT NULL)   
        AND (@Version_MUID IS NULL OR MUID = @Version_MUID)   
        AND (@Version_Name IS NULL OR Name = @Version_Name)  
        AND Model_ID = @Model_ID;  
    IF @Version_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR300006|The supplied version is not valid.', 16, 1);  
        RETURN;  
    END;  
  
    EXEC mdm.udpInformationLookupEntity @User_ID = @User_ID, @Model_ID = @Model_ID, @Entity_MUID = @Entity_MUID, @Entity_Name = @Entity_Name, @ID = @Entity_ID OUTPUT;  
    IF @Entity_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR300008|The supplied entity is not valid.', 16, 1);  
        RETURN;  
    END;  
  
    SET @AnnotationTableName = CONCAT(mdm.udfTableNameGetByID(@Entity_ID, @MemberType_ID), N'_AN');  
  
    SET @SQL = CONCAT(N'  
        SELECT @Owner_ID = [EnterUserID]  
        FROM [mdm].', QUOTENAME(@AnnotationTableName), N'  
        WHERE Version_ID = @VersionID AND ID = @Annotation_ID');  
    EXEC sp_executesql @SQL, N'@VersionID INT, @Annotation_ID INT, @Owner_ID INT OUTPUT', @Version_ID, @Annotation_ID, @Owner_ID = @Owner_ID OUTPUT;  
    IF @Owner_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR310032|The annotation ID is not valid.', 16, 1);  
        RETURN;  
    END  
  
    IF @User_ID != @Owner_ID AND NOT EXISTS(  
        SELECT 1 FROM [mdm].[viw_SYSTEM_SECURITY_USER_MODEL] WHERE [User_ID] = @User_ID AND Privilege_ID = 5 /*Admin*/  
    )  
    BEGIN  
        RAISERROR('MDSERR120002|The user does not have permission to perform this operation.', 16, 1);  
        RETURN;  
    END  
  
    SET @SQL = CONCAT(N'DELETE [mdm].', QUOTENAME(@AnnotationTableName), N' WHERE Version_ID = @VersionID AND ID = @Annotation_ID');  
    EXEC sp_executesql @SQL, N'@VersionID INT, @Annotation_ID INT', @Version_ID, @Annotation_ID;  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpEntityMemberAnnotationSave]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
--This can be called to save or create a new Annotations  
--Create or Update annotation Transaction  
EXEC mdm.udpEntityMemberAnnotationSave @User_ID = 1, @Model_Name = N'Product', @Entity_Name = N'Product', @Version_Name = N'Version 1', @MemberType_ID= 1, @Revision_ID = 0, @Member_Code = N'BB-8107', @Comment = N'haha';  
  
EXEC mdm.udpEntityMemberAnnotationSave @User_ID = 1, @Model_Name = N'Product', @Entity_Name = N'Product', @Version_Name = N'Version 1', @MemberType_ID= 1, @Comment = N'haha2', @Annotation_ID = 1;  
*/  
CREATE PROCEDURE [mdm].[udpEntityMemberAnnotationSave]  
(  
    @User_ID        INT,  
    @Model_Name     NVARCHAR(50) = NULL,  
    @Model_MUID     UNIQUEIDENTIFIER = NULL,  
    @Entity_Name    NVARCHAR(50) = NULL,  
    @Entity_MUID    UNIQUEIDENTIFIER= NULL,  
    @Version_Name   NVARCHAR(50) = NULL,  
    @Version_MUID   UNIQUEIDENTIFIER = NULL,  
    @MemberType_ID  TINYINT,  
    @Revision_ID    BIGINT = NULL,  
    @Annotation_ID  INT = NULL OUTPUT,  
    @Comment        NVARCHAR(500),  
    @CorrelationID  UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
  
    DECLARE @GuidEmpty                      UNIQUEIDENTIFIER = CAST(0x0 AS UNIQUEIDENTIFIER),  
            @Owner_ID                       INT,  
            @Model_ID                       INT,  
            @Entity_ID                      INT,  
            @Version_ID                     INT,  
            @Member_ID                      INT,  
  
            @MemberIDColumn                 SYSNAME,  
            @EntityMemberTableName          SYSNAME,  
            @EntityMemberHistoryTableName   SYSNAME,  
            @AnnotationTableName            SYSNAME,  
  
            @Privilege_ID                   TINYINT,  
            @AccessPermission               TINYINT,  
            @Permission_Access              TINYINT = 4,  
            @Permission_Inferred            TINYINT = 99,  
            @AccessPermission_Update        TINYINT = 2,  
  
            @MemberType_Leaf                TINYINT = 1,  
            @MemberType_Consolidated        TINYINT = 2,  
            @MemberType_Collection          TINYINT = 3,  
            @MemberType_Hierarchy           TINYINT = 4,  
            @MemberType_CollectionMember    TINYINT = 5,  
  
            @SQL                            NVARCHAR(MAX);  
  
    SELECT  
        @User_ID = NULLIF(@User_ID, 0),  
        @Model_MUID = NULLIF(@Model_MUID, @GuidEmpty),  
        @Model_Name = NULLIF(LTRIM(RTRIM(@Model_Name)), N''),  
        @Entity_MUID = NULLIF(@Entity_MUID, @GuidEmpty),  
        @Entity_Name = NULLIF(LTRIM(RTRIM(@Entity_Name)), N''),  
        @Version_MUID = NULLIF(@Version_MUID, @GuidEmpty),  
        @Version_Name = NULLIF(LTRIM(RTRIM(@Version_Name)), N''),  
        @MemberType_ID = NULLIF(@MemberType_ID, 0),  
        @Revision_ID = NULLIF(@Revision_ID, 0),  
        @Annotation_ID = NULLIF(@Annotation_ID, 0),  
        @Comment = NULLIF(LTRIM(RTRIM(@Comment)), N'');  
  
    IF @User_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR100009|The User ID is not valid.', 16, 1);  
        RETURN;  
    END  
  
    IF @Comment IS NULL  
    BEGIN  
        RAISERROR('MDSERR310031|Comment is not valid.', 16, 1);  
        RETURN;  
    END  
  
    IF @MemberType_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR210021|MemberType ID is not valid.', 16, 1);  
        RETURN;  
    END  
  
    EXEC mdm.udpInformationLookupModel @User_ID = @User_ID, @Model_MUID = @Model_MUID, @Model_Name = @Model_Name, @ID = @Model_ID OUTPUT;  
    IF @Model_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR300005|The supplied model is not valid.', 16, 1);  
        RETURN;  
    END;  
  
    SELECT @Version_ID = ID  
    FROM mdm.tblModelVersion  
    WHERE  
            (@Version_MUID IS NOT NULL OR @Version_Name IS NOT NULL)  
        AND (@Version_MUID IS NULL OR MUID = @Version_MUID)  
        AND (@Version_Name IS NULL OR Name = @Version_Name)  
        AND Model_ID = @Model_ID;  
    IF @Version_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR300006|The supplied version is not valid.', 16, 1);  
        RETURN;  
    END;  
  
    EXEC mdm.udpInformationLookupEntity @User_ID = @User_ID, @Model_ID = @Model_ID, @Entity_MUID = @Entity_MUID, @Entity_Name = @Entity_Name, @ID = @Entity_ID OUTPUT;  
    IF @Entity_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR300008|The supplied entity is not valid.', 16, 1);  
        RETURN;  
    END;  
  
    SET @EntityMemberTableName = mdm.udfTableNameGetByID(@Entity_ID, @MemberType_ID);  
    SET @EntityMemberHistoryTableName = CONCAT(@EntityMemberTableName, N'_HS');  
    SET @AnnotationTableName = CONCAT(@EntityMemberTableName, N'_AN');  
    SET @MemberIDColumn =  
        CASE @MemberType_ID  
            WHEN @MemberType_Leaf THEN N'EN_ID'  
            WHEN @MemberType_Consolidated THEN N'HP_ID'  
            WHEN @MemberType_Collection THEN N'CN_ID'  
            WHEN @MemberType_Hierarchy THEN N'HR_ID'  
            WHEN @MemberType_CollectionMember THEN N'CM_ID'  
        END;  
  
    IF @Annotation_ID IS NULL  
    BEGIN  
        IF @Revision_ID IS NULL  
        BEGIN  
            RAISERROR('MDSERR200223|Revision ID is not valid.', 16, 1);  
            RETURN;  
        END  
  
        SET @SQL = CONCAT(N'  
            SELECT @Member_ID = ID  
            FROM [mdm].', QUOTENAME(@EntityMemberTableName), N'  
            WHERE Version_ID = @Version_ID AND LastChgTS = @Revision_ID;  
              
            IF @Member_ID IS NULL  
            BEGIN  
                SELECT @Member_ID = ', QUOTENAME(@MemberIDColumn), N'  
                FROM [mdm].', QUOTENAME(@EntityMemberHistoryTableName), N'  
                WHERE Version_ID = @Version_ID AND ID = @Revision_ID;  
            END');  
  
        EXEC sp_executesql @SQL, N'@Version_ID INT, @Revision_ID BIGINT, @Member_ID INT OUTPUT',  
                                   @Version_ID,     @Revision_ID,        @Member_ID OUTPUT;  
  
        IF @Member_ID IS NULL  
        BEGIN  
            RAISERROR('MDSERR200223|Revision ID is not valid.', 16, 1);  
            RETURN;  
        END  
  
        EXEC mdm.udpSecurityMemberResolverGet @User_ID, @Version_ID, NULL,NULL, @Entity_ID, @Member_ID, @MemberType_ID, @Privilege_ID OUTPUT, @AccessPermission OUTPUT;  
  
        -- User need have aleast one attribute update permission to add annotation  
        IF NOT ((@Privilege_ID = @Permission_Access OR @Privilege_ID = @Permission_Inferred) AND EXISTS (  
            SELECT 1  
            FROM mdm.viw_SYSTEM_SECURITY_USER_ATTRIBUTE sec  
            INNER JOIN mdm.tblAttribute att  
            ON sec.ID = att.ID  
            WHERE sec.User_ID = @User_ID  
                AND att.Entity_ID = @Entity_ID  
                AND att.MemberType_ID = @MemberType_ID  
                AND (AccessPermission & @AccessPermission_Update) = @AccessPermission_Update  
        ))  
        BEGIN  
            RAISERROR('MDSERR120002|The user does not have permission to perform this operation.', 16, 1);  
            RETURN;  
        END  
  
        SET @SQL = CONCAT(N'  
            INSERT INTO [mdm].', QUOTENAME(@AnnotationTableName), N'  
            (  
                Version_ID,  
                Revision_ID,  
                Comment,  
                EnterUserID,  
                LastChgUserID  
            )  
            VALUES  
            (  
                @Version_ID,  
                @Revision_ID,  
                @Comment,  
                @User_ID,  
                @User_ID  
            );')  
  
        EXEC sp_executesql @SQL, N'@Version_ID INT, @Revision_ID INT, @Comment NVARCHAR(500), @User_ID INT',  
                                   @Version_ID,     @Revision_ID,     @Comment,               @User_ID;  
  
        SET @Annotation_ID = SCOPE_IDENTITY();  
    END  
    ELSE  
    BEGIN  
        SET @SQL = CONCAT(N'  
            SELECT @Owner_ID = [EnterUserID]  
            FROM [mdm].', QUOTENAME(@AnnotationTableName), N'  
            WHERE Version_ID = @VersionID AND ID = @Annotation_ID');  
        EXEC sp_executesql @SQL, N'@VersionID INT, @Annotation_ID INT, @Owner_ID INT OUTPUT', @Version_ID, @Annotation_ID, @Owner_ID OUTPUT;  
        IF @Owner_ID IS NULL  
        BEGIN  
            RAISERROR('MDSERR310032|The annotation ID is not valid.', 16, 1);  
            RETURN;  
        END  
  
        IF @User_ID != @Owner_ID AND NOT EXISTS(  
            SELECT 1 FROM [mdm].[viw_SYSTEM_SECURITY_USER_MODEL] WHERE [User_ID] = @User_ID AND Privilege_ID = 5 /*Admin*/  
        )  
        BEGIN  
            RAISERROR('MDSERR120002|The user does not have permission to perform this operation.', 16, 1);  
            RETURN;  
        END  
  
        SET @SQL = CONCAT(N'  
            UPDATE [mdm].', QUOTENAME(@AnnotationTableName) + N'  
            SET Comment = @Comment,  
                LastChgDTM = GETUTCDATE(),  
                LastChgUserID = @User_ID  
            WHERE ID = @Annotation_ID AND Version_ID = @Version_ID;');  
  
        EXEC sp_executesql @SQL, N'@Version_ID INT, @Annotation_ID INT, @Comment NVARCHAR(500), @User_ID INT',  
                                   @Version_ID,     @Annotation_ID,     @Comment,               @User_ID;  
  
        SET @Annotation_ID = @Annotation_ID;  
    END  
  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpEntityMemberAnnotationsGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
This can be called to get Annotations for a revision.  
EXEC mdm.udpEntityMemberAnnotationsGet @User_ID = 1, @Model_Name = N'Product', @Entity_Name = N'Product', @Version_Name = N'Version 1', @MemberType_ID= 1, @Revision_ID = 0  
*/  
CREATE PROCEDURE [mdm].[udpEntityMemberAnnotationsGet]  
(  
    @User_ID        INT,  
    @Model_Name     NVARCHAR(50) = NULL,  
    @Model_MUID     UNIQUEIDENTIFIER = NULL,  
    @Entity_Name    NVARCHAR(50) = NULL,  
    @Entity_MUID    UNIQUEIDENTIFIER= NULL,  
    @Version_Name   NVARCHAR(50) = NULL,  
    @Version_MUID   UNIQUEIDENTIFIER = NULL,  
    @MemberType_ID  TINYINT,  
    @Revision_ID    BIGINT,  
    @CorrelationID  UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
  
    DECLARE @GuidEmpty                      UNIQUEIDENTIFIER = CAST(0x0 AS UNIQUEIDENTIFIER),  
            @Model_ID                       INT,  
            @Entity_ID                      INT,  
            @Version_ID                     INT,  
            @Member_ID                      INT,  
  
            @MemberIDColumn                 SYSNAME,  
            @EntityMemberTableName          SYSNAME,  
            @EntityMemberHistoryTableName   SYSNAME,  
            @AnnotationTableName            SYSNAME,  
  
            @ModelPrivilege_ID              TINYINT,  
            @Privilege_ID                   TINYINT,  
            @AccessPermission               TINYINT,  
            @Permission_Access              TINYINT = 4,  
            @Permission_Inferred            TINYINT = 99,  
            @Permission_Admin               TINYINT = 5,  
            @AccessPermission_Read          TINYINT = 0,  
            @AccessPermission_ReadUpdateDelete  TINYINT = 6,  
  
            @MemberType_Leaf                TINYINT = 1,  
            @MemberType_Consolidated        TINYINT = 2,  
            @MemberType_Collection          TINYINT = 3,  
            @MemberType_Hierarchy           TINYINT = 4,  
            @MemberType_CollectionMember    TINYINT = 5,  
  
            @IsModelAdmin                   BIT = 0,  
  
            @SQL                            NVARCHAR(MAX);  
  
    SELECT  
        @User_ID = NULLIF(@User_ID, 0),  
        @Model_MUID = NULLIF(@Model_MUID, @GuidEmpty),  
        @Model_Name = NULLIF(LTRIM(RTRIM(@Model_Name)), N''),  
        @Entity_MUID = NULLIF(@Entity_MUID, @GuidEmpty),  
        @Entity_Name = NULLIF(LTRIM(RTRIM(@Entity_Name)), N''),  
        @Version_MUID = NULLIF(@Version_MUID, @GuidEmpty),  
        @Version_Name = NULLIF(LTRIM(RTRIM(@Version_Name)), N''),  
        @MemberType_ID = NULLIF(@MemberType_ID, 0),  
        @Revision_ID = NULLIF(@Revision_ID, 0);  
  
    IF @User_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR100009|The User ID is not valid.', 16, 1);  
        RETURN;  
    END  
  
    IF @Revision_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR200223|Revision ID is not valid.', 16, 1);  
        RETURN;  
    END  
  
    IF @MemberType_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR210021|MemberType ID is not valid.', 16, 1);  
        RETURN;  
    END  
  
    EXEC mdm.udpInformationLookupModel @User_ID = @User_ID, @Model_MUID = @Model_MUID, @Model_Name = @Model_Name, @ID = @Model_ID OUTPUT, @Privilege_ID = @ModelPrivilege_ID OUTPUT;  
    IF @Model_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR300005|The supplied model is not valid.', 16, 1);  
        RETURN;  
    END;  
  
    IF @ModelPrivilege_ID = @Permission_Admin  
    BEGIN  
        SET @IsModelAdmin = 1;  
    END  
  
    SELECT @Version_ID = ID  
    FROM mdm.tblModelVersion   
    WHERE  
            (@Version_MUID IS NOT NULL OR @Version_Name IS NOT NULL)   
        AND (@Version_MUID IS NULL OR MUID = @Version_MUID)   
        AND (@Version_Name IS NULL OR Name = @Version_Name)  
        AND Model_ID = @Model_ID;  
    IF @Version_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR300006|The supplied version is not valid.', 16, 1);  
        RETURN;  
    END;  
  
    EXEC mdm.udpInformationLookupEntity @User_ID = @User_ID, @Model_ID = @Model_ID, @Entity_MUID = @Entity_MUID, @Entity_Name = @Entity_Name, @ID = @Entity_ID OUTPUT;  
    IF @Entity_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR300008|The supplied entity is not valid.', 16, 1);  
        RETURN;  
    END;  
  
    SET @EntityMemberTableName = mdm.udfTableNameGetByID(@Entity_ID, @MemberType_ID);  
    SET @EntityMemberHistoryTableName = CONCAT(@EntityMemberTableName, N'_HS');  
    SET @AnnotationTableName = CONCAT(@EntityMemberTableName, N'_AN');  
    SET @MemberIDColumn =  
        CASE @MemberType_ID  
            WHEN @MemberType_Leaf THEN N'EN_ID'  
            WHEN @MemberType_Consolidated THEN N'HP_ID'  
            WHEN @MemberType_Collection THEN N'CN_ID'  
            WHEN @MemberType_Hierarchy THEN N'HR_ID'  
            WHEN @MemberType_CollectionMember THEN N'CM_ID'  
        END;  
  
    SET @SQL = CONCAT(N'  
        SELECT @Member_ID = ID  
        FROM [mdm].', QUOTENAME(@EntityMemberTableName), N'  
        WHERE Version_ID = @Version_ID AND LastChgTS = @Revision_ID;  
              
        IF @Member_ID IS NULL  
        BEGIN  
            SELECT @Member_ID = ', QUOTENAME(@MemberIDColumn), N'  
            FROM [mdm].', QUOTENAME(@EntityMemberHistoryTableName), N'  
            WHERE Version_ID = @Version_ID AND ID = @Revision_ID;  
        END');  
  
    EXEC sp_executesql @SQL, N'@Version_ID INT, @Revision_ID BIGINT, @Member_ID INT OUTPUT',  
                               @Version_ID,     @Revision_ID,        @Member_ID OUTPUT;  
  
    IF @Member_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR200223|Revision ID is not valid.', 16, 1);  
        RETURN;  
    END  
  
    EXEC mdm.udpSecurityMemberResolverGet @User_ID, @Version_ID, NULL,NULL, @Entity_ID, @Member_ID, @MemberType_ID, @Privilege_ID OUTPUT, @AccessPermission OUTPUT;  
  
    IF NOT (@Privilege_ID = @Permission_Access OR @Privilege_ID = @Permission_Inferred)  
    BEGIN  
        RAISERROR('MDSERR120002|The user does not have permission to perform this operation.', 16, 1);  
        RETURN;  
    END  
  
    SET @SQL = CONCAT(N'  
        SELECT  
            a.ID,  
            a.Comment,  
            a.Revision_ID,  
            a.EnterDTM,  
            eu.UserName AS EnterUserName,  
            eu.ID AS EnterUserID,  
            eu.MUID AS EnterUserMUID,  
            a.LastChgDTM,  
            lu.UserName AS LastChgUserName,  
            lu.ID AS LastChgUserID,  
            lu.MUID AS LastChgUserMUID,  
            CONVERT(BIGINT, a.LastChgTS) AS LastChgTS,  
            @Permission_Access AS SecurityPermission,  
            CASE  
                WHEN @IsModelAdmin = 1 OR a.EnterUserID = @User_ID THEN @AccessPermission_ReadUpdateDelete  
                ELSE @AccessPermission_Read  
            END AS AccessPermission  
        FROM [mdm].', QUOTENAME(@AnnotationTableName), ' a  
        INNER JOIN [mdm].[tblUser] eu on eu.ID = a.EnterUserID  
        INNER JOIN [mdm].[tblUser] lu on lu.ID = a.LastChgUserID  
        WHERE  
            Version_ID = @Version_ID  
            AND Revision_ID = @Revision_ID  
        ');  
        EXEC sp_executesql @SQL, N'@User_ID INT, @Version_ID INT, @Revision_ID BIGINT, @IsModelAdmin BIT, @Permission_Access TINYINT, @AccessPermission_Read TINYINT, @AccessPermission_ReadUpdateDelete TINYINT',  
                                   @User_ID,     @Version_ID,     @Revision_ID,        @IsModelAdmin,     @Permission_Access,         @AccessPermission_Read,         @AccessPermission_ReadUpdateDelete;  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpEntityMemberChangesetDelete]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpEntityMemberChangesetDelete]  
(  
    @User_ID                INT,  
    @Model_Name             NVARCHAR(50) = NULL,  
    @Model_MUID             UNIQUEIDENTIFIER = NULL,  
    @Version_Name           NVARCHAR(50) = NULL,  
    @Version_MUID           UNIQUEIDENTIFIER = NULL,  
    @ChangesetName          NVARCHAR(250) = NULL,  
    @ChangesetMUID          UNIQUEIDENTIFIER = NULL,  
    @Description            NVARCHAR(500) = NULL,  
    @CorrelationID          UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
  
    DECLARE @GuidEmpty                  UNIQUEIDENTIFIER = CAST(0x0 AS UNIQUEIDENTIFIER),  
            @Owner_ID                   INT,  
            @Model_ID                   INT,  
            @Entity_ID                  INT,  
            @Version_ID                 INT,  
            @Changeset_ID               INT,  
  
            @CurrentState               TINYINT,  
            @ChangesetStatus_Open       TINYINT = 1,  
            @ChangesetStatus_Pending    TINYINT = 2,  
            @ChangesetStatus_Approved   TINYINT = 3,  
            @ChangesetStatus_Rejected   TINYINT = 4,  
            @ChangesetStatus_Committed  TINYINT = 5,  
  
            @Permission_Deny            TINYINT = 1,  
  
            @ChangesetTableName         SYSNAME,  
            @PendingChangesTableName    SYSNAME,  
            @TruncationGuard            NVARCHAR(MAX) = N'',  
            @SQL                        NVARCHAR(MAX);  
  
    SELECT  
        @User_ID = NULLIF(@User_ID, 0),  
        @Model_MUID = NULLIF(@Model_MUID, @GuidEmpty),  
        @Model_Name = NULLIF(LTRIM(RTRIM(@Model_Name)), N''),  
        @Version_MUID = NULLIF(@Version_MUID, @GuidEmpty),  
        @Version_Name = NULLIF(LTRIM(RTRIM(@Version_Name)), N''),  
        @ChangesetMUID = NULLIF(@ChangesetMUID, @GuidEmpty),  
        @ChangesetName = NULLIF(LTRIM(RTRIM(@ChangesetName)), N'');  
  
    IF @User_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR100009|The User ID is not valid.', 16, 1);  
        RETURN;  
    END  
  
    SELECT  
         @Model_ID = m.ID  
    FROM mdm.tblModel m  
    INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_MODEL s  
    ON  m.ID = s.ID  
        AND s.User_ID = @User_ID  
    WHERE (@Model_MUID IS NOT NULL OR @Model_Name IS NOT NULL)  
        AND (@Model_MUID IS NULL OR @Model_MUID = m.MUID)  
        AND (@Model_Name IS NULL OR @Model_Name = m.Name)  
        AND s.Privilege_ID <> @Permission_Deny  
  
    IF @Model_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR300005|The supplied model is not valid.', 16, 1);  
        RETURN;  
    END;  
  
    SELECT @Version_ID = ID  
    FROM mdm.tblModelVersion  
    WHERE (@Version_MUID IS NOT NULL OR @Version_Name IS NOT NULL)  
        AND (@Version_MUID IS NULL OR MUID = @Version_MUID)  
        AND (@Version_Name IS NULL OR Name = @Version_Name)  
        AND Model_ID = @Model_ID;  
  
    IF @Version_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR300006|The supplied version is not valid.', 16, 1);  
        RETURN;  
    END;  
  
    SET @ChangesetTableName = CONCAT(N'tbl_', @Model_ID, N'_CS');  
  
    SET @SQL = CONCAT(N'  
            SELECT @Changeset_ID = ID, @Owner_ID = EnterUserID , @CurrentState = Status, @Entity_ID = Entity_ID  
            FROM [mdm].', @ChangesetTableName, N'  
            WHERE Version_ID = @Version_ID  
                AND (@ChangesetMUID IS NOT NULL OR @ChangesetName IS NOT NULL)  
                AND (@ChangesetMUID IS NULL OR MUID = @ChangesetMUID)  
                AND (@ChangesetName IS NULL OR Name = @ChangesetName)');  
    EXEC sp_executesql @SQL, N'@Version_ID INT, @Entity_ID INT OUTPUT, @ChangesetName NVARCHAR(250), @ChangesetMUID UNIQUEIDENTIFIER, @Owner_ID INT OUTPUT, @Changeset_ID INT OUTPUT, @CurrentState TINYINT OUT',  
            @Version_ID, @Entity_ID OUTPUT, @ChangesetName, @ChangesetMUID, @Owner_ID OUTPUT, @Changeset_ID OUTPUT, @CurrentState OUTPUT;  
  
    IF @Changeset_ID IS NULL  
    BEGIN  
        RAISERROR(N'MDSERR300031|The changeset id is invalid or you don''t have the permission to update the changeset.', 16, 1);  
        RETURN;  
    END  
  
    IF @User_ID != @Owner_ID  
    BEGIN  
        RAISERROR(N'MDSERR120002|The user does not have permission to perform this operation.', 16, 1);    
        RETURN;  
    END;  
  
    IF @CurrentState NOT IN(@ChangesetStatus_Open, @ChangesetStatus_Committed, @ChangesetStatus_Rejected)  
    BEGIN  
        RAISERROR(N'MDSERR300029|The changeset cannot transfer to the target status.', 16, 1);  
        RETURN;  
    END  
  
    SET @PendingChangesTableName = CONCAT(N'tbl_', @Model_ID, N'_', @Entity_ID, N'_EN_PD');  
    SET @SQL = CONCAT(@TruncationGuard + N'  
        DELETE mdm.', @PendingChangesTableName, N'  
        WHERE Version_ID = @Version_ID AND CS_ID = @Changeset_ID;  
        DELETE mdm.', @ChangesetTableName, N'  
        WHERE Version_ID = @Version_ID AND ID = @Changeset_ID');  
  
    EXEC sp_executesql @SQL, N'@Version_ID INT, @Changeset_ID INT', @Version_ID, @Changeset_ID;  
END
GO
/****** Object:  StoredProcedure [mdm].[udpEntityMemberChangesetSave]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpEntityMemberChangesetSave]  
(  
    @User_ID                INT,  
    @Model_Name             NVARCHAR(50) = NULL,  
    @Model_MUID             UNIQUEIDENTIFIER = NULL,  
    @Entity_Name            NVARCHAR(50) = NULL,  
    @Entity_MUID            UNIQUEIDENTIFIER= NULL,  
    @Version_Name           NVARCHAR(50) = NULL,  
    @Version_MUID           UNIQUEIDENTIFIER = NULL,  
    @ChangesetName          NVARCHAR(250) = NULL,  
    @ChangesetMUID          UNIQUEIDENTIFIER = NULL OUTPUT,  
    @Description            NVARCHAR(500) = NULL,  
    @ChangesetStatus        TINYINT,  
    @CorrelationID          UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
  
    DECLARE @GuidEmpty                  UNIQUEIDENTIFIER = CAST(0x0 AS UNIQUEIDENTIFIER),  
            @Owner_ID                   INT,  
            @Model_ID                   INT,  
            @Entity_ID                  INT,  
            @Version_ID                 INT,  
            @Changeset_ID               INT,  
  
            @RequireApproval            BIT,  
  
            @CurrentState               TINYINT,  
            @ChangesetStatus_Open       TINYINT = 1,  
            @ChangesetStatus_Pending    TINYINT = 2,  
            @ChangesetStatus_Approved   TINYINT = 3,  
            @ChangesetStatus_Rejected   TINYINT = 4,  
            @ChangesetStatus_Committed  TINYINT = 5,  
  
            @EntityPermission           TINYINT,  
            @Permission_Deny            TINYINT = 1,  
            @Permission_Admin           TINYINT = 5,  
  
            @MemberType_Leaf            TINYINT = 1,  
  
            @Status_Active              TINYINT = 1,  
            @Status_Deactivated         TINYINT = 2,  
  
            --Attribute Types  
            @AttributeType_FreeForm     TINYINT = 1,  
            @AttributeType_DBA          TINYINT = 2,  
            @AttributeType_SYSTEM       TINYINT = 3,  
            @AttributeType_File         TINYINT = 4,  
  
            --Attribute DataTypes  
            @AttributeDataType_DateTime TINYINT = 3,  
            @AttributeDataType_Link     TINYINT = 6,  
  
            @SysNull_Text               NVARCHAR(1) = NCHAR(0),  
            @CommitFailedMessage        NVARCHAR(50) = CONVERT(NVARCHAR(50),NEWID()),  
  
            @PendingView                SYSNAME,  
            @MemberTable                SYSNAME,  
  
            @ChangesetTableName         SYSNAME,  
            @TruncationGuard            NVARCHAR(MAX) = N'',  
            @SQL                        NVARCHAR(MAX),  
            @SetStatusSQL               NVARCHAR(MAX);  
  
    SELECT  
        @User_ID = NULLIF(@User_ID, 0),  
        @Model_MUID = NULLIF(@Model_MUID, @GuidEmpty),  
        @Model_Name = NULLIF(LTRIM(RTRIM(@Model_Name)), N''),  
        @Entity_MUID = NULLIF(@Entity_MUID, @GuidEmpty),  
        @Entity_Name = NULLIF(LTRIM(RTRIM(@Entity_Name)), N''),  
        @Version_MUID = NULLIF(@Version_MUID, @GuidEmpty),  
        @Version_Name = NULLIF(LTRIM(RTRIM(@Version_Name)), N''),  
        @ChangesetMUID = NULLIF(@ChangesetMUID, @GuidEmpty),  
        @ChangesetName = NULLIF(LTRIM(RTRIM(@ChangesetName)), N''),  
        @Description = NULLIF(LTRIM(RTRIM(@Description)), N'');  
  
    IF @User_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR100009|The User ID is not valid.', 16, 1);  
        RETURN;  
    END  
  
    SELECT  
         @Model_ID = m.ID,  
         @Model_MUID = m.MUID,  
         @Model_Name = m.Name  
    FROM mdm.tblModel m  
    INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_MODEL s  
    ON      m.ID = s.ID  
        AND s.Privilege_ID <> @Permission_Deny  
        AND s.User_ID = @User_ID  
    WHERE (@Model_MUID IS NOT NULL OR @Model_Name IS NOT NULL)  
        AND (@Model_MUID IS NULL OR @Model_MUID = m.MUID)  
        AND (@Model_Name IS NULL OR @Model_Name = m.Name)  
  
    IF @Model_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR300005|The supplied model is not valid.', 16, 1);  
        RETURN;  
    END;  
  
    SELECT  
        @Version_ID = ID,  
        @Version_MUID = MUID,  
        @Version_Name = Name  
    FROM mdm.tblModelVersion  
    WHERE (@Version_MUID IS NOT NULL OR @Version_Name IS NOT NULL)  
        AND (@Version_MUID IS NULL OR MUID = @Version_MUID)  
        AND (@Version_Name IS NULL OR Name = @Version_Name)  
        AND Model_ID = @Model_ID;  
  
    IF @Version_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR300006|The supplied version is not valid.', 16, 1);  
        RETURN;  
    END;  
  
    SELECT  
        @Entity_ID = e.ID,  
        @Entity_MUID = e.MUID,  
        @Entity_Name = e.Name,  
        @EntityPermission = s.Privilege_ID,  
        @RequireApproval = e.RequireApproval  
    FROM mdm.tblEntity e  
    INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_ENTITY s  
    ON      e.ID = s.ID  
        AND s.Privilege_ID <> @Permission_Deny  
        AND s.User_ID = @User_ID  
    WHERE (@Entity_MUID IS NOT NULL OR @Entity_Name IS NOT NULL)  
        AND (@Entity_MUID IS NULL OR @Entity_MUID = e.MUID)  
        AND (@Entity_Name IS NULL OR @Entity_Name = e.Name)  
        AND e.Model_ID = @Model_ID;  
  
    IF @Entity_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR300008|The supplied entity is not valid.', 16, 1);  
        RETURN;  
    END;  
  
    -- Verify the entity version is not a sync target.  
    IF EXISTS(SELECT 1 FROM mdm.tblSyncRelationship  
              WHERE TargetEntity_ID = @Entity_ID  
                AND TargetVersion_ID = @Version_ID)  
    BEGIN  
        RAISERROR('MDSERR200220|The entity member(s) cannot be saved. The entity version is the target of a sync relationship.', 16, 1);  
        RETURN;  
    END  
    SET @ChangesetTableName = CONCAT(N'tbl_', @Model_ID, N'_CS');  
  
    IF @ChangesetMUID IS NULL  
    BEGIN  
        IF @ChangesetName IS NULL  
        BEGIN  
            RAISERROR(N'MDSERR300027|The changeset name is required.', 16, 1);  
            RETURN;  
        END;  
  
        SET @SQL = CONCAT(N'  
            IF NOT EXISTS (  
                SELECT 1  
                FROM [mdm].', @ChangesetTableName, N'  
                WHERE Version_ID = @Version_ID  
                    AND Name = @ChangesetName  
            )  
            BEGIN  
                SET @ChangesetMUID = NEWID();  
                INSERT [mdm].', @ChangesetTableName, N' (Version_ID, Entity_ID, Name, Description, MUID, Status, EnterUserID, LastChgUserID)  
                VALUES(@Version_ID, @Entity_ID, @ChangesetName, @Description, @ChangesetMUID, ', @ChangesetStatus_Open, N', @User_ID, @User_ID);  
            END');  
        EXEC sp_executesql @SQL, N'@Version_ID INT, @Entity_ID INT, @ChangesetName NVARCHAR(250), @Description NVARCHAR(500), @User_ID INT, @ChangesetMUID UNIQUEIDENTIFIER OUTPUT',  
            @Version_ID, @Entity_ID, @ChangesetName, @Description, @User_ID, @ChangesetMUID OUTPUT;  
  
        IF @ChangesetMUID IS NULL  
        BEGIN  
            RAISERROR(N'MDSERR300030|The changeset name is not unqinue.', 16, 1);  
            RETURN;  
        END;  
    END  
    ELSE  
    BEGIN  
        SET @SQL = CONCAT(N'  
            SELECT @Changeset_ID = ID, @Owner_ID = EnterUserID , @CurrentState = Status  
            FROM [mdm].', @ChangesetTableName, N'  
            WHERE Version_ID = @Version_ID  
                AND MUID = @ChangesetMUID');  
        EXEC sp_executesql @SQL, N'@Version_ID INT, @ChangesetMUID UNIQUEIDENTIFIER, @Owner_ID INT OUTPUT, @Changeset_ID INT OUTPUT, @CurrentState TINYINT OUT',  
                @Version_ID, @ChangesetMUID, @Owner_ID OUTPUT, @Changeset_ID OUTPUT, @CurrentState OUTPUT;  
  
        IF @Changeset_ID IS NOT NULL AND @Owner_ID != @User_ID AND @EntityPermission != @Permission_Admin  
        BEGIN  
            RAISERROR(N'MDSERR300031|The changeset id is invalid or you don''t have the permission to update the changeset.', 16, 1);  
            RETURN;  
        END  
  
        IF @ChangesetName IS NOT NULL OR @Description IS NOT NULL  
        BEGIN  
            DECLARE @Ret BIT = 0;  
            SET @SQL = CONCAT(N'  
                IF @ChangesetName IS NULL OR  
                    NOT EXISTS (  
                        SELECT 1  
                        FROM [mdm].', @ChangesetTableName, N'  
                        WHERE Version_ID = @Version_ID  
                            AND Name = @ChangesetName  
                            AND ID <> @Changeset_ID  
                )  
                BEGIN  
                    UPDATE [mdm].', @ChangesetTableName, N'  
                    SET Name = COALESCE(@ChangesetName, Name),  
                        Description = COALESCE(@Description, Description)  
                    WHERE Version_ID = @Version_ID  
                        AND ID = @Changeset_ID  
                    SET @Ret = 1;  
                END  
                ELSE  
                BEGIN  
                    SET @Ret = 0;  
                END');  
            EXEC sp_executesql @SQL, N'@Version_ID INT, @Changeset_ID INT, @ChangesetName NVARCHAR(250), @Description NVARCHAR(500), @Ret BIT OUTPUT',  
                @Version_ID, @Changeset_ID, @ChangesetName, @Description, @Ret OUTPUT;  
  
            IF @Ret = 0  
            BEGIN  
                RAISERROR(N'MDSERR300030|The changeset name is not unqinue.', 16, 1);  
                RETURN;  
            END  
        END  
  
        IF @ChangesetStatus = @CurrentState  
        BEGIN  
            RETURN;  
        END  
  
        SET @SQL = CONCAT(N'  
            SELECT @ChangesetName = Name  
            FROM [mdm].', @ChangesetTableName, N'  
            WHERE Version_ID = @Version_ID  
                AND ID = @Changeset_ID');  
        EXEC sp_executesql @SQL, N'@Version_ID INT, @Changeset_ID INT, @ChangesetName NVARCHAR(250) OUTPUT',  
            @Version_ID, @Changeset_ID, @ChangesetName OUTPUT;  
  
        DECLARE @StateMachineTransition TABLE  
        (  
            FromState TINYINT NOT NULL,  
            ToState TINYINT NOT NULL,  
            RequireAdmin BIT NOT NULL  
        );  
  
        IF @RequireApproval = 1  
        BEGIN  
            INSERT @StateMachineTransition (FromState, ToState, RequireAdmin)  
            VALUES (@ChangesetStatus_Open, @ChangesetStatus_Pending, 0),  
                (@ChangesetStatus_Pending, @ChangesetStatus_Open, 0),  
                (@ChangesetStatus_Pending, @ChangesetStatus_Rejected, 1),  
                (@ChangesetStatus_Pending, @ChangesetStatus_Approved, 1),  
                (@ChangesetStatus_Rejected, @ChangesetStatus_Pending, 0),  
                (@ChangesetStatus_Rejected, @ChangesetStatus_Open, 0),  
                (@ChangesetStatus_Approved, @ChangesetStatus_Open, 0),  
                (@ChangesetStatus_Approved, @ChangesetStatus_Committed, 0);  
        END  
        ELSE  
        BEGIN  
            INSERT @StateMachineTransition (FromState, ToState, RequireAdmin)  
            VALUES (@ChangesetStatus_Open, @ChangesetStatus_Committed, 0),  
                -- In case of entity is not require approve anymore, the orphan state can transit back  
                (@ChangesetStatus_Rejected, @ChangesetStatus_Committed, 0),  
                (@ChangesetStatus_Rejected, @ChangesetStatus_Open, 0),  
                (@ChangesetStatus_Pending, @ChangesetStatus_Open, 0),  
                (@ChangesetStatus_Approved, @ChangesetStatus_Open, 0);  
        END  
  
        DECLARE @RequireAdmin BIT = NULL;  
  
        SELECT @RequireAdmin = RequireAdmin  
        FROM @StateMachineTransition  
        WHERE FromState = @CurrentState  
            AND ToState = @ChangesetStatus  
  
        IF @RequireAdmin IS NULL  
        BEGIN  
            RAISERROR(N'MDSERR300029|The changeset cannot transfer to the target status.', 16, 1);  
            RETURN;  
        END  
  
        IF (@RequireAdmin = 1 AND (@EntityPermission != @Permission_Admin OR @User_ID = @Owner_ID))  
            OR (@RequireAdmin = 0 AND @User_ID != @Owner_ID)  
        BEGIN  
            RAISERROR(N'MDSERR120002|The user does not have permission to perform this operation.', 16, 1);  
            RETURN;  
        END  
  
        SET @SetStatusSQL = CONCAT(N'  
            UPDATE [mdm].', @ChangesetTableName, N'  
            SET Status = @ChangesetStatus,  
                LastChgDTM = GETUTCDATE(),  
                LastChgUserID = @User_ID  
            WHERE ID = @Changeset_ID  
                AND Version_ID = @Version_ID');  
  
        SET @PendingView = mdm.udfViewNameGet(@Model_ID, @Entity_ID, @MemberType_Leaf, 0, 1);  
        SET @MemberTable = CONCAT(N'tbl_', @Model_ID, N'_', @Entity_ID, N'_EN')  
  
        IF @ChangesetStatus = @ChangesetStatus_Committed  
        BEGIN  
            DECLARE @TranCounter INT = @@TRANCOUNT;  
            IF @TranCounter > 0  
            BEGIN  
                SAVE TRANSACTION TX;  
            END ELSE  
            BEGIN  
                BEGIN TRANSACTION;  
            END;  
  
            BEGIN TRY  
                -- Approve workflow  
                DECLARE @AttributeIDUnPivot NVARCHAR(MAX),  
                        @AttributeSelector  NVARCHAR(MAX);  
  
                SELECT  
                    @AttributeIDUnPivot = CONCAT(@AttributeIDUnPivot, N' ,', QUOTENAME(ID)),  
                    @AttributeSelector =  
                        CASE  
                            WHEN AttributeType_ID = @AttributeType_FreeForm AND DataType_ID = @AttributeDataType_DateTime  
                            THEN CONCAT(@AttributeSelector, N',  
                        CASE ', QUOTENAME(a.Name + N'.IsChanged'), N'WHEN 1 THEN COALESCE(CONVERT(NVARCHAR(MAX), ', QUOTENAME(a.Name), N', 126) /*ISO8601*/, @SysNull_Text) END AS', QUOTENAME(ID))  
                            WHEN AttributeType_ID = @AttributeType_DBA  
                            THEN CONCAT(@AttributeSelector, N',  
                        CASE ', QUOTENAME(a.Name + N'.IsChanged'), N'WHEN 1 THEN COALESCE(CONVERT(NVARCHAR(MAX), ', QUOTENAME(a.Name), N'), @SysNull_Text) END AS', QUOTENAME(ID))  
                            WHEN AttributeType_ID = @AttributeType_File  
                            THEN CONCAT(@AttributeSelector, N',  
                        CASE ', QUOTENAME(a.Name + N'.IsChanged'), N'WHEN 1 THEN COALESCE(CONVERT(NVARCHAR(MAX), ', QUOTENAME(a.Name + '.ID'), N'), @SysNull_Text) END AS', QUOTENAME(ID))  
                            ELSE CONCAT(@AttributeSelector, N',  
                        CASE ', QUOTENAME(a.Name + N'.IsChanged'), N'WHEN 1 THEN COALESCE(CONVERT(NVARCHAR(MAX), ', QUOTENAME(a.Name), N'), @SysNull_Text) END AS', QUOTENAME(ID))  
                        END  
                FROM mdm.tblAttribute a  
                WHERE Entity_ID = @Entity_ID  
                    AND AttributeType_ID <> @AttributeType_SYSTEM  
                    AND MemberType_ID = @MemberType_Leaf  
  
                SET @AttributeIDUnPivot = RIGHT(@AttributeIDUnPivot, Len(@AttributeIDUnPivot) - 2);  
  
                SET @SQL = CONCAT(@TruncationGuard, N'  
                    -- Update changeset status  
                    ', @SetStatusSQL, N'  
  
                    DECLARE @Ret INT = 0;  
                    -- Delete member  
                    DECLARE @MemberIds mdm.MemberId;  
                    INSERT @MemberIds (ID, MemberType_ID, Code, MUID)  
                    SELECT 0, ', @MemberType_Leaf, N', N'''', pd.MUID  
                    FROM mdm.', @PendingView, N' pd  
                    INNER JOIN mdm.', @MemberTable, N' en  
                        ON pd.ID = en.ID AND pd.Version_ID = en.Version_ID  
                    WHERE CS_ID = @Changeset_ID  
                        AND pd.Version_ID = @Version_ID  
                        AND pd.Status_ID = ', @Status_Deactivated, '  
                        AND pd.Status_ID != en.Status_ID  
  
                    IF EXISTS (SELECT 1 FROM @MemberIds)  
                    BEGIN  
                        EXEC @Ret = mdm.udpMembersStatusSet  
                            @User_ID = @User_ID,  
                            @Model_ID = @Model_ID,  
                            @Entity_ID = @Entity_ID,  
                            @Version_ID = @Version_ID,  
                            @MemberIds = @MemberIds,  
                            @MemberType_ID = ', @MemberType_Leaf, N',  
                            @Status_ID = ', @Status_Deactivated, N',  
                            @Approved = 1,  
                            @ResetDbaReferences = 0,  
                            @TransactionBehavior = 2, /*AllOrNothingByBatch*/  
                            @LogFlag = 1,  
                            @RaiseFirstError = 0;  
  
                        IF @Ret != 1  
                        BEGIN  
                            RAISERROR(@CommitFailedMessage, 16, 1);  
                            RETURN  
                        END  
                    END  
  
                    -- Reactive member  
                    DELETE @MemberIds  
  
                    INSERT @MemberIds (ID, MemberType_ID, Code, MUID)  
                    SELECT 0, ', @MemberType_Leaf, N', N'''', pd.MUID  
                    FROM mdm.', @PendingView, N' pd  
                    INNER JOIN mdm.', @MemberTable, N' en  
                        ON pd.ID = en.ID AND pd.Version_ID = en.Version_ID  
                    WHERE CS_ID = @Changeset_ID  
                        AND pd.Version_ID = @Version_ID  
                        AND pd.Status_ID = ', @Status_Active, '  
                        AND pd.Status_ID != en.Status_ID  
  
                    IF EXISTS (SELECT 1 FROM @MemberIds)  
                    BEGIN  
                        EXEC @Ret = mdm.udpMembersStatusSet  
                            @User_ID = @User_ID,  
                            @Model_ID = @Model_ID,  
                            @Entity_ID = @Entity_ID,  
                            @Version_ID = @Version_ID,  
                            @MemberIds = @MemberIds,  
                            @MemberType_ID = ', @MemberType_Leaf, N',  
                            @Status_ID = ', @Status_Active, N',  
                            @Approved = 1,  
                            @ResetDbaReferences = 1,  
                            @TransactionBehavior = 2, /*AllOrNothingByBatch*/  
                            @LogFlag = 1,  
                            @RaiseFirstError = 0;  
  
                        IF @Ret != 1  
                        BEGIN  
                            RAISERROR(@CommitFailedMessage, 16, 1);  
                            RETURN  
                        END  
                    END  
  
                    -- Create or update member  
                    DECLARE @Members            mdm.MemberSaveList,  
                            @MemberAttributes   mdm.MemberAttributeValues;  
  
                    INSERT @Members (RowID, MemberCode, MemberName, MemberMUID)  
                    SELECT  
                        PD_ID,  
                        CASE WHEN ID IS NULL THEN Code ELSE NULL END,  
                        CASE WHEN ID IS NULL THEN Name ELSE NULL END,  
                        MUID  
                    FROM mdm.', @PendingView, N'  
                    WHERE CS_ID = @Changeset_ID  
                        AND Version_ID = @Version_ID  
                        AND Status_ID = ', @Status_Active, ';  
  
                    INSERT @MemberAttributes (MemberRowID, AttributeID, AttributeValue)  
                    SELECT ID, AttributeID, NULLIF(AttributeValue, @SysNull_Text)  
                    FROM  
                    (  
                        SELECT PD_ID AS ID ' ,@AttributeSelector, N'  
                        FROM mdm.', @PendingView, N'  
                        WHERE CS_ID = @Changeset_ID  
                           AND Version_ID = @Version_ID  
                           AND Status_ID = ', @Status_Active, '  
                    ) p  
                    UNPIVOT(AttributeValue FOR AttributeID IN (', @AttributeIDUnPivot, N')) AS unpvt  
  
                    IF EXISTS (SELECT 1 FROM @Members)  
                    BEGIN  
                        EXEC @Ret = mdm.udpEntityMembersSave  
                            @User_ID = @User_ID,  
                            @Model_ID = @Model_ID,  
                            @Entity_ID = @Entity_ID,  
                            @Version_ID = @Version_ID,  
                            @MemberType_ID = ', @MemberType_Leaf, N',  
                            @Members = @Members,  
                            @MemberAttributes = @MemberAttributes,  
                            @SaveMode = 2, /*Merge*/  
                            @TransactionBehavior = 2, /*AllOrNothingByBatch*/  
                            @LogFlag = 1,  
                            @ReturnCreatedMembers = 0,  
                            @ValidateDataTypes = 1,  
                            @DoInheritanceRuleCheck = 1,  
                            @ErrorReportingType = 1,  
                            @Approved = 1;  
  
                        IF @Ret != 1  
                        BEGIN  
                            RAISERROR(@CommitFailedMessage, 16, 1);  
                            RETURN  
                        END  
                    END');  
  
                EXEC sp_executesql @SQL,  
                    N'@Version_ID INT, @Changeset_ID INT, @User_ID INT, @Model_ID INT, @Entity_ID INT, @ChangesetStatus TINYINT, @CommitFailedMessage NVARCHAR(50), @SysNull_Text NVARCHAR(1)',  
                      @Version_ID,     @Changeset_ID,     @User_ID,     @Model_ID,     @Entity_ID,     @ChangesetStatus,         @CommitFailedMessage,              @SysNull_Text;  
  
                IF @RequireApproval = 1  
                BEGIN  
                    EXEC mdm.udpNotificationCreateChangesetStatusChange  
                        @User_ID = @User_ID,  
                        @Model_Name = @Model_Name,  
                        @Model_MUID = @Model_MUID,  
                        @Model_ID = @Model_ID,  
                        @Entity_Name = @Entity_Name,  
                        @Entity_MUID = @Entity_MUID,  
                        @Entity_ID = @Entity_ID,  
                        @Version_Name = @Version_Name,  
                        @Version_MUID = @Version_MUID,  
                        @Version_ID = @Version_ID,  
                        @Changeset_MUID = @ChangesetMUID,  
                        @Changeset_Name = @ChangesetName,  
                        @Onwer_ID = @Owner_ID,  
                        @PriorStatus_ID = @CurrentState,  
                        @NewStatus_ID = @ChangesetStatus  
                END  
  
                IF @TranCounter = 0  
                BEGIN  
                    COMMIT TRANSACTION;  
                END  
            END TRY  
            BEGIN CATCH  
                DECLARE  
                    @ErrorSeverity INT,  
                    @ErrorState INT,  
                    @ErrorNumber INT,  
                    @ErrorLine INT,  
                    @ErrorProcedure NVARCHAR(126),  
                    @ErrorMessage NVARCHAR(4000);  
  
                EXEC mdm.udpGetErrorInfo  
                    @ErrorMessage = @ErrorMessage OUTPUT,  
                    @ErrorSeverity = @ErrorSeverity OUTPUT,  
                    @ErrorState = @ErrorState OUTPUT,  
                    @ErrorNumber = @ErrorNumber OUTPUT,  
                    @ErrorLine = @ErrorLine OUTPUT,  
                    @ErrorProcedure = @ErrorProcedure OUTPUT  
  
                IF @TranCounter = 0  
                BEGIN  
                    ROLLBACK TRANSACTION;  
                END  
                ELSE IF XACT_STATE() <> -1  
                BEGIN  
                    ROLLBACK TRANSACTION TX;  
                END  
  
                IF @ErrorMessage <> @CommitFailedMessage  
                BEGIN  
                    RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);  
                END  
            END CATCH  
        END  
        ELSE  
        BEGIN  
            IF @ChangesetStatus = @ChangesetStatus_Pending  
            BEGIN  
                DECLARE @HasPendingChanges BIT = 0;  
                SET @SQL = CONCAT(@TruncationGuard, N'  
                    IF EXISTS (  
                        SELECT 1  
                        FROM mdm.', @PendingView, '  
                        WHERE CS_ID = @Changeset_ID  
                            AND Version_ID = @Version_ID  
                    )  
                    BEGIN  
                        SET @HasPendingChanges = 1;  
                    END  
                ');  
  
                EXEC sp_executesql @SQL,  
                    N'@Version_ID INT, @Changeset_ID INT, @HasPendingChanges BIT OUTPUT',  
                        @Version_ID,     @Changeset_ID,     @HasPendingChanges OUTPUT;  
  
                IF(@HasPendingChanges != 1)  
                BEGIN  
                    RAISERROR(N'MDSERR300037|Can''t submit an empty changeset for approval.', 16, 1);  
                    RETURN;  
                END  
            END  
  
            EXEC sp_executesql @SetStatusSQL,  
                N'@Version_ID INT, @User_ID INT, @Changeset_ID INT, @ChangesetStatus TINYINT',  
                  @Version_ID,     @User_ID,     @Changeset_ID,     @ChangesetStatus;  
  
            IF @RequireApproval = 1  
            BEGIN  
                EXEC mdm.udpNotificationCreateChangesetStatusChange  
                    @User_ID = @User_ID,  
                    @Model_Name = @Model_Name,  
                    @Model_MUID = @Model_MUID,  
                    @Model_ID = @Model_ID,  
                    @Entity_Name = @Entity_Name,  
                    @Entity_MUID = @Entity_MUID,  
                    @Entity_ID = @Entity_ID,  
                    @Version_Name = @Version_Name,  
                    @Version_MUID = @Version_MUID,  
                    @Version_ID = @Version_ID,  
                    @Changeset_MUID = @ChangesetMUID,  
                    @Changeset_Name = @ChangesetName,  
                    @Onwer_ID = @Owner_ID,  
                    @PriorStatus_ID = @CurrentState,  
                    @NewStatus_ID = @ChangesetStatus  
            END  
  
            IF @ChangesetStatus = @ChangesetStatus_Approved  
            BEGIN  
                -- Commit the change on owner behalf  
                EXEC mdm.udpEntityMemberChangesetSave  
                    @User_ID = @Owner_ID,  
                    @Model_Name = @Model_Name,  
                    @Model_MUID = @Model_MUID,  
                    @Entity_Name = @Entity_Name,  
                    @Entity_MUID = @Entity_MUID,  
                    @Version_Name = @Version_Name,  
                    @Version_MUID = @Version_MUID,  
                    @ChangesetMUID = @ChangesetMUID,  
                    @ChangesetStatus = @ChangesetStatus_Committed;  
            END  
        END  
    END  
END
GO
/****** Object:  StoredProcedure [mdm].[udpEntityMemberChangesetsGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpEntityMemberChangesetsGet]  
(  
    @User_ID                INT,  
    @Model_Name             NVARCHAR(50) = NULL,  
    @Model_MUID             UNIQUEIDENTIFIER = NULL,  
    @Entity_Name            NVARCHAR(50) = NULL,  
    @Entity_MUID            UNIQUEIDENTIFIER= NULL,  
    @Version_Name           NVARCHAR(50) = NULL,  
    @Version_MUID           UNIQUEIDENTIFIER = NULL,  
    @Changeset_Name         NVARCHAR(50) = NULL,  
    @Changeset_MUID         UNIQUEIDENTIFIER = NULL,  
    @SortColumn_Name        NVARCHAR(128) = NULL,  
    @SortDirection          NVARCHAR(4) = NULL,  
    @ChangesetStatus        TINYINT = NULL,  
    @CorrelationID          UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
  
    DECLARE @GuidEmpty                  UNIQUEIDENTIFIER = CAST(0x0 AS UNIQUEIDENTIFIER),  
            @Model_ID                   INT,  
            @Entity_ID                  INT,  
            @Version_ID                 INT,  
  
            @ChangesetStatus_Open       TINYINT = 1,  
            @ChangesetStatus_Pending    TINYINT = 2,  
            @ChangesetStatus_Committed  TINYINT = 3,  
  
            @EntityPermission           TINYINT,  
            @Permission_Deny            TINYINT = 1,  
            @Permission_Admin           TINYINT = 5,  
  
            @ChangesetTableName         SYSNAME,  
            @TruncationGuard            NVARCHAR(MAX) = N'',  
            @SortTerm                   NVARCHAR(MAX) = NULL,  
            @SQL                        NVARCHAR(MAX);  
  
    SELECT  
        @User_ID = NULLIF(@User_ID, 0),  
        @Model_MUID = NULLIF(@Model_MUID, @GuidEmpty),  
        @Model_Name = NULLIF(LTRIM(RTRIM(@Model_Name)), N''),  
        @Entity_MUID = NULLIF(@Entity_MUID, @GuidEmpty),  
        @Entity_Name = NULLIF(LTRIM(RTRIM(@Entity_Name)), N''),  
        @Version_MUID = NULLIF(@Version_MUID, @GuidEmpty),  
        @Version_Name = NULLIF(LTRIM(RTRIM(@Version_Name)), N''),  
        @Changeset_MUID = NULLIF(@Changeset_MUID, @GuidEmpty),  
        @Changeset_Name = NULLIF(LTRIM(RTRIM(@Changeset_Name)), N''),  
        @SortColumn_Name = NULLIF(LTRIM(RTRIM(@SortColumn_Name)), N''),  
        @SortDirection = NULLIF(LTRIM(RTRIM(@SortDirection)), N''),  
        @ChangesetStatus = NULLIF(@ChangesetStatus, 0);  
  
    IF @User_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR100009|The User ID is not valid.', 16, 1);  
        RETURN;  
    END  
  
    SELECT  
         @Model_ID = m.ID  
    FROM mdm.tblModel m  
    INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_MODEL s  
    ON m.ID = s.ID  
        AND s.User_ID = @User_ID  
    WHERE (@Model_MUID IS NOT NULL OR @Model_Name IS NOT NULL)  
        AND (@Model_MUID IS NULL OR @Model_MUID = m.MUID)  
        AND (@Model_Name IS NULL OR @Model_Name = m.Name)  
        AND s.Privilege_ID <> @Permission_Deny  
  
    IF @Model_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR300005|The supplied model is not valid.', 16, 1);  
        RETURN;  
    END;  
  
    SELECT @Version_ID = ID  
    FROM mdm.tblModelVersion  
    WHERE (@Version_MUID IS NOT NULL OR @Version_Name IS NOT NULL)  
        AND (@Version_MUID IS NULL OR MUID = @Version_MUID)  
        AND (@Version_Name IS NULL OR Name = @Version_Name)  
        AND Model_ID = @Model_ID;  
  
    IF @Version_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR300006|The supplied version is not valid.', 16, 1);  
        RETURN;  
    END;  
  
    SELECT  
         @Entity_ID = e.ID,  
         @EntityPermission = s.Privilege_ID  
    FROM mdm.tblEntity e  
    INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_ENTITY s  
    ON e.ID = s.ID  
        AND s.User_ID = @User_ID  
    WHERE (@Entity_MUID IS NOT NULL OR @Entity_Name IS NOT NULL)  
        AND (@Entity_MUID IS NULL OR @Entity_MUID = e.MUID)  
        AND (@Entity_Name IS NULL OR @Entity_Name = e.Name)  
        AND e.Model_ID = @Model_ID  
        AND s.Privilege_ID <> @Permission_Deny  
  
    IF @SortColumn_Name IS NOT NULL  
    BEGIN  
        SET @SortTerm = CONCAT(QUOTENAME(@SortColumn_Name), CASE WHEN UPPER(@SortDirection) = N'ASC' THEN N' ASC' ELSE N' DESC' END);  
    END  
    ELSE  
    BEGIN  
        SET @SortTerm = N'LastChgDTM DESC'  
    END  
  
    SET @ChangesetTableName = CONCAT(N'tbl_', @Model_ID, N'_CS');  
  
    SET @SQL = CONCAT(@TruncationGuard + N'  
        SELECT  
            cs.MUID,  
            cs.Name,  
            e.MUID AS EntityMUID,  
            e.Name AS EntityName,  
            cs.Description,  
            cs.Status,  
            cs.EnterDTM,  
            eu.UserName AS EnterUserName,  
            eu.MUID AS EnterUserMUID,  
            cs.LastChgDTM,  
            lu.UserName AS LastChgUserName,  
            lu.MUID AS LastChgUserMUID  
        FROM mdm.', QUOTENAME(@ChangesetTableName), N' cs  
        INNER JOIN mdm.tblEntity e ON e.ID = cs.Entity_ID  
        LEFT JOIN [mdm].[tblUser] eu ON eu.ID = cs.EnterUserID  
        LEFT JOIN [mdm].[tblUser] lu ON lu.ID = cs.LastChgUserID  
        WHERE cs.Version_ID = @Version_ID  
            AND (cs.Entity_ID = @Entity_ID OR @Entity_ID IS NULL)  
            AND (cs.Status = @ChangesetStatus OR @ChangesetStatus IS NULL)  
            AND (cs.Name = @Changeset_Name OR @Changeset_Name IS NULL)  
            AND (cs.MUID = @Changeset_MUID OR @Changeset_MUID IS NULL)  
    ');  
  
    IF @EntityPermission = @Permission_Admin  
    BEGIN  
        SET @SQL += CONCAT(N'  
            AND (cs.EnterUserID = @User_ID OR cs.Status = ', @ChangesetStatus_Pending, N')');  
    END  
    ELSE  
    BEGIN  
        SET @SQL += N'  
            AND cs.EnterUserID = @User_ID';  
    END  
  
    SET @SQL += N'  
        ORDER BY ' + @SortTerm;  
  
    EXEC sp_executesql @SQL,  
        N'@Version_ID INT,  @User_ID INT, @Entity_ID INT, @ChangesetStatus TINYINT, @Changeset_Name NVARCHAR(50), @Changeset_MUID UNIQUEIDENTIFIER',  
          @Version_ID,      @User_ID,     @Entity_ID,     @ChangesetStatus,         @Changeset_Name,              @Changeset_MUID;  
END
GO
/****** Object:  StoredProcedure [mdm].[udpEntityMemberHistoryRollback]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
EXEC mdm.udpEntityMemberHistoryRollback @User_ID = 1, @Model_Name = N'Product', @Entity_Name = N'Product', @Version_Name = N'Version 4', @MemberType_ID= 1, @Revision_ID = 248390, @LogFlag = 1;  
EXEC mdm.udpEntityMemberHistoryRollback @User_ID = 1, @Model_Name = N'Product', @Entity_Name = N'Product', @Version_Name = N'Version 4', @MemberType_ID= 2, @Revision_ID = 248862, @LogFlag = 1;  
EXEC mdm.udpEntityMemberHistoryRollback @User_ID = 1, @Model_Name = N'Product', @Entity_Name = N'Product', @Version_Name = N'Version 4', @MemberType_ID= 3, @Revision_ID = 248850, @LogFlag = 1;  
EXEC mdm.udpEntityMemberHistoryRollback @User_ID = 1, @Model_Name = N'Product', @Entity_Name = N'Product', @Version_Name = N'Version 4', @MemberType_ID= 4, @Revision_ID = 248625, @LogFlag = 1;  
EXEC mdm.udpEntityMemberHistoryRollback @User_ID = 1, @Model_Name = N'Product', @Entity_Name = N'Product', @Version_Name = N'Version 4', @MemberType_ID= 5, @Revision_ID = 248850, @LogFlag = 1;  
*/  
CREATE PROCEDURE [mdm].[udpEntityMemberHistoryRollback]  
(  
    @User_ID                INT,  
    @Model_Name             NVARCHAR(50) = NULL,  
    @Model_MUID             UNIQUEIDENTIFIER = NULL,  
    @Entity_Name            NVARCHAR(50) = NULL,  
    @Entity_MUID            UNIQUEIDENTIFIER= NULL,  
    @Version_Name           NVARCHAR(50) = NULL,  
    @Version_MUID           UNIQUEIDENTIFIER = NULL,  
    @MemberType_ID          TINYINT,  
    @Revision_ID            BIGINT,  
    @CorrelationID          UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    DECLARE @GuidEmpty                      UNIQUEIDENTIFIER = CAST(0x0 AS UNIQUEIDENTIFIER),  
            @Model_ID                       INT,  
            @Entity_ID                      INT,  
            @Version_ID                     INT,  
            @Member_ID                      INT,  
  
            @EntityMemberTableName          SYSNAME,  
            @EntityHistoryTableName         SYSNAME,  
            @MemberIDColumn                 SYSNAME,  
            @EntityParentMemberTableName    SYSNAME,  
            @EntityChildMemberTableName     SYSNAME,  
            @ChildTypeMemberType_ID         TINYINT,  
            @ChildMemberIDColumn            SYSNAME,  
            @AnnotationTableName            SYSNAME,  
  
            @Model_Permission               INT,  
            @Member_Permission              INT,  
            @Member_AccessPermission        TINYINT,  
            @Permission_Admin               INT = 5,  
            @Permission_Access              INT = 4,  
            @Permission_Deny                INT = 1,  
            @AccessPermission_All           TINYINT = 7,  
            @AccessPermission_Create        TINYINT = 1,  
            @AccessPermission_Update        TINYINT = 2,  
            @AccessPermission_Delete        TINYINT = 4,  
  
            @MemberType_Leaf                TINYINT = 1,  
            @MemberType_Consolidated        TINYINT = 2,  
            @MemberType_Collection          TINYINT = 3,  
            @MemberType_Hierarchy           TINYINT = 4,  
            @MemberType_CollectionMember    TINYINT = 5,  
  
            @AttributeType_Domain           TINYINT = 2,  
            @AttributeType_System           TINYINT = 3,  
  
            @CurrentStatus                  TINYINT,  
            @HistoryStatus                  TINYINT,  
            @Status_Active                  TINYINT = 1,  
  
            @ColumnString                   NVARCHAR(MAX),  
            @DBAInnerJoinString             NVARCHAR(MAX),  
            @GetMemeberHistoryOutputQuery   NVARCHAR(MAX),  
            @SQL                            NVARCHAR(MAX);  
  
    SELECT  
        @User_ID = NULLIF(@User_ID, 0),  
        @Model_MUID = NULLIF(@Model_MUID, @GuidEmpty),  
        @Model_Name = NULLIF(LTRIM(RTRIM(@Model_Name)), N''),  
        @Entity_MUID = NULLIF(@Entity_MUID, @GuidEmpty),  
        @Entity_Name = NULLIF(LTRIM(RTRIM(@Entity_Name)), N''),  
        @Version_MUID = NULLIF(@Version_MUID, @GuidEmpty),  
        @Version_Name = NULLIF(LTRIM(RTRIM(@Version_Name)), N''),  
        @Revision_ID = NULLIF(@Revision_ID, 0)  
  
    IF @User_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR100009|The User ID is not valid.', 16, 1);  
        RETURN;  
    END  
  
    IF @MemberType_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR210021|MemberType ID is not valid.', 16, 1);  
        RETURN;  
    END  
  
    IF @Revision_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR200223|Revision ID is not valid.', 16, 1);  
        RETURN;  
    END  
  
    EXEC mdm.udpInformationLookupModel @User_ID = @User_ID, @Model_MUID = @Model_MUID, @Model_Name = @Model_Name, @ID = @Model_ID OUTPUT, @Privilege_ID = @Model_Permission OUTPUT;  
    IF @Model_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR300005|The supplied model is not valid.', 16, 1);  
        RETURN;  
    END;  
  
    SELECT @Version_ID = ID  
    FROM mdm.tblModelVersion   
    WHERE  
            (@Version_MUID IS NOT NULL OR @Version_Name IS NOT NULL)   
        AND (@Version_MUID IS NULL OR MUID = @Version_MUID)   
        AND (@Version_Name IS NULL OR Name = @Version_Name)  
        AND Model_ID = @Model_ID;  
    IF @Version_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR300006|The supplied version is not valid.', 16, 1);  
        RETURN;  
    END;  
  
    EXEC mdm.udpInformationLookupEntity @User_ID = @User_ID, @Model_ID = @Model_ID, @Entity_MUID = @Entity_MUID, @Entity_Name = @Entity_Name, @ID = @Entity_ID OUTPUT;  
    IF @Entity_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR300008|The supplied entity is not valid.', 16, 1);  
        RETURN;  
    END;  
  
    SET @EntityMemberTableName = mdm.udfTableNameGetByID(@Entity_ID, @MemberType_ID);  
    SET @EntityHistoryTableName = CONCAT(mdm.udfTableNameGetByID(@Entity_ID, @MemberType_ID), N'_HS');  
  
    SET @MemberIDColumn =  
        CASE @MemberType_ID  
            WHEN @MemberType_Leaf THEN N'EN_ID'  
            WHEN @MemberType_Consolidated THEN N'HP_ID'  
            WHEN @MemberType_Collection THEN N'CN_ID'  
            WHEN @MemberType_Hierarchy THEN N'HR_ID'  
            WHEN @MemberType_CollectionMember THEN N'CM_ID'  
        END;  
  
    SET @SQL = CONCAT(N'  
        DECLARE @HistoryMember_ID INT;  
        SELECT @HistoryMember_ID = ', @MemberIDColumn, ', @HistoryStatus = Status_ID',  
            CASE WHEN @MemberType_ID = @MemberType_Hierarchy OR @MemberType_ID = @MemberType_CollectionMember THEN N', @ChildTypeMemberType_ID = ChildType_ID' END  
         , N'  
        FROM [mdm].', QUOTENAME(@EntityHistoryTableName), N'  
        WHERE Version_ID = @Version_ID AND ID = @Revision_ID;  
  
        IF @HistoryMember_ID IS NOT NULL  
        BEGIN  
            SELECT @Member_ID = ID, @CurrentStatus = Status_ID  
            FROM [mdm].', QUOTENAME(@EntityMemberTableName), N'  
            WHERE Version_ID = @Version_ID AND ID = @HistoryMember_ID;  
        END;  
        ');  
  
    EXEC sp_executesql @SQL, N'@Version_ID INT, @Revision_ID BIGINT, @Member_ID INT OUTPUT, @HistoryStatus TINYINT OUT, @CurrentStatus TINYINT OUT, @ChildTypeMemberType_ID TINYINT OUT',  
                               @Version_ID,     @Revision_ID,        @Member_ID OUTPUT,     @HistoryStatus OUT,         @CurrentStatus OUT,         @ChildTypeMemberType_ID OUT;  
  
    IF @Member_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR200223|Revision ID is not valid or Member does not exist.', 16, 1);  
        RETURN;  
    END  
  
    SET @ChildMemberIDColumn =  
        CASE @ChildTypeMemberType_ID  
            WHEN @MemberType_Leaf THEN N'Child_EN_ID'  
            WHEN @MemberType_Consolidated THEN N'Child_HP_ID'  
            WHEN @MemberType_Collection THEN N'Child_CN_ID'  
        END;  
  
    IF @Model_Permission = @Permission_Admin  
    BEGIN  
        SET @Member_Permission = @Permission_Access;  
        SET @Member_AccessPermission = @AccessPermission_All;  
    END  
    ELSE  
    BEGIN  
        DECLARE @Member_Permission_TINYINT TINYINT;  
        EXEC mdm.udpSecurityMemberResolverGet @User_ID, @Version_ID, NULL,NULL, @Entity_ID, @Member_ID, @MemberType_ID, @Member_Permission_TINYINT OUTPUT, @Member_AccessPermission OUTPUT;  
  
        SET @Member_Permission = @Member_Permission_TINYINT;  
        IF @Member_Permission = @Permission_Deny  
        BEGIN  
            RAISERROR('MDSERR120002|The user does not have permission to perform this operation.', 16, 1);  
            RETURN;  
        END  
    END  
  
    IF @CurrentStatus != @HistoryStatus  
    BEGIN  
          
        IF @CurrentStatus = @Status_Active AND (@Member_AccessPermission & @AccessPermission_Delete != @AccessPermission_Delete)  
        -- Rollback to inactive  
        BEGIN  
            RAISERROR('MDSERR120002|The user does not have permission to perform this operation.', 16, 1);  
            RETURN;  
        END  
        ELSE IF @Member_AccessPermission & @AccessPermission_Create != @AccessPermission_Create  
        -- Rollback to active  
        BEGIN  
            RAISERROR('MDSERR120002|The user does not have permission to perform this operation.', 16, 1);  
            RETURN;  
        END  
    END  
  
    SET @GetMemeberHistoryOutputQuery = mdm.udfGetHistoryOutputQuery(@Entity_ID, @MemberType_ID, NULL, NULL);  
  
    IF (@MemberType_ID = @MemberType_Leaf OR @MemberType_ID = @MemberType_Consolidated OR @MemberType_ID = @MemberType_Collection)  
    BEGIN  
        --Working set to look up MUID/Name and confirm that provided pairs match  
        CREATE TABLE #AttributesWorkingSet  
        (  
            MUID UNIQUEIDENTIFIER NULL,  
            Name NVARCHAR(250) COLLATE DATABASE_DEFAULT NULL,  
            TableColumn SYSNAME,  
            DBAEntityTable SYSNAME NULL,  
            ID INT NULL,  
            AttributeType_ID TINYINT NULL,  
            DataType_ID TINYINT NULL,  
            AccessPermission TINYINT  
        );  
        CREATE INDEX #ix_AttributesWorkingSet_Name ON #AttributesWorkingSet(Name);  
  
        INSERT INTO #AttributesWorkingSet  
        (  
            MUID,  
            Name,  
            TableColumn,  
            DBAEntityTable,  
            ID,  
            AttributeType_ID,  
            DataType_ID,  
            AccessPermission  
        )  
        SELECT  
            att.MUID,  
            att.Name,  
            att.TableColumn,  
            en.EntityTable,  
            att.ID,  
            att.AttributeType_ID,  
            att.DataType_ID,  
            sec.AccessPermission  
        FROM mdm.tblAttribute att  
        INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_ATTRIBUTE sec ON att.ID = sec.ID  
        LEFT JOIN mdm.tblEntity en ON att.DomainEntity_ID = en.ID AND att.AttributeType_ID = @AttributeType_Domain  
        WHERE sec.User_ID = @User_ID  
            AND att.Entity_ID = @Entity_ID  
            AND att.MemberType_ID = @MemberType_ID  
            AND att.AttributeType_ID <> @AttributeType_System  
            AND (AccessPermission & @AccessPermission_Update) = @AccessPermission_Update  
  
        IF NOT EXISTS(SELECT ID FROM #AttributesWorkingSet)  
        BEGIN  
            RAISERROR('MDSERR120002|The user does not have permission to perform this operation.', 16, 1);  
            RETURN;  
        END  
  
        SET @ColumnString = N'  
                LastChgDTM = @Now,  
                LastChgUserID = @User_ID,  
                Status_ID = hs.Status_ID';  
        SET @DBAInnerJoinString = N'';  
  
        SELECT  
            @DBAInnerJoinString += CONCAT(N'  
            LEFT JOIN mdm.', QUOTENAME(DBAEntityTable), N' ', TableColumn, N'_EN' ,' ON hs.', QUOTENAME(TableColumn), N' = ', TableColumn, N'_EN.[ID] AND ', TableColumn,'_EN.Version_ID = @Version_ID')  
        FROM #AttributesWorkingSet  
        WHERE AttributeType_ID = @AttributeType_Domain;  
  
        IF @MemberType_ID = @MemberType_Collection  
        BEGIN  
            SET @DBAInnerJoinString += N'  
            LEFT JOIN [mdm].[tblUser] owner on owner.ID = hs.Owner_ID';  
        END  
  
        SELECT  
            @ColumnString += N',  
                ' + CASE  
                    WHEN @MemberType_ID = @MemberType_Collection AND Name = N'Owner_ID' THEN N'Owner_ID = owner.ID'  
                    WHEN AttributeType_ID = @AttributeType_Domain THEN CONCAT(QUOTENAME(TableColumn), N' = ', QUOTENAME(TableColumn + '_EN'), N'.ID')  
                    ELSE CONCAT(QUOTENAME(TableColumn), N'= hs.', QUOTENAME(TableColumn)) END  
        FROM #AttributesWorkingSet  
  
        SET @SQL = CONCAT(N'  
            DECLARE @Now DATETIME2 = GETUTCDATE();  
            UPDATE m  
            SET',  
            @ColumnString, @GetMemeberHistoryOutputQuery, N'  
            FROM [mdm].', QUOTENAME(@EntityMemberTableName), ' m  
            INNER JOIN [mdm].', QUOTENAME(@EntityHistoryTableName), ' hs ON hs.', @MemberIDColumn, ' = m.ID AND m.Version_ID = @Version_ID', @DBAInnerJoinString, N'  
            WHERE hs.Version_ID = @Version_ID  
                AND hs.ID = @Revision_ID;  
            ');  
        EXEC sp_executesql @SQL, N'@Version_ID INT, @Revision_ID BIGINT, @User_ID INT',  
                                   @Version_ID,     @Revision_ID,        @User_ID;  
    END  
    ELSE IF @MemberType_ID = @MemberType_Hierarchy  
    BEGIN  
        SET @EntityParentMemberTableName = mdm.udfTableNameGetByID(@Entity_ID, @MemberType_Consolidated);  
        SET @EntityChildMemberTableName = mdm.udfTableNameGetByID(@Entity_ID, @ChildTypeMemberType_ID);  
        SET @SQL = CONCAT(N'  
        DECLARE @Now DATETIME2 = GETUTCDATE();  
        UPDATE hr  
        SET  
            LastChgDTM = @Now,  
            LastChgUserID = @User_ID,  
            Status_ID = hs.Status_ID,  
            Parent_HP_ID = hs.Parent_HP_ID,  
            ChildType_ID = hs.ChildType_ID,  
            ',  
            CASE @ChildTypeMemberType_ID  
               WHEN @MemberType_Leaf THEN N'Child_EN_ID = hs.Child_EN_ID,'  
               WHEN @MemberType_Consolidated THEN N'Child_HP_ID = hs.Child_HP_ID,'  
            END, N'  
            SortOrder = hs.SortOrder,  
            LevelNumber = hs.LevelNumber', @GetMemeberHistoryOutputQuery, N'  
        FROM [mdm].', QUOTENAME(@EntityMemberTableName), ' hr  
        INNER JOIN [mdm].', QUOTENAME(@EntityHistoryTableName), ' hs ON hs.', @MemberIDColumn ,N' = hr.ID AND hr.Version_ID = @Version_ID  
        INNER JOIN [mdm].', QUOTENAME(@EntityChildMemberTableName), ' child ON hs.', @ChildMemberIDColumn ,N' = child.ID AND child.Version_ID = @Version_ID  
        LEFT JOIN [mdm].', QUOTENAME(@EntityParentMemberTableName), ' parent ON hs.Parent_HP_ID = parent.ID AND parent.Version_ID = @Version_ID  
        WHERE hs.Version_ID = @Version_ID  
            AND hs.ID = @Revision_ID  
            AND (hs.Parent_HP_ID IS NULL OR parent.ID IS NOT NULL)');  
        EXEC sp_executesql @SQL, N'@Version_ID INT, @Revision_ID BIGINT, @User_ID INT',  
                                   @Version_ID,     @Revision_ID,        @User_ID;  
    END  
    ELSE IF @MemberType_ID = @MemberType_CollectionMember  
    BEGIN  
        SET @EntityParentMemberTableName = mdm.udfTableNameGetByID(@Entity_ID, @MemberType_Collection);  
        SET @EntityChildMemberTableName = mdm.udfTableNameGetByID(@Entity_ID, @ChildTypeMemberType_ID);  
        SET @SQL = CONCAT(N'  
        DECLARE @Now DATETIME2 = GETUTCDATE();  
        UPDATE cm  
        SET  
            LastChgDTM = @Now,  
            LastChgUserID = @User_ID,  
            Status_ID = hs.Status_ID,  
            Parent_CN_ID = hs.Parent_CN_ID,  
            ChildType_ID = hs.ChildType_ID,  
            ',  
            CASE @ChildTypeMemberType_ID  
               WHEN @MemberType_Leaf THEN N'Child_EN_ID = hs.Child_EN_ID,'  
               WHEN @MemberType_Consolidated THEN N'Child_HP_ID = hs.Child_HP_ID,'  
               WHEN @MemberType_Collection THEN N'Child_CN_ID = hs.Child_CN_ID,'  
            END, N'  
            SortOrder = hs.SortOrder,  
            Weight = hs.Weight', @GetMemeberHistoryOutputQuery, N'  
        FROM [mdm].', QUOTENAME(@EntityMemberTableName), ' cm  
        INNER JOIN [mdm].', QUOTENAME(@EntityHistoryTableName), ' hs ON hs.', @MemberIDColumn ,N' = cm.ID AND cm.Version_ID = @Version_ID  
        INNER JOIN [mdm].', QUOTENAME(@EntityChildMemberTableName), ' child ON hs.', @ChildMemberIDColumn ,N' = child.ID AND child.Version_ID = @Version_ID  
        INNER JOIN [mdm].', QUOTENAME(@EntityParentMemberTableName), ' parent on hs.Parent_CN_ID = parent.ID AND parent.Version_ID = @Version_ID  
        WHERE hs.Version_ID =  @Version_ID  
            AND hs.ID = @Revision_ID');  
        EXEC sp_executesql @SQL, N'@Version_ID INT, @Revision_ID BIGINT, @User_ID INT',  
                                   @Version_ID,    @Revision_ID,        @User_ID;  
    END  
END
GO
/****** Object:  StoredProcedure [mdm].[udpEntityMemberPendingChangesGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
DECLARE @MemberCount INT;  
  
EXEC mdm.udpEntityMemberPendingChangesGet @User_ID = 1, @Model_Name = N'Product', @Entity_Name = N'Product', @Version_Name = N'Version 1', @MemberCount = @MemberCount OUTPUT, @MemberReturnOption = 3;  
SELECT @MemberCount  
*/  
CREATE PROCEDURE [mdm].[udpEntityMemberPendingChangesGet]  
(  
    @User_ID                INT,  
    @Model_MUID             UNIQUEIDENTIFIER = NULL,  
    @Model_Name             NVARCHAR(MAX) = NULL,  
    @Entity_MUID            UNIQUEIDENTIFIER = NULL,  
    @Entity_Name            NVARCHAR(MAX) = NULL,  
    @Version_MUID           UNIQUEIDENTIFIER = NULL,  
    @Version_Name           NVARCHAR(MAX) = NULL,  
    @Changeset_Name         NVARCHAR(250) = NULL,  
    @Changeset_MUID         UNIQUEIDENTIFIER = NULL,  
    @Hierarchy_MUID         UNIQUEIDENTIFIER = NULL,  
    @Hierarchy_Name         NVARCHAR(MAX) = NULL,  
    @HierarchyType_ID       TINYINT = NULL,  
    @HierarchyLevelNumber   INT = NULL, -- viw_SYSTEM_SCHEMA_HIERARCHY_DERIVED_LEVELS.LevelNumber (starts with zero at the top level)  
    @ParentEntity_MUID      UNIQUEIDENTIFIER = NULL,  
    @ParentEntity_Name      NVARCHAR(MAX) = NULL,  
    @ParentCode             NVARCHAR(250) = NULL,  
    @AttributeTable         mdm.Identifier READONLY,  
    @AttributeGroup_MUID    UNIQUEIDENTIFIER = NULL,  
    @AttributeGroup_Name    NVARCHAR(MAX) = NULL,  
    @SearchTable            mdm.MemberGetCriteria READONLY,  
    @PageNumber             INT = NULL,  
    @PageSize               INT = NULL OUTPUT,  
    @SortColumn_MUID        UNIQUEIDENTIFIER = NULL,  
    @SortColumn_Name        NVARCHAR(128) = NULL,  
    @SortDirection          NVARCHAR(4) = NULL,  
    @IncludeUnchangedValue  BIT = 0,  
    @IncludeAuditInfo       BIT = 0,  
    @MemberReturnOption     TINYINT = 3, -- Data, counts  
    @MemberCount            INT = NULL OUTPUT,  
    @CorrelationID          UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
    DECLARE @GuidEmpty                                  UNIQUEIDENTIFIER = CAST(0x0 AS UNIQUEIDENTIFIER),  
            @Owner_ID                                   INT,  
            @CurrentState                               TINYINT,  
            @Model_ID                                   INT,  
            @Entity_ID                                  INT,  
            @Version_ID                                 INT,  
            @Changeset_ID                               INT,  
            @AttributeGroup_ID                          INT,  
            @Hierarchy_ID                               INT,  
            @HierarchyLevel_ID                          INT,  
            @ParentEntity_ID                            INT,  
            @ParentAttribute_ID                         INT,  
            @ParentAttribute_Name                       SYSNAME,  
            @Parent_ID                                  INT,  
  
            @Unused_ID                                  INT = -1,  
            @Root_ID                                    INT = 0,  
  
            @UseMemberSecurity                          BIT = 0,  
            @IsDefaultOrder                             BIT = 0,  
  
            @SecurityTableName                          SYSNAME,  
            @HierarchyTable                             SYSNAME,  
            @MemberViewName                             SYSNAME,  
            @ChangesetTableName                         SYSNAME,  
            @EnViewName                                 SYSNAME,  
  
            @HierarchyType_Explicit                     TINYINT = 0,  
            @HierarchyType_Derived                      TINYINT = 1,  
  
            @MemberReturnOptionData                     TINYINT = 1,  
            @MemberReturnOptionCount                    TINYINT = 2,  
  
            @ChangesetStatus_Open                       TINYINT = 1,  
            @ChangesetStatus_Pending                    TINYINT = 2,  
            @ChangesetStatus_Approved                   TINYINT = 3,  
            @ChangesetStatus_Rejected                   TINYINT = 4,  
            @ChangesetStatus_Committed                  TINYINT = 5,  
  
            @MemberType_Leaf                            TINYINT = 1,  
  
            @AttributeType_FreeForm                     TINYINT = 1,  
            @AttributeType_Domain                       TINYINT = 2,  
            @AttributeType_System                       TINYINT = 3,  
            @AttributeType_File                         TINYINT = 4,  
  
            @ForeignType_Entity                         TINYINT = 0,  
            @ForeignType_DBA                            TINYINT = 1,  
            @ForeignType_ManyToMany                     TINYINT = 5,  
  
            @MemberStatusActive                         TINYINT = 1,  
  
            @Model_Permission                           TINYINT,  
            @Entity_Permission                          TINYINT,  
            @MemberType_Permission                      TINYINT,  
            @Permission_Deny                            TINYINT = 1,  
            @Permission_Access                          TINYINT = 4,  
            @Permission_Admin                           TINYINT = 5,  
            @Permission_Inferred                        TINYINT = 99,  
  
            @MemberType_AccessPermission                TINYINT,  
            @AccessPermission_All                       TINYINT = 7,  
            @AccessPermission_Read                      TINYINT = 0,  
            @AccessPermission_Update                    TINYINT = 2,  
            @AccessPermission_Delete                    TINYINT = 4,  
            @AccessPermission_UpdateDelete              TINYINT = 6, -- 2+4  
  
            @VersionStatus                              TINYINT,  
            @VersionStatus_Locked                       TINYINT = 2,  
            @VersionStatus_Committed                    TINYINT = 3,  
  
            @AttributeDataType_Text                     TINYINT = 1,  
            @AttributeDataType_Number                   TINYINT = 2,  
            @AttributeDataType_DateTime                 TINYINT = 3,  
            @AttributeDataType_Link                     TINYINT = 6,  
  
            @SortColumn_TableName                       SYSNAME = NULL,  
            @ColumnString                               NVARCHAR(MAX) = NULL,  
            @SortTerm                                   NVARCHAR(MAX) = NULL,  
            @PagingTerm                                 NVARCHAR(MAX) = NULL,  
            @MembersCTE                                 NVARCHAR(MAX) = NULL,  
            @PagedIdsCTE                                NVARCHAR(MAX) = NULL,  
            @MemberFrom                                 NVARCHAR(MAX) = NULL,  
            @MemberWhere                                NVARCHAR(MAX) = NULL,  
            @SQL                                        NVARCHAR(MAX);  
  
    SELECT  
        @User_ID = NULLIF(@User_ID, 0),  
        @Model_MUID = NULLIF(@Model_MUID, @GuidEmpty),  
        @Model_Name = NULLIF(LTRIM(RTRIM(@Model_Name)), N''),  
        @Entity_MUID = NULLIF(@Entity_MUID, @GuidEmpty),  
        @Entity_Name = NULLIF(LTRIM(RTRIM(@Entity_Name)), N''),  
        @Version_MUID = NULLIF(@Version_MUID, @GuidEmpty),  
        @Version_Name = NULLIF(LTRIM(RTRIM(@Version_Name)), N''),  
        @Changeset_MUID = NULLIF(@Changeset_MUID, @GuidEmpty),  
        @Changeset_Name = NULLIF(LTRIM(RTRIM(@Changeset_Name)), N''),  
        @AttributeGroup_MUID = NULLIF(@AttributeGroup_MUID, @GuidEmpty),  
        @AttributeGroup_Name = NULLIF(LTRIM(RTRIM(@AttributeGroup_Name)), N''),  
        @Hierarchy_MUID = NULLIF(@Hierarchy_MUID, @GuidEmpty),  
        @Hierarchy_Name = NULLIF(LTRIM(RTRIM(@Hierarchy_Name)), N''),  
        @ParentEntity_MUID = NULLIF(@ParentEntity_MUID, @GuidEmpty),  
        @ParentEntity_Name = NULLIF(LTRIM(RTRIM(@ParentEntity_Name)), N''),  
        @ParentCode = NULLIF(LTRIM(RTRIM(@ParentCode)), N''),  
        @SortColumn_MUID = NULLIF(@SortColumn_MUID, @GuidEmpty),  
        @SortColumn_Name = NULLIF(LTRIM(RTRIM(@SortColumn_Name)), N''),  
        @SortDirection = NULLIF(LTRIM(RTRIM(@SortDirection)), N''),  
        @MemberCount = NULL;  
  
    -- Validate parameters  
    IF @User_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR100009|The User ID is not valid.', 16, 1);  
        RETURN;  
    END  
  
    EXEC mdm.udpInformationLookupModel  
        @User_ID = @User_ID,  
        @Model_MUID = @Model_MUID,  
        @Model_Name = @Model_Name,  
        @ID = @Model_ID OUTPUT,  
        @Privilege_ID = @Model_Permission OUTPUT;  
    IF @Model_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR300005|The supplied model is not valid.', 16, 1);  
        RETURN;  
    END;  
  
    SELECT @Version_ID = ID, @VersionStatus = Status_ID  
    FROM mdm.tblModelVersion   
    WHERE  
            (@Version_MUID IS NOT NULL OR @Version_Name IS NOT NULL)   
        AND (@Version_MUID IS NULL OR MUID = @Version_MUID)   
        AND (@Version_Name IS NULL OR Name = @Version_Name)  
        AND Model_ID = @Model_ID;  
    IF @Version_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR300006|The supplied version is not valid.', 16, 1);  
        RETURN;  
    END;  
  
    SET @ChangesetTableName = CONCAT(N'tbl_', @Model_ID, N'_CS');  
  
    EXEC mdm.udpInformationLookupEntity  
        @User_ID = @User_ID,  
        @Model_ID = @Model_ID,  
        @Entity_MUID = @Entity_MUID,  
        @Entity_Name = @Entity_Name,  
        @ID = @Entity_ID OUTPUT,  
        @Privilege_ID = @Entity_Permission OUTPUT;  
    IF @Entity_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR300008|The supplied entity is not valid.', 16, 1);  
        RETURN;  
    END;  
  
    SET @HierarchyTable = CONCAT(N'tbl_', @Model_ID, N'_', @Entity_ID ,N'_HR');  
    SET @SecurityTableName = CONCAT(N'tbl_', @Model_ID, N'_', @Entity_ID ,N'_EN_MS');  
  
    IF @ParentEntity_MUID IS NOT NULL OR @ParentEntity_Name IS NOT NULL  
    BEGIN  
        EXEC mdm.udpInformationLookupEntity  
            @User_ID = @User_ID,  
            @Model_ID = @Model_ID,  
            @Entity_MUID = @ParentEntity_MUID,  
            @Entity_Name = @ParentEntity_Name,  
            @ID = @ParentEntity_ID OUTPUT  
        IF @ParentEntity_ID IS NULL  
        BEGIN  
            RAISERROR(N'MDSERR300008|Entity is Invalid', 16, 1);  
            RETURN;  
        END;  
    END  
  
    IF @Hierarchy_MUID IS NOT NULL OR @Hierarchy_Name IS NOT NULL  
    BEGIN  
  
        IF @HierarchyType_ID = @HierarchyType_Explicit  
        BEGIN  
            EXEC mdm.udpInformationLookupHierarchy  
                @User_ID = @User_ID,  
                @Entity_ID = @Entity_ID,  
                @Hierarchy_MUID = @Hierarchy_MUID,  
                @Hierarchy_Name = @Hierarchy_Name,  
                @ID = @Hierarchy_ID OUTPUT  
            IF @Hierarchy_ID IS NULL  
            BEGIN  
                RAISERROR(N'MDSERR300009|Explicit Hierarchy is Invalid', 16, 1);  
                RETURN;  
            END;  
        END  
        ELSE IF @HierarchyType_ID = @HierarchyType_Derived  
        BEGIN  
            EXEC mdm.udpInformationLookupDerivedHierarchy  
                @User_ID = @User_ID,  
                @Model_ID = @Model_ID,  
                @DerivedHierarchy_ID = @Hierarchy_ID,  
                @DerivedHierarchy_MUID = @Hierarchy_MUID,  
                @DerivedHierarchy_Name = @Hierarchy_Name,  
                @ID = @Hierarchy_ID OUTPUT  
            IF @Hierarchy_ID IS NULL  
            BEGIN  
                RAISERROR(N'MDSERR300007|DerivedHierarchy is Invalid', 16, 1);  
                RETURN;  
            END;  
        END  
    END  
  
    -- Check paging, sorting and search term.  
    SET @PageNumber = COALESCE(@PageNumber, 0);  
    SET @PageSize = COALESCE(@PageSize, (SELECT SettingValue FROM mdm.tblSystemSetting WHERE SettingName = CAST(N'RowsPerBatch' AS NVARCHAR(100))))  
    IF @PageNumber > 0 AND @PageSize > 0  
    BEGIN  
        SET @PagingTerm = N'  
    OFFSET ((@PageNumber - 1) * @PageSize) ROWS  
    FETCH NEXT @PageSize ROWS ONLY'  
    END  
  
    IF  @SortColumn_MUID IS NOT NULL OR @SortColumn_Name IS NOT NULL  
    BEGIN  
        EXEC mdm.udpInformationLookupAttribute  
            @User_ID = @User_ID,  
            @Entity_ID = @Entity_ID,  
            @Attribute_MUID = @SortColumn_MUID,  
            @Attribute_Name = @SortColumn_Name,  
            @Name = @SortColumn_TableName OUTPUT  
        IF @SortColumn_TableName IS NULL  
        BEGIN  
            IF  @SortColumn_MUID IS NOT NULL  
            BEGIN  
                RAISERROR(N'MDSERR300010|Attribute is Invalid', 16, 1);  
                RETURN;  
            END  
            ELSE  
            BEGIN  
                SET @SortColumn_TableName = @SortColumn_Name;  
            END  
        END;  
    END  
  
    EXEC [mdm].[udpResolveMemberGetCriteria] @SearchTable, @MemberWhere OUTPUT, @SortTerm OUTPUT;  
  
    IF @SortColumn_TableName IS NOT NULL  
    BEGIN  
        SET @SortTerm += CONCAT(QUOTENAME(@SortColumn_TableName), CASE WHEN UPPER(@SortDirection) = N'ASC' THEN N' ASC' ELSE N' DESC' END);  
    END  
    ELSE IF @IncludeUnchangedValue = 1  
    BEGIN  
        SET @SortTerm += N'CS_ID DESC'  
    END  
  
    IF(@SortTerm = N'')  
    BEGIN  
        SET @SortTerm = N'ID ASC';  
        SET @IsDefaultOrder = 1;  
    END  
  
    IF @Changeset_Name IS NOT NULL OR @Changeset_MUID IS NOT NULL  
    BEGIN  
        SET @SQL = CONCAT(N'  
                    SELECT @Changeset_ID = ID, @Owner_ID = EnterUserID , @CurrentState = Status  
                    FROM [mdm].', @ChangesetTableName, N'  
                    WHERE Version_ID = @Version_ID  
                        AND Entity_ID = @Entity_ID  
                        AND (@Changeset_MUID IS NOT NULL OR @Changeset_Name IS NOT NULL)  
                        AND (@Changeset_MUID IS NULL OR MUID = @Changeset_MUID)  
                        AND (@Changeset_Name IS NULL OR Name = @Changeset_Name)');  
        EXEC sp_executesql @SQL, N'@Version_ID INT, @Entity_ID INT, @Changeset_Name NVARCHAR(250), @Changeset_MUID UNIQUEIDENTIFIER, @Owner_ID INT OUTPUT, @Changeset_ID INT OUTPUT, @CurrentState TINYINT OUT',  
                @Version_ID, @Entity_ID, @Changeset_Name, @Changeset_MUID, @Owner_ID OUTPUT, @Changeset_ID OUTPUT, @CurrentState OUTPUT;  
    END  
  
    IF @Changeset_ID IS NULL OR NOT (@Owner_ID = @User_ID OR (@Entity_Permission = @Permission_Admin AND @CurrentState = @ChangesetStatus_Pending))  
    BEGIN  
        RAISERROR(N'MDSERR300031|The changeset id is invalid or you don''t have the permission to update the changeset.', 16, 1);  
        RETURN;  
    END  
  
    -- Check member type security.  
    IF @Entity_Permission = @Permission_Admin  
    BEGIN  
        SET @MemberType_Permission = @Permission_Access;  
        SET @MemberType_AccessPermission = @AccessPermission_All;  
    END  
    ELSE  
    BEGIN  
        SELECT @MemberType_Permission = Privilege_ID,  
            @MemberType_AccessPermission = AccessPermission  
        FROM mdm.viw_SYSTEM_SECURITY_USER_MEMBERTYPE  
        WHERE [User_ID] = @User_ID  
            AND [Entity_ID] = @Entity_ID  
            AND ID = @MemberType_Leaf;  
  
        SET @MemberType_Permission = COALESCE(@MemberType_Permission, @Permission_Deny);  
  
        -- In the case of Privilege_ID is inferred, should be Interpreted as Access and ReadOnly  
        IF  @MemberType_Permission = @Permission_Inferred  
        BEGIN  
            SET @MemberType_Permission = @Permission_Access;  
            SET @MemberType_AccessPermission = @AccessPermission_Read;  
        END;  
  
        IF @MemberType_Permission = @Permission_Deny   
        BEGIN  
            RAISERROR(N'MDSERR120002|The user does not have permission to perform this operation.', 16, 1);  
            RETURN;  
        END;  
  
        SET @UseMemberSecurity = mdm.udfUseMemberSecurity (@User_ID, @Entity_ID, @Version_ID, @MemberType_Leaf);  
    END  
  
    -- Process attribtues  
    CREATE TABLE #AttributesWorkingSet  
    (  
        MUID UNIQUEIDENTIFIER NULL,  
        Name NVARCHAR(250) COLLATE DATABASE_DEFAULT NULL,  
        ID INT NULL,  
        AttributeType_ID TINYINT NULL,  
        DataType_ID TINYINT NULL,  
        SortOrder INT,  
        AccessPermission TINYINT  
    );  
    CREATE INDEX #ix_AttributesWorkingSet_Name ON #AttributesWorkingSet(Name);  
  
    IF (@AttributeGroup_MUID IS NOT NULL OR @AttributeGroup_Name IS NOT NULL)  
    BEGIN  
        EXEC mdm.udpInformationLookupAttributeGroup  
            @User_ID = @User_ID,  
            @Entity_ID = @Entity_ID,  
            @AttributeGroup_MUID = @AttributeGroup_MUID,  
            @AttributeGroup_Name = @AttributeGroup_Name,  
            @ID = @AttributeGroup_ID OUTPUT;  
        IF @AttributeGroup_ID IS NULL  
        BEGIN  
            RAISERROR(N'MDSERR300011|Attribute Group is Invalid', 16, 1);  
            RETURN;  
        END;  
  
        INSERT INTO #AttributesWorkingSet  
        (  
            MUID  
            ,Name  
            ,ID  
            ,AttributeType_ID  
            ,DataType_ID  
            ,SortOrder  
            ,AccessPermission  
        )  
        SELECT  
            att.MUID  
            ,att.Name  
            ,att.ID  
            ,att.AttributeType_ID  
            ,att.DataType_ID  
            ,COALESCE(agDetail.SortOrder, att.SortOrder)  
            ,sec.AccessPermission  
        FROM mdm.tblAttribute att  
        INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_ATTRIBUTE sec -- Only return AttributeType_ID <> @AttributeType_System  
        ON att.ID = sec.ID AND sec.User_ID = @User_ID AND att.Entity_ID = @Entity_ID AND att.MemberType_ID = @MemberType_Leaf  
        LEFT JOIN mdm.tblAttributeGroupDetail agDetail  
        ON agDetail.Attribute_ID = sec.ID AND agDetail.AttributeGroup_ID = @AttributeGroup_ID  
        WHERE agDetail.Attribute_ID IS NOT NULL OR att.IsSystem = 1  
    END  
    ELSE IF EXISTS (SELECT 1 FROM @AttributeTable)  
    BEGIN  
        INSERT INTO #AttributesWorkingSet  
        (  
            MUID  
            ,Name  
            ,ID  
            ,AttributeType_ID  
            ,DataType_ID  
            ,SortOrder  
            ,AccessPermission  
        )  
        SELECT  
            att.MUID  
            ,att.Name  
            ,att.ID  
            ,att.AttributeType_ID  
            ,att.DataType_ID  
            ,att.SortOrder  
            ,sec.AccessPermission  
        FROM mdm.tblAttribute att  
        INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_ATTRIBUTE sec -- Only return AttributeType_ID <> @AttributeType_System  
        ON att.ID = sec.ID AND sec.User_ID = @User_ID AND att.Entity_ID = @Entity_ID AND att.MemberType_ID = @MemberType_Leaf  
        LEFT JOIN @AttributeTable at  
        ON (at.MUID IS NULL OR at.MUID = 0x0 OR at.MUID = att.MUID) AND (at.Name IS NULL OR at.Name = N'' OR at.Name = att.Name)  
        WHERE (at.MUID IS NOT NULL AND at.MUID != 0x0) OR (at.Name IS NOT NULL AND at.Name != N'') OR att.IsSystem = 1  
    END  
    ELSE  
    BEGIN  
        INSERT INTO #AttributesWorkingSet  
        (  
            MUID  
            ,Name  
            ,ID  
            ,AttributeType_ID  
            ,DataType_ID  
            ,SortOrder  
            ,AccessPermission  
        )  
        SELECT  
            att.MUID  
            ,att.Name  
            ,att.ID  
            ,att.AttributeType_ID  
            ,att.DataType_ID  
            ,att.SortOrder  
            ,sec.AccessPermission  
        FROM mdm.tblAttribute att  
        INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_ATTRIBUTE sec -- Only return AttributeType_ID <> @AttributeType_System  
        ON att.ID = sec.ID AND sec.User_ID = @User_ID AND att.Entity_ID = @Entity_ID AND att.MemberType_ID = @MemberType_Leaf  
    END  
  
    SET @MemberType_AccessPermission = @MemberType_AccessPermission & @AccessPermission_UpdateDelete;  
  
    IF EXISTS(SELECT ID FROM #AttributesWorkingSet WHERE (AccessPermission & @AccessPermission_Update) = @AccessPermission_Update)  
    BEGIN  
        SET @MemberType_AccessPermission |= @AccessPermission_Update;  
    END  
    ELSE  
    BEGIN  
        SET @MemberType_AccessPermission &= @AccessPermission_Delete;  
    END;  
  
    -- If version status is committed or locked, the member is readonly.  
    IF (@VersionStatus = @VersionStatus_Committed) OR (@VersionStatus = @VersionStatus_Locked AND @Model_Permission != @Permission_Admin)  
    BEGIN  
        SET @MemberType_AccessPermission = @AccessPermission_Read;  
    END  
  
    IF NOT (@CurrentState = @ChangesetStatus_Open OR @CurrentState = @ChangesetStatus_Rejected)  
    BEGIN  
        SET @MemberType_AccessPermission = @AccessPermission_Read;  
    END  
  
    IF @IncludeUnchangedValue = 0  
    BEGIN  
        SET @ColumnString = CONCAT(N'  
            T.CS_ID AS CS_ID  
            ,COALESCE(T.ID, 0) AS ID  
            ,CASE WHEN en.ID IS NULL THEN T.[Code] ELSE en.[Code] END AS [Code]  
            ,CASE WHEN en.ID IS NULL THEN T.[Name] ELSE en.[Name] END AS [Name]  
            ,T.MUID  
            ,T.LastChgTS',  
            CASE @IncludeAuditInfo  
                WHEN 1 THEN N'  
            ,T.EnterDTM  
            ,T.EnterUserName  
            ,T.LastChgDTM  
            ,T.LastChgUserName'  
            END, N'  
            ,T.Status_ID  
            ,T.Code AS [Code.New]  
            ,T.[Code.IsChanged] AS [Code.New.IsChanged]  
            ,T.Name AS [Name.New]  
            ,T.[Name.IsChanged] AS [Name.New.IsChanged]');  
    END  
    ELSE  
    BEGIN  
        SET @ColumnString = CONCAT(N'  
            T.CS_ID AS CS_ID  
            ,COALESCE(T.ID, en.ID, 0) AS ID  
            ,CASE WHEN T.[Code.IsChanged] = 1 THEN T.Code ELSE en.Code END AS Code  
            ,T.[Code.IsChanged] AS [Code.IsChanged]  
            ,CASE WHEN T.[Name.IsChanged] = 1 THEN T.Name ELSE en.Name END AS Name  
            ,T.[Name.IsChanged] AS [Name.IsChanged]  
            ,COALESCE(T.MUID, en.MUID) AS MUID  
            ,COALESCE(T.LastChgTS, en.LastChgTS) AS LastChgTS',  
            CASE @IncludeAuditInfo  
                WHEN 1 THEN N'  
            ,COALESCE(T.EnterUserName, en.EnterUserName) AS EnterUserName  
            ,COALESCE(T.EnterDTM, en.EnterDTM) AS EnterDTM  
            ,COALESCE(T.LastChgUserName, en.LastChgUserName) AS LastChgUserName  
            ,COALESCE(T.LastChgDTM, en.LastChgDTM) AS LastChgDTM'  
            END);  
    END  
  
    IF @IncludeUnchangedValue = 0  
    BEGIN  
        SELECT  
            @ColumnString +=  
                CASE  
                    WHEN AttributeType_ID = @AttributeType_Domain  
                    THEN CONCAT(N'  
            ,T.', QUOTENAME(Name), N'  
            ,T.', QUOTENAME(Name + '.ID'), N'  
            ,T.', QUOTENAME(Name + '.Name'), N'  
            ,T.', QUOTENAME(Name + '.MUID'), N'  
            ,T.', QUOTENAME(Name + '.IsChanged'))  
                    ELSE CONCAT(N'  
            ,T.', QUOTENAME(Name), N'  
            ,T.', QUOTENAME(Name + '.IsChanged'))  
                END  
        FROM #AttributesWorkingSet  
        WHERE Name <> N'Code'  
            AND Name <> N'Name'  
    END  
    ELSE  
    BEGIN  
        SELECT  
            @ColumnString +=  
                CASE  
                    WHEN AttributeType_ID = @AttributeType_Domain  
                    THEN CONCAT(N'  
            ,CASE WHEN T.', QUOTENAME(Name + N'.IsChanged'), N' = 1 THEN T.', QUOTENAME(Name), N' ELSE en.', QUOTENAME(Name), N' END AS ', QUOTENAME(Name), N'  
            ,CASE WHEN T.', QUOTENAME(Name + N'.IsChanged'), N' = 1 THEN T.', QUOTENAME(Name + N'.ID'), N' ELSE en.', QUOTENAME(Name + N'.ID'), N' END AS ', QUOTENAME(Name + N'.ID'), N'  
            ,CASE WHEN T.', QUOTENAME(Name + N'.IsChanged'), N' = 1 THEN T.', QUOTENAME(Name + N'.Name'), N' ELSE en.', QUOTENAME(Name + N'.Name'), N' END AS ', QUOTENAME(Name + N'.Name'), N'  
            ,CASE WHEN T.', QUOTENAME(Name + N'.IsChanged'), N' = 1 THEN T.', QUOTENAME(Name + N'.MUID'), N' ELSE en.', QUOTENAME(Name + N'.MUID'), N' END AS ', QUOTENAME(Name + N'.MUID'), N'  
            ,T.', QUOTENAME(Name + N'.IsChanged'), N' AS ', QUOTENAME(Name + '.IsChanged'))  
                    ELSE CONCAT(N'  
            ,CASE WHEN T.', QUOTENAME(Name + N'.IsChanged'), N' = 1 THEN T.', QUOTENAME(Name), N' ELSE en.', QUOTENAME(Name), N' END', N' AS ', QUOTENAME(Name), N'  
            ,T.', QUOTENAME(Name + N'.IsChanged'), N' AS ', QUOTENAME(Name + '.IsChanged'))  
                END  
        FROM #AttributesWorkingSet  
        WHERE Name <> N'Code'  
            AND Name <> N'Name'  
    END  
  
    IF @UseMemberSecurity = 0  
    BEGIN  
        SET @ColumnString = CONCAT(@ColumnString, N'  
        ,@MemberType_Permission AS Privilege_ID  
        ,@MemberType_AccessPermission AS AccessPermission');  
    END  
    ELSE  
    BEGIN  
        SET @ColumnString = CONCAT(@ColumnString, N'  
        ,@MemberType_Permission AS Privilege_ID  
        ,CONVERT(TINYINT, COALESCE(membersresolved.AccessPermission & @MemberType_AccessPermission, @MemberType_AccessPermission)) AS AccessPermission');  
    END;  
  
    SET @MemberViewName = mdm.udfViewNameGet(@Model_ID, @Entity_ID, @MemberType_Leaf, 0, 1);  
    SET @EnViewName = mdm.udfViewNameGet(@Model_ID, @Entity_ID, @MemberType_Leaf, 0, 0);  
  
    SET @MemberFrom = N'';  
    IF @MemberWhere IS NOT NULL AND @MemberWhere <> N''  
    BEGIN  
        SET @MemberWhere = N'  
            AND ' + @MemberWhere;  
    END  
    ELSE  
    BEGIN  
        SET @MemberWhere = N'';  
    END  
  
    IF @ParentCode IS NULL  
    BEGIN  
        SET @Parent_ID = NULL;  
    END  
    ELSE IF UPPER(@ParentCode) = N'MDMUNUSED'  
    BEGIN  
        SET @Parent_ID = @Unused_ID;  
    END  
    ELSE IF UPPER(@ParentCode) = N'ROOT'  
    BEGIN  
        SET @Parent_ID = @Root_ID;  
    END   
    ELSE IF @Hierarchy_ID IS NOT NULL  
    BEGIN  
        DECLARE @TempTableName SYSNAME =  
            CASE @HierarchyType_Derived  
                WHEN @HierarchyType_ID THEN  CONCAT(N'tbl_', @Model_ID, N'_', @ParentEntity_ID ,N'_EN')  
                ELSE CONCAT(N'tbl_', @Model_ID, N'_', @Entity_ID ,N'_HP')  
            END;  
  
        SET @SQL = CONCAT(N'  
            SELECT TOP 1 @Parent_ID = ID  
            FROM mdm.', QUOTENAME(@TempTableName), N'   
            WHERE Version_ID = @Version_ID AND Code = @ParentCode;');  
        EXEC sp_executesql @SQL, N'@ParentCode NVARCHAR(250), @Version_ID INT, @Parent_ID INT OUTPUT', @ParentCode, @Version_ID, @Parent_ID OUTPUT;  
  
        IF @Parent_ID IS NULL  
        BEGIN  
            RAISERROR('MDSERR100025|Either the parent code or the parent type is not valid.', 16, 1);  
            RETURN;  
        END  
    END  
  
    IF @Hierarchy_ID IS NOT NULL  
    BEGIN  
        --Derived Hierarchy  
        IF @HierarchyType_ID = @HierarchyType_Derived  
        BEGIN  
            -- Determine if it is a recursive hierarchy that anchors null recursions.  
            DECLARE @IsRecursiveAndAnchorsNullRecursions BIT = COALESCE(  
               (SELECT TOP 1 tDH.AnchorNullRecursions  
                FROM mdm.tblDerivedHierarchy tDH  
                LEFT JOIN mdm.viw_SYSTEM_SCHEMA_HIERARCHY_DERIVED_LEVELS tDHL  
                ON tDHL.Hierarchy_ID = tDH.ID  
                WHERE   tDH.ID = @Hierarchy_ID  
                    AND tDHL.IsRecursive = 1  
                    AND tDHL.LevelNumber = 0)-- only look at top recursive level  
                , 0);  
  
            DECLARE @RootEntity_ID INT = 0;  
            IF @IsRecursiveAndAnchorsNullRecursions = 0 AND @ParentCode IS NULL --Find Entities for the root of the Derived Hierarchy  
            BEGIN  
                SELECT TOP 1  
                    @RootEntity_ID = Entity_ID  
                FROM mdm.viw_SYSTEM_SCHEMA_HIERARCHY_DERIVED_LEVELS  
                WHERE   Hierarchy_ID = @Hierarchy_ID  
                    AND LevelNumber = 0 -- topmost level  
            END  
  
            IF @RootEntity_ID != @Entity_ID  
            BEGIN  
                -- We are looking for the foreign ID of the Derived Hierarchy. In the normal case there should be only one returned that match the hierarchy ID  
                -- and is of type DBA. If there is a hidden level, the tblAttribute.Entity_ID will NOT be the same as the given entity. But, as we only get back one result it is correct  
                -- But, .in the case of a recursive hierarchy that has level(s) beneath the recursive levels, there will be more than 1 returned result. We only want to filter out the one that has the same entity ID in the attribute  
                -- We solve this by sorting by the equality of attribute.Entity_ID to the given entity ID. if there is only one result, it doesn't matter. For multiple results we will  
                -- always get back first the one that has the ID we are looking for and choose it using a TOP 1.  
  
                IF (@HierarchyLevelNumber IS NULL)  
                BEGIN  
                    SELECT TOP 1  
                         @ParentAttribute_ID = dhd.Foreign_ID  
                        ,@HierarchyLevel_ID = dhd.Level_ID  
                    FROM mdm.tblDerivedHierarchyDetail dhd  
                    INNER JOIN mdm.tblAttribute a  
                    ON      dhd.Foreign_ID = a.ID  
                        AND dhd.ForeignType_ID IN (@ForeignType_DBA, @ForeignType_ManyToMany)  
                    WHERE   dhd.DerivedHierarchy_ID = @Hierarchy_ID  
                        AND a.DomainEntity_ID = @ParentEntity_ID  
                    ORDER BY (CASE WHEN a.Entity_ID = @Entity_ID THEN 0 ELSE dhd.Level_ID END)  ASC  
                END ELSE  
                BEGIN  
                    IF (@HierarchyLevelNumber = 0)  
                    BEGIN  
                        -- Top-level of hierarchy  
                        SELECT TOP 1  
                             @ParentAttribute_ID = CASE WHEN dhd.IsRecursive = 1 THEN Foreign_ID END  
                            ,@HierarchyLevel_ID = Level_ID  
                        FROM mdm.viw_SYSTEM_SCHEMA_HIERARCHY_DERIVED_LEVELS dhd  
                        WHERE   dhd.Hierarchy_ID = @Hierarchy_ID  
                            AND dhd.ForeignType_ID IN (@ForeignType_DBA, @ForeignType_ManyToMany)  
                            AND dhd.LevelNumber = 0  
                    END  
                    ELSE BEGIN  
                        -- Below the top level of hierarchy  
                        DECLARE @ParentLevel_ID INT;  
                        SELECT TOP 1  
                             @ParentAttribute_ID = Foreign_ID -- The Attribute_ID is the Foreign_ID of the level above the specified level  
                            ,@ParentLevel_ID = Level_ID  
                        FROM mdm.viw_SYSTEM_SCHEMA_HIERARCHY_DERIVED_LEVELS dhd  
                        WHERE   dhd.Hierarchy_ID = @Hierarchy_ID  
                            AND dhd.ForeignType_ID IN (@ForeignType_DBA, @ForeignType_ManyToMany)  
                            AND dhd.LevelNumber < @HierarchyLevelNumber -- Get the nearest matching parent level (make skip levels if the immediate parent is not visible)  
                            AND dhd.IsLevelVisible = 1  
                            AND dhd.Entity_ID = @ParentEntity_ID  
                        ORDER BY dhd.Level_ID  
  
                        SET @HierarchyLevel_ID = @ParentLevel_ID - 1;  
                    END  
                END  
  
                DECLARE  
                    @CurrentLevel_ID                        INT,  
                    @PriorLevel_ID                          INT,  
                    @PriorLevelForeignType_ID               TINYINT,  
                    @PriorLevelManyToManyChildAttribute_ID  INT;  
  
                --Fetch the attribute DBA column name  
                SELECT  
                    @ParentAttribute_Name = [Name]  
                FROM mdm.tblAttribute WHERE ID = @ParentAttribute_ID;  
  
                --Check to see if any levels were skipped; if so, create the proper join string------------  
                --Fetch the prior level  
                SELECT TOP 1  
                     @PriorLevel_ID = Level_ID  
                    ,@PriorLevelForeignType_ID = ForeignType_ID  
                    ,@PriorLevelManyToManyChildAttribute_ID = ManyToManyChildAttribute_ID  
                FROM mdm.tblDerivedHierarchyDetail  
                WHERE   DerivedHierarchy_ID = @Hierarchy_ID  
                    AND Foreign_ID = @ParentAttribute_ID  
                    AND ForeignType_ID IN (@ForeignType_DBA, @ForeignType_ManyToMany)  
                    AND (@HierarchyLevel_ID IS NULL OR Level_ID > @HierarchyLevel_ID)  
                ORDER BY Level_ID DESC;  
  
                --Fetch the current level  
                SELECT TOP 1 @CurrentLevel_ID = Level_ID  
                FROM mdm.tblDerivedHierarchyDetail  
                WHERE   DerivedHierarchy_ID = @Hierarchy_ID  
                    AND Level_ID < @PriorLevel_ID  
                    AND IsVisible = 1  
                ORDER BY Level_ID DESC;  
  
                --Fetch the list of tables to join (if skipping levels)  
                DECLARE @SkippedLevel TABLE  
                (  
                     Level_ID                       INT PRIMARY KEY  
                    ,ForeignType_ID                 TINYINT NOT NULL  
                    ,AttributeName                  SYSNAME NOT NULL -- Name of Foreign_ID  
                    ,EntityViewName                 SYSNAME NOT NULL  
                    ,DomainEntityViewName           SYSNAME NOT NULL  
                    ,ManyToManyChildAttribute_Name  SYSNAME NULL  
                );  
                INSERT INTO @SkippedLevel  
                SELECT  
                     l.Level_ID  
                    ,l.ForeignType_ID  
                    ,l.Foreign_Name AS AttributeName  
                    ,mdm.udfViewNameGetByID(  
                        CASE l.ForeignType_ID  
                        WHEN @ForeignType_ManyToMany THEN a.Entity_ID -- Use the mapping table for M2M levels  
                        ELSE l.Entity_ID END  
                        , @MemberType_Leaf, 0, 0) AS EntityViewName  
                    ,mdm.udfViewNameGetByID(a.DomainEntity_ID, @MemberType_Leaf, 0, 0) AS DomainEntityViewName  
                    ,l.ManyToManyChildAttribute_Name  
                FROM mdm.viw_SYSTEM_SCHEMA_HIERARCHY_DERIVED_LEVELS l  
                LEFT JOIN mdm.tblAttribute a  
                ON      l.Foreign_ID = a.ID  
                    AND l.ForeignType_ID IN (@ForeignType_DBA, @ForeignType_ManyToMany)  
                WHERE   l.Hierarchy_ID = @Hierarchy_ID  
                    AND l.Level_ID > @CurrentLevel_ID  
                    AND l.Level_ID < @PriorLevel_ID ;  
  
                DECLARE  
                    @TempLevel_ID                   INT,  
                    @TempForeignType_ID             TINYINT,  
                    @TempEntityViewName             SYSNAME = NULL,  
                    @TempDomainEntityViewName       SYSNAME = NULL,  
                    @TempViewAlias                  SYSNAME = NULL,  
                    @TempPriorViewAlias             SYSNAME = N'T',  
                    @TempAttributeName              SYSNAME,  
                    @ManyToManyChildAttributeName   SYSNAME  
                     ;  
  
                WHILE EXISTS(SELECT 1 FROM @SkippedLevel)  
                BEGIN  
                    SELECT TOP 1  
                        @TempLevel_ID                   = Level_ID,  
                        @TempForeignType_ID             = ForeignType_ID,  
                        @TempAttributeName              = AttributeName,  
                        @TempEntityViewName             = EntityViewName,  
                        @TempDomainEntityViewName       = DomainEntityViewName,  
                        @ManyToManyChildAttributeName   = ManyToManyChildAttribute_Name  
                    FROM @SkippedLevel  
                    ORDER BY Level_ID ASC;  
  
                    IF (@TempForeignType_ID = @ForeignType_ManyToMany)  
                    BEGIN  
                        -- Join with the mapping table  
                        SET @TempViewAlias = CONCAT('skipMapLvl', @TempLevel_ID);  
                        SET @MemberFrom += CONCAT(N'  
                    LEFT JOIN mdm.', QUOTENAME(@TempEntityViewName), N' AS ', QUOTENAME(@TempViewAlias), N'  
                    ON      ', QUOTENAME(@TempPriorViewAlias), N'.ID = ', QUOTENAME(@TempViewAlias), N'.', QUOTENAME(CONCAT(@ManyToManyChildAttributeName, N'.ID')), N'  
                        AND ', QUOTENAME(@TempPriorViewAlias), N'.Version_ID = ', QUOTENAME(@TempViewAlias), N'.Version_ID');  
                        SET @TempPriorViewAlias = @TempViewAlias;  
                    END  
  
                    -- Join with the skipped level's entity view  
                    SET @TempViewAlias = CONCAT(N'skipLvl', @TempLevel_ID)  
                    SET @MemberFrom += CONCAT(N'  
                    LEFT JOIN mdm.', QUOTENAME(@TempDomainEntityViewName), N' AS ', QUOTENAME(@TempViewAlias), N'  
                    ON      ', QUOTENAME(@TempPriorViewAlias), '.', QUOTENAME(CONCAT(@TempAttributeName, N'.ID')), N' = ' + QUOTENAME(@TempViewAlias), N'.ID  
                        AND ', QUOTENAME(@TempPriorViewAlias), '.Version_ID = ', QUOTENAME(@TempViewAlias) + N'.Version_ID');  
  
                    SET @TempPriorViewAlias = @TempViewAlias;  
  
                    DELETE FROM @SkippedLevel  
                    WHERE Level_ID = @TempLevel_ID;  
                END; --while  
  
                DECLARE @MappingTableAlias SYSNAME = NULL;  
                IF @PriorLevelForeignType_ID = @ForeignType_ManyToMany  
                BEGIN  
                    SET @MappingTableAlias = CONCAT(N'mapLvl', @PriorLevel_ID);  
                    -- Join with the mapping entity  
                    DECLARE  
                         @MappingEntityViewName SYSNAME  
                        ,@ParentAttributeName   SYSNAME  
                        ,@ChildAttributeName    SYSNAME;  
  
                    SELECT  
                         @MappingEntityViewName = mdm.udfViewNameGetByID(a.Entity_ID, @MemberType_Leaf, 0, 0)  
                        ,@ParentAttributeName   = Name  
                    FROM mdm.tblAttribute a  
                    WHERE ID = @ParentAttribute_ID;  
  
                    SELECT @ChildAttributeName = Name  
                    FROM mdm.tblAttribute  
                    WHERE ID = @PriorLevelManyToManyChildAttribute_ID  
  
                    -- Note: This is a LEFT rather than INNER JOIN so that it works for MDMUNUSED (i.e. when the attribute value is null and the join condition won't have matches only for unused members)  
                    SET @MemberFrom += CONCAT(N'  
                    LEFT JOIN mdm.', QUOTENAME(@MappingEntityViewName), N' ', @MappingTableAlias, N'  
                    ON      ', COALESCE(@TempViewAlias, 'T'), N'.ID = ', @MappingTableAlias, N'.', QUOTENAME(CONCAT(@ChildAttributeName, N'.ID')), N'  
                        AND ', COALESCE(@TempViewAlias, 'T'), N'.Version_ID = ', @MappingTableAlias, N'.Version_ID  
                    ');  
                END  
  
                SET @MemberWhere += N'  
                        AND ' + COALESCE(@MappingTableAlias, @TempViewAlias, 'T') + '.' + QUOTENAME(CONCAT(@ParentAttribute_Name, N'.ID')) + CASE  
                        WHEN COALESCE(@Parent_ID, 0) <= 0 THEN N' IS NULL '  
                        ELSE N' = @Parent_ID '  
                        END;  
            END  
        END  
        -- Explicit hierarchy  
        ELSE IF @HierarchyType_ID = @HierarchyType_Explicit  
        BEGIN  
            IF @Parent_ID IS NOT NULL  
            -- Display members under a explicit hierarchy  
            BEGIN  
                -- Unused Leaf members  
                IF @Parent_ID = @Unused_ID  
                BEGIN  
                    SET @MemberFrom += CONCAT(N'  
                         LEFT JOIN [mdm].', @HierarchyTable, N' HR  
                         ON HR.ChildType_ID = ', @MemberType_Leaf, N'  
                            AND HR.Version_ID = @Version_ID  
                            AND HR.Hierarchy_ID = @Hierarchy_ID  
                            AND HR.Child_EN_ID = T.ID  
                            AND HR.Status_ID = ', @MemberStatusActive, N'  
                        ');  
  
                    SET @MemberWhere += N'  
                            AND HR.Child_EN_ID IS NULL'  
                END  
                -- Under consolidate member or root  
                ELSE  
                BEGIN  
                    SET @MemberFrom += CONCAT(N'  
                    INNER JOIN [mdm].', @HierarchyTable, N' AS HR  
                    ON HR.ChildType_ID = ', @MemberType_Leaf, N'  
                        AND HR.Version_ID = @Version_ID  
                        AND HR.Hierarchy_ID = @Hierarchy_ID  
                        AND HR.Child_EN_ID = T.ID  
                        AND HR.Status_ID = ', @MemberStatusActive, N'  
                        ');  
  
                    SET @MemberWhere += N'  
                        AND ISNULL(HR.Parent_HP_ID, 0) = @Parent_ID'  
                END  
            END  
        END  
    END  
  
    -- Create members CTE  
    SET @MembersCTE = CONCAT(N'  
    pendingChanges AS  
    (  
        SELECT ', @ColumnString, N'  
        FROM (  
            SELECT * FROM [mdm].', @MemberViewName, N'  
            WHERE CS_ID = @Changeset_ID AND Version_ID = @Version_ID  
        ) T',  
        CASE WHEN @IncludeUnchangedValue = 1 THEN N'  
        FULL OUTER '  
        ELSE N'  
        LEFT '  
        END, N'JOIN (  
            SELECT * FROM [mdm].', @EnViewName, '  
            WHERE Version_ID = @Version_ID  
        ) en ON T.ID = en.ID',  
        CASE  
            WHEN @UseMemberSecurity = 1 THEN CONCAT(N'  
        LEFT JOIN [mdm].', @SecurityTableName, N' membersresolved  
        ON membersresolved.ID = T.ID  
            AND membersresolved.User_ID = @User_ID  
            AND membersresolved.Version_ID = @Version_ID  
        WHERE (T.ID IS NULL OR membersresolved.ID IS NOT NULL)',  
                CASE   
                    WHEN @IncludeUnchangedValue = 1 THEN N' AND (T.Status_ID = 1 OR T.Status_ID IS NULL)'  
                END)  
            ELSE  
                CASE   
                    WHEN @IncludeUnchangedValue = 1 THEN N'  
        WHERE (T.Status_ID = 1 OR T.Status_ID IS NULL)'  
            END  
                END  
        , N'  
    ),  
    members AS  
    (  
        SELECT T.*  
        FROM pendingChanges T',  
        @MemberFrom,  
        CASE WHEN @MemberWhere IS NOT NULL AND @MemberWhere != N'' THEN CONCAT(N'  
        WHERE 1 = 1 ', @MemberWhere) END,  
        N'  
    )');  
  
    IF (@MemberReturnOption & @MemberReturnOptionData <> 0)  
    BEGIN  
        IF @IncludeUnchangedValue = 0  
        BEGIN  
            SELECT  
                 MUID  
                ,Name  
                ,ID  
                ,AttributeType_ID  
                ,DataType_ID  
            FROM #AttributesWorkingSet  
            ORDER BY SortOrder, ID  
        END  
        ELSE  
        BEGIN  
            SELECT  
                MUID  
                ,Name  
                ,ID  
                ,AttributeType_ID  
                ,DataType_ID  
            FROM #AttributesWorkingSet  
            WHERE Name <> N'Code'  
                AND Name <> N'Name'  
            ORDER BY SortOrder, ID  
        END  
  
        SET @SQL = CONCAT(N'  
    WITH',  
    @MembersCTE, N'  
    SELECT *  
    FROM members T',  
    CASE  
        WHEN @PagingTerm IS NOT NULL  
        THEN CONCAT (N'  
    ORDER BY ', @SortTerm,  
    @PagingTerm)  
        ELSE N''  
    END,  
    ';');  
        --SELECT CONVERT(XML, @SQL);  
        EXEC sp_executesql @SQL, N'@Version_ID INT, @User_ID INT, @Changeset_ID INT, @MemberType_Permission TINYINT, @MemberType_AccessPermission TINYINT, @PageNumber INT, @PageSize INT, @SearchTable mdm.MemberGetCriteria READONLY, @Parent_ID INT, @Hierarchy_ID INT',  
                                   @Version_ID,     @User_ID,     @Changeset_ID,     @MemberType_Permission,         @MemberType_AccessPermission,         @PageNumber,     @PageSize,     @SearchTable,                       @Parent_ID,     @Hierarchy_ID;  
    END  
  
    IF @MemberReturnOption & @MemberReturnOptionCount <> 0  
    BEGIN  
        SET @SQL = CONCAT(N'  
    WITH',  
    @MembersCTE, N'  
            SELECT @MemberCount = Count(*)  
    FROM members T');  
        EXEC sp_executesql @SQL, N'@Version_ID INT, @User_ID INT, @Changeset_ID INT, @MemberType_Permission TINYINT, @MemberType_AccessPermission TINYINT, @SearchTable mdm.MemberGetCriteria READONLY, @Parent_ID INT, @Hierarchy_ID INT, @MemberCount INT OUTPUT',  
                                   @Version_ID,     @User_ID,     @Changeset_ID,     @MemberType_Permission,         @MemberType_AccessPermission,         @SearchTable,                                @Parent_ID,     @Hierarchy_ID,     @MemberCount OUTPUT;  
    END  
END
GO
/****** Object:  StoredProcedure [mdm].[udpEntityMembersCreate]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
Description: Bulk creates entity members.  
  
Permission:  
---         MemberType, Attribute,    Member  
-- Create,  Create,     Create,       N/A  
-- Update,  N/A,        Update,       Update  
-- Merge,   Create,     CreateUpdate, Update  
-- Get,     N/A,        Read,         Read  
-- Delete   Delete,     N/A,          Delete  
  
The following are assumed validated prior to calling and are not validated here:  
    * User  
    * Version  
    * Entity  
    * Member Type  
    * Hierarchy  
  
declare  
    @MemberCodes AS mdm.MemberCodes  
  
insert into @MemberCodes(MemberCode, MemberName) values (N'HL-U509-BL', N'HL-U509-BL'); -- Invalid.  Existing leaf code  
insert into @MemberCodes(MemberCode, MemberName) values (N'BK-M38S-46', N'BK-M38S-46'); -- Invalid.  Existing leaf code  
insert into @MemberCodes(MemberCode, MemberName) values (N'BK-M38Z-50', N'BK-M38S-56'); -- New code  
insert into @MemberCodes(MemberCode, MemberName) values (N'BK-M38Z-51', N'BK-M38S-57'); -- New code  
insert into @MemberCodes(MemberCode, MemberName) values (N'BK-M38Z-55', N'BK-M38S-58'); -- New code  
insert into @MemberCodes(MemberCode, MemberName) values (N'BK-M38Z-55', N'BK-M38S-58'); -- Invalid.  Duplicate code  
insert into @MemberCodes(MemberCode, MemberName) values (N'ROOT', N'ROOT');   -- Invalid.  Reserved word  
  
insert into @MemberCodes(MemberCode, MemberName, HierarchyName) values (N'ZZ3C', N'ZZ 3C', N'Index'); -- New  
insert into @MemberCodes(MemberCode, MemberName, HierarchyName) values (N'ZZ4C', N'ZZ 4C', N'Bundle'); -- New  
EXEC mdm.udpEntityMembersCreate @User_ID=1, @Version_ID = 20, @Entity_ID = 31, @MemberType_ID = 2, @MemberCodes = @MemberCodes, @LogFlag = 1, @ErrorIfExists = 1  
  
*/  
CREATE PROCEDURE [mdm].[udpEntityMembersCreate]  
(  
    @User_ID                INT,  
    @Version_ID             INT,  
    @Entity_ID              INT,  
    @MemberType_ID          TINYINT,  
    @MemberCodes            mdm.MemberCodes READONLY,  
    @LogFlag                BIT = NULL, --1 indicates log the transaction  
    @ErrorIfExists          BIT = 1, --1 indicates return error if member code already exists  
    @ReturnCreatedMembers   BIT = 0,  
    @ReturnErrors           BIT = 1,-- 1 indicates that a row will be returned for each error. 0 indicates that if an error is found it will be raised.  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE  
         @SQL                   NVARCHAR(MAX)  
        ,@TableName             SYSNAME  
        ,@AnnotationTableName   SYSNAME  
        ,@EntityTable           SYSNAME  
        ,@HierarchyParentTable  SYSNAME  
        ,@CollectionTable       SYSNAME  
        ,@SecurityTable         SYSNAME  
        ,@IsCollectionEnabled   BIT  
        ,@IsHierarchyEnabled    BIT  
        ,@RequireApproval       BIT  
        ,@Member_ID             INT  
        ,@SecurityRoleID        INT  
        ,@ErrorCode             INT  
        ,@ErrorObjectType       INT  
  
        ,@TransactionLogType            TINYINT  
        ,@TransactionLogType_Attribute  TINYINT = 1  
        ,@TransactionLogType_Member     TINYINT = 2  
        ,@TransactionLogType_None       TINYINT = 3  
  
        --Code and Name attribute metadata  
        ,@CodeAttributeName     NVARCHAR(MAX)  
        ,@CodeAttributeMUID     UNIQUEIDENTIFIER  
        ,@CodeAttributeLength   INT  
        ,@NameAttributeName     NVARCHAR(MAX)  
        ,@NameAttributeMUID     UNIQUEIDENTIFIER  
        ,@NameAttributeLength   INT  
  
        ,@UseMemberSecurity             BIT = 0  
  
        --Error ObjectTypes  
        ,@ObjectType_Hierarchy          INT = 6  
        ,@ObjectType_MemberCode         INT = 12  
        ,@ObjectType_MemberId           INT = 19  
        ,@ObjectType_MemberAttribute    INT = 22  
  
        --Error Codes  
        ,@ErrorCode_ReservedWord                                INT = 110006  
        ,@ErrorCode_IdAlreadyExists                             INT = 110008  
        ,@ErrorCode_AttributeValueLengthGreaterThanMaximum      INT = 110017  
        ,@ErrorCode_NoPermissionForThisOperation                INT = 120002  
        ,@ErrorCode_NoPermissionForThisOperationOnThisObject    INT = 120003  
        ,@ErrorCode_DuplicateInputMemberCodes                   INT = 210001  
        ,@ErrorCode_MemberCodeExists                            INT = 300003  
        ,@ErrorCode_InvalidExplicitHierarchy                    INT = 300009  
        ,@ErrorCode_ConsolidatedMemberCreateHierarchyRequired   INT = 300017  
        ,@ErrorCode_InvalidFlatEntityForMemberCreate            INT = 310021  
        ,@ErrorCode_InvalidBlankMemberCode                      INT = 310022  
  
        --Member Types  
        ,@MemberType_Leaf           INT = 1  
        ,@MemberType_Consolidated   INT = 2  
        ,@MemberType_Collection     INT = 3  
  
        --Permission  
        ,@MemberType_Permission         INT  
        ,@Permission_None           INT = 0  
        ,@Permission_Deny           INT = 1  
        ,@Permission_Access         INT = 4  
        ,@Permission_Inferred       INT = 99  
  
        ,@MemberType_AccessPermission   TINYINT  
        ,@AccessPermission_Create   TINYINT = 1  
  
        ,@IsAdmin                   BIT = 0  
  
        --Store the current time for use in this SPROC  
        ,@CurrentTime               DATETIME2(3) = GETUTCDATE()  
  
        --Transaction type for entity member update  
        ,@TransactionType_Create    INT = 1  
        ,@TransactionType_ParentSet INT = 4  
  
        --A flag indicating whether or not to generate code for this entity  
        ,@CodeGenEnabled            BIT = 0  
  
        --Character constants  
        ,@Tab                    NCHAR(1) = CHAR(9)  
        ,@NewLine                NCHAR(1) = CHAR(10)  
        ,@CarriageReturn         NCHAR(1) = CHAR(13)  
  
        --Transaction and annotation table names  
        ,@Model_ID                          INT  
        ,@TransactionTableName              SYSNAME  
        ,@TransactionAnnotationTableName    SYSNAME  
        ,@ValidationStatus_Succeeded        INT = 3  
    ;  
  
    --Final results to be returned.  
    CREATE TABLE #MemberCodeWorkingSet  
        (  
          Row_ID                INT IDENTITY(1,1) NOT NULL  
         ,MemberCode            NVARCHAR(MAX) COLLATE DATABASE_DEFAULT  
         ,MemberName            NVARCHAR(MAX) COLLATE DATABASE_DEFAULT NULL  
         ,Hierarchy_ID          INT NULL  
         ,HierarchyName         NVARCHAR(MAX) COLLATE DATABASE_DEFAULT NULL  
         ,NewMemberID           INT  
         ,Attribute_MUID        UniqueIdentifier  
         ,AttributeName         NVARCHAR(MAX) COLLATE DATABASE_DEFAULT NULL  
         ,ErrorCode             INT NULL  
         ,ErrorObjectType       INT NULL  
         ,TransactionAnnotation NVARCHAR(MAX) NULL  
         ,MUID                  UNIQUEIDENTIFIER NULL  
         ,Revision_ID          BIGINT  
        );  
  
    --IDs of new members created.  
    CREATE TABLE #NewMembers  
        (  
            ID          INT,  
            MUID        UNIQUEIDENTIFIER,  
            MemberCode  NVARCHAR(250) COLLATE DATABASE_DEFAULT,  
            Revision_ID BIGINT  
        );  
  
    --Get Entity information.  
    SELECT  
        @EntityTable = EntityTable,  
        @HierarchyParentTable = HierarchyParentTable,  
        @CollectionTable = CollectionTable,  
        @IsCollectionEnabled = CASE WHEN CollectionTable IS NULL THEN 0 ELSE 1 END,  
        @IsHierarchyEnabled  = CASE WHEN HierarchyTable  IS NULL THEN 0 ELSE 1 END,  
        @Model_ID = Model_ID,  
        @TransactionLogType = CASE @LogFlag WHEN 1 THEN TransactionLogType ELSE @TransactionLogType_None END,  
        @RequireApproval = RequireApproval  
    FROM  
        mdm.tblEntity WHERE ID = @Entity_ID;  
  
    IF @RequireApproval = 1 AND @MemberType_ID = @MemberType_Leaf  
    BEGIN  
        RAISERROR('MDSERR300023|The entity requires approval for leaf member changes.', 16, 1);  
        RETURN;  
    END;  
  
    --Figure out whether code generation is enabled  
    DECLARE @result INT;  
    EXEC @result = mdm.udpIsCodeGenEnabled @Entity_ID;  
    SET @CodeGenEnabled = CONVERT(BIT, @result);  
  
    SET @SecurityTable =  
        CASE @MemberType_ID  
            WHEN @MemberType_Leaf THEN CONCAT(N'tbl_', @Model_ID, N'_', @Entity_ID ,N'_EN_MS')  
            WHEN @MemberType_Consolidated THEN CONCAT(N'tbl_', @Model_ID, N'_', @Entity_ID ,N'_HP_MS')  
        END;  
  
    IF @MemberType_ID =  @MemberType_Leaf BEGIN  
        SET @TableName = @EntityTable;  
    END  
    ELSE  
    IF @MemberType_ID =  @MemberType_Consolidated BEGIN  
        SET @TableName = @HierarchyParentTable;  
    END  
    ELSE  
    IF @MemberType_ID =  @MemberType_Collection BEGIN  
        SELECT @TableName = @CollectionTable;  
    END  
  
    IF @TransactionLogType = @TransactionLogType_Attribute  
    BEGIN  
        --Get transaction and annotation table names  
        SET @TransactionTableName = mdm.udfGetTransactionTableName(@Model_ID);  
        SET @TransactionAnnotationTableName = mdm.udfGetTransactionAnnotationTableName(@Model_ID);  
    END  
    ELSE IF @TransactionLogType = @TransactionLogType_Member  
    BEGIN  
        SET @AnnotationTableName = CONCAT(@TableName, '_AN');  
    END  
  
    ----------------------------------------------------------------------------------------  
    --Seed results with input values.  
    --Clean values  
    ----------------------------------------------------------------------------------------  
    INSERT INTO #MemberCodeWorkingSet (MemberCode, MemberName, HierarchyName, TransactionAnnotation, MUID)  
    SELECT  
         NULLIF(LTRIM(RTRIM(MemberCode)), N'')  
        ,MemberName  
        ,HierarchyName  
        ,NULLIF(LTRIM(RTRIM(TransactionAnnotation)), N'')  
        ,MUID  
    FROM @MemberCodes;  
  
    ----------------------------------------------------------------------------------------  
    --Check to see if the entity has a hierarchy  
    ----------------------------------------------------------------------------------------  
    IF     (@IsCollectionEnabled = 0 AND @MemberType_ID = @MemberType_Collection)  
        OR (@IsHierarchyEnabled = 0  AND @MemberType_ID = @MemberType_Consolidated)  
    BEGIN  
        --Entity has no hierarchies and/or doesn't support collections  
        UPDATE #MemberCodeWorkingSet  
            SET ErrorCode = @ErrorCode_InvalidFlatEntityForMemberCreate,  
                ErrorObjectType = @ObjectType_MemberCode  
        WHERE ErrorCode IS NULL;  
    END  
  
    ----------------------------------------------------------------------------------------  
    --Get Code and Name attribute metadata.  
    ----------------------------------------------------------------------------------------  
    SELECT  
         @CodeAttributeName = Name  
        ,@CodeAttributeMUID = MUID  
        ,@CodeAttributeLength = DataTypeInformation  
    FROM mdm.tblAttribute AS att  
    WHERE Entity_ID = @Entity_ID  
    AND MemberType_ID = @MemberType_ID  
    AND IsCode = 1;  
  
    SELECT  
         @NameAttributeName = Name  
        ,@NameAttributeMUID = MUID  
        ,@NameAttributeLength = DataTypeInformation  
    FROM mdm.tblAttribute AS att  
    WHERE Entity_ID = @Entity_ID  
    AND MemberType_ID = @MemberType_ID  
    AND IsName = 1;  
  
    ----------------------------------------------------------------------------------------  
    --Check for missing member codes  
    --Only do this check for entities where code gen is not enabled or the member type is not leaf  
    ----------------------------------------------------------------------------------------  
    IF @MemberType_ID <> @MemberType_Leaf OR @CodeGenEnabled = 0  
        BEGIN  
            UPDATE #MemberCodeWorkingSet  
                SET ErrorCode = @ErrorCode_InvalidBlankMemberCode,  
                    ErrorObjectType = @ObjectType_MemberAttribute,  
                    AttributeName = @CodeAttributeName,  
                    Attribute_MUID = @CodeAttributeMUID  
            WHERE MemberCode IS NULL;  
        END  
  
    ----------------------------------------------------------------------------------------  
    --Check member type security  
    ----------------------------------------------------------------------------------------  
    --Check security level before going any further.  
  
    SELECT @MemberType_Permission = Privilege_ID,  
        @MemberType_AccessPermission = AccessPermission,  
        @IsAdmin = IsAdmin  
    FROM mdm.viw_SYSTEM_SECURITY_USER_MEMBERTYPE  
    WHERE [User_ID] = @User_ID  
        AND [Entity_ID] = @Entity_ID  
        AND ID = @MemberType_ID;  
  
    IF @IsAdmin != 1  
    BEGIN  
        SET @MemberType_Permission = COALESCE(@MemberType_Permission, @Permission_Deny);  
        SET @UseMemberSecurity = mdm.udfUseMemberSecurity(@User_ID, @Entity_ID, @Version_ID, @MemberType_ID);  
  
        IF NOT(@MemberType_Permission = @Permission_Access AND (@MemberType_AccessPermission & @AccessPermission_Create) != 0)  
        BEGIN  
            UPDATE #MemberCodeWorkingSet  
            SET ErrorCode = @ErrorCode_NoPermissionForThisOperation,  
                ErrorObjectType = @ObjectType_MemberCode  
            WHERE ErrorCode IS NULL;  
        END;  
    END  
  
    --Get hierarchies based on user's permissions  
    UPDATE ws  
        SET ws.Hierarchy_ID = h.ID  
    FROM #MemberCodeWorkingSet ws  
    INNER JOIN mdm.tblHierarchy h  
        ON h.Name = ws.HierarchyName  
    INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_HIERARCHY sec  
        ON h.ID = sec.ID  
        AND sec.User_ID = @User_ID  
    WHERE h.Entity_ID = @Entity_ID;  
  
    ----------------------------------------------------------------------------------------  
    --Check for reserved words in the MemberCode.  
    ----------------------------------------------------------------------------------------  
    UPDATE ws  
    SET ErrorCode = @ErrorCode_ReservedWord,  
        ErrorObjectType = @ObjectType_MemberAttribute,  
        AttributeName = @CodeAttributeName,  
        Attribute_MUID = @CodeAttributeMUID  
    FROM #MemberCodeWorkingSet ws  
    INNER JOIN mdm.udfItemReservedWordsGet(12) rw  
        ON UPPER(LTRIM(RTRIM(REPLACE(REPLACE(REPLACE(ws.MemberCode, @Tab,N''), @CarriageReturn, N'') , @NewLine, N'')))) = UPPER(rw.ReservedWord);  
  
    --Flag code and name attributes where the value length exceeds the maximum length allowed.  
    UPDATE ws SET  
           ErrorCode = @ErrorCode_AttributeValueLengthGreaterThanMaximum,  
           ErrorObjectType = @ObjectType_MemberAttribute,  
           AttributeName = @CodeAttributeName,  
           Attribute_MUID = @CodeAttributeMUID  
    FROM #MemberCodeWorkingSet AS ws  
    WHERE ErrorCode IS NULL  
    AND (LEN(ws.MemberCode) > @CodeAttributeLength);  
  
    UPDATE ws SET  
           ErrorCode = @ErrorCode_AttributeValueLengthGreaterThanMaximum,  
           ErrorObjectType = @ObjectType_MemberAttribute,  
           AttributeName = @NameAttributeName,  
           Attribute_MUID = @NameAttributeMUID  
    FROM #MemberCodeWorkingSet AS ws  
    WHERE ErrorCode IS NULL  
    AND (LEN(ws.MemberName) > @NameAttributeLength);  
  
    --Exclude duplicate member codes across the working set table.  These will not be treated as  
    --errors that get returned but simply marked as errors so they will not be processed below.  
    WITH rawWithCount AS  
    (  
        SELECT  
            ROW_NUMBER() OVER (PARTITION BY MemberCode ORDER BY Row_ID) AS RN,  
            Row_ID  
        FROM #MemberCodeWorkingSet  
        --If code gen is enabled and the member type is Leaf then this test only applies to members that have non-null codes  
        WHERE @CodeGenEnabled = 0 OR @MemberType_ID <> @MemberType_Leaf OR MemberCode IS NOT NULL  
    ),  
    duplicateCodeValues AS  
    (  
        SELECT Row_ID FROM rawWithCount WHERE RN > 1  
    )  
    UPDATE ws SET  
        ErrorCode = @ErrorCode_DuplicateInputMemberCodes,  
        ErrorObjectType = @ObjectType_MemberAttribute,  
        AttributeName = @CodeAttributeName,  
        Attribute_MUID = @CodeAttributeMUID  
    FROM #MemberCodeWorkingSet AS ws  
    INNER JOIN duplicateCodeValues AS dup  
        ON ws.Row_ID = dup.Row_ID  
        AND ErrorCode IS NULL;  
  
    --Duplicate MemberCode, HierarchyName combo is an error.  
    WITH rawWithCount AS  
    (  
        SELECT  
            ROW_NUMBER() OVER (PARTITION BY MemberCode, HierarchyName ORDER BY Row_ID) AS RN,  
            Row_ID  
        FROM #MemberCodeWorkingSet  
        --If code gen is enabled and the member type is Leaf then this test only applies to members that have non-null codes  
        WHERE @CodeGenEnabled = 0 OR @MemberType_ID <> @MemberType_Leaf OR MemberCode IS NOT NULL  
    ),  
    duplicateCodeValues AS  
    (  
        SELECT Row_ID FROM rawWithCount WHERE RN > 1  
    )  
    UPDATE ws  
        SET ErrorCode = @ErrorCode_MemberCodeExists,  
            ErrorObjectType = @ObjectType_MemberAttribute,  
            AttributeName = @CodeAttributeName,  
            Attribute_MUID = @CodeAttributeMUID  
    FROM #MemberCodeWorkingSet AS ws  
    INNER JOIN duplicateCodeValues AS dup  
        ON ws.Row_ID = dup.Row_ID  
        AND ErrorCode = @ErrorCode_DuplicateInputMemberCodes;  
  
    ----------------------------------------------------------------------------------------  
    --Check for existing MUIDs.  
    ----------------------------------------------------------------------------------------  
    SET @SQL = N'  
        UPDATE ws  
        SET  
             ErrorCode = @ErrorCode_IdAlreadyExists  
            ,ErrorObjectType = @ObjectType_MemberId  
        FROM #MemberCodeWorkingSet AS ws  
        INNER JOIN  mdm.' + @TableName + N' AS m  
        ON      ws.MUID IS NOT NULL  
            AND ws.MUID = m.MUID  
            AND ws.ErrorCode IS NULL;  
    ';  
    EXEC sp_executesql @SQL, N'@ErrorCode_IdAlreadyExists INT, @ObjectType_MemberId INT', @ErrorCode_IdAlreadyExists, @ObjectType_MemberId;  
  
    ----------------------------------------------------------------------------------------  
    --Check for existing MemberCodes.  
    ----------------------------------------------------------------------------------------  
    SELECT  
         @ErrorCode = @ErrorCode_MemberCodeExists  
        ,@ErrorObjectType = @ObjectType_MemberAttribute;  
  
    IF @IsCollectionEnabled = 0 AND @IsHierarchyEnabled = 0  
    BEGIN  
        SET @SQL = N'  
            UPDATE ws  
            SET ErrorCode = @ErrorCode_MemberCodeExists,  
                ErrorObjectType = @ErrorObjectType,  
                AttributeName = @CodeAttributeName,  
                Attribute_MUID = @CodeAttributeMUID  
            FROM #MemberCodeWorkingSet AS ws  
            INNER JOIN  mdm.' + @EntityTable + N' AS m  
            ON ws.MemberCode = m.Code  
            AND m.Version_ID = @Version_ID  
            AND m.Status_ID = 1  
            AND ws.ErrorCode IS NULL;  
        ';  
        EXEC sp_executesql @SQL, N'@Version_ID INT, @ErrorCode_MemberCodeExists INT, @ErrorObjectType INT, @CodeAttributeName NVARCHAR(MAX), @CodeAttributeMUID UniqueIdentifier',  
            @Version_ID, @ErrorCode_MemberCodeExists, @ErrorObjectType, @CodeAttributeName, @CodeAttributeMUID;  
    END  
    ELSE BEGIN  
        SET @SQL = N'  
            UPDATE ws  
            SET ErrorCode = @ErrorCode_MemberCodeExists,  
                ErrorObjectType = @ErrorObjectType,  
                AttributeName = @CodeAttributeName,  
                Attribute_MUID = @CodeAttributeMUID  
            FROM #MemberCodeWorkingSet AS ws  
            INNER JOIN (  
                SELECT Code FROM mdm.' + @EntityTable + N' WHERE Version_ID = @Version_ID AND Status_ID = 1' +  
                CASE WHEN @IsHierarchyEnabled = 1 THEN N'  
                UNION ALL  
                SELECT Code FROM mdm.' + @HierarchyParentTable + N' WHERE Version_ID = @Version_ID AND Status_ID = 1' ELSE N'' END +  
                CASE WHEN @IsCollectionEnabled = 1 THEN N'  
                UNION ALL  
                SELECT Code FROM mdm.' + @CollectionTable + N' WHERE Version_ID = @Version_ID AND Status_ID = 1' ELSE N'' END + N'  
            ) AS existingCodes  
            ON ws.MemberCode = existingCodes.Code  
            AND ws.ErrorCode IS NULL;  
        ';  
        EXEC sp_executesql @SQL, N'@Version_ID INT, @ErrorCode_MemberCodeExists INT, @ErrorObjectType INT, @CodeAttributeName NVARCHAR(MAX), @CodeAttributeMUID UniqueIdentifier',  
            @Version_ID, @ErrorCode_MemberCodeExists, @ErrorObjectType, @CodeAttributeName, @CodeAttributeMUID;  
    END  
  
    ----------------------------------------------------------------------------------------  
    --Update and validate the hierarchy Ids  
    ----------------------------------------------------------------------------------------  
    -- Flag any invalid hierarchy names for any that were specified.  
    UPDATE #MemberCodeWorkingSet  
        SET ErrorCode = @ErrorCode_InvalidExplicitHierarchy,  
            ErrorObjectType = @ObjectType_Hierarchy  
    WHERE HierarchyName IS NOT NULL  
    AND Hierarchy_ID IS NULL  
    AND ErrorCode IS NULL;  
  
    ----------------------------------------------------------------------------------------  
    --Consolidated members should be set to a hierarchy names.  
    ----------------------------------------------------------------------------------------  
    IF @MemberType_ID = @MemberType_Consolidated BEGIN  
        UPDATE #MemberCodeWorkingSet  
            SET ErrorCode = @ErrorCode_ConsolidatedMemberCreateHierarchyRequired,  
                ErrorObjectType = @ObjectType_MemberCode  
        WHERE HierarchyName IS NULL  
        AND ErrorCode IS NULL;  
    END;  
  
    ----------------------------------------------------------------------------------------  
    --Start transaction, being careful to check if we are nested  
    ----------------------------------------------------------------------------------------  
    DECLARE @TranCounter INT;  
    SET @TranCounter = @@TRANCOUNT;  
    IF @TranCounter > 0 SAVE TRANSACTION TX;  
    ELSE BEGIN TRANSACTION;  
  
    BEGIN TRY  
  
        --If the entity is code gen enabled  
        IF @CodeGenEnabled = 1  
            BEGIN  
                --Gather up the valid user provided codes  
                DECLARE @CodesToProcess mdm.MemberCodes;  
  
                INSERT @CodesToProcess (MemberCode)  
                SELECT MemberCode  
                FROM #MemberCodeWorkingSet  
                WHERE MemberCode IS NOT NULL AND ErrorCode IS NULL;  
  
                --Process the user-provided codes to update the code gen info table with the largest one  
                EXEC mdm.udpProcessCodes @Entity_ID, @CodesToProcess;  
  
                IF @MemberType_ID = @MemberType_Leaf  
                    BEGIN  
                        DECLARE @NumberOfCodeToGenerate INT = (SELECT COUNT(*) FROM #MemberCodeWorkingSet WHERE MemberCode IS NULL AND ErrorCode IS NULL);  
  
                        IF @NumberOfCodeToGenerate > 0  
                            BEGIN  
                                DECLARE @AllocatedRangeStart BIGINT, @AllocatedRangeEnd BIGINT;  
                                EXEC mdm.udpGenerateCodeRange   @Entity_ID = @Entity_ID,  
                                                                @NumberOfCodesToGenerate = @NumberOfCodeToGenerate,  
                                                                @CodeRangeStart = @AllocatedRangeStart OUTPUT,  
                                                                @CodeRangeEnd = @AllocatedRangeEnd OUTPUT;  
  
                                DECLARE @AllocatedCodeCounter BIGINT = @AllocatedRangeStart - 1;  
  
                                --Generate any codes the user did not provide  
                                UPDATE #MemberCodeWorkingSet  
                                SET @AllocatedCodeCounter = @AllocatedCodeCounter + 1,  
                                    MemberCode = CONVERT(NVARCHAR(MAX), @AllocatedCodeCounter)  
                                WHERE MemberCode IS NULL;  
                            END  
                    END  
            END  
  
        ----------------------------------------------------------------------------------------  
        --Insert into the appropriate entity table  
        ----------------------------------------------------------------------------------------  
        SET @SQL = N'  
            INSERT INTO mdm.' + @TableName + N'  
            (  
                Version_ID,  
                Status_ID,  
                Name,  
                Code,' +  
                CASE @MemberType_ID WHEN @MemberType_Consolidated THEN N'Hierarchy_ID,' WHEN @MemberType_Collection THEN N'[Owner_ID],' ELSE N'' END + N'  
                EnterDTM,  
                EnterUserID,  
                EnterVersionID,  
                LastChgDTM,  
                LastChgUserID,  
                LastChgVersionID,  
                MUID  
            )  
            OUTPUT inserted.ID, inserted.MUID, inserted.Code, inserted.LastChgTS INTO #NewMembers  
            SELECT  
                 @Version_ID  
                ,1  
                ,ws.MemberName  
                ,ws.MemberCode' +  
                CASE @MemberType_ID WHEN @MemberType_Consolidated THEN N',ws.Hierarchy_ID' WHEN @MemberType_Collection THEN N',@User_ID' ELSE N'' END + N'  
                ,GETUTCDATE()  
                ,@User_ID  
                ,@Version_ID  
                ,GETUTCDATE()  
                ,@User_ID  
                ,@Version_ID  
                ,COALESCE(MUID, NEWID())  
            FROM #MemberCodeWorkingSet ws  
            WHERE ws.ErrorCode IS NULL  
            ;';  
  
        --PRINT(@SQL);  
        EXEC sp_executesql @SQL,  
            N'@User_ID INT, @Version_ID INT', @User_ID, @Version_ID;  
  
        ----------------------------------------------------------------------------------------  
        --Update working set with new member Ids  
        ----------------------------------------------------------------------------------------  
        UPDATE ws  
            SET NewMemberID = n.ID, ws.MUID = n.MUID, ws.Revision_ID = n.Revision_ID  
        FROM #MemberCodeWorkingSet ws INNER JOIN  
             #NewMembers n  
             ON  ws.MemberCode = n.MemberCode  
             AND ws.ErrorCode IS NULL;  
  
        ----------------------------------------------------------------------------------------  
        --Add new members to hierarchies  
        ----------------------------------------------------------------------------------------  
        DECLARE @HierarchyMembers mdm.HierarchyMembers;  
        IF @IsHierarchyEnabled = 1  
        BEGIN  
            --Create the hierarchy relationship(s) and set the parent to 0 (Root).  
            IF @MemberType_ID = @MemberType_Leaf BEGIN  
                --Children are assigned to all hierarchies.  
                INSERT INTO @HierarchyMembers (Hierarchy_ID, Child_ID, ChildMemberType_ID, Parent_ID)  
                SELECT  
                     h.ID  
                    ,ws.NewMemberID  
                    ,@MemberType_ID  
                    ,0  
                FROM #MemberCodeWorkingSet ws CROSS JOIN mdm.tblHierarchy h  
                WHERE h.Entity_ID = @Entity_ID AND h.IsMandatory = 1 AND ws.NewMemberID IS NOT NULL;  
  
            END    ELSE IF @MemberType_ID = @MemberType_Consolidated BEGIN --Parent  
                INSERT INTO @HierarchyMembers (Hierarchy_ID, Child_ID, ChildMemberType_ID, Parent_ID)  
                SELECT DISTINCT  
                     ws.Hierarchy_ID  
                    ,ws.NewMemberID  
                    ,@MemberType_ID  
                    ,0  
                FROM #MemberCodeWorkingSet ws WHERE ws.NewMemberID IS NOT NULL;  
  
            END; --if  
  
            EXEC mdm.udpHierarchyMembersCreate @User_ID, @Version_ID, @Entity_ID, @HierarchyMembers, @LogFlag;  
        END  
  
        IF @TransactionLogType = @TransactionLogType_Member  
        BEGIN  
            ----------------------------------------------------------------------------------------  
            --Insert annotation  
            ----------------------------------------------------------------------------------------  
            IF EXISTS(SELECT 1 FROM #MemberCodeWorkingSet WHERE TransactionAnnotation IS NOT NULL AND ErrorCode IS NULL)  
            BEGIN  
                SET @SQL = CONCAT(N'  
                    INSERT mdm.', @AnnotationTableName, N' (Version_ID, Revision_ID, Comment, EnterUserID, LastChgUserID)  
                    SELECT @Version_ID, mws.Revision_ID, mws.TransactionAnnotation, @User_ID, @User_ID  
                    FROM #MemberCodeWorkingSet mws  
                    WHERE mws.TransactionAnnotation IS NOT NULL AND mws.ErrorCode IS NULL;');  
  
                --PRINT(@SQL);  
                EXEC sp_executesql @SQL,  
                    N'@User_ID INT, @Version_ID INT', @User_ID, @Version_ID;  
            END  
        END  
        ELSE IF @TransactionLogType = @TransactionLogType_Attribute  
        BEGIN  
            ----------------------------------------------------------------------------------------  
            --Log the transaction  
            ----------------------------------------------------------------------------------------  
            --Log member add transactions  
            SET @SQL = N'  
            INSERT INTO [mdm].' + QUOTENAME(@TransactionTableName) + N'  
            (  
                Version_ID,  
                TransactionType_ID,  
                OriginalTransaction_ID,  
                Hierarchy_ID,  
                Entity_ID,  
                Member_ID,  
                Member_MUID,  
                MemberType_ID,  
                MemberCode,  
                OldValue,  
                OldCode,  
                NewValue,  
                NewCode,  
                EnterDTM,  
                EnterUserID,  
                LastChgDTM,  
                LastChgUserID  
            )  
            SELECT  
                @Version_ID,  
                @TransactionType_Create, --TransactionType_ID  
                0, --OriginalTransaction_ID  
                NULLIF(ws.Hierarchy_ID, 0),  
                @Entity_ID,  
                ws.NewMemberID,  
                ws.MUID,  
                @MemberType_ID,  
                ws.MemberCode,  
                N'''', --OldValue  
                N'''', --OldCode  
                N'''', --NewValue  
                N'''', --NewCode  
                @CurrentTime,  
                @User_ID,  
                @CurrentTime,  
                @User_ID  
            FROM #MemberCodeWorkingSet AS ws  
            WHERE ws.NewMemberID IS NOT NULL;  
            ';  
            EXEC sp_executesql @SQL, N'@Version_ID INT, @TransactionType_Create INT, @Entity_ID INT, @MemberType_ID TINYINT, @CurrentTime DATETIME2(3), @User_ID INT',  
                                        @Version_ID,     @TransactionType_Create,     @Entity_ID,     @MemberType_ID,         @CurrentTime,              @User_ID;  
  
            --If a leaf (that has a hierarchy) or a consolidation then log the relationship save transaction  
            IF @IsHierarchyEnabled = 1  
            BEGIN  
                SET @SQL = N'  
                INSERT INTO [mdm].' + QUOTENAME(@TransactionTableName) + N'  
                (  
                    Version_ID,  
                    TransactionType_ID,  
                    OriginalTransaction_ID,  
                    Hierarchy_ID,  
                    Entity_ID,  
                    Member_ID,  
                    Member_MUID,  
                    MemberType_ID,  
                    MemberCode,  
                    OldValue,  
                    OldCode,  
                    NewValue,  
                    NewCode,  
                    EnterDTM,  
                    EnterUserID,  
                    LastChgDTM,  
                    LastChgUserID  
                )  
                SELECT  
                    @Version_ID,  
                    @TransactionType_ParentSet,  
                    0,  
                    hr.Hierarchy_ID,  
                    @Entity_ID,  
                    hr.Child_ID,  
                    ws.MUID,  
                    @MemberType_ID,  
                    ws.MemberCode,  
                    0,  
                    N''ROOT'',  
                    0,  
                    N''ROOT'',  
                    @CurrentTime,  
                    @User_ID,  
                    @CurrentTime,  
                    @User_ID  
                FROM #MemberCodeWorkingSet AS ws  
                INNER JOIN @HierarchyMembers hr  
                    ON ws.NewMemberID = hr.Child_ID  
                    AND ws.NewMemberID IS NOT NULL;  
                ';  
                EXEC sp_executesql @SQL, N'@Version_ID INT, @TransactionType_ParentSet INT, @Entity_ID INT, @MemberType_ID TINYINT, @CurrentTime DATETIME2(3), @User_ID INT, @HierarchyMembers mdm.HierarchyMembers READONLY',  
                                           @Version_ID,     @TransactionType_ParentSet,     @Entity_ID,     @MemberType_ID,         @CurrentTime,              @User_ID,     @HierarchyMembers;  
            END --if  
  
            ----------------------------------------------------------------------------------------  
            --Add any annotation comments that came in with the create  
            --Add annotation comments to both the create and set parent transactions  
            ----------------------------------------------------------------------------------------  
            SET @SQL = N'  
            INSERT INTO [mdm].' + QUOTENAME(@TransactionAnnotationTableName) + N'  
            (  
                Version_ID,  
                Transaction_ID,  
                Comment,  
                EnterUserID,  
                EnterDTM,  
                LastChgDTM,  
                LastChgUserID  
            )  
            SELECT  
                Transactions.Version_ID,  
                Transactions.ID,  
                ws.TransactionAnnotation,  
                Transactions.EnterUserID,  
                Transactions.EnterDTM,  
                Transactions.LastChgDTM,  
                Transactions.LastChgUserID  
            FROM #MemberCodeWorkingSet AS ws  
            LEFT JOIN [mdm].' + QUOTENAME(@TransactionTableName) + N' AS Transactions  
                ON  ws.MemberCode = Transactions.MemberCode  
                AND ws.NewMemberID = Transactions.Member_ID  
            WHERE   Transactions.Entity_ID = @Entity_ID  
                AND Transactions.Version_ID = @Version_ID  
                AND Transactions.MemberType_ID = @MemberType_ID  
                AND Transactions.EnterUserID = @User_ID  
                AND Transactions.EnterDTM = @CurrentTime  
                AND Transactions.TransactionType_ID IN (@TransactionType_Create, @TransactionType_ParentSet)  
                AND ws.TransactionAnnotation IS NOT NULL  
            ';  
            EXEC sp_executesql @SQL, N'@Version_ID INT, @Entity_ID INT, @MemberType_ID TINYINT, @CurrentTime DATETIME2(3), @User_ID INT, @TransactionType_Create INT, @TransactionType_ParentSet INT',  
                                       @Version_ID,     @Entity_ID,     @MemberType_ID,         @CurrentTime,              @User_ID,     @TransactionType_Create,     @TransactionType_ParentSet;  
        END; --if  
  
        ----------------------------------------------------------------------------------------  
        --If member security is in play then add the appropriate member security records.  
        ----------------------------------------------------------------------------------------  
        IF @UseMemberSecurity = 1  
        BEGIN  
            --Add a record to the MS table for the user which created the member so it will be visible to the creator  
            IF @MemberType_ID IN (@MemberType_Leaf, @MemberType_Consolidated)  
            BEGIN  
                --Get the role for the user  
                SELECT @SecurityRoleID = Role_ID FROM mdm.tblSecurityAccessControl where Principal_ID=@User_ID AND PrincipalType_ID=1;  
  
                -- Role ID can be null for a user when user permissions are inherited only from a group. The permission for the member added  
                -- should be set to update for the user. This requires that the sercurity role be added for the user.  
                -- Correct security permissions are applied when the member security update batch process is run by the Service Broker.  
                If(    @SecurityRoleID IS NULL)  
                BEGIN  
  
                    DECLARE @Principal_Name NVARCHAR (100)  
                    SELECT @Principal_Name = UserName FROM mdm.tblUser WHERE ID = @User_ID;  
  
                    INSERT INTO mdm.tblSecurityRole ([Name], EnterUserID, LastChgUserID) VALUES  
                            (N'Role for ' +  + N'UserAccount' + @Principal_Name, 1, 1);  
                    SET @SecurityRoleID = SCOPE_IDENTITY() ;  
  
                    INSERT INTO mdm.tblSecurityAccessControl (PrincipalType_ID, Principal_ID, Role_ID, Description, EnterUserID, LastChgUserID)  
                    VALUES (1, @User_ID, @SecurityRoleID, LEFT(@Principal_Name + N'UserAccount ', 110), 1, 1);  
  
                END  
  
                SET @SQL = N'  
                    INSERT INTO mdm.' + @SecurityTable + N'  
                    (  
                        Version_ID,  
                        User_ID,  
                        ID,  
                        AccessPermission  
                    )  
                    SELECT  
                         @Version_ID  
                        ,@User_ID  
                        ,ws.NewMemberID  
                        ,7 --All  
                    FROM #MemberCodeWorkingSet AS ws  
                    WHERE ws.NewMemberID IS NOT NULL  
                    ;';  
                EXEC sp_executesql @SQL, N'@Version_ID INT, @User_ID INT', @Version_ID, @User_ID;  
            END  
  
            --Put a msg onto the SB queue to process member security  
            EXEC mdm.udpSecurityMemberQueueSave  
                @User_ID    = NULL,-- update member security for all users  
                @Version_ID = @Version_ID,  
                @Entity_ID  = @Entity_ID;  
  
            -- Put a msa onto the SB queue to trancate security related view  
	        EXEC mdm.udpPerformanceQueueSave;  
        END;  
  
        --In a Merge situation we do not care that the code or MUID exists so we clear out any of those errors.  
        --During a Merge operation we set @ErrorIfExists = 0.  
        IF COALESCE(@ErrorIfExists, 0) = 0 BEGIN  
            UPDATE #MemberCodeWorkingSet  
            SET ErrorCode = NULL,  
                ErrorObjectType = NULL  
            WHERE ErrorCode = @ErrorCode_MemberCodeExists OR ErrorCode = @ErrorCode_IdAlreadyExists;  
        END  
  
        --Clear out any duplicate input member code errors because those are not real errors that need to be returned to the consumer.  
        UPDATE #MemberCodeWorkingSet  
        SET ErrorCode = NULL,  
            ErrorObjectType = NULL  
        WHERE ErrorCode = @ErrorCode_DuplicateInputMemberCodes;  
  
        IF @ReturnErrors = 1 OR @ReturnCreatedMembers = 1  
        BEGIN  
            --If ReturnCreatedMembers is turned on, return the create items  
            --along with those in error. If ReturnCreatedMembers is turned  
            --off, only return items that have errors  
            SELECT  
                 MemberCode  
                ,MemberName  
                ,NewMemberID  
                ,MUID  
                ,HierarchyName  
                ,Attribute_MUID  
                ,AttributeName  
                ,ErrorCode  
                ,ErrorObjectType  
                ,@MemberType_ID AS MemberType_ID  
            FROM #MemberCodeWorkingSet  
            WHERE   @ReturnCreatedMembers = 1  
                OR (@ReturnErrors = 1 AND ErrorCode IS NOT NULL)  
        END;  
        IF @ReturnErrors = 0  
        BEGIN  
            -- Raise an error for the first error in the working set  
            DECLARE @FirstErrorCode INT = NULL;  
            SELECT TOP 1  
                @FirstErrorCode = ErrorCode  
            FROM #MemberCodeWorkingSet  
            WHERE ErrorCode IS NOT NULL;  
  
            IF @FirstErrorCode IS NOT NULL  
            BEGIN  
                DECLARE @Message NVARCHAR(50) = N'MDSERR' + CONVERT(NVARCHAR, @FirstErrorCode);  
                RAISERROR(@Message, 16, 1);  
            END;  
        END;  
  
        --Commit only if we are not nested  
        IF @TranCounter = 0 COMMIT TRANSACTION;  
        RETURN(0);  
  
    END TRY  
    --Compensate as necessary  
    BEGIN CATCH  
  
        -- Get error info.  
        DECLARE  
            @ErrorMessage NVARCHAR(4000),  
            @ErrorSeverity INT,  
            @ErrorState INT,  
            @ErrorNumber INT,  
            @ErrorLine INT,  
            @ErrorProcedure NVARCHAR(126);  
        EXEC mdm.udpGetErrorInfo  
            @ErrorMessage = @ErrorMessage OUTPUT,  
            @ErrorSeverity = @ErrorSeverity OUTPUT,  
            @ErrorState = @ErrorState OUTPUT,  
            @ErrorNumber = @ErrorNumber OUTPUT,  
            @ErrorLine = @ErrorLine OUTPUT,  
            @ErrorProcedure = @ErrorProcedure OUTPUT  
  
        SET @ErrorMessage = CONCAT(@ErrorMessage, N', @ErrorNumber = ', @ErrorNumber, N', @ErrorProcedure = "', @ErrorProcedure, N'", line ', @ErrorLine);  
  
        IF @TranCounter = 0 ROLLBACK TRANSACTION;  
        ELSE IF XACT_STATE() <> -1 ROLLBACK TRANSACTION TX;  
        --SELECT @ErrorMessage += N'Line: ' + CONVERT(NVARCHAR(20), @ErrorLine);  
        RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);  
        RETURN(1);  
  
    END CATCH;  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpEntityMembersGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
-- Entity members sample  
-- Account/Account/Leaf  
DECLARE @p27 INT  
DECLARE @p28 mdm.MemberGetCriteria  
DECLARE @p29 mdm.Identifier  
EXEC mdm.udpEntityMembersGet @User_ID=1,@Version_Name=N'Version 4',@Model_Name=N'Product',@Entity_Name=N'Product', @MemberType_ID=1, @PageNumber=1,@PageSize=50,@SortColumn_MUID=NULL,@SortColumn_Name=NULL,@SortDirection=NULL,@MemberReturnOption=3,@MemberCount=@p27 output,@SearchTable=@p28,@AttributeTable=@p29  
SELECT @p27  
  
-- Account/Account/Leaf History  
DECLARE @p27 INT  
DECLARE @p28 mdm.MemberGetCriteria  
DECLARE @p29 mdm.Identifier  
EXEC mdm.udpEntityMembersGet @User_ID=1,@Version_Name=N'Version 4',@Model_Name=N'Product',@Entity_Name=N'Product', @MemberType_ID=1, @PageNumber=1,@PageSize=50,@SortColumn_MUID=NULL,@SortColumn_Name=NULL,@SortDirection=NULL,@MemberReturnOption=18,@MemberCount=@p27 output,@SearchTable=@p28,@AttributeTable=@p29  
SELECT @p27  
  
-- Entity members in Explicit Hierarchy Samples  
-- Product/Bundle/Root (Leaf)  
DECLARE @p27 INT  
DECLARE @p28 mdm.MemberGetCriteria  
DECLARE @p29 mdm.Identifier  
EXEC mdm.udpEntityMembersGet @User_ID=1,@Version_Name=N'Version 4',@Model_Name=N'Product',@Entity_Name=N'Product',@Hierarchy_Name=N'Bundle',@HierarchyType_ID=0,@ParentEntity_Name=N'Product',@MemberType_ID=1,@ParentCode=N'ROOT',@PageNumber=1,@PageSize=50,@SortColumn_MUID=NULL,@SortColumn_Name=NULL,@SortDirection=NULL,@MemberReturnOption=3,@MemberCount=@p27 output,@SearchTable=@p28,@AttributeTable=@p29  
SELECT @p27  
  
-- Product/Bundle/Root (Leaf) History  
DECLARE @p27 INT  
DECLARE @p28 mdm.MemberGetCriteria  
DECLARE @p29 mdm.Identifier  
EXEC mdm.udpEntityMembersGet @User_ID=1,@Version_Name=N'Version 4',@Model_Name=N'Product',@Entity_Name=N'Product',@Hierarchy_Name=N'Bundle',@HierarchyType_ID=0,@ParentEntity_Name=N'Product',@MemberType_ID=1,@ParentCode=N'ROOT',@PageNumber=1,@PageSize=50,@SortColumn_MUID=NULL,@SortColumn_Name=NULL,@SortDirection=NULL,@MemberReturnOption=18,@MemberCount=@p27 output,@SearchTable=@p28,@AttributeTable=@p29  
SELECT @p27  
  
-- Product/Bundle/Root (Consolidated)  
DECLARE @p27 INT  
DECLARE @p28 mdm.MemberGetCriteria  
DECLARE @p29 mdm.Identifier  
EXEC mdm.udpEntityMembersGet @User_ID=1,@Version_Name=N'Version 4',@Model_Name=N'Product',@Entity_Name=N'Product',@Hierarchy_Name=N'Bundle',@HierarchyType_ID=0,@ParentEntity_Name=N'Product',@MemberType_ID=1,@ParentCode=N'ROOT',@PageNumber=1,@PageSize=50,@SortColumn_MUID=NULL,@SortColumn_Name=NULL,@SortDirection=NULL,@MemberReturnOption=3,@MemberCount=@p27 output,@SearchTable=@p28,@AttributeTable=@p29  
SELECT @p27  
  
-- Product/Bundle/Root (Consolidated) History  
DECLARE @p27 INT  
DECLARE @p28 mdm.MemberGetCriteria  
DECLARE @p29 mdm.Identifier  
EXEC mdm.udpEntityMembersGet @User_ID=1,@Version_Name=N'Version 4',@Model_Name=N'Product',@Entity_Name=N'Product',@Hierarchy_Name=N'Bundle',@HierarchyType_ID=0,@ParentEntity_Name=N'Product',@MemberType_ID=1,@ParentCode=N'ROOT',@PageNumber=1,@PageSize=50,@SortColumn_MUID=NULL,@SortColumn_Name=NULL,@SortDirection=NULL,@MemberReturnOption=18,@MemberCount=@p27 output,@SearchTable=@p28,@AttributeTable=@p29  
SELECT @p27  
  
-- Product/Bundle/Root/Bundle10 (Leaf)  
DECLARE @p27 INT  
DECLARE @p28 mdm.MemberGetCriteria  
DECLARE @p29 mdm.Identifier  
EXEC mdm.udpEntityMembersGet @User_ID=1,@Version_Name=N'Version 4',@Model_Name=N'Product',@Entity_Name=N'Product',@Hierarchy_Name=N'Bundle',@HierarchyType_ID=0,@ParentEntity_Name=N'Product',@MemberType_ID=1,@ParentCode=N'BUNDLE10',@PageNumber=1,@PageSize=50,@SortColumn_MUID=NULL,@SortColumn_Name=NULL,@SortDirection=NULL,@MemberReturnOption=3,@MemberCount=@p27 output,@SearchTable=@p28,@AttributeTable=@p29  
SELECT @p27  
  
-- Product/Bundle/Root/Bundle10 (Leaf) History  
DECLARE @p27 INT  
DECLARE @p28 mdm.MemberGetCriteria  
DECLARE @p29 mdm.Identifier  
EXEC mdm.udpEntityMembersGet @User_ID=1,@Version_Name=N'Version 4',@Model_Name=N'Product',@Entity_Name=N'Product',@Hierarchy_Name=N'Bundle',@HierarchyType_ID=0,@ParentEntity_Name=N'Product',@MemberType_ID=1,@ParentCode=N'BUNDLE10',@PageNumber=1,@PageSize=50,@SortColumn_MUID=NULL,@SortColumn_Name=NULL,@SortDirection=NULL,@MemberReturnOption=18,@MemberCount=@p27 output,@SearchTable=@p28,@AttributeTable=@p29  
SELECT @p27  
  
-- Product/Bundle/Root/Bundle10 (Consolidated)  
DECLARE @p27 INT  
DECLARE @p28 mdm.MemberGetCriteria  
DECLARE @p29 mdm.Identifier  
EXEC mdm.udpEntityMembersGet @User_ID=1,@Version_Name=N'Version 4',@Model_Name=N'Product',@Entity_Name=N'Product',@Hierarchy_Name=N'Bundle',@HierarchyType_ID=0,@ParentEntity_Name=N'Product',@MemberType_ID=2,@ParentCode=N'BUNDLE10',@PageNumber=1,@PageSize=50,@SortColumn_MUID=NULL,@SortColumn_Name=NULL,@SortDirection=NULL,@MemberReturnOption=3,@MemberCount=@p27 output,@SearchTable=@p28,@AttributeTable=@p29  
SELECT @p27  
  
-- Product/Bundle/Root/Bundle10 (Consolidated) History  
DECLARE @p27 INT  
DECLARE @p28 mdm.MemberGetCriteria  
DECLARE @p29 mdm.Identifier  
EXEC mdm.udpEntityMembersGet @User_ID=1,@Version_Name=N'Version 4',@Model_Name=N'Product',@Entity_Name=N'Product',@Hierarchy_Name=N'Bundle',@HierarchyType_ID=0,@ParentEntity_Name=N'Product',@MemberType_ID=2,@ParentCode=N'BUNDLE10',@PageNumber=1,@PageSize=50,@SortColumn_MUID=NULL,@SortColumn_Name=NULL,@SortDirection=NULL,@MemberReturnOption=18,@MemberCount=@p27 output,@SearchTable=@p28,@AttributeTable=@p29  
SELECT @p27  
  
-- All Consolidate in Product/Bundle  
DECLARE @p27 INT  
DECLARE @p28 mdm.MemberGetCriteria  
DECLARE @p29 mdm.Identifier  
EXEC mdm.udpEntityMembersGet @User_ID=1,@Version_Name=N'Version 4',@Model_Name=N'Product',@Entity_Name=N'Product',@Hierarchy_Name=N'Bundle',@HierarchyType_ID=0,@ParentEntity_Name=N'Product',@MemberType_ID=2,@ParentCode=NULL,@PageNumber=1,@PageSize=50,@SortColumn_MUID=NULL,@SortColumn_Name=NULL,@SortDirection=NULL,@MemberReturnOption=3,@MemberCount=@p27 output,@SearchTable=@p28,@AttributeTable=@p29  
SELECT @p27  
  
-- All Consolidate in Product/Bundle History  
DECLARE @p27 INT  
DECLARE @p28 mdm.MemberGetCriteria  
DECLARE @p29 mdm.Identifier  
EXEC mdm.udpEntityMembersGet @User_ID=1,@Version_Name=N'Version 4',@Model_Name=N'Product',@Entity_Name=N'Product',@Hierarchy_Name=N'Bundle',@HierarchyType_ID=0,@ParentEntity_Name=N'Product',@MemberType_ID=2,@ParentCode=NULL,@PageNumber=1,@PageSize=50,@SortColumn_MUID=NULL,@SortColumn_Name=NULL,@SortDirection=NULL,@MemberReturnOption=18,@MemberCount=@p27 output,@SearchTable=@p28,@AttributeTable=@p29  
SELECT @p27  
  
-- Entity members in Derived Hierarchy Samples  
-- Product/Color/Unused  
DECLARE @p27 INT  
DECLARE @p28 mdm.MemberGetCriteria  
DECLARE @p29 mdm.Identifier  
EXEC mdm.udpEntityMembersGet @User_ID=1,@Version_Name=N'Version 4',@Model_Name=N'Product',@Entity_Name=N'Product',@Hierarchy_Name=N'Color',@HierarchyType_ID=1,@ParentEntity_Name=N'Color',@MemberType_ID=1,@ParentCode=N'MDMUNUSED',@PageNumber=1,@PageSize=50,@SortColumn_MUID=NULL,@SortColumn_Name=NULL,@SortDirection=NULL,@MemberReturnOption=3,@MemberCount=@p27 output,@SearchTable=@p28,@AttributeTable=@p29  
SELECT @p27  
  
-- Product/Color/Unused History  
DECLARE @p27 INT  
DECLARE @p28 mdm.MemberGetCriteria  
DECLARE @p29 mdm.Identifier  
EXEC mdm.udpEntityMembersGet @User_ID=1,@Version_Name=N'Version 4',@Model_Name=N'Product',@Entity_Name=N'Product',@Hierarchy_Name=N'Color',@HierarchyType_ID=1,@ParentEntity_Name=N'Color',@MemberType_ID=1,@ParentCode=N'MDMUNUSED',@PageNumber=1,@PageSize=50,@SortColumn_MUID=NULL,@SortColumn_Name=NULL,@SortDirection=NULL,@MemberReturnOption=18,@MemberCount=@p27 output,@SearchTable=@p28,@AttributeTable=@p29  
SELECT @p27  
  
-- Product/Color/White  
DECLARE @p27 INT  
DECLARE @p28 mdm.MemberGetCriteria  
DECLARE @p29 mdm.Identifier  
EXEC mdm.udpEntityMembersGet @User_ID=1,@Version_Name=N'Version 4',@Model_Name=N'Product',@Entity_Name=N'Product',@Hierarchy_Name=N'Color',@HierarchyType_ID=1,@ParentEntity_Name=N'Color',@MemberType_ID=1,@ParentCode=N'White',@PageNumber=1,@PageSize=50,@SortColumn_MUID=NULL,@SortColumn_Name=NULL,@SortDirection=NULL,@MemberReturnOption=3,@MemberCount=@p27 output,@SearchTable=@p28,@AttributeTable=@p29  
SELECT @p27  
  
-- Product/Color/White History  
DECLARE @p27 INT  
DECLARE @p28 mdm.MemberGetCriteria  
DECLARE @p29 mdm.Identifier  
EXEC mdm.udpEntityMembersGet @User_ID=1,@Version_Name=N'Version 4',@Model_Name=N'Product',@Entity_Name=N'Product',@Hierarchy_Name=N'Color',@HierarchyType_ID=1,@ParentEntity_Name=N'Color',@MemberType_ID=1,@ParentCode=N'White',@PageNumber=1,@PageSize=50,@SortColumn_MUID=NULL,@SortColumn_Name=NULL,@SortDirection=NULL,@MemberReturnOption=18,@MemberCount=@p27 output,@SearchTable=@p28,@AttributeTable=@p29  
SELECT @p27  
*/  
CREATE PROCEDURE [mdm].[udpEntityMembersGet]  
(  
    @User_ID                INT,  
    @Model_MUID             UNIQUEIDENTIFIER = NULL,  
    @Model_Name             NVARCHAR(MAX) = NULL,  
    @Entity_MUID            UNIQUEIDENTIFIER = NULL,  
    @Entity_Name            NVARCHAR(MAX) = NULL,  
    @Version_MUID           UNIQUEIDENTIFIER = NULL,  
    @Version_Name           NVARCHAR(MAX) = NULL,  
    @MemberType_ID          TINYINT,  
    @Hierarchy_MUID         UNIQUEIDENTIFIER = NULL,  
    @Hierarchy_Name         NVARCHAR(MAX) = NULL,  
    @HierarchyType_ID       TINYINT = NULL,  
    @HierarchyLevelNumber   INT = NULL, -- viw_SYSTEM_SCHEMA_HIERARCHY_DERIVED_LEVELS.LevelNumber (starts with zero at the top level)  
    @ParentEntity_MUID      UNIQUEIDENTIFIER = NULL,  
    @ParentEntity_Name      NVARCHAR(MAX) = NULL,  
    @ParentCode             NVARCHAR(250) = NULL,  
    @AttributeTable         mdm.Identifier READONLY,  
    @AttributeGroup_MUID    UNIQUEIDENTIFIER = NULL,  
    @AttributeGroup_Name    NVARCHAR(MAX) = NULL,  
    @SearchTable            mdm.MemberGetCriteria READONLY,  
    @PageNumber             INT = NULL,  
    @PageSize               INT = NULL OUTPUT,  
    @SortColumn_MUID        UNIQUEIDENTIFIER = NULL,  
    @SortColumn_Name        NVARCHAR(128) = NULL,  
    @SortDirection          NVARCHAR(4) = NULL,  
    @IncludeAuditInfo       BIT = 0,  
    @MemberReturnOption     TINYINT = 7, -- Data, counts & membership information  
    @MemberCount            INT = NULL OUTPUT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
    DECLARE @GuidEmpty                                  UNIQUEIDENTIFIER = CAST(0x0 AS UNIQUEIDENTIFIER),  
            @Model_ID                                   INT,  
            @Entity_ID                                  INT,  
            @Version_ID                                 INT,  
            @AttributeGroup_ID                          INT,  
            @Hierarchy_ID                               INT,  
            @HierarchyLevel_ID                          INT,  
            @ParentEntity_ID                            INT,  
            @ParentAttribute_ID                         INT,  
            @ParentAttribute_Name                       SYSNAME,  
            @Parent_ID                                  INT,  
            @ParentViewAlias                            SYSNAME = NULL,  
  
            @Unused_ID                                  INT = -1,  
            @Root_ID                                    INT = 0,  
  
            @UseMemberSecurity                          BIT = 0,  
            @IsDefaultOrder                             BIT = 0,  
            @IsCollectionEnabled                        BIT = 0,  
            @IsHierarchyEnabled                         BIT = 0,  
            @IsHistoricalData                           BIT = 0,  
            @IsHistoricalMembershipInformation          BIT = 0,  
  
            @SecurityTableName                          SYSNAME,  
            @HierarchyTable                             SYSNAME,  
            @MemberViewName                             SYSNAME,  
  
            @HierarchyType_Explicit                     TINYINT = 0,  
            @HierarchyType_Derived                      TINYINT = 1,  
  
            @MemberReturnOptionData                     TINYINT = 1,  
            @MemberReturnOptionCount                    TINYINT = 2,  
            @MemberReturnOptionMembershipInformation    TINYINT = 4,  
            @MemberReturnOptionDerivedHierarchyParents  TINYINT = 8,-- return the Parents member Id  
            @MemberReturnOptionHistoricalData           TINYINT = 16,  
            @MemberReturnOptionHistoricalMembershipInformation  TINYINT = 32,  
  
            @MemberType_NotSpecified                    TINYINT = 0,  
            @MemberType_Leaf                            TINYINT = 1,  
            @MemberType_Consolidated                    TINYINT = 2,  
            @MemberType_Collection                      TINYINT = 3,  
  
            @AttributeType_Domain                       TINYINT = 2,  
            @AttributeType_System                       TINYINT = 3,  
  
            @ForeignType_Entity                         TINYINT = 0,  
            @ForeignType_DBA                            TINYINT = 1,  
            @ForeignType_ManyToMany                     TINYINT = 5,  
  
            @MemberStatusActive                         TINYINT = 1,  
  
            @Model_Permission                           TINYINT,  
            @Entity_Permission                          TINYINT,  
            @MemberType_Permission                      TINYINT,  
            @Permission_Deny                            TINYINT = 1,  
            @Permission_Access                          TINYINT = 4,  
            @Permission_Admin                           TINYINT = 5,  
            @Permission_Inferred                        TINYINT = 99,  
  
            @MemberType_AccessPermission                TINYINT,  
            @AccessPermission_All                       TINYINT = 7,  
            @AccessPermission_Read                      TINYINT = 0,  
            @AccessPermission_Update                    TINYINT = 2,  
            @AccessPermission_Delete                    TINYINT = 4,  
            @AccessPermission_UpdateDelete              TINYINT = 6, -- 2+4  
  
            @VersionStatus                              TINYINT,  
            @VersionStatus_Locked                       TINYINT = 2,  
            @VersionStatus_Committed                    TINYINT = 3,  
  
            @SortColumn_TableName                       SYSNAME = NULL,  
            @ColumnString                               NVARCHAR(MAX) = NULL,  
            @MemberOrderBy                              NVARCHAR(MAX) = NULL,  
            @PagingTerm                                 NVARCHAR(MAX) = NULL,  
            @MemberFrom                                 NVARCHAR(MAX) = NULL,  
            @DerivedHierarchyParentJoin                 NVARCHAR(MAX) = NULL,  
            @MemberWhere                                NVARCHAR(MAX) = NULL,  
            @TruncateGuard                              NVARCHAR(MAX) = N'',  
            @SQL                                        NVARCHAR(MAX);  
  
    SELECT  
        @User_ID = NULLIF(@User_ID, 0),  
        @Model_MUID = NULLIF(@Model_MUID, @GuidEmpty),  
        @Model_Name = NULLIF(LTRIM(RTRIM(@Model_Name)), N''),  
        @Entity_MUID = NULLIF(@Entity_MUID, @GuidEmpty),  
        @Entity_Name = NULLIF(LTRIM(RTRIM(@Entity_Name)), N''),  
        @Version_MUID = NULLIF(@Version_MUID, @GuidEmpty),  
        @Version_Name = NULLIF(LTRIM(RTRIM(@Version_Name)), N''),  
        @AttributeGroup_MUID = NULLIF(@AttributeGroup_MUID, @GuidEmpty),  
        @AttributeGroup_Name = NULLIF(LTRIM(RTRIM(@AttributeGroup_Name)), N''),  
        @Hierarchy_MUID = NULLIF(@Hierarchy_MUID, @GuidEmpty),  
        @Hierarchy_Name = NULLIF(LTRIM(RTRIM(@Hierarchy_Name)), N''),  
        @ParentEntity_MUID = NULLIF(@ParentEntity_MUID, @GuidEmpty),  
        @ParentEntity_Name = NULLIF(LTRIM(RTRIM(@ParentEntity_Name)), N''),  
        @ParentCode = NULLIF(LTRIM(RTRIM(@ParentCode)), N''),  
        @SortColumn_MUID = NULLIF(@SortColumn_MUID, @GuidEmpty),  
        @SortColumn_Name = NULLIF(LTRIM(RTRIM(@SortColumn_Name)), N''),  
        @SortDirection = NULLIF(LTRIM(RTRIM(@SortDirection)), N''),  
        @IsHistoricalData = CASE WHEN @MemberReturnOption & @MemberReturnOptionHistoricalData <> 0 THEN 1 ELSE -0 END,  
        @IsHistoricalMembershipInformation = CASE WHEN @MemberReturnOption & @MemberReturnOptionHistoricalMembershipInformation <> 0 THEN 1 ELSE -0 END,  
        @MemberCount = NULL;  
  
    -- Validate parameters  
    IF @User_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR100009|The User ID is not valid.', 16, 1);  
        RETURN;  
    END  
  
    EXEC mdm.udpInformationLookupModel  
        @User_ID = @User_ID,  
        @Model_MUID = @Model_MUID,  
        @Model_Name = @Model_Name,  
        @ID = @Model_ID OUTPUT,  
        @Privilege_ID = @Model_Permission OUTPUT;  
    IF @Model_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR300005|The supplied model is not valid.', 16, 1);  
        RETURN;  
    END;  
  
    SELECT @Version_ID = ID, @VersionStatus = Status_ID  
    FROM mdm.tblModelVersion  
    WHERE  
            (@Version_MUID IS NOT NULL OR @Version_Name IS NOT NULL)  
        AND (@Version_MUID IS NULL OR MUID = @Version_MUID)  
        AND (@Version_Name IS NULL OR Name = @Version_Name)  
        AND Model_ID = @Model_ID;  
    IF @Version_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR300006|The supplied version is not valid.', 16, 1);  
        RETURN;  
    END;  
  
    EXEC mdm.udpInformationLookupEntity  
        @User_ID = @User_ID,  
        @Model_ID = @Model_ID,  
        @Entity_MUID = @Entity_MUID,  
        @Entity_Name = @Entity_Name,  
        @ID = @Entity_ID OUTPUT,  
        @Privilege_ID = @Entity_Permission OUTPUT,  
        @IsCollectionEnabled = @IsCollectionEnabled OUTPUT,  
        @IsHierarchyEnabled = @IsHierarchyEnabled OUTPUT;  
    IF @Entity_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR300008|The supplied entity is not valid.', 16, 1);  
        RETURN;  
    END;  
  
    SET @SecurityTableName =  
        CASE @MemberType_ID  
            WHEN @MemberType_Leaf THEN CONCAT(N'tbl_', @Model_ID, N'_', @Entity_ID ,N'_EN_MS')  
            WHEN @MemberType_Consolidated THEN CONCAT(N'tbl_', @Model_ID, N'_', @Entity_ID ,N'_HP_MS')  
        END;  
  
    SET @HierarchyTable = CONCAT(N'tbl_', @Model_ID, N'_', @Entity_ID ,N'_HR');  
  
    IF @IsHierarchyEnabled = 0 AND @MemberType_ID = @MemberType_Consolidated  
    BEGIN  
        RAISERROR('MDSERR300035|The member type is not supported by the entity.', 16, 1);  
        RETURN;  
    END  
  
    IF @IsCollectionEnabled = 0 AND @MemberType_ID =  @MemberType_Collection  
    BEGIN  
        -- No collections have been created yet, so return.  
        RETURN;  
    END;  
  
    SET @MemberType_ID = COALESCE(@MemberType_ID, @MemberType_NotSpecified);  
    IF @MemberType_ID NOT IN (@MemberType_Leaf, @MemberType_Consolidated, @MemberType_Collection)  
    BEGIN  
        RAISERROR('MDSERR100002|The Member Type is not valid.', 16, 1);  
        RETURN;  
    END;  
  
    IF @ParentEntity_MUID IS NOT NULL OR @ParentEntity_Name IS NOT NULL  
    BEGIN  
        EXEC mdm.udpInformationLookupEntity  
            @User_ID = @User_ID,  
            @Model_ID = @Model_ID,  
            @Entity_MUID = @ParentEntity_MUID,  
            @Entity_Name = @ParentEntity_Name,  
            @ID = @ParentEntity_ID OUTPUT  
        IF @ParentEntity_ID IS NULL  
        BEGIN  
            RAISERROR(N'MDSERR300008|The supplied entity is not valid.', 16, 1);  
            RETURN;  
        END;  
    END  
  
    IF @Hierarchy_MUID IS NOT NULL OR @Hierarchy_Name IS NOT NULL  
    BEGIN  
  
        IF @HierarchyType_ID = @HierarchyType_Explicit  
        BEGIN  
            EXEC mdm.udpInformationLookupHierarchy  
                @User_ID = @User_ID,  
                @Entity_ID = @Entity_ID,  
                @Hierarchy_MUID = @Hierarchy_MUID,  
                @Hierarchy_Name = @Hierarchy_Name,  
                @ID = @Hierarchy_ID OUTPUT  
            IF @Hierarchy_ID IS NULL  
            BEGIN  
                RAISERROR(N'MDSERR300009|Explicit Hierarchy is Invalid', 16, 1);  
                RETURN;  
            END;  
        END  
        ELSE IF @HierarchyType_ID = @HierarchyType_Derived  
        BEGIN  
            EXEC mdm.udpInformationLookupDerivedHierarchy  
                @User_ID = @User_ID,  
                @Model_ID = @Model_ID,  
                @DerivedHierarchy_ID = @Hierarchy_ID,  
                @DerivedHierarchy_MUID = @Hierarchy_MUID,  
                @DerivedHierarchy_Name = @Hierarchy_Name,  
                @ID = @Hierarchy_ID OUTPUT  
            IF @Hierarchy_ID IS NULL  
            BEGIN  
                RAISERROR(N'MDSERR300007|DerivedHierarchy is Invalid', 16, 1);  
                RETURN;  
            END;  
        END  
    END  
  
    -- Check paging, sorting and search term.  
    SET @PageNumber = COALESCE(@PageNumber, 0);  
    SET @PageSize = COALESCE(@PageSize, (SELECT SettingValue FROM mdm.tblSystemSetting WHERE SettingName = CAST(N'RowsPerBatch' AS NVARCHAR(100))))  
    IF @PageNumber > 0 AND @PageSize > 0  
    BEGIN  
        SET @PagingTerm = N'  
OFFSET ((@PageNumber - 1) * @PageSize) ROWS  
FETCH NEXT @PageSize ROWS ONLY'  
    END  
  
    IF  @SortColumn_MUID IS NOT NULL OR @SortColumn_Name IS NOT NULL  
    BEGIN  
        EXEC mdm.udpInformationLookupAttribute  
            @User_ID = @User_ID,  
            @Entity_ID = @Entity_ID,  
            @Attribute_MUID = @SortColumn_MUID,  
            @Attribute_Name = @SortColumn_Name,  
            @Name = @SortColumn_TableName OUTPUT  
        IF @SortColumn_TableName IS NULL  
        BEGIN  
            IF  @SortColumn_MUID IS NOT NULL  
            BEGIN  
                RAISERROR(N'MDSERR300010|Attribute is Invalid', 16, 1);  
                RETURN;  
            END  
            ELSE  
            BEGIN  
                SET @SortColumn_TableName = @SortColumn_Name;  
            END  
        END;  
    END  
  
    EXEC mdm.udpResolveMemberGetCriteria @SearchTable, @MemberWhere OUTPUT, @MemberOrderBy OUTPUT;  
  
    IF @SortColumn_TableName IS NOT NULL  
    BEGIN  
        SET @MemberOrderBy = CONCAT(N'T.', QUOTENAME(@SortColumn_TableName), CASE WHEN UPPER(@SortDirection) = N'ASC' THEN N' ASC' ELSE N' DESC' END);  
    END  
  
    IF NULLIF(@MemberOrderBy, N'') IS NULL  
    BEGIN  
        SET @MemberOrderBy = CASE @IsHistoricalData WHEN 0 THEN N'T.ID ASC' ELSE N'T.HS_ID DESC' END;  
        SET @IsDefaultOrder = 1;  
    END  
  
    SET @MemberOrderBy = CONCAT(N'  
ORDER BY ', @MemberOrderBy);  
  
    -- Check member security.  
    IF @Entity_Permission = @Permission_Admin  
    BEGIN  
        SET @MemberType_Permission = @Permission_Access;  
        SET @MemberType_AccessPermission = @AccessPermission_All;  
    END  
    ELSE  
    BEGIN  
        SELECT @MemberType_Permission = Privilege_ID,  
            @MemberType_AccessPermission = AccessPermission  
        FROM mdm.viw_SYSTEM_SECURITY_USER_MEMBERTYPE  
        WHERE [User_ID] = @User_ID  
            AND [Entity_ID] = @Entity_ID  
            AND ID = @MemberType_ID;  
  
        SET @MemberType_Permission = COALESCE(@MemberType_Permission, @Permission_Deny);  
  
        -- In the case of Privilege_ID is inferred, should be INTerpreted as Access and ReadOnly  
        IF  @MemberType_Permission = @Permission_Inferred  
        BEGIN  
            SET @MemberType_Permission = @Permission_Access;  
            SET @MemberType_AccessPermission = @AccessPermission_Read;  
        END;  
  
        IF @MemberType_Permission = @Permission_Deny  
        BEGIN  
            RAISERROR(N'MDSERR120002|The user does not have permission to perform this operation.', 16, 1);  
            RETURN;  
        END;  
  
        -- Only leaf and consolidated has member security  
        IF @MemberType_ID IN (@MemberType_Leaf, @MemberType_Consolidated)  
        BEGIN  
            SET @UseMemberSecurity = mdm.udfUseMemberSecurity (@User_ID, @Entity_ID, @Version_ID, @MemberType_ID);  
        END  
    END;  
  
    -- Process attributes  
    DECLARE @AttributesWorkingSet TABLE  
    (  
        Name NVARCHAR(250) COLLATE DATABASE_DEFAULT PRIMARY KEY,  
        MUID UNIQUEIDENTIFIER,  
        ID INT NULL,  
        AttributeType_ID TINYINT NULL,  
        DataType_ID TINYINT NULL,  
        SortOrder INT,  
        AccessPermission TINYINT  
    );  
  
    IF (@AttributeGroup_MUID IS NOT NULL OR @AttributeGroup_Name IS NOT NULL)  
    BEGIN  
        EXEC mdm.udpInformationLookupAttributeGroup  
            @User_ID = @User_ID,  
            @Entity_ID = @Entity_ID,  
            @MemberType_ID = @MemberType_ID,  
            @AttributeGroup_MUID = @AttributeGroup_MUID,  
            @AttributeGroup_Name = @AttributeGroup_Name,  
            @ID = @AttributeGroup_ID OUTPUT;  
        IF @AttributeGroup_ID IS NULL  
        BEGIN  
            RAISERROR(N'MDSERR300011|Attribute Group is Invalid', 16, 1);  
            RETURN;  
        END;  
  
        INSERT INTO @AttributesWorkingSet  
        (  
            MUID  
            ,Name  
            ,ID  
            ,AttributeType_ID  
            ,DataType_ID  
            ,SortOrder  
            ,AccessPermission  
        )  
        SELECT  
            att.MUID  
            ,att.Name  
            ,att.ID  
            ,att.AttributeType_ID  
            ,att.DataType_ID  
            ,COALESCE(agDetail.SortOrder, att.SortOrder)  
            ,sec.AccessPermission  
        FROM mdm.tblAttribute att  
        INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_ATTRIBUTE sec -- Only return AttributeType_ID <> @AttributeType_System  
        ON att.ID = sec.ID AND sec.User_ID = @User_ID AND att.Entity_ID = @Entity_ID AND att.MemberType_ID = @MemberType_ID  
        LEFT JOIN mdm.tblAttributeGroupDetail agDetail  
        ON agDetail.Attribute_ID = sec.ID AND agDetail.AttributeGroup_ID = @AttributeGroup_ID  
        WHERE agDetail.Attribute_ID IS NOT NULL OR att.IsSystem = 1  
    END  
    ELSE IF EXISTS (SELECT 1 FROM @AttributeTable)  
    BEGIN  
        INSERT INTO @AttributesWorkingSet  
        (  
            MUID  
            ,Name  
            ,ID  
            ,AttributeType_ID  
            ,DataType_ID  
            ,SortOrder  
            ,AccessPermission  
        )  
        SELECT  
            att.MUID  
            ,att.Name  
            ,att.ID  
            ,att.AttributeType_ID  
            ,att.DataType_ID  
            ,att.SortOrder  
            ,sec.AccessPermission  
        FROM mdm.tblAttribute att  
        INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_ATTRIBUTE sec -- Only return AttributeType_ID <> @AttributeType_System  
        ON att.ID = sec.ID AND sec.User_ID = @User_ID AND att.Entity_ID = @Entity_ID AND att.MemberType_ID = @MemberType_ID  
        LEFT JOIN @AttributeTable at  
        ON (at.MUID IS NULL OR at.MUID = 0x0 OR at.MUID = att.MUID) AND (at.Name IS NULL OR at.Name = N'' OR at.Name = att.Name)  
        WHERE (at.MUID IS NOT NULL AND at.MUID != 0x0) OR (at.Name IS NOT NULL AND at.Name != N'') OR att.IsSystem = 1  
    END  
    ELSE  
    BEGIN  
        INSERT INTO @AttributesWorkingSet  
        (  
            MUID  
            ,Name  
            ,ID  
            ,AttributeType_ID  
            ,DataType_ID  
            ,SortOrder  
            ,AccessPermission  
        )  
        SELECT  
            att.MUID  
            ,att.Name  
            ,att.ID  
            ,att.AttributeType_ID  
            ,att.DataType_ID  
            ,att.SortOrder  
            ,sec.AccessPermission  
        FROM mdm.tblAttribute att  
        INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_ATTRIBUTE sec -- Only return AttributeType_ID <> @AttributeType_System  
        ON att.ID = sec.ID AND sec.User_ID = @User_ID AND att.Entity_ID = @Entity_ID AND att.MemberType_ID = @MemberType_ID  
    END  
  
    SET @MemberType_AccessPermission = @MemberType_AccessPermission & @AccessPermission_UpdateDelete;  
  
    IF EXISTS(SELECT ID FROM @AttributesWorkingSet WHERE (AccessPermission & @AccessPermission_Update) = @AccessPermission_Update)  
    BEGIN  
        SET @MemberType_AccessPermission |= @AccessPermission_Update;  
    END  
    ELSE  
    BEGIN  
        SET @MemberType_AccessPermission &= @AccessPermission_Delete;  
    END;  
  
    -- If version status is committed or locked, the member is read-only.  
    IF (@VersionStatus = @VersionStatus_Committed) OR (@VersionStatus = @VersionStatus_Locked AND @Model_Permission != @Permission_Admin)  
    BEGIN  
        SET @MemberType_AccessPermission = @AccessPermission_Read;  
    END  
  
    SET @ColumnString = CONCAT(@TruncateGuard, N'  
     T.ID  
    ,T.Code  
    ,T.Name  
    ,T.MUID  
    ');  
  
    SET @ColumnString = CONCAT(@ColumnString,  
        CASE @IsHistoricalData  
            WHEN 0 THEN N'  
    ,T.ValidationStatus_ID  
    ,CONVERT(BIGINT, T.LastChgTS) AS LastChgTS'  
            ELSE N'  
    ,T.HS_ID  
    ,T.Status_ID  
    ,T.LastChgTS AS LastChgTS'  
            END);  
  
    SET @ColumnString = CONCAT(@ColumnString,  
        CASE @IncludeAuditInfo  
            WHEN 1 THEN N'  
    ,T.EnterDTM  
    ,T.EnterUserName  
    ,T.LastChgDTM  
    ,T.LastChgUserName'  
        END);  
  
    SELECT  
        @ColumnString +=  
            CASE AttributeType_ID  
                WHEN @AttributeType_Domain THEN CONCAT(N'  
    ,', QUOTENAME(Name), N'  
    ,', QUOTENAME(Name + N'.Name'), N'  
    ,', QUOTENAME(Name + N'.MUID'), N'  
    ,', QUOTENAME(Name + N'.ID'))  
                ELSE CONCAT(N'  
    ,', QUOTENAME(Name), N'')  
            END  
        FROM @AttributesWorkingSet  
        WHERE Name <> N'Code'  
            AND Name <> N'Name'  
  
    SET @ColumnString = CONCAT(@ColumnString, N'  
    ,@MemberType_Permission AS Privilege_ID  
    ,', CASE WHEN @UseMemberSecurity = 0 OR @IsHistoricalData = 1  
        THEN N'@MemberType_AccessPermission'   
        ELSE N'CONVERT(TINYINT, id.AccessPermission & @MemberType_AccessPermission)' END,   
        N' AS AccessPermission')  
  
    SET @MemberViewName = mdm.udfViewNameGet(@Model_ID, @Entity_ID, @MemberType_ID, 0, CASE @IsHistoricalData WHEN 0 THEN 0 ELSE 2 END);  
  
    SET @MemberFrom = CONCAT(@TruncateGuard, N'  
FROM mdm.', QUOTENAME(@MemberViewName), N' T', CASE WHEN @UseMemberSecurity = 1 THEN CONCAT(N'  
INNER JOIN mdm.', QUOTENAME(@SecurityTableName), N' ms  
ON      T.Version_ID = ms.Version_ID  
    AND T.ID = ms.ID  
    AND ms.User_ID = @User_ID') END)  
  
    SET @MemberWhere = CONCAT(N'  
WHERE   ', @MemberWhere, CASE WHEN @MemberWhere IS NOT NULL THEN N'  
    AND ' END, N'T.Version_ID = @Version_ID');  
  
    IF @ParentCode IS NULL OR @ParentCode  = N'MDMNULL'  
    BEGIN  
        SET @Parent_ID = NULL;  
    END  
    ELSE IF UPPER(@ParentCode) = N'MDMUNUSED'  
    BEGIN  
        SET @Parent_ID = @Unused_ID;  
    END  
    ELSE IF UPPER(@ParentCode) = N'ROOT'  
    BEGIN  
        SET @Parent_ID = @Root_ID;  
    END   
    ELSE IF @Hierarchy_ID IS NOT NULL  
    BEGIN  
        -- Lookup @Parent_ID from @ParentCode  
        SET @SQL = CONCAT(@TruncateGuard, N'  
            SELECT TOP 1 @Parent_ID = ID  
            FROM mdm.', QUOTENAME(CONCAT(N'tbl_', @Model_ID, N'_',  
                CASE @HierarchyType_ID  
                    WHEN @HierarchyType_Derived THEN CONCAT(@ParentEntity_ID, N'_EN')  
                    ELSE                             CONCAT(@Entity_ID,       N'_HP')  
                    END)), N'   
            WHERE   Version_ID = @Version_ID   
                AND Code = @ParentCode  
                AND Status_ID = ', @MemberStatusActive, N'; -- ignore soft-deleted members');  
        EXEC sp_executesql @SQL, N'@ParentCode NVARCHAR(250), @Version_ID INT, @Parent_ID INT OUTPUT', @ParentCode, @Version_ID, @Parent_ID OUTPUT;  
  
        IF @Parent_ID IS NULL  
        BEGIN  
            RAISERROR('MDSERR100025|Either the parent code or the parent type is not valid.', 16, 1);  
            RETURN;  
        END  
    END  
  
    IF @Hierarchy_ID IS NOT NULL  
    BEGIN  
        --Derived Hierarchy  
        IF @HierarchyType_ID = @HierarchyType_Derived  
        BEGIN  
            -- Determine if it is a recursive hierarchy that anchors null recursions.  
            DECLARE @IsRecursiveAndAnchorsNullRecursions BIT = COALESCE(  
               (SELECT TOP 1 tDH.AnchorNullRecursions  
                FROM mdm.tblDerivedHierarchy tDH  
                LEFT JOIN mdm.viw_SYSTEM_SCHEMA_HIERARCHY_DERIVED_LEVELS tDHL  
                ON tDHL.Hierarchy_ID = tDH.ID  
                WHERE   tDH.ID = @Hierarchy_ID  
                    AND tDHL.IsRecursive = 1  
                    AND tDHL.LevelNumber = 0)-- only look at top recursive level  
                , 0);  
  
            DECLARE @RootEntity_ID INT = 0;  
            IF @IsRecursiveAndAnchorsNullRecursions = 0 AND COALESCE(@Parent_ID, @Root_ID) = @Root_ID -- Find Entity for the root of the Derived Hierarchy  
            BEGIN  
                SELECT TOP 1  
                    @RootEntity_ID = Entity_ID  
                FROM mdm.viw_SYSTEM_SCHEMA_HIERARCHY_DERIVED_LEVELS  
                WHERE   Hierarchy_ID = @Hierarchy_ID  
                    AND LevelNumber = 0 -- topmost level  
            END  
  
            IF @RootEntity_ID != @Entity_ID  
            BEGIN  
                -- We are looking for the foreign ID of the Derived Hierarchy. In the normal case there should be only one returned that match the hierarchy ID  
                -- and is of type DBA. If there is a hidden level, the tblAttribute.Entity_ID will NOT be the same as the given entity. But, as we only get back one result it is correct  
                -- But, in the case of a recursive hierarchy that has level(s) beneath the recursive levels, there will be more than 1 returned result. We only want to filter out the one that has the same entity ID in the attribute  
                -- We solve this by sorting by the equality of attribute.Entity_ID to the given entity ID. if there is only one result, it doesn't matter. For multiple results we will  
                -- always get back first the one that has the ID we are looking for and choose it using a TOP 1.  
                  
                IF (@HierarchyLevelNumber IS NULL)  
                BEGIN  
                    SELECT TOP 1  
                         @ParentAttribute_ID = dhd.Foreign_ID  
                        ,@HierarchyLevel_ID = dhd.Level_ID  
                    FROM mdm.tblDerivedHierarchyDetail dhd  
                    INNER JOIN mdm.tblAttribute a  
                    ON      dhd.Foreign_ID = a.ID  
                        AND dhd.ForeignType_ID IN (@ForeignType_DBA, @ForeignType_ManyToMany)  
                    WHERE   dhd.DerivedHierarchy_ID = @Hierarchy_ID  
                        AND a.DomainEntity_ID = @ParentEntity_ID  
                    ORDER BY (CASE WHEN a.Entity_ID = @Entity_ID THEN 0 ELSE dhd.Level_ID END)  ASC  
                END ELSE  
                BEGIN  
                    IF (@HierarchyLevelNumber = 0)  
                    BEGIN  
                        -- Top-level of hierarchy  
                        SELECT TOP 1  
                             @ParentAttribute_ID = CASE WHEN dhd.IsRecursive = 1 THEN Foreign_ID END  
                            ,@HierarchyLevel_ID = Level_ID  
                        FROM mdm.viw_SYSTEM_SCHEMA_HIERARCHY_DERIVED_LEVELS dhd  
                        WHERE   dhd.Hierarchy_ID = @Hierarchy_ID  
                            AND dhd.ForeignType_ID IN (@ForeignType_DBA, @ForeignType_ManyToMany)  
                            AND dhd.LevelNumber = 0  
                    END ELSE   
                    BEGIN  
                        -- Below the top level of hierarchy  
                        DECLARE @ParentLevel_ID INT;  
                        SELECT TOP 1  
                             @ParentAttribute_ID = Foreign_ID -- The Attribute_ID is the Foreign_ID of the level above the specified level  
                            ,@ParentLevel_ID = Level_ID  
                        FROM mdm.viw_SYSTEM_SCHEMA_HIERARCHY_DERIVED_LEVELS dhd  
                        WHERE   dhd.Hierarchy_ID = @Hierarchy_ID  
                            AND dhd.ForeignType_ID IN (@ForeignType_DBA, @ForeignType_ManyToMany)  
                            AND dhd.LevelNumber < @HierarchyLevelNumber -- Get the nearest matching parent level (may skip levels if the immediate parent is not visible)  
                            AND dhd.IsLevelVisible = 1  
                            AND dhd.Entity_ID = @ParentEntity_ID  
                        ORDER BY dhd.Level_ID  
  
                        SET @HierarchyLevel_ID = @ParentLevel_ID - 1;  
                    END  
                END  
  
                DECLARE  
                    @CurrentLevel_ID                        INT,  
                    @PriorLevel_ID                          INT,  
                    @PriorLevelForeignType_ID               TINYINT,  
                    @PriorLevelManyToManyChildAttribute_ID  INT;  
  
                --Fetch the attribute DBA column name  
                SELECT  
                    @ParentAttribute_Name = [Name]  
                FROM mdm.tblAttribute WHERE ID = @ParentAttribute_ID;  
  
                --Check to see if any levels were skipped; if so, create the proper join string------------  
                --Fetch the prior level  
                SELECT TOP 1  
                     @PriorLevel_ID = Level_ID  
                    ,@PriorLevelForeignType_ID = ForeignType_ID  
                    ,@PriorLevelManyToManyChildAttribute_ID = ManyToManyChildAttribute_ID  
                FROM mdm.tblDerivedHierarchyDetail  
                WHERE   DerivedHierarchy_ID = @Hierarchy_ID  
                    AND Foreign_ID = @ParentAttribute_ID  
                    AND ForeignType_ID IN (@ForeignType_DBA, @ForeignType_ManyToMany)  
                    AND (@HierarchyLevel_ID IS NULL OR Level_ID > @HierarchyLevel_ID)  
                ORDER BY Level_ID DESC;  
  
                --Fetch the current level  
                SELECT TOP 1 @CurrentLevel_ID = Level_ID  
                FROM mdm.tblDerivedHierarchyDetail  
                WHERE   DerivedHierarchy_ID = @Hierarchy_ID  
                    AND Level_ID < @PriorLevel_ID  
                    AND IsVisible = 1  
                ORDER BY Level_ID DESC;  
  
                --Fetch the list of tables to join (if skipping levels)  
                DECLARE @SkippedLevel TABLE  
                (  
                     Level_ID                       INT PRIMARY KEY  
                    ,ForeignType_ID                 TINYINT NOT NULL  
                    ,AttributeName                  SYSNAME NOT NULL -- Name of Foreign_ID  
                    ,EntityViewName                 SYSNAME NOT NULL  
                    ,DomainEntityViewName           SYSNAME NOT NULL  
                    ,ManyToManyChildAttribute_Name  SYSNAME NULL  
                );  
                INSERT INTO @SkippedLevel  
                SELECT  
                     l.Level_ID  
                    ,l.ForeignType_ID  
                    ,l.Foreign_Name AS AttributeName  
                    ,mdm.udfViewNameGetByID(  
                        CASE l.ForeignType_ID  
                        WHEN @ForeignType_ManyToMany THEN a.Entity_ID -- Use the mapping table for M2M levels  
                        ELSE l.Entity_ID END  
                        , @MemberType_Leaf, 0, 0) AS EntityViewName  
                    ,mdm.udfViewNameGetByID(a.DomainEntity_ID, @MemberType_Leaf, 0, 0) AS DomainEntityViewName  
                    ,l.ManyToManyChildAttribute_Name  
                FROM mdm.viw_SYSTEM_SCHEMA_HIERARCHY_DERIVED_LEVELS l  
                LEFT JOIN mdm.tblAttribute a  
                ON      l.Foreign_ID = a.ID  
                    AND l.ForeignType_ID IN (@ForeignType_DBA, @ForeignType_ManyToMany)  
                WHERE   l.Hierarchy_ID = @Hierarchy_ID  
                    AND l.Level_ID > @CurrentLevel_ID  
                    AND l.Level_ID < @PriorLevel_ID ;  
  
                DECLARE  
                    @TempLevel_ID                   INT,  
                    @TempForeignType_ID             TINYINT,  
                    @TempEntityViewName             SYSNAME = NULL,  
                    @TempDomainEntityViewName       SYSNAME = NULL,  
                    @TempViewAlias                  SYSNAME = NULL,  
                    @TempPriorViewAlias             SYSNAME = N'T',  
                    @TempAttributeName              SYSNAME,  
                    @ManyToManyChildAttributeName   SYSNAME  
                     ;  
  
                WHILE EXISTS(SELECT 1 FROM @SkippedLevel)  
                BEGIN  
                    SELECT TOP 1  
                        @TempLevel_ID                   = Level_ID,  
                        @TempForeignType_ID             = ForeignType_ID,  
                        @TempAttributeName              = AttributeName,  
                        @TempEntityViewName             = EntityViewName,  
                        @TempDomainEntityViewName       = DomainEntityViewName,  
                        @ManyToManyChildAttributeName   = ManyToManyChildAttribute_Name  
                    FROM @SkippedLevel  
                    ORDER BY Level_ID ASC;  
  
                    IF (@TempForeignType_ID = @ForeignType_ManyToMany)  
                    BEGIN  
                        -- Join with the mapping table  
                        SET @TempViewAlias = CONCAT('skipMapLvl', @TempLevel_ID);  
                        SET @DerivedHierarchyParentJoin = CONCAT(@DerivedHierarchyParentJoin, N'  
LEFT JOIN mdm.', QUOTENAME(@TempEntityViewName), N' AS ', QUOTENAME(@TempViewAlias), N'  
ON      ', QUOTENAME(@TempPriorViewAlias), N'.ID = ', QUOTENAME(@TempViewAlias), N'.', QUOTENAME(CONCAT(@ManyToManyChildAttributeName, N'.ID')), N'  
    AND ', QUOTENAME(@TempPriorViewAlias), N'.Version_ID = ', QUOTENAME(@TempViewAlias), N'.Version_ID');  
                        SET @TempPriorViewAlias = @TempViewAlias;  
                    END  
  
                    -- Join with the skipped level's entity view  
                    SET @TempViewAlias = CONCAT(N'skipLvl', @TempLevel_ID)  
                    SET @DerivedHierarchyParentJoin = CONCAT(@DerivedHierarchyParentJoin, N'  
LEFT JOIN mdm.', QUOTENAME(@TempDomainEntityViewName), N' AS ', QUOTENAME(@TempViewAlias), N'  
ON      ', QUOTENAME(@TempPriorViewAlias), '.', QUOTENAME(CONCAT(@TempAttributeName, N'.ID')), N' = ' + QUOTENAME(@TempViewAlias), N'.ID  
    AND ', QUOTENAME(@TempPriorViewAlias), '.Version_ID = ', QUOTENAME(@TempViewAlias) + N'.Version_ID');  
  
                    SET @TempPriorViewAlias = @TempViewAlias;  
  
                    DELETE FROM @SkippedLevel  
                    WHERE Level_ID = @TempLevel_ID;  
                END; --while  
  
                DECLARE @MappingTableAlias SYSNAME = NULL;  
                IF @PriorLevelForeignType_ID = @ForeignType_ManyToMany  
                BEGIN  
                    SET @MappingTableAlias = CONCAT(N'mapLvl', @PriorLevel_ID);  
                    -- Join with the mapping entity  
                    DECLARE  
                         @MappingEntityViewName SYSNAME  
                        ,@ParentAttributeName   SYSNAME  
                        ,@ChildAttributeName    SYSNAME;  
  
                    SELECT  
                         @MappingEntityViewName = mdm.udfViewNameGetByID(a.Entity_ID, @MemberType_Leaf, 0, 0)  
                        ,@ParentAttributeName   = Name  
                    FROM mdm.tblAttribute a  
                    WHERE ID = @ParentAttribute_ID;  
  
                    SELECT @ChildAttributeName = Name  
                    FROM mdm.tblAttribute  
                    WHERE ID = @PriorLevelManyToManyChildAttribute_ID  
  
                    -- Note: This is a LEFT rather than INNER JOIN so that it works for MDMUNUSED (i.e. when the attribute value is null and the join condition won't have matches only for unused members)  
                    SET @DerivedHierarchyParentJoin = CONCAT(@DerivedHierarchyParentJoin, N'  
LEFT JOIN mdm.', QUOTENAME(@MappingEntityViewName), N' ', @MappingTableAlias, N'  
ON      ', COALESCE(@TempViewAlias, 'T'), N'.ID = ', @MappingTableAlias, N'.', QUOTENAME(CONCAT(@ChildAttributeName, N'.ID')), N'  
    AND ', COALESCE(@TempViewAlias, 'T'), N'.Version_ID = ', @MappingTableAlias, N'.Version_ID');  
                END  
  
                SET @ParentViewAlias = COALESCE(@MappingTableAlias, @TempViewAlias, 'T');  
                IF (@Parent_ID IS NOT NULL AND @ParentAttribute_Name IS NOT NULL)  
                BEGIN  
                    SET @MemberWhere = CONCAT(@MemberWhere, N'  
    AND ', @ParentViewAlias, '.', QUOTENAME(CONCAT(@ParentAttribute_Name, N'.ID')), CASE  
                        WHEN @Parent_ID <= 0 THEN N' IS NULL '  
                        ELSE N' = @Parent_ID '  
                        END);  
                    SET @MemberFrom = CONCAT(@MemberFrom, @DerivedHierarchyParentJoin);  
                END;  
            END -- @RootEntity_ID != @Entity_ID  
        END -- Derived Hierarchy  
        -- Explicit hierarchy  
        ELSE IF @HierarchyType_ID = @HierarchyType_Explicit  
        BEGIN  
            IF @Parent_ID IS NULL  
            BEGIN  
                IF @MemberType_ID = @MemberType_Consolidated  
                BEGIN  
                    SET @MemberFrom += CONCAT(N'  
                         INNER JOIN [mdm].', @HierarchyTable, N' HR  
                         ON HR.ChildType_ID = ', @MemberType_Consolidated, N'  
                            AND HR.Version_ID = T.Version_ID  
                            AND HR.Hierarchy_ID = @Hierarchy_ID  
                            AND HR.Child_HP_ID = T.ID  
                            AND HR.Status_ID = ', @MemberStatusActive, N'  
                        ');  
                END  
            END  
           -- Display members under a explicit hierarchy  
            ELSE  
            BEGIN  
                -- Unused Leaf members  
                IF @Parent_ID = @Unused_ID AND @MemberType_ID = @MemberType_Leaf  
                BEGIN  
                    SET @MemberFrom += CONCAT(N'  
                         LEFT JOIN [mdm].', @HierarchyTable, N' HR  
                         ON HR.ChildType_ID = ', @MemberType_Leaf, N'  
                            AND HR.Version_ID = @Version_ID  
                            AND HR.Hierarchy_ID = @Hierarchy_ID  
                            AND HR.Child_EN_ID = T.ID  
                            AND HR.Status_ID = ', @MemberStatusActive, N'  
                        ');  
  
                    SET @MemberWhere += N'  
                            AND HR.Child_EN_ID IS NULL'  
                END  
                -- Under consolidate member or root  
                ELSE  
                BEGIN  
                    SET @MemberFrom += CONCAT(N'  
                    INNER JOIN [mdm].', @HierarchyTable, N' AS HR  
                    ON HR.ChildType_ID = ', @MemberType_ID, N'  
                        AND HR.Version_ID = @Version_ID  
                        AND HR.Hierarchy_ID = @Hierarchy_ID  
                        AND HR.' + CASE @MemberType_ID WHEN @MemberType_Leaf THEN N'Child_EN_ID' ELSE N'Child_HP_ID' END, N' = T.ID  
                        AND HR.Status_ID = ', @MemberStatusActive, N'  
                        ');  
  
                    SET @MemberWhere += N'  
                        AND ISNULL(HR.Parent_HP_ID, 0) = @Parent_ID'  
                END  
            END  
        END  
    END -- Get hierarchy members  
  
    DECLARE @MemberIdsCte NVARCHAR(MAX) = CONCAT(@TruncateGuard, N'  
WITH memberIdsCte AS  
(  
    SELECT ', CASE @IsHistoricalData WHEN 0 THEN N'T.ID' ELSE N'T.HS_ID' END, -- get all member IDs from within the selected page  
            CASE WHEN @UseMemberSecurity = 1 AND @IsHistoricalData <> 1 THEN N'  
          ,ms.AccessPermission AS AccessPermission'  
            END,  
            @MemberFrom, @MemberWhere, CASE WHEN LEN(@PagingTerm) > 0 THEN @MemberOrderBy END/*Exclude the ORDER BY clause if there is no paging*/, @PagingTerm, N'  
)'       )  
        ,@PagedMemberFrom NVARCHAR(MAX) = CONCAT(@TruncateGuard, N'  
FROM mdm.', QUOTENAME(@MemberViewName), N' T  
INNER JOIN memberIdsCte id  
ON      T.Version_ID = @Version_ID  
    AND ', CASE @IsHistoricalData WHEN 0 THEN N'T.ID = id.ID' ELSE N'T.HS_ID = id.HS_ID' END);  
  
    IF (@MemberReturnOption & @MemberReturnOptionData <> 0) OR (@MemberReturnOption & @MemberReturnOptionHistoricalData <> 0)  
    BEGIN  
        SELECT  
            MUID  
            ,Name  
            ,ID  
            ,AttributeType_ID  
            ,DataType_ID  
            ,SortOrder  
        FROM @AttributesWorkingSet  
        WHERE Name <> N'Code'  
            AND Name <> N'Name'  
        ORDER BY SortOrder, ID  
  
        SET @SQL = CONCAT(@TruncateGuard, N'  
-- Get member data', @MemberIdsCte, N'  
SELECT ', @ColumnString, @PagedMemberFrom, @MemberOrderBy);  
  
        --SELECT CONVERT(XML, @SQL);  
        EXEC sp_executesql @SQL, N'@Version_ID INT, @User_ID INT, @MemberType_Permission TINYINT, @MemberType_AccessPermission TINYINT, @PageNumber INT, @PageSize INT, @SearchTable mdm.MemberGetCriteria READONLY, @Parent_ID INT, @Hierarchy_ID INT',  
                                   @Version_ID,     @User_ID,     @MemberType_Permission,         @MemberType_AccessPermission,         @PageNumber,     @PageSize,     @SearchTable,                                @Parent_ID,     @Hierarchy_ID;  
    END  
  
    IF @MemberReturnOption & @MemberReturnOptionCount <> 0  
    BEGIN  
        SET @SQL = CONCAT(@TruncateGuard, N'  
-- Get member count  
SELECT @MemberCount = COUNT(DISTINCT T.', CASE @IsHistoricalData WHEN 0 THEN N'ID' ELSE N'HS_ID' END, ')', @MemberFrom, @MemberWhere);  
  
        --SELECT CONVERT(XML, @SQL);  
        EXEC sp_executesql @SQL, N'@Version_ID INT, @User_ID INT, @MemberType_Permission TINYINT, @MemberType_AccessPermission TINYINT, @SearchTable mdm.MemberGetCriteria READONLY, @Parent_ID INT, @Hierarchy_ID INT, @MemberCount INT OUTPUT',  
                                   @Version_ID,     @User_ID,     @MemberType_Permission,         @MemberType_AccessPermission,         @SearchTable,                                @Parent_ID,     @Hierarchy_ID,     @MemberCount OUTPUT;  
    END  
  
    -- Deprecated @MemberReturnOptionMembershipInformation  
    IF (@MemberReturnOption & @MemberReturnOptionMembershipInformation <> 0) OR (@MemberReturnOption & @MemberReturnOptionHistoricalMembershipInformation <> 0)  
    BEGIN  
        -- Use the exploded view to get parent info  
        DECLARE @ExplodedMemberViewName SYSNAME = mdm.udfViewNameGet(@Model_ID, @Entity_ID, @MemberType_ID, 1/*@IsExplodedView*/, CASE @IsHistoricalMembershipInformation WHEN 0 THEN 0 ELSE 2 END);  
  
        -- Have to join back again with the member view (but the exploded one) so that paging will work, since each member could have more than one EH parent  
        SET @SQL = CONCAT(@TruncateGuard, @MemberIdsCte, N'  
-- Get Explicit Hierarchy membership  
SELECT   
     CONVERT(BIGINT, T.LastChgTS) AS LastChgTS',-- The child's revision ID is used to match the child with its parent record(s)  
     CASE WHEN @IsHierarchyEnabled = 1 THEN N'  
    ,T.Parent_Status_ID  
    ,T.Parent_Code  
    ,T.Parent_Name  
    ,T.Parent_HierarchyMuid  
    ,T.Parent_HierarchyName  
    ,T.Parent_HierarchyId  
    ,T.Child_SortOrder  
    ,T.Parent_LastChgTS' END,  
    CASE WHEN @IncludeAuditInfo = 1 AND @IsHierarchyEnabled = 1 THEN N'  
    ,T.Parent_EnterDTM  
    ,T.Parent_EnterUserName  
    ,T.Parent_LastChgDTM  
    ,T.Parent_LastChgUserName'  
    END,  
    CASE WHEN @IsCollectionEnabled = 1 THEN N'  
    ,T.Collection_Status_ID  
    ,T.Collection_Code  
    ,T.Collection_Name  
    ,T.Collection_SortOrder  
    ,T.Collection_Weight  
    ,T.Collection_LastChgTS' END,  
    CASE WHEN @IncludeAuditInfo = 1 AND @IsCollectionEnabled = 1 THEN N'  
    ,T.Collection_EnterDTM  
    ,T.Collection_EnterUserName  
    ,T.Collection_LastChgDTM  
    ,T.Collection_LastChgUserName'  
    END,  
            REPLACE(@PagedMemberFrom, QUOTENAME(@MemberViewName), QUOTENAME(@ExplodedMemberViewName)),   
            CASE WHEN @IsHierarchyEnabled = 0 AND @IsCollectionEnabled = 0 THEN N'  
WHERE 0 = 1' END); -- don't both returning any rows (but still return an empty result set) if neither explicit hierarchies nor collections are enabled.  
  
        --SELECT CONVERT(XML, @SQL);  
        EXEC sp_executesql @SQL, N'@Version_ID INT, @User_ID INT, @MemberType_Permission TINYINT, @MemberType_AccessPermission TINYINT, @PageNumber INT, @PageSize INT, @SearchTable mdm.MemberGetCriteria READONLY, @Parent_ID INT, @Hierarchy_ID INT',  
                                   @Version_ID,     @User_ID,     @MemberType_Permission,         @MemberType_AccessPermission,         @PageNumber,     @PageSize,     @SearchTable,                                @Parent_ID,     @Hierarchy_ID;  
    END;  
  
    IF (@MemberReturnOption & @MemberReturnOptionDerivedHierarchyParents <> 0)   
        AND @HierarchyType_ID = @HierarchyType_Derived   
        AND @ParentAttribute_Name IS NOT NULL  
    BEGIN  
        SET @SQL = CONCAT(@TruncateGuard, @MemberIdsCte, N'  
-- Get Derived Hierarchy parents  
SELECT   
     CONVERT(BIGINT, T.LastChgTS) AS LastChgTS  
    ,', @ParentViewAlias, N'.', QUOTENAME(CONCAT(@ParentAttribute_Name, N'.MUID')), N' Parent_Muid', @MemberFrom,   
            CASE WHEN @Parent_ID IS NULL THEN @DerivedHierarchyParentJoin END -- If a parent wasn't specified, then @MemberFrom does not already include the DH parent join(s), so add it here.  
            , N'  
INNER JOIN memberIdsCte id  
ON      T.Version_ID = @Version_ID  
    AND T.ID = id.ID', @MemberWhere, CONCAT(N'  
    AND ', @ParentViewAlias, N'.', QUOTENAME(@ParentAttribute_Name), N' IS NOT NULL')); -- Ignore rows with null parent info  
  
        --SELECT CONVERT(XML, @SQL);  
        EXEC sp_executesql @SQL, N'@Version_ID INT, @User_ID INT, @MemberType_Permission TINYINT, @MemberType_AccessPermission TINYINT, @PageNumber INT, @PageSize INT, @SearchTable mdm.MemberGetCriteria READONLY, @Parent_ID INT, @Hierarchy_ID INT',  
                                   @Version_ID,     @User_ID,     @MemberType_Permission,         @MemberType_AccessPermission,         @PageNumber,     @PageSize,     @SearchTable,                                @Parent_ID,     @Hierarchy_ID;  
    END  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpEntityMembersSave]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
Bulk saves entity members. Leaf and Collection members only (not Consolidated)  
  
Returned tables:  
- Errors, if @ErrorReportingType indicates that errors should be included in the result set.  
- Created Members, if @ReturnCreatedMembers = 1  
  
Permission:  
---         MemberType, Attribute,      Member  
-- Create,  N/A,        Create*,        N/A  
-- Update,  N/A,        Update,         Update  
-- Merge,   N/A,        CreateUpdate**, Update  
-- Get,     N/A,        Read,           Read  
-- Delete   Delete,     N/A,            Delete  
  
*Includes Code and Name  
**Depends on the member is new or existing, will require Create or Update  
  
If this sproc raises an error, it means that the entire batch was rolled back and no tables were changed.  
On the other hand, if the sproc doesn't raise an error but does return errors (in the result set and/or in the @Errors XML  
output param), the member table(s) may have been modified.  
  
  
**********************************************************  
The below code can be used to help troubleshoot issues and measure perf.  
  
-- Create a log table for measuring perf  
CREATE TABLE mdm.tblPerfLog  
(  
     ID INT IDENTITY(1,1) NOT NULL  
    ,SPID INT NOT NULL  
    ,[Message] NVARCHAR(MAX)  
    ,[Time]   DATETIME2(7)  
)  
  
-- Create a sproc to write messages to the log table.  
CREATE PROC mdm.udpLogMessage  
(  
    @Message NVARCHAR(MAX) = NULL  
)  
AS  
BEGIN  
    DECLARE @Len INT = LEN(@Message)  
    PRINT CONVERT(NVARCHAR, SYSDATETIME()) + N': ' + @Message  
    DECLARE @StartIndex INT = 4000  
    WHILE @StartIndex < @Len  
    BEGIN  
        PRINT SUBSTRING(@Message, @StartIndex, 4000)  
        SET @StartIndex += 4000;  
    END  
  
    INSERT INTO mdm.tblPerfLog  
        (SPID, [Message], [Time])  
    VALUES  
        (@@SPID, @Message, SYSDATETIME());  
END;  
  
  
-- Get the items from the perf log table, and compute duration between entries. This is useful for identifying  
-- bottlenecks in the sproc. Run this query after changing all of the "IF @Debug = 1" lines to call udpLogMessage  
-- instead of calling PRINT, and then set the @Debug flag when running this sproc.  
SELECT  
     msg.*  
    ,DATEDIFF(ms, msg.[Time], nextMessage.[Time]) AS DurationInMs  -- How much time passed between when this message and the very next message were logged.  
FROM mdm.tblPerfLog msg  
LEFT JOIN mdm.tblPerfLog nextMessage  
ON msg.ID + 1 = nextMessage.ID  
ORDER BY msg.ID  
  
*/  
CREATE PROCEDURE [mdm].[udpEntityMembersSave]  
(  
     @User_ID                   INT  
  
     -- The metadata item (Model, Version, Entity) identifier properties are output params because this sproc looks up complete identifier info for the caller,  
     -- which is useful when only partial info was passed in. For example,  
     -- If the caller passes in @EntityMuid but leaves @EntityName null, then by the time this sproc finishes @EntityName will be populated with the correct  
     -- value (if the Entity MUID was valid and the user has permission to see the Entity). Doing metadata item lookups in this sproc reduces the number  
     -- of db calls from the web service.  
    ,@ModelName                 NVARCHAR(50) = NULL OUTPUT  
    ,@ModelMuid                 UNIQUEIDENTIFIER = NULL  OUTPUT  
    ,@Model_ID                  INT = NULL OUTPUT  
    ,@EntityName                NVARCHAR(50) = NULL OUTPUT  
    ,@EntityMuid                UNIQUEIDENTIFIER = NULL OUTPUT  
    ,@Entity_ID                 INT = NULL OUTPUT  
    ,@VersionName               NVARCHAR(50) = NULL OUTPUT  
    ,@VersionMuid               UNIQUEIDENTIFIER = NULL OUTPUT  
    ,@Version_ID                INT = NULL OUTPUT  
  
    ,@MemberType_ID             TINYINT = NULL -- Only Leaf and Collection supported.  
  
    ,@Members                   mdm.MemberSaveList READONLY -- Contains member identifier info (i.e. Name, Code, Muid, etc) for the members being created/updated  
    ,@MemberAttributes          mdm.MemberAttributeValues READONLY  -- Contains new attribute values of the members in the @Members param  
  
    ,@SaveMode                  TINYINT = 0 -- 1 = Create, 2 = Merge, 3 = Update  
    ,@TransactionBehavior       TINYINT = 0 -- 0 = BestEffort,  
                                            -- 1 = AllOrNothingByMember (if any part of a member has an error, then all member-related changes will be aborted)  
                                            -- 2 = AllOrNothingByBatch  (if any part of any member has an error, then all changes in the entire batch will be aborted)  
  
    ,@LogFlag                   BIT = NULL -- 1 = log the transaction  
    ,@ReturnCreatedMembers      BIT = 0  
    ,@ValidateDataTypes         BIT = 1 -- Do not set to 0 unless the attribute data types have been validated before calling this sproc. Otherwise, unhandled conversion errors may be thrown.  
    ,@DoInheritanceRuleCheck    BIT = NULL -- Only set to 1 from C#  
  
    ,@ChangesetName             NVARCHAR(250) = NULL  
    ,@ChangesetMuid             UNIQUEIDENTIFIER = NULL  
    ,@Approved                  BIT = 0 -- Called by udpEntityMemberChangesetSave  
  
    ,@ErrorReportingType        TINYINT = 1 -- A flag (values can be combined) that indicates how the sproc should report any errors  
                                            -- 0 = Errors are not reported back to the caller  
                                            -- 1 = Return errors in result set  
                                            -- 2 = Add errors to the XML out param.  
                                            -- 4 = Raise the first error found (results in the whole batch being rolled back)  
    ,@Errors                    XML = NULL OUTPUT -- @ErrorReportingType indicates whether this param should be filled with any errors found.  
  
    ,@Debug                     BIT = 0 -- Set to 1 to facilitate troubleshooting this sproc. Causes various print statements to provide info about the internal sproc execution steps.  
    ,@CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
    IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'udpEntityMembersSave started.'  
  
    DECLARE  
        -- Looked up from tblEntity  
         @MemberTableName               SYSNAME -- E.g. "tbl_7_31_[EN|HP|CN]". The name of the table in which this sproc call will add/update members.  
        ,@MemberViewName                SYSNAME -- E.g. "viw_SYSTEM_7_31_[CHILD|COLLECTION|PARENT]ATTRIBUTES". The name of the view corresponding to the member table.  
        ,@MemberAnnotationTableName     SYSNAME  
        ,@EntityTableName               SYSNAME -- E.g. "tbl_7_31_EN". Contains Leaf members.  
        ,@HierarchyParentTableName      SYSNAME -- E.g. "tbl_7_31_HP". Contains Consolidated members.  
        ,@CollectionTableName           SYSNAME -- E.g. "tbl_7_31_CN". Contains Collection members.  
        ,@HierarchyTableName            SYSNAME -- E.g. "tbl_7_31_HR"  
        ,@SecurityTableName             SYSNAME -- E.g. "tbl_7_31_EN_MS"  
        ,@PendingTableName              SYSNAME -- E.g. "tbl_7_31_EN_PD"  
        ,@ChangesetTableName            SYSNAME -- E.g. "tbl_7_CS"  
        ,@ChangesetStatus               TINYINT  
        ,@GetMemeberHistoryOutputQuery  NVARCHAR(MAX)  
        ,@IsCollectionEnabled           BIT  
        ,@IsHierarchyEnabled            BIT  
        ,@DataCompression               TINYINT  
        ,@RequireApproval               BIT  
        ,@Changeset_ID                  INT = NULL  
  
        ,@HasDba                        BIT  
        ,@HasFile                       BIT  
  
        -- Looked up from tblAttribute (Code and Name attribute metadata)  
        ,@AttributeName_Code            NVARCHAR(100)  
        ,@AttributeName_Name            NVARCHAR(100)  
        ,@AttributeName_MUID            NVARCHAR(100)  
        ,@AttributeMUID_Code            UNIQUEIDENTIFIER  
        ,@AttributeMUID_Name            UNIQUEIDENTIFIER  
        ,@AttributeMUID_MUID            UNIQUEIDENTIFIER  
        ,@AttributeID_Code              INT  
        ,@AttributeID_Name              INT  
        ,@AttributeMaxLength_Code       INT  
        ,@AttributeMaxLength_Name       INT  
  
        --Member Types  
        ,@MemberType_Unknown            TINYINT = 0  
        ,@MemberType_Leaf               TINYINT = 1  
        ,@MemberType_Consolidated       TINYINT = 2  
        ,@MemberType_Collection         TINYINT = 3  
        ,@MemberType_Hierarchy          TINYINT = 4  
  
        --Member status  
        ,@MemberStatus_Active           TINYINT = 1  
        ,@MemberStatus_Inactive         TINYINT = 2  
  
        ,@VersionStatus                 TINYINT  
        ,@VersionStatus_NotSpecified    TINYINT = 0  
        ,@VersionStatus_Open            TINYINT = 1  
        ,@VersionStatus_Locked          TINYINT = 2  
        ,@VersionStatus_Committed       TINYINT = 3  
  
        ,@TransactionLogType            TINYINT  
        ,@TransactionLogType_Attribute  TINYINT = 1  
        ,@TransactionLogType_Member     TINYINT = 2  
        ,@TransactionLogType_None       TINYINT = 3  
  
        ,@HistoryTableName              SYSNAME  
        ,@MemberIDColumn                SYSNAME  
  
        --Error ObjectTypes  
        ,@ObjectType_MemberCode         TINYINT = 12  
        ,@ObjectType_MemberId           TINYINT = 19  
        ,@ObjectType_MemberAttribute    TINYINT = 22  
  
        ,@ChangesetStatus_Open          TINYINT = 1  
        ,@ChangesetStatus_Rejected      TINYINT = 4  
        --Error Codes  
        ,@ErrorCode_FailedDueToAllOrNothingErrorPropagation     INT = -1 -- This error type is for internal use only. It should not be reported back to the user. It flags rows that should be ignored (not used to update master data tables) because it pertains to a member that had an error somewhere, and the @TransactionBehavior is AllOrNothingByMember.  
        ,@ErrorCode_ReservedWord                                INT = 110006  
        ,@ErrorCode_IdNotValid                                  INT = 110007  
        ,@ErrorCode_IdAlreadyExists                             INT = 110008  
        ,@ErrorCode_AttributeValueLengthGreaterThanMaximum      INT = 110017  
        ,@ErrorCode_NoPermissionForThisOperation                INT = 120002  
        ,@ErrorCode_NoPermissionForThisOperationOnThisObject    INT = 120003  
        ,@ErrorCode_InvalidMemberCode                           INT = 300002  
        ,@ErrorCode_MemberCodeExists                            INT = 300003  
        ,@ErrorCode_InvalidAttribute                            INT = 300010  
        ,@ErrorCode_ReadOnlyAttribute                           INT = 300014  
        ,@ErrorCode_DuplicateInputMemberCodes                   INT = 300019  
        ,@ErrorCode_MemberCausesCircularReference               INT = 300020  
        ,@ErrorCode_MemberMergeConflict                         INT = 300021  
        ,@ErrorCode_AttributeMergeConflict                      INT = 300022  
        ,@ErrorCode_InvalidBlankMemberCode                      INT = 310022  
        ,@ErrorCode_InvalidAttributeValueForDataType            INT = 310033  
        ,@ErrorCode_InvalidAttributeValueForMember              INT = 310042  
        ,@ErrorCode_AttributeValueNotCompatibleWithFilter       INT = 310055  
        ,@ErrorCode_PossiblyImpactedByIncompatibleFilteredValue INT = 310056  
  
        -- Error reporting types  
        ,@ErrorReportingType_None           TINYINT = 0 -- Errors are not reported back to the caller  
        ,@ErrorReportingType_Return         TINYINT = 1 -- Return errors in result set  
        ,@ErrorReportingType_Xml            TINYINT = 2 -- Add errors to the XML out param.  
        ,@ErrorReportingType_Raise          TINYINT = 4 -- Raise the first error found, rolling back the entire batch  
  
        ,@PrincipalType_User                TINYINT = 1  
  
        ,@SecurityRoleID                    INT  
  
        ,@MemberSecurity                    INT = 0  
  
        --Permission  
        ,@ModelPermission                   INT  
        ,@MemberTypePermission              INT = NULL  
        ,@Permission_None                   INT = 0  
        ,@Permission_Deny                   INT = 1  
        ,@Permission_Access                 INT = 4  
        ,@Permission_Admin                  INT = 5  
        ,@Permission_Inferred               INT = 99  
  
        ,@MemberTypeAccessPermission        TINYINT = NULL  
        ,@AccessPermission_None             TINYINT = 0  
        ,@AccessPermission_Read             TINYINT = 0  
        ,@AccessPermission_Create           TINYINT = 1  
        ,@AccessPermission_Update           TINYINT = 2  
        ,@AccessPermission_All              TINYINT = 7  
        ,@AccessPermission_CreateUpdate     TINYINT = 3  
  
        --Validation Statuses  
        ,@ValidationStatus_Succeeded                            INT = 3  
        ,@ValidationStatus_AwaitingRevalidation                 INT = 4  
        ,@ValidationStatus_AwaitingDependentMemberRevalidation  INT = 5  
        ,@ValidationStatus                                      INT = NULL  
  
        --Transaction type  
        ,@TransactionType_Create                INT = 1  
        ,@TransactionType_Update                INT = 3  
        ,@TransactionType_HierarchyParentSet    INT = 4  
  
        -- Save mode  
        ,@SaveMode_NotSpecified         TINYINT = 0  
        ,@SaveMode_Create               TINYINT = 1  
        ,@SaveMode_Merge                TINYINT = 2  
        ,@SaveMode_Update               TINYINT = 3  
  
        -- Transaction behavior  
        ,@TransactionBehavior_BestEffort            TINYINT = 0 -- Apply all possible member changes. For example, user tries to create a member and set one of its attributes to an invalid value. The member will be created, but the attribute will be left blank.  
        ,@TransactionBehavior_AllOrNothingByMember  TINYINT = 1 -- If any of the given member changes has an error, ignore all changes for that member. For example, user tries to create a member and set one of its attributes to an invalid value. The member will not be created.  
        ,@TransactionBehavior_AllOrNothingByBatch   TINYINT = 2 -- If any of the given member changes has an error, ignore all changes to all members (not just those with errors) in this batch. I.e, abort the whole batch if any errors are found.  
  
        --Attribute Types  
        ,@AttributeType_NotSpecified    TINYINT = 0  
        ,@AttributeType_FreeForm        TINYINT = 1  
        ,@AttributeType_DBA             TINYINT = 2  
        ,@AttributeType_File            TINYINT = 4  
  
        --Attribute DataTypes  
        ,@AttributeDataType_NotSpecified    TINYINT = 0  
        ,@AttributeDataType_Text            TINYINT = 1  
        ,@AttributeDataType_Number          TINYINT = 2  
        ,@AttributeDataType_DateTime        TINYINT = 3  
        ,@AttributeDataType_Link            TINYINT = 6  
  
        --Special values that input attribute NULL values get mapped to.  
        ,@SysNull_Text          NVARCHAR(1) = NCHAR(0)  
        ,@SysNull_ForeignKey    INT = 0  
        ,@SysNull_Number        DECIMAL(38,0) = -98765432101234567890  
        ,@SysNull_DateTime      DATETIME2(3) = CAST(N'5555-11-22T12:34:56' AS DATETIME2(3))  
  
        --Table column SQL snippets  
        ,@AttributeIdList               NVARCHAR(MAX) = N''-- a comma-delimited list of int attribute IDs, each wrapped in square brackets (needed for pivot)  
        ,@AttributeIdListWithDBACode    NVARCHAR(MAX) = N''-- same as @AttributeIdList, but with an extra domain member Code column for each DBA  
        ,@AttributeValueMappedAsColumns NVARCHAR(MAX) = N''  
        ,@TableColumnsUnPivotDefn       NVARCHAR(MAX) = N''  
        ,@ViewColumnsUnPivotDefn        NVARCHAR(MAX) = N''  
        ,@TableColumnsUpdateDefn        NVARCHAR(MAX) = N''  
        ,@TableColumnsUpdateDbaIdsDefn  NVARCHAR(MAX) = N''  
  
        --A flag indicating whether this entity supports auto code generation for Leaf members.  
        ,@CodeGenEnabled                BIT = 0  
  
        ,@SQL                           NVARCHAR(MAX)  
  
        -- This pseudo-constant is for use in string concatenation operations to prevent string truncation. When concatenating two or more strings,  
        -- if none of the strings is an NVARCHAR(MAX) or an NVARCHAR constant that is longer than 4,000 characters, then the resulting string  
        -- will be silently truncated to 4,000 characters. Concatenating wPrivilege_IDith this empty NVARCHAR(MAX), is sufficient to prevent truncation.  
        -- See http://connect.microsoft.com/SQLServer/feedback/details/283368/nvarchar-max-concatenation-yields-silent-truncation.  
        ,@TruncationGuard            NVARCHAR(MAX) = N''  
  
        ,@ValidationLogTableName            SYSNAME  
        ,@TransactionTableName              SYSNAME  
        ,@TransactionAnnotationTableName    SYSNAME  
  
  
        ,@GuidEmpty                     UNIQUEIDENTIFIER = CAST(0x0 AS UNIQUEIDENTIFIER)  
        ;  
  
    DECLARE @MemberPermissions AS TABLE (ID INT PRIMARY KEY, MemberType_ID INT, Privilege_ID INT, AccessPermission TINYINT);  
  
    DECLARE @PerformanceQueueSaveFlag BIT = 0;  
  
    -- Replace null param values with defaults.  
    SET @SaveMode = COALESCE(@SaveMode, @SaveMode_NotSpecified);  
    SET @ValidateDataTypes = COALESCE(@ValidateDataTypes, 0);  
    SET @TransactionBehavior = COALESCE(@TransactionBehavior, @TransactionBehavior_BestEffort);  
    SET @ErrorReportingType = COALESCE(@ErrorReportingType, @ErrorReportingType_None);  
    SET @LogFlag = COALESCE(@LogFlag, 0);  
    SET @Errors = NULL;  
  
    -- Validate save mode.  
    IF @SaveMode NOT IN (@SaveMode_Create, @SaveMode_Merge, @SaveMode_Update)  
    BEGIN  
        RAISERROR('MDSERR100010|The Parameters are not valid.', 16, 1);  
        RETURN;  
    END;  
  
    -- Validate model, entity, version request IDs and member type  
    SET @ModelName  = NULLIF(@ModelName, N'');  
    SET @EntityName = NULLIF(@EntityName, N'');  
    SET @VersionName = NULLIF(@VersionName, N'');  
    SET @ChangesetName = NULLIF(@ChangesetName, N'');  
    SET @ModelMuid = NULLIF(@ModelMuid, @GuidEmpty);  
    SET @EntityMuid = NULLIF(@EntityMuid, @GuidEmpty);  
    SET @VersionMuid = NULLIF(@VersionMuid, @GuidEmpty);  
    SET @ChangesetMuid = NULLIF(@ChangesetMuid, @GuidEmpty);  
    SET @Model_ID = NULLIF(@Model_ID, 0);  
    SET @Entity_ID = NULLIF(@Entity_ID, 0);  
    SET @Version_ID = NULLIF(@Version_ID, 0);  
    SET @MemberType_ID = COALESCE(@MemberType_ID, @MemberType_Unknown);  
  
    DECLARE @LocalModelID INT = NULL;-- used to determine if the model exists  
  
    -- Validate @Model_ID and the user's permission to see the model.  
    IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Validate model.'  
    SELECT  
         @LocalModelID = m.ID  
        ,@ModelName = m.Name  
        ,@ModelMuid = m.MUID  
        ,@ModelPermission = s.Privilege_ID  
    FROM mdm.tblModel m  
    INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_MODEL s  
    ON      m.ID = s.ID  
        AND ISNULL(s.Privilege_ID, @Permission_Deny) <> @Permission_Deny  
        AND s.User_ID = @User_ID  
    WHERE  
            (@ModelMuid IS NOT NULL OR @ModelName IS NOT NULL OR @Model_ID IS NOT NULL) -- At least one Identifier param must be provided.  
        AND (@ModelMuid IS NULL OR @ModelMuid = m.MUID)  
        AND (@ModelName IS NULL OR @ModelName = m.Name)  
        AND (@Model_ID  IS NULL OR @Model_ID  = m.ID)  
  
    IF @LocalModelID IS NULL  
    BEGIN  
        RAISERROR('MDSERR300005|The supplied model is not valid.', 16, 1);  
        RETURN;  
    END  
    ELSE  
    BEGIN  
        SELECT @Model_ID = @LocalModelID;  
    END;  
  
    SET @ValidationLogTableName = mdm.udfGetValidationLogTableName(@Model_ID);  
  
    -- Validate @Version_ID  
    IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Validate version.'  
    SELECT  
         @Version_ID = ID  
        ,@VersionName = Name  
        ,@VersionMuid = MUID  
        ,@VersionStatus = Status_ID  
    FROM mdm.tblModelVersion  
    WHERE  
        (@VersionMuid IS NOT NULL OR @VersionName IS NOT NULL OR @Version_ID IS NOT NULL) -- At least one Identifier param must be provided.  
    AND (@VersionMuid IS NULL OR @VersionMuid = MUID)  
    AND (@VersionName IS NULL OR @VersionName = Name)  
    AND (@Version_ID  IS NULL OR @Version_ID  = ID)  
    AND Model_ID = @Model_ID  
    IF @Version_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR300006|The supplied version is not valid.', 16, 1);  
        RETURN;  
    END;  
    SET @VersionStatus = COALESCE(@VersionStatus, @VersionStatus_NotSpecified);  
  
    IF @VersionStatus = @VersionStatus_Committed  
        OR (@VersionStatus = @VersionStatus_Locked AND @ModelPermission <> @Permission_Admin)  
    BEGIN  
        RAISERROR(N'MDSERR300012|The version is read-only. You do not have permission to update the version.', 16, 1);  
        RETURN;  
    END;  
  
    -- Lookup @Entity_ID and related info, validating that it exists and (if applicable) that the user has permissions to see it.  
    IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Validate entity.'  
    SELECT  
         @Entity_ID = e.ID  
        ,@EntityName = e.Name  
        ,@EntityMuid = e.MUID  
        ,@EntityTableName = e.EntityTable  
        ,@PendingTableName = CAST(e.EntityTable + '_PD' AS SYSNAME)  
        ,@HierarchyTableName = e.HierarchyTable  
        ,@HierarchyParentTableName = e.HierarchyParentTable  
        ,@CollectionTableName = e.CollectionTable  
        ,@DataCompression = e.DataCompression  
        ,@RequireApproval = RequireApproval  
        ,@TransactionLogType = CASE @LogFlag WHEN 1 THEN TransactionLogType ELSE @TransactionLogType_None END  
        ,@HistoryTableName =  
            CASE TransactionLogType  
                WHEN @TransactionLogType_Member THEN  
                    CASE @MemberType_ID  
                        WHEN @MemberType_Leaf THEN e.EntityTable  
                        WHEN @MemberType_Consolidated THEN e.HierarchyParentTable  
                        WHEN @MemberType_Collection THEN e.CollectionTable  
                    END + N'_HS'  
                ELSE NULL  
            END  
    FROM mdm.tblEntity e  
    INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_ENTITY s  
    ON      e.ID = s.ID  
        AND ISNULL(s.Privilege_ID, @Permission_Deny) <> @Permission_Deny  
        AND s.User_ID = @User_ID  
    WHERE  
            (@EntityMuid IS NOT NULL OR @EntityName IS NOT NULL OR @Entity_ID IS NOT NULL) -- At least one Identifier param must be provided.  
        AND (@EntityMuid IS NULL OR @EntityMuid = e.MUID)  
        AND (@EntityName IS NULL OR @EntityName = e.Name)  
        AND (@Entity_ID  IS NULL OR @Entity_ID  = e.ID)  
        AND e.Model_ID = @Model_ID;  
  
    SET @MemberIDColumn =  
        CASE @MemberType_ID  
            WHEN @MemberType_Leaf THEN N'[EN_ID]'  
            WHEN @MemberType_Consolidated THEN N'[HP_ID]'  
            WHEN @MemberType_Collection THEN N'[CN_ID]'  
        END;  
  
    IF @EntityTableName IS NULL  
    BEGIN  
        RAISERROR('MDSERR300008|The supplied entity is not valid..', 16, 1);  
        RETURN;  
    END;  
  
    SET @ChangesetTableName = CONCAT(N'tbl_', @Model_ID, N'_CS');  
    IF @ChangesetName IS NOT NULL OR @ChangesetName IS NOT NULL  
    BEGIN  
        SET @SQL = CONCAT(N'  
                SELECT @Changeset_ID = ID, @ChangesetStatus = Status, @ChangesetMuid = MUID  
                FROM [mdm].', @ChangesetTableName, N'  
                WHERE Version_ID = @Version_ID  
                    AND Entity_ID = @Entity_ID  
                    AND EnterUserID = @User_ID  
                    AND (@ChangesetMuid IS NOT NULL OR @ChangesetName IS NOT NULL)  
                    AND (@ChangesetMuid IS NULL OR MUID = @ChangesetMuid)  
                    AND (@ChangesetName IS NULL OR Name = @ChangesetName)');  
        EXEC sp_executesql @SQL, N'@Version_ID INT, @Entity_ID INT, @User_ID INT, @ChangesetName NVARCHAR(250), @ChangesetMuid UNIQUEIDENTIFIER OUTPUT, @Changeset_ID INT OUTPUT, @ChangesetStatus TINYINT OUTPUT',  
                @Version_ID, @Entity_ID, @User_ID, @ChangesetName, @ChangesetMuid OUTPUT, @Changeset_ID OUTPUT, @ChangesetStatus OUTPUT;  
  
        IF @Changeset_ID IS NULL OR @ChangesetStatus NOT IN (@ChangesetStatus_Open, @ChangesetStatus_Rejected)  
        BEGIN  
            RAISERROR(N'MDSERR300028|The changeset id is invalid or you don''t have the permission to update pending changes of this changeset.', 16, 1);  
            RETURN;  
        END  
  
        IF @ChangesetStatus = @ChangesetStatus_Rejected  
        BEGIN  
            EXEC mdm.udpEntityMemberChangesetSave  
                @User_ID = @User_ID,  
                @Model_Name = @ModelName,  
                @Model_MUID = @ModelMuid,  
                @Entity_Name = @EntityName,  
                @Entity_MUID = @EntityMuid,  
                @Version_Name = @VersionName,  
                @Version_MUID = @VersionMuid,  
                @ChangesetMUID = @ChangesetMuid,  
                @ChangesetStatus = @ChangesetStatus_Open;  
        END  
    END  
  
    IF @RequireApproval = 1 AND @MemberType_ID = @MemberType_Leaf AND @Approved = 0 AND @Changeset_ID IS NULL  
    BEGIN  
        RAISERROR(N'MDSERR300023|The entity requires approval for leaf member changes.', 16, 1);  
        RETURN;  
    END;  
  
    -- Verify the entity version is not a sync target.  
    IF EXISTS(SELECT 1 FROM mdm.tblSyncRelationship   
              WHERE TargetEntity_ID = @Entity_ID  
                AND TargetVersion_ID = @Version_ID)  
    BEGIN  
        RAISERROR('MDSERR200220|The entity member(s) cannot be saved. The entity version is the target of a sync relationship.', 16, 1);  
        RETURN;  
    END  
  
    SET @IsCollectionEnabled = CASE WHEN @CollectionTableName IS NULL THEN 0 ELSE 1 END;  
    SET @IsHierarchyEnabled  = CASE WHEN @HierarchyTableName  IS NULL THEN 0 ELSE 1 END;  
  
    IF @MemberType_ID = @MemberType_Collection  
        AND @IsCollectionEnabled = 0  
    BEGIN  
        DECLARE  
             @TableOptions NVARCHAR(MAX) = mdm.udfGetTableOptions(@DataCompression, @Model_ID)  
            ,@IndexOptions NVARCHAR(MAX) = mdm.udfGetIndexOptions(@DataCompression, @Model_ID);  
  
        EXEC mdm.udpCollectionTablesCreate @User_ID, @Model_ID, @Version_ID, @Entity_ID, @IsHierarchyEnabled, @TableOptions, @IndexOptions, @CollectionTableName OUTPUT;  
        SET @IsCollectionEnabled = 1;  
    END;  
  
    -- Note: This sproc assumes that the caller has already verified that the user has functional area permission.  
  
    ----------------------------------------------------------------------------------------  
    -- Check member type security and version editability.  
    ----------------------------------------------------------------------------------------  
    IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Check member type permission.'  
    -- Check the object permission on the Entity Member Type.  
    SELECT @MemberTypePermission = Privilege_ID,  
        @MemberTypeAccessPermission = AccessPermission  
    FROM mdm.viw_SYSTEM_SECURITY_USER_MEMBERTYPE  
    WHERE [User_ID] = @User_ID  
        AND [Entity_ID] = @Entity_ID  
        AND ID = @MemberType_Leaf;  
  
    SET @MemberTypePermission = COALESCE(@MemberTypePermission, @Permission_Deny);  
  
    IF @MemberTypePermission = @Permission_Deny   
    BEGIN  
        RAISERROR(N'MDSERR120002|The user does not have permission to perform this operation.', 16, 1);  
        RETURN;  
    END;  
  
    -- Get the name of the member table to which the new members will be added.  
    SET @MemberTableName = CASE @MemberType_ID  
        WHEN @MemberType_Leaf           THEN @EntityTableName  
        WHEN @MemberType_Collection     THEN @CollectionTableName  
        END;  
      
    SET @MemberViewName = mdm.udfViewNameGet(@Model_ID, @Entity_ID, @MemberType_ID, 0, 0);  
  
    SET @SecurityTableName =  
        CASE @MemberType_ID  
            WHEN @MemberType_Leaf THEN CONCAT(N'tbl_', @Model_ID, N'_', @Entity_ID ,N'_EN_MS')  
        END;  
  
    IF @TransactionLogType = @TransactionLogType_Member  
    BEGIN  
        SET @MemberAnnotationTableName = CONCAT(@MemberTableName, N'_AN');  
        SET @GetMemeberHistoryOutputQuery = mdm.udfGetHistoryOutputQuery(@Entity_ID, @MemberType_ID, NULL, NULL);  
    END  
    ELSE IF @TransactionLogType = @TransactionLogType_Attribute  
    BEGIN  
        SET @TransactionTableName = mdm.udfGetTransactionTableName(@Model_ID);  
        SET @TransactionAnnotationTableName = mdm.udfGetTransactionAnnotationTableName(@Model_ID);  
    END;  
  
    --Figure out whether code generation is enabled  
    DECLARE @result INT;  
    EXEC @result = mdm.udpIsCodeGenEnabled @Entity_ID;  
    SET @CodeGenEnabled = CONVERT(BIT, @result);  
  
    ----------------------------------------------------------------------------------------  
    -- Create working set temporary tables  
    --  Note that these are temp tables rather than table vars because  
    --  1. They will be referenced in dynamic SQL, and  
    --  2. Table vars are too limited with respect to how they can be indexed.  
    ----------------------------------------------------------------------------------------  
    IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Create working sets.'  
    -- Create working set temp table for new members.  
    CREATE TABLE #MembersWorkingSet  
    (  
         Row_ID                 INT PRIMARY KEY CLUSTERED  
        ,MemberCode             NVARCHAR(251) COLLATE DATABASE_DEFAULT NULL -- Can't use NVARCHAR(MAX) for an indexed column, but need something longer than the max code length (250) to detect codes that are too long)  
        ,MemberName             NVARCHAR(MAX) COLLATE DATABASE_DEFAULT NULL  
        ,MemberMUID             UNIQUEIDENTIFIER NULL  
        ,MemberID               INT NULL  
        ,TransactionAnnotation  NVARCHAR(500) COLLATE DATABASE_DEFAULT NULL  
        ,RevisionID             BIGINT NULL  
        ,ErrorAttributeMUID     UNIQUEIDENTIFIER NULL  
        ,ErrorAttributeName     NVARCHAR(100) COLLATE DATABASE_DEFAULT NULL  
        ,ErrorCode              INT NULL  
        ,ErrorParameters        NVARCHAR(MAX) NULL -- optionally add here any error message format string parameters, delimited by '|'  
        ,ErrorObjectType        TINYINT NULL  
        ,IsNewMember            BIT DEFAULT(0)  
    );  
    CREATE INDEX #ix_NewMemberWorkingSet_MemberID_MemberMUID_MemberCode_ErrorCode ON #MembersWorkingSet(MemberID, MemberMUID, MemberCode, ErrorCode);  
    CREATE INDEX #ix_NewMemberWorkingSet_IsNewMember ON #MembersWorkingSet(IsNewMember);  
  
    -- Create working set temp table for attribute value changes.  
    CREATE TABLE #MemberAttributeWorkingSet  
    (  
         Row_ID                 INT IDENTITY(1,1) PRIMARY KEY NOT NULL  
        ,MemberRowID            INT  
        ,AttributeID            INT NULL  
        ,AttributeValue         NVARCHAR(MAX) COLLATE DATABASE_DEFAULT NULL  
        ,AttributeValueMapped   NVARCHAR(MAX) COLLATE DATABASE_DEFAULT NULL -- The final value that gets written to the member table. For DBA's, set to the INT ID of the domain entity member.  
        ,PriorValue             NVARCHAR(MAX) COLLATE DATABASE_DEFAULT NULL  
        ,PriorValueMapped       NVARCHAR(MAX) COLLATE DATABASE_DEFAULT NULL  
        ,PriorFileId            NVARCHAR(MAX) COLLATE DATABASE_DEFAULT NULL  
        ,IsChanged              BIT NULL  
        ,ChangeTrackingMask     INT NULL DEFAULT 0  
        ,TransactionAnnotation  NVARCHAR(500) COLLATE DATABASE_DEFAULT NULL  
        ,ErrorCode              INT NULL  
        ,ErrorParameters        NVARCHAR(MAX) NULL -- optionally add here any error message format string parameters, delimited by '|'  
        ,ErrorObjectType        TINYINT NULL -- This will usually be Attribute, but could occasionally be something different, like MemberCode  
    );  
    CREATE INDEX #ix_MemberAttributeWorkingSet_MemberRowID_AttributeID_ErrorCode ON #MemberAttributeWorkingSet(MemberRowID, AttributeID, ErrorCode);  
  
    -- Store attribute definitions for attributes being updated.  
    CREATE TABLE #AttributeDefinition  
    (  
         AttributeID                    INT PRIMARY KEY  
        ,AttributeMUID                  UNIQUEIDENTIFIER  
        ,IsSystem                       BIT  
        ,AttributeName                  NVARCHAR(100) COLLATE DATABASE_DEFAULT NULL  
        ,AttributeType_ID               TINYINT NULL  
        ,DataType_ID                    TINYINT NULL  
        ,DataTypeInformation            INT NULL  
        ,Dba_Entity_ID                  INT NULL  
        ,Dba_Entity_Table_Name          SYSNAME COLLATE DATABASE_DEFAULT NULL  
        ,ChangeTrackingGroup_ID         INT NULL  
        ,TableColumn                    SYSNAME COLLATE DATABASE_DEFAULT NULL  
        ,TableColumnUnPivotDefn         NVARCHAR(MAX) COLLATE DATABASE_DEFAULT NULL  
        ,TableColumnUpdateDefn          NVARCHAR(MAX) COLLATE DATABASE_DEFAULT NULL  
        ,TableColumnUpdateDbaIdsDefn    NVARCHAR(MAX) COLLATE DATABASE_DEFAULT NULL  
    );  
    CREATE NONCLUSTERED INDEX #ix_AttributeDefinition_AttributeName ON #AttributeDefinition(AttributeName);  
    CREATE NONCLUSTERED INDEX #ix_AttributeDefinition_AttributeType_ID ON #AttributeDefinition(AttributeType_ID);  
    CREATE NONCLUSTERED INDEX #ix_AttributeDefinition_DataType_ID ON #AttributeDefinition(DataType_ID);  
  
    ----------------------------------------------------------------------------------------  
    -- Copy the new member data from the param to the working set.  
    ----------------------------------------------------------------------------------------  
    IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Load #MembersWorkingSet.'  
    INSERT INTO #MembersWorkingSet  
    (  
         Row_ID  
        ,MemberCode  
        ,MemberName  
        ,MemberMUID  
        ,TransactionAnnotation  
        ,RevisionID  
    )  
    SELECT  
         RowID  
        ,NULLIF(MemberCode, N'')  
        ,MemberName  
        ,NULLIF(MemberMUID, @GuidEmpty) -- Note: Do not generate a MUID here if one is not provided. The MUID will be looked up for existing members. For new members, a new MUID will be generated right before adding the members to the member table.  
        ,NULLIF(LTRIM(RTRIM(TransactionAnnotation)), N'')  
        ,NULLIF(RevisionID, 0)  
    FROM @Members;  
  
    ----------------------------------------------------------------------------------------  
    -- Copy the member attribute data from the param to the working set.  
    ----------------------------------------------------------------------------------------  
    IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Load #MemberAttributeWorkingSet.'  
    INSERT INTO #MemberAttributeWorkingSet  
    (  
         MemberRowID  
        ,AttributeID  
        ,AttributeValue  
        ,AttributeValueMapped  
        ,TransactionAnnotation  
        ,IsChanged  
    )  
    SELECT  
         MemberRowID  
        ,AttributeID  
        ,AttributeValue  
        ,AttributeValue  
        ,NULLIF(LTRIM(RTRIM(TransactionAnnotation)), N'')  
        ,CASE @SaveMode WHEN @SaveMode_Create THEN 1 ELSE NULL END -- IsChanged is always true when creating new members.  
    FROM @MemberAttributes a  
  
    -----------------------------------------------------------------------------------------------  
    -- Add errors for attribute rows that do not reference a row in the members working set.  
    -----------------------------------------------------------------------------------------------  
    IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Add errors for attribute rows that do not reference a row in the members working set.'  
    UPDATE aws  
    SET  ErrorCode = @ErrorCode_IdNotValid  
        ,ErrorObjectType = @ObjectType_MemberId  
    FROM #MemberAttributeWorkingSet aws  
    LEFT JOIN #MembersWorkingSet mws  
    ON aws.MemberRowID = mws.Row_ID  
    WHERE mws.Row_ID IS NULL  
  
    ----------------------------------------------------------------------------------------  
    --Get Code, Name, and MUID attribute metadata.  
    ----------------------------------------------------------------------------------------  
    IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Get Code, Name, and MUID attribute metadata.'  
    SELECT  
         @AttributeName_Code = Name  
        ,@AttributeMUID_Code = MUID  
        ,@AttributeID_Code = ID  
        ,@AttributeMaxLength_Code = DataTypeInformation  
    FROM mdm.tblAttribute  
    WHERE   [Entity_ID] = @Entity_ID  
        AND MemberType_ID = @MemberType_ID  
        AND IsCode = 1;  
  
    SELECT  
         @AttributeName_Name = Name  
        ,@AttributeMUID_Name = MUID  
        ,@AttributeID_Name = ID  
        ,@AttributeMaxLength_Name = DataTypeInformation  
    FROM mdm.tblAttribute  
    WHERE   [Entity_ID] = @Entity_ID  
        AND MemberType_ID = @MemberType_ID  
        AND IsName = 1;  
  
    SELECT  
         @AttributeName_MUID = Name  
        ,@AttributeMUID_MUID = MUID  
    FROM mdm.tblAttribute a  
    WHERE   [Entity_ID] = @Entity_ID  
        AND MemberType_ID = @MemberType_ID  
        AND Name = N'MUID'  
        AND IsSystem = 1;  
  
    -- Lookup IDs of existing active members.  
    IF @SaveMode IN (@SaveMode_Update, @SaveMode_Merge)-- In create mode, don't bother looking in the member table for pre-existing members. This check will be done later (on all member tables) to ensure new member Code and MUID uniqueness.  
    BEGIN  
        -- !!!The following queries (to load existing members based on codes and MUID) have been separated on purpose.  
        --Combining the two results in significantly worse performance!!!  
  
        IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Lookup pre-existing member MUIDs and IDs from the member table based on input codes'  
        SET @SQL = CONCAT(@TruncationGuard, N'  
            UPDATE ws  
            SET  ws.MemberID   = m.ID  
                ,ws.MemberCode = m.Code  
                ,ws.MemberMUID = m.MUID  
                ,ws.MemberName = m.Name  
            FROM #MembersWorkingSet ws  
            INNER JOIN mdm.', @MemberTableName, N' m  
            ON      m.Version_ID = @Version_ID  
                AND ws.MemberCode = m.Code  
                AND m.Status_ID = ', @MemberStatus_Active, N' -- include only active members (i.e. do not include soft deleted members). DO NOT replace this hardcoded number with a var. It would be bad for perf.  
            WHERE   ws.ErrorCode IS NULL  
                AND ws.MemberCode IS NOT NULL --We are only looking for members that have MemberCode set up  
        ');  
        --IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT @SQL  
        EXEC sp_executesql @SQL, N'@Version_ID INT', @Version_ID  
  
        IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Lookup pre-existing member MUIDs and IDs from the member table based on input MUIDs'  
        SET @SQL = CONCAT(@TruncationGuard, N'  
            UPDATE ws  
            SET  ws.MemberID   = m.ID  
                ,ws.MemberCode = m.Code  
                ,ws.MemberMUID = m.MUID  
                ,ws.MemberName = m.Name  
            FROM #MembersWorkingSet ws  
            INNER JOIN mdm.', @MemberTableName, N' m  
            ON      m.Version_ID = @Version_ID  
                AND ws.MemberMUID = m.MUID  
            WHERE   ws.ErrorCode IS NULL  
                AND ws.MemberID IS NULL --Only look for members that have not already been looked up  
                AND ws.MemberMUID IS NOT NULL --We are only looking for members that have MUID set up  
                AND m.Status_ID = ', @MemberStatus_Active, N'; -- include only active members (i.e. do not include soft deleted members). DO NOT replace this hardcoded number with a var. It would be bad for perf.  
        ');  
        --IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT @SQL  
        EXEC sp_executesql @SQL, N'@Version_ID INT', @Version_ID;  
  
        --IF it is for pending changes, set a dummy MemberID  
        IF @Changeset_ID IS NOT NULL  
        BEGIN  
            SET @SQL = CONCAT(N'  
                UPDATE ws  
                SET ws.MemberID   = 0,  
                    ws.MemberCode = m.Code,  
                    ws.MemberMUID = m.MUID,  
                    ws.MemberName = m.Name  
                FROM #MembersWorkingSet ws  
                INNER JOIN mdm.', @PendingTableName, N' m  
                ON ws.MemberMUID = m.MUID AND m.CS_ID = @Changeset_ID AND m.Version_ID = @Version_ID  
                WHERE ws.ErrorCode IS NULL  
                    AND ws.MemberID IS NULL --Only look for members that have not already been looked up  
                    AND ws.MemberMUID IS NOT NULL --We are only looking for members that have MUID set up  
                    AND m.Status_ID = ', @MemberStatus_Active, ';');  
            --IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT @SQL  
            EXEC sp_executesql @SQL, N'@Version_ID INT, @Changeset_ID INT', @Version_ID, @Changeset_ID;  
        END  
  
        -- Add an error if trying to update a member that doesn't exist.  
        IF @SaveMode = @SaveMode_Update  
        BEGIN  
            UPDATE #MembersWorkingSet  
            SET  ErrorCode = @ErrorCode_InvalidMemberCode  
                ,ErrorObjectType = @ObjectType_MemberAttribute  
                ,ErrorAttributeName = @AttributeName_Code  
                ,ErrorAttributeMUID = @AttributeMUID_Code  
            WHERE   MemberID IS NULL  
                AND ErrorCode IS NULL;  
        END;  
    END; -- Lookup existing members for Update and Merge.  
  
    ----------------------------------------------------------------------------------------  
    -- Check for missing MemberCode.  
    -- Blank MemberCodes are allowed only when creating (not merging) Leaf members on an  
    -- entity that is CodeGen-enabled.  
    ----------------------------------------------------------------------------------------  
    IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Check for missing MemberCode.';  
    IF     @MemberType_ID <> @MemberType_Leaf  
        OR @CodeGenEnabled = 0  
        OR @SaveMode <> @SaveMode_Create -- In a Merge or Update operation all codes must be specified, even when the Entity is CodeGen enabled.  
    BEGIN  
        -- Add errors for all blank member codes.  
        UPDATE #MembersWorkingSet  
        SET  ErrorCode = @ErrorCode_InvalidBlankMemberCode  
            ,ErrorObjectType = @ObjectType_MemberAttribute  
            ,ErrorAttributeName = @AttributeName_Code  
            ,ErrorAttributeMUID = @AttributeMUID_Code  
        WHERE   MemberCode IS NULL  
            AND ErrorCode IS NULL;  
    END;  
  
    ----------------------------------------------------------------------------------------  
    -- Check for duplicate Code values in the working set.  
    ----------------------------------------------------------------------------------------  
    IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Check for duplicate Code values in the working set.';  
    WITH duplicateCodes AS  
    (  
        SELECT MemberCode  
        FROM #MembersWorkingSet  
        WHERE   MemberCode IS NOT NULL  
            AND ErrorCode IS NULL  
        GROUP BY MemberCode  
        HAVING COUNT(*) > 1  
    )  
    UPDATE ws  
    SET  ErrorCode = @ErrorCode_DuplicateInputMemberCodes  
        ,ErrorObjectType = @ObjectType_MemberAttribute  
        ,ErrorAttributeName = @AttributeName_Code  
        ,ErrorAttributeMUID = @AttributeMUID_Code  
    FROM #MembersWorkingSet AS ws  
    INNER JOIN duplicateCodes AS dup  
    ON ws.MemberCode = dup.MemberCode  
    WHERE ws.ErrorCode IS NULL;  
  
    ----------------------------------------------------------------------------------------  
    -- Check for duplicate MUIDs in the working set.  
    ----------------------------------------------------------------------------------------  
    IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Check for duplicate MUIDs in the working set.';  
    WITH duplicateMuids AS  
    (  
        SELECT MemberMUID  
        FROM #MembersWorkingSet  
        WHERE   ErrorCode IS NULL  
            AND MemberMUID IS NOT NULL  
        GROUP BY MemberMUID  
        HAVING COUNT(*) > 1  
    )  
    UPDATE ws  
    SET  ErrorCode = @ErrorCode_IdNotValid  
        ,ErrorObjectType = @ObjectType_MemberAttribute  
        ,ErrorAttributeName = @AttributeName_MUID  
        ,ErrorAttributeMUID = @AttributeMUID_MUID  
    FROM #MembersWorkingSet AS ws  
    INNER JOIN duplicateMuids AS dup  
    ON ws.MemberMUID = dup.MemberMUID  
    WHERE ws.ErrorCode IS NULL;  
  
    -- Create a SQL fragment that gets all pre-existing member ids.  
    DECLARE @ExistingCodesCteSQL NVARCHAR(MAX) = CONCAT(N'  
        ;WITH existingCodesCte AS  
        (  
            SELECT  
                 Code  
                ,MUID  
                ,Status_ID  
            FROM mdm.', @EntityTableName, N'  
            WHERE Version_ID = @Version_ID',  
            -- Only look at Consolidated and Collection tables if they exist  
            CASE WHEN @IsHierarchyEnabled = 1 THEN CONCAT(N'  
            UNION ALL -- deduplication not needed  
            SELECT  
                 Code  
                ,MUID  
                ,Status_ID  
            FROM mdm.', @HierarchyParentTableName, N'  
            WHERE Version_ID = @Version_ID') END +  
            CASE WHEN @IsCollectionEnabled = 1 THEN CONCAT(N'  
            UNION ALL -- deduplication not needed  
            SELECT  
                 Code  
                ,MUID  
                ,Status_ID  
            FROM mdm.', @CollectionTableName, N'  
            WHERE Version_ID = @Version_ID') END, N'  
        )');  
  
    IF @SaveMode IN (@SaveMode_Create, @SaveMode_Merge)  
    BEGIN  
        ----------------------------------------------------------------------------------------  
        -- Check for reserved words in the MemberCode.  
        ----------------------------------------------------------------------------------------  
        IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Check for reserved words in the MemberCode.';  
        UPDATE ws  
        SET  ErrorCode = @ErrorCode_ReservedWord  
            ,ErrorObjectType = @ObjectType_MemberAttribute  
            ,ErrorAttributeName = @AttributeName_Code  
            ,ErrorAttributeMUID = @AttributeMUID_Code  
        FROM #MembersWorkingSet ws  
        INNER JOIN mdm.udfItemReservedWordsGet(12/*Leaf member*/) rw  
        ON UPPER(ws.MemberCode) = UPPER(rw.ReservedWord)  
        WHERE   ws.MemberID IS NULL -- If the member ID is not null, then the member already exists (for a Merge operation) and can be skipped for this check.  
            AND ws.ErrorCode IS NULL;  
  
        ----------------------------------------------------------------------------------------  
        -- Check for Name and Code values that are too long.  
        ----------------------------------------------------------------------------------------  
        IF @ValidateDataTypes = 1  
        BEGIN  
            IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Check for Name and Code values that are too long.';  
            UPDATE #MembersWorkingSet  
            SET  ErrorCode = @ErrorCode_AttributeValueLengthGreaterThanMaximum  
                ,ErrorObjectType = @ObjectType_MemberAttribute  
                ,ErrorAttributeName = @AttributeName_Code  
                ,ErrorAttributeMUID = @AttributeMUID_Code  
            WHERE   ErrorCode IS NULL  
                AND MemberID IS NULL -- If the member ID is not null, then the member already exists (for a Merge operation) and can be skipped for this check.  
                AND ISNULL(LEN(MemberCode), 0) > @AttributeMaxLength_Code;  
  
            UPDATE #MembersWorkingSet  
            SET  ErrorCode = @ErrorCode_AttributeValueLengthGreaterThanMaximum  
                ,ErrorObjectType = @ObjectType_MemberAttribute  
                ,ErrorAttributeName = @AttributeName_Name  
                ,ErrorAttributeMUID = @AttributeMUID_Name  
            WHERE   ErrorCode IS NULL  
                AND MemberID IS NULL -- If the member ID is not null, then the member already exists (for a Merge operation) and can be skipped for this check.  
                AND ISNULL(LEN(MemberName), 0) > @AttributeMaxLength_Name;  
        END; -- Name and Code length  
  
        -- !!!The following checks (for duplicate MUIDs and codes) have been separated on purpose. Combining the two results in significantly worse performance!!!  
  
        ----------------------------------------------------------------------------------------  
        -- Ensure that new members' Codes don't conflict with existing members.  
        -- !!!This check has been separated from the MUID check on purpose. Combining the two results in significantly worse performance!!!  
        ----------------------------------------------------------------------------------------  
        IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Ensure that new members Codes don''t conflict with existing members.';  
        SET @SQL = CONCAT(@ExistingCodesCteSQL, N'  
            UPDATE ws  
            SET  ErrorCode = @ErrorCode_MemberCodeExists  
                ,ErrorObjectType = @ObjectType_MemberAttribute  
                ,ErrorAttributeName = @AttributeName_Code  
                ,ErrorAttributeMUID = @AttributeMUID_Code  
            FROM #MembersWorkingSet AS ws  
            INNER JOIN existingCodesCte c  
            ON      ws.MemberCode = c.Code  
                AND c.Status_ID = ', @MemberStatus_Active, N' -- include only active members (i.e. do not include soft deleted members). DO NOT replace this hardcoded number with a var. It would be bad for perf.  
            WHERE   ws.ErrorCode IS NULL  
                AND ws.MemberID IS NULL -- If the member ID is not null, then the member already exists (for a Merge operation) and can be skipped for this check.  
            ');  
  
        EXEC sp_executesql @SQL,  
            N'@Version_ID INT,  @ErrorCode_MemberCodeExists INT, @ErrorCode_IdAlreadyExists INT, @ObjectType_MemberAttribute INT, @ObjectType_MemberId INT, @AttributeName_Code NVARCHAR(100), @AttributeMUID_Code UNIQUEIDENTIFIER',  
              @Version_ID,       @ErrorCode_MemberCodeExists,     @ErrorCode_IdAlreadyExists,     @ObjectType_MemberAttribute,     @ObjectType_MemberId,     @AttributeName_Code,               @AttributeMUID_Code;  
  
        ----------------------------------------------------------------------------------------  
        -- Ensure that new members' MUIDs don't conflict with existing members.  
        -- !!!This check has been separated from the Code check on purpose. Combining the two results in significantly worse performance!!!  
        ----------------------------------------------------------------------------------------  
        IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Ensure that new members MUIDs don''t conflict with existing members.';  
        SET @SQL = @ExistingCodesCteSQL + N'  
            UPDATE ws  
            SET  ErrorCode = @ErrorCode_IdAlreadyExists  
                ,ErrorObjectType = @ObjectType_MemberId  
            FROM #MembersWorkingSet AS ws  
            INNER JOIN existingCodesCte c  
            ON     ws.MemberMUID = c.MUID  
            WHERE   ws.ErrorCode IS NULL  
                AND ws.MemberID IS NULL -- If the member ID is not null, then the member already exists (for a Merge operation) and can be skipped for this check.  
            ';  
  
        EXEC sp_executesql @SQL,  
            N'@Version_ID INT, @ErrorCode_MemberCodeExists INT, @ErrorCode_IdAlreadyExists INT, @ObjectType_MemberAttribute INT, @ObjectType_MemberId INT, @AttributeName_Code NVARCHAR(100), @AttributeMUID_Code UNIQUEIDENTIFIER',  
              @Version_ID,     @ErrorCode_MemberCodeExists,     @ErrorCode_IdAlreadyExists,     @ObjectType_MemberAttribute,     @ObjectType_MemberId,     @AttributeName_Code,               @AttributeMUID_Code;  
    END; -- Create or Merge  
  
    -----------------------------------------------------------------------------------------------  
    -- Delete attribute working set rows that pertain to new members that  
    -- have an error (Can't set the attributes of members that don't exist).  
    -----------------------------------------------------------------------------------------------  
    IF EXISTS(SELECT 1 FROM #MembersWorkingSet WHERE ErrorCode IS NOT NULL)  
    BEGIN  
        IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Delete attribute rows that pertain to members that have an error.';  
        DELETE aws  
        FROM #MemberAttributeWorkingSet aws  
        INNER JOIN #MembersWorkingSet nm  
        ON aws.MemberRowID = nm.Row_ID  
        WHERE nm.ErrorCode IS NOT NULL  
  
-- TODO: Also delete from the collections working set  
  
    END;  
  
    -----------------------------------------------------------------------------------------------  
    -- Process attribute value changes.  
    -----------------------------------------------------------------------------------------------  
  
    ----------------------------------------------------------------------------------------  
    -- Load SysNull Datatype mappings.    
    ----------------------------------------------------------------------------------------  
    IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Load SysNull Datatype mappings.'  
    CREATE TABLE #SysNullDataTypeMap  
    (  
         AtributeType_ID    TINYINT NOT NULL  
        ,DataType_ID        TINYINT NOT NULL  
        ,SysNullName        NVARCHAR(20) COLLATE DATABASE_DEFAULT NOT NULL  
        ,SysNullValue       NVARCHAR(60) COLLATE DATABASE_DEFAULT NOT NULL  
    );  
    CREATE UNIQUE CLUSTERED INDEX #ix_SysNullDataTypeMap_AtributeType_ID_DataType_ID ON #SysNullDataTypeMap(AtributeType_ID, DataType_ID);  
    INSERT INTO #SysNullDataTypeMap  
        (AtributeType_ID,           DataType_ID,                    SysNullName,                SysNullValue)  
    VALUES  
         (@AttributeType_FreeForm,  @AttributeDataType_Text,        N'@SysNull_Text',           @SysNull_Text)  
        ,(@AttributeType_FreeForm,  @AttributeDataType_Number,      N'@SysNull_Number',         CONVERT(NVARCHAR(60), @SysNull_Number))  
        ,(@AttributeType_FreeForm,  @AttributeDataType_DateTime,    N'@SysNull_DateTime',       CONVERT(NVARCHAR(60), @SysNull_DateTime))  
        ,(@AttributeType_FreeForm,  @AttributeDataType_Link,        N'@SysNull_Text',           @SysNull_Text)  
        ,(@AttributeType_DBA,       @AttributeDataType_Text,        N'@SysNull_ForeignKey' ,    CONVERT(NVARCHAR(60), @SysNull_ForeignKey))  
        ,(@AttributeType_File,      @AttributeDataType_Link,        N'@SysNull_ForeignKey',     CONVERT(NVARCHAR(60), @SysNull_ForeignKey))  
    ;  
  
    ----------------------------------------------------------------------------------------  
    -- Get attribute definitions  
    ----------------------------------------------------------------------------------------  
    IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Load #AttributeDefinition.';  
    ;WITH attributeIdCte AS -- Get all distinct attribute names.  
    (  
        SELECT DISTINCT  
            AttributeID  
        FROM #MemberAttributeWorkingSet  
        WHERE ErrorCode IS NULL  
    )  
    INSERT INTO #AttributeDefinition  
    (  
         AttributeID  
        ,AttributeMUID  
        ,IsSystem  
        ,AttributeName  
        ,AttributeType_ID  
        ,DataType_ID  
        ,DataTypeInformation  
        ,Dba_Entity_ID  
        ,Dba_Entity_Table_Name  
        ,ChangeTrackingGroup_ID  
        ,TableColumn  
        ,TableColumnUnPivotDefn  
        ,TableColumnUpdateDbaIdsDefn  
        ,TableColumnUpdateDefn  
    )  
    SELECT DISTINCT  
         att.ID  
        ,att.MUID  
        ,att.IsSystem  
        ,att.Name  
        ,att.AttributeType_ID  
        ,att.DataType_ID  
        ,att.DataTypeInformation  
        ,att.DomainEntity_ID  
        ,dbaEnt.EntityTable  
        ,att.ChangeTrackingGroup  
        ,att.TableColumn  
        ,  
        CASE  
            WHEN att.AttributeType_ID = @AttributeType_FreeForm AND att.DataType_ID = @AttributeDataType_DateTime  
            THEN N'CONVERT(NVARCHAR(MAX),' + QUOTENAME(att.TableColumn) + N', 126) AS ' + QUOTENAME(att.ID) -- Datetime is passed in as ISO8601  
            ELSE N'CONVERT(NVARCHAR(MAX),' + QUOTENAME(att.TableColumn) + N') AS ' + QUOTENAME(att.ID)  
        END -- TableColumnUnPivotDefn  
        ,CASE  
            WHEN att.AttributeType_ID = @AttributeType_DBA  
             THEN CONCAT(N'SELECT ID, Code, ', att.ID, N' AS AttributeID FROM mdm.', QUOTENAME(dbaEnt.EntityTable), N' WHERE Version_ID = @Version_ID AND Status_ID = 1')  
            ELSE N''  
         END -- TableColumnUpdateDbaIdsDefn  
        ,CASE  
            WHEN att.Name = N'Code'  
            THEN  
                CASE  
                    WHEN @Changeset_ID IS NULL THEN N'm.' + att.TableColumn + N'= ISNULL(updates.' + att.TableColumn + N',m.' + att.TableColumn + N')'  
                    ELSE CONCAT(N'm.', att.TableColumn, N' = CASE WHEN isChanged.', att.TableColumn, N' = 1 THEN updates.', att.TableColumn +N' ELSE NULL END')  
                END  
  
            --Special handling for Owner_ID on collection members because in tblAttribute this  
            --attribute is registered as text. However, the column itself is an int. If we don't  
            --add this handling, the ELSE logic will try and put SysNull_Text as the relevant null value. We  
            --don't care about null values because the user can't possibly supply a null value (there will always  
            --be at least one user on the application)  
            WHEN att.Name = N'Owner_ID' AND @MemberType_ID = @MemberType_Collection  
            THEN N'm.' + att.TableColumn + N'= ISNULL(updates.' + att.TableColumn + N',m.' + att.TableColumn + N')'  
  
            ELSE  
                CASE  
                    WHEN @Changeset_ID IS NULL THEN N'm.' + att.TableColumn + N' = NULLIF(ISNULL(updates.' + att.TableColumn + N', m.' + att.TableColumn + '),' + m.SysNullName + N')'  
                    ELSE CONCAT(N'm.', att.TableColumn, N' = CASE WHEN isChanged.', att.TableColumn, N' = 1 THEN CASE WHEN m.EN_ID IS NULL THEN NULLIF(updates.', att.TableColumn, N' ,', m.SysNullName, N') ELSE updates.', att.TableColumn, N' END ELSE NULL END')  
                END  
         END -- TableColumnUpdateDefn  
    FROM attributeIdCte AS ws  
    INNER JOIN mdm.tblAttribute att  
    ON      ws.AttributeID = att.ID  
    INNER JOIN #SysNullDataTypeMap m  
    ON      m.AtributeType_ID = att.AttributeType_ID  
        AND m.DataType_ID = att.DataType_ID  
    LEFT JOIN mdm.tblEntity dbaEnt  
    ON dbaEnt.ID = att.DomainEntity_ID;  
  
    --------------------------------------------------------------------------------------------------  
    -- Add errors for invalid attributes.  
    --------------------------------------------------------------------------------------------------  
    IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Add errors for invalid attributes.'  
    UPDATE ws  
    SET ErrorCode = @ErrorCode_InvalidAttribute,  
        ErrorObjectType = @ObjectType_MemberAttribute  
    FROM #MemberAttributeWorkingSet ws  
    LEFT JOIN #AttributeDefinition att  
    ON ws.AttributeID = att.AttributeID  
    WHERE   att.AttributeMUID IS NULL  
        AND ws.ErrorCode IS NULL;  
  
    --------------------------------------------------------------------------------------------------  
    -- Check for duplicate member-attribute assignments. These are not allowed because they are ambiguous (i.e. which assignment wins?)  
    --------------------------------------------------------------------------------------------------  
    IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Check for duplicate member-attribute assignments.';  
    WITH duplicateAttributes AS  
    (  
        SELECT  
             MemberRowID  
            ,AttributeID  
        FROM #MemberAttributeWorkingSet  
        WHERE ErrorCode IS NULL  
        GROUP BY MemberRowID, AttributeID  
        HAVING COUNT(*) > 1  
    )  
    UPDATE ws  
    SET  ErrorCode = @ErrorCode_InvalidAttributeValueForMember  
        ,ErrorObjectType = @ObjectType_MemberAttribute  
    FROM #MemberAttributeWorkingSet AS ws  
    INNER JOIN duplicateAttributes AS dup  
    ON      ws.MemberRowID = dup.MemberRowID  
        AND ws.AttributeID = dup.AttributeID  
    WHERE ws.ErrorCode IS NULL;  
  
    ----------------------------------------------------------------------------------------  
    --Check security  
    ----------------------------------------------------------------------------------------  
    IF @ModelPermission != @Permission_Admin  
    BEGIN  
        IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Lookup attribute permissions.'  
  
        DECLARE @AttributePermissions TABLE  
        (  
             AttributeID INT PRIMARY KEY  
            ,Privilege_ID TINYINT NOT NULL  
            ,AccessPermission TINYINT NOT NULL  
        )  
  
        ;WITH attributesCte AS  
        (  
            SELECT AttributeID  
            FROM #AttributeDefinition  
              
            UNION  
  
            -- Ensure Name and Code attributes are included  
            SELECT @AttributeID_Code  
            UNION   
            SELECT @AttributeID_Name  
        )  
        INSERT INTO @AttributePermissions  
        SELECT  
             a.AttributeID  
            ,COALESCE(sec.Privilege_ID, @Permission_Deny)  
            ,COALESCE(sec.AccessPermission, @AccessPermission_Read)  
        FROM attributesCte a  
        LEFT JOIN mdm.viw_SYSTEM_SECURITY_USER_ATTRIBUTE sec  
        ON a.AttributeID = sec.ID  
        WHERE sec.User_ID = @User_ID  
  
  
        IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Check Object Permissions: Create on Name and Code for new members.'  
        --Check Object Permissions.  Mark any attributes the user doesn't have permission to.  
  
        -- Require create on Name and Code for new members  
        IF EXISTS(  
            SELECT 1  
            FROM mdm.tblAttribute a  
            LEFT JOIN @AttributePermissions ap  
            ON a.ID = ap.AttributeID  
            WHERE   a.ID IN (@AttributeID_Code, @AttributeID_Name)  
                AND NOT (ap.Privilege_ID = @Permission_Access  
                    AND ap.AccessPermission & @AccessPermission_Create = @AccessPermission_Create)  
        )  
        BEGIN  
            UPDATE #MembersWorkingSet  
            SET ErrorCode = @ErrorCode_NoPermissionForThisOperation,  
                ErrorObjectType = @ObjectType_MemberId  
            WHERE MemberID IS NULL  
        END  
  
        IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Check Object Permissions: Create/Update on other attributes.'  
        -- Require create on attribute on new member  
        -- Require update on attribute on update member  
        UPDATE ws  
        SET  ErrorCode =  
                CASE COALESCE(ap.Privilege_ID, @Permission_Deny)  
                    WHEN @Permission_Access THEN @ErrorCode_ReadOnlyAttribute -- AccessPermission check is done below  
                    WHEN @Permission_Inferred THEN @ErrorCode_ReadOnlyAttribute  
                    WHEN @Permission_Deny THEN @ErrorCode_InvalidAttribute  
                    WHEN @Permission_None THEN @ErrorCode_InvalidAttribute  
                    ELSE NULL  
                END  
            ,ErrorObjectType = @ObjectType_MemberAttribute  
        FROM #MemberAttributeWorkingSet AS ws  
        INNER JOIN #MembersWorkingSet nm  
        ON ws.MemberRowID = nm.Row_ID  
        LEFT JOIN @AttributePermissions ap  
        ON ws.AttributeID = ap.AttributeID  
        WHERE    ws.ErrorCode IS NULL   
            AND (ap.Privilege_ID IS NULL  
                OR ap.Privilege_ID <> @Permission_Access  
                OR ap.AccessPermission & CASE WHEN nm.MemberID IS NULL THEN @AccessPermission_Create ELSE @AccessPermission_Update END = 0)  
  
        IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Determine whether member security applies.'  
        --Check Member Permissions.  Mark any members the user doesn't have permission to.  
        SET @MemberSecurity = mdm.udfUseMemberSecurity(@User_ID, @Entity_ID, @Version_ID, @MemberType_ID);  
    END  
  
    IF @MemberSecurity = 1  
    BEGIN  
        IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Check Member Permissions.  Mark any members the user doesn''t have permission to update.'  
        DECLARE @MemberIds mdm.MemberId;  
        INSERT INTO @MemberIds (ID, MemberType_ID)  
        SELECT DISTINCT  
                mws.MemberID  
            ,@MemberType_ID  
        FROM #MemberAttributeWorkingSet aws  
        INNER JOIN #MembersWorkingSet mws  
        ON aws.MemberRowID = mws.Row_ID  
        WHERE   mws.MemberID IS NOT NULL -- New members will have null MemberID, so they will be excluded from this query  
            AND aws.ErrorCode IS NULL;  
  
        IF EXISTS (SELECT 1 FROM @MemberIds)  
        BEGIN  
            DELETE FROM @MemberPermissions;  
            INSERT INTO @MemberPermissions  
            EXEC mdm.udpSecurityMembersResolverGet @User_ID, @Version_ID, @Entity_ID, @MemberIds;  
  
            UPDATE aws  
            SET ErrorCode = @ErrorCode_NoPermissionForThisOperationOnThisObject,  
                ErrorObjectType = @ObjectType_MemberCode  
            FROM #MemberAttributeWorkingSet aws  
            INNER JOIN #MembersWorkingSet mws  
            ON aws.MemberRowID = mws.Row_ID  
            LEFT JOIN @MemberPermissions prm  
            ON  mws.MemberID = prm.ID  
            WHERE NOT (ISNULL(prm.Privilege_ID, @Permission_Deny) = @Permission_Access AND (ISNULL(prm.AccessPermission, @AccessPermission_None) & @AccessPermission_Update) = @AccessPermission_Update)  
                AND mws.MemberID IS NOT NULL -- New members will have null MemberID, so they will be excluded from this query  
                AND aws.ErrorCode IS NULL;  
        END;  
    END;  
  
    SET @HasDba = CASE WHEN EXISTS(SELECT 1 FROM #AttributeDefinition WHERE ISNULL(AttributeType_ID, @AttributeType_NotSpecified) = @AttributeType_DBA)  
        THEN 1 ELSE 0 /*Can skip DBA processing*/ END;  
    SET @HasFile = CASE WHEN EXISTS(SELECT 1 FROM #AttributeDefinition WHERE ISNULL(AttributeType_ID, @AttributeType_NotSpecified) = @AttributeType_File)  
        THEN 1 ELSE 0 /*No file attributes to update*/ END;  
  
    ----------------------------------------------------------------------------------------  
    --Set column name strings.  
    ----------------------------------------------------------------------------------------  
    IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Set column name strings.'  
    SELECT  
         @TableColumnsUnPivotDefn   +=  CONCAT(N'  
    ,', TableColumnUnPivotDefn, N' --', AttributeName)  
        ,@ViewColumnsUnPivotDefn += CONCAT(N'  
    ,CONVERT(NVARCHAR(MAX),', QUOTENAME(CONCAT(AttributeName, CASE WHEN AttributeType_ID = @AttributeType_DBA THEN N'.ID' END)), N') AS ', QUOTENAME(AttributeID), N' --', AttributeName, CASE WHEN AttributeType_ID = @AttributeType_DBA THEN CONCAT(N'  
    ,CONVERT(NVARCHAR(MAX),', QUOTENAME(AttributeName), N') AS ', QUOTENAME(CONCAT(AttributeID, N'_Code'))) END) -- extra column for DBA member code  
        ,@TableColumnsUpdateDefn    +=  CONCAT(N'  
    ,', TableColumnUpdateDefn)  
        ,@AttributeIdList           += CONCAT(CASE WHEN @AttributeIdList <> N'' THEN ',' END, QUOTENAME(AttributeID))   
        ,@AttributeIdListWithDBACode = CONCAT(@AttributeIdListWithDBACode, CASE WHEN AttributeType_ID = @AttributeType_DBA THEN CONCAT(CASE WHEN @AttributeIdListWithDBACode <> N'' THEN ',' END, QUOTENAME(CONCAT(AttributeID, N'_Code'))) END)   
        ,@AttributeValueMappedAsColumns += CONCAT(N'  
        ,MAX(', QUOTENAME(AttributeID), N') AS ', TableColumn)  
    FROM #AttributeDefinition  
    ORDER BY AttributeID;  
  
    If @HasDba = 1  
    BEGIN  
        SELECT @TableColumnsUpdateDbaIdsDefn += CONCAT(CASE WHEN @TableColumnsUpdateDbaIdsDefn <> N'' THEN N'  
                    UNION ALL  
                    ' END, TableColumnUpdateDbaIdsDefn)  
        FROM #AttributeDefinition   
        WHERE COALESCE(Dba_Entity_ID, 0) > 0   
        ORDER BY AttributeID;  
    END;  
  
    ----------------------------------------------------------------------------------------  
    -- Validate attribute working set.  
    ----------------------------------------------------------------------------------------  
    IF (@ValidateDataTypes = 1)  
    BEGIN  
        --Flag FreeForm and Link attributes where the value length exceeds the maximum length allowed.  
        UPDATE ws  
        SET  ErrorCode = @ErrorCode_AttributeValueLengthGreaterThanMaximum  
            ,ErrorObjectType = @ObjectType_MemberAttribute  
        FROM #MemberAttributeWorkingSet AS ws  
        INNER JOIN #AttributeDefinition AS att  
        ON ws.AttributeID = att.AttributeID  
        WHERE   att.AttributeType_ID = @AttributeType_FreeForm  
            AND (att.DataType_ID = @AttributeDataType_Text OR att.DataType_ID = @AttributeDataType_Link)  
            AND ISNULL(LEN(ws.AttributeValue), 0) > ISNULL(att.DataTypeInformation, 0)  
            AND ws.ErrorCode IS NULL;  
  
        DECLARE @SqlAzureEngineEdition INT = 5;  
        DECLARE  
             @IsAzure BIT = CASE SERVERPROPERTY(N'EngineEdition') WHEN @SqlAzureEngineEdition THEN 1 ELSE 0 END  
            ,@NewAttributeValue NVARCHAR(MAX)  
            ,@Row_ID INT  
  
        --Flag attributes with incorrect numeric types  
        IF (@IsAzure = 0)  
        BEGIN  
            -- SQL CLR is supported.  
            UPDATE ws  
            SET  ErrorCode = CASE mdq.IsNumber(ws.AttributeValue) WHEN 0 THEN  
                    @ErrorCode_InvalidAttributeValueForDataType ELSE -- 'Error - The AttributeValue must be a number.'  
                    @ErrorCode_InvalidAttributeValueForMember END  -- 'Error - The AttributeValue is too long.'  
                ,ErrorObjectType = @ObjectType_MemberAttribute  
            FROM #MemberAttributeWorkingSet AS ws  
            INNER JOIN #AttributeDefinition AS att  
            ON ws.AttributeID = att.AttributeID  
            WHERE   att.AttributeType_ID = @AttributeType_FreeForm  
                AND att.DataType_ID = @AttributeDataType_Number  
                AND ws.AttributeValue IS NOT NULL  
                AND CASE -- using a CASE statement here ensures Boolean short-circuiting. If the value isn't numeric then trying to convert it to float will crash  
                    WHEN ISNULL(mdq.IsNumber(ws.AttributeValue), 0) <> 1 THEN 1  
                    WHEN mdq.IsNumber(STR(CONVERT(FLOAT, ws.AttributeValue), 38 - att.DataTypeInformation, att.DataTypeInformation)) <> 1 THEN 1  
                    ELSE 0 END = 1  
                AND ws.ErrorCode IS NULL;  
  
        END ELSE  
        BEGIN  
            -- SQL CLR is not supported. Use a slower TSQL equivalent by checking one row at a time in a loop.  
            -- TODO: Consider removing this ELSE block when SQL Azure adds support for SQL CLR  
  
            -- Find all working set rows that change the value of a numeric attribute.  
            DECLARE @NumericAttributeRowIndexes TABLE  
            (  
                 ID INT PRIMARY KEY  
                ,NewAttributeValue NVARCHAR(MAX) COLLATE DATABASE_DEFAULT  
                ,DataTypeInformation INT  
            );  
            INSERT INTO @NumericAttributeRowIndexes  
            SELECT  
                 ws.Row_ID  
                ,ws.AttributeValue  
                ,att.DataTypeInformation  
            FROM #MemberAttributeWorkingSet AS ws  
            INNER JOIN #AttributeDefinition AS att  
            ON ws.AttributeID = att.AttributeID  
            WHERE   att.AttributeType_ID = @AttributeType_FreeForm  
                AND att.DataType_ID = @AttributeDataType_Number  
                AND ws.AttributeValue IS NOT NULL  
                AND ws.ErrorCode IS NULL;  
  
            -- Loop through each numeric attribute working set row, and ensure the new value is numeric.  
            DECLARE  
                 @IsNumeric           BIT  
                ,@ErrorCode           INT  
                ,@DataTypeInformation INT;  
            WHILE EXISTS (SELECT 1 FROM @NumericAttributeRowIndexes)  
            BEGIN  
                -- Get the next row  
                SELECT TOP 1  
                     @Row_ID = ID  
                    ,@NewAttributeValue = NewAttributeValue  
                    ,@DataTypeInformation = DataTypeInformation  
                FROM @NumericAttributeRowIndexes;  
  
                DELETE FROM @NumericAttributeRowIndexes WHERE ID = @Row_ID;  
  
                SET @IsNumeric = 0;  
                SET @ErrorCode = NULL;  
                EXEC mdq.udpIsNumber @NewAttributeValue, @IsNumeric OUTPUT  
                IF COALESCE(@IsNumeric, 0) = 0  
                BEGIN  
                    SET @ErrorCode = @ErrorCode_InvalidAttributeValueForDataType; -- 'Error - The AttributeValue must be a number.'  
                END ELSE  
                BEGIN  
                    -- The new value is numeric, but ensure it is not too long  
                    SET @NewAttributeValue = STR(CONVERT(FLOAT, @NewAttributeValue), 38 - @DataTypeInformation, @DataTypeInformation);  
                    SET @IsNumeric = 0;  
                    EXEC mdq.udpIsNumber @NewAttributeValue, @IsNumeric OUTPUT  
                    IF COALESCE(@IsNumeric, 0) = 0  
                    BEGIN  
                        SET @ErrorCode = @ErrorCode_InvalidAttributeValueForMember; -- 'Error - The AttributeValue is too long.'  
                    END;  
                END;  
  
                IF @ErrorCode IS NOT NULL  
                BEGIN  
                    UPDATE #MemberAttributeWorkingSet  
                    SET  ErrorCode = @ErrorCode  
                        ,ErrorObjectType = @ObjectType_MemberAttribute  
                    WHERE Row_ID = @Row_ID  
                END;  
            END;-- WHILE  
        END;  
  
        -- Numeric data types in scientific notation format cannot be directly converted to type  
        -- DECIMAL, so convert them to fixed-point notation.  
        UPDATE ws  
        SET AttributeValueMapped =  
            -- the CASE condition is redundant with part of the JOIN clause, but it is necessary because even when false the query will still  
            -- sometimes evaluate the right-hand side of this assignment, which can cause a "failure to convert NVARCHAR to float" error.  
                CASE COALESCE(ws.ErrorCode, N'')  
                    WHEN N'' THEN STR(CONVERT(FLOAT, ws.AttributeValue), 38 - att.DataTypeInformation, att.DataTypeInformation)  
                    ELSE ws.AttributeValue  
                END  
        FROM #MemberAttributeWorkingSet AS ws  
        INNER JOIN #AttributeDefinition AS att  
        ON ws.AttributeID = att.AttributeID  
        WHERE   ISNULL(att.DataType_ID, @AttributeDataType_NotSpecified) = @AttributeDataType_Number  
            AND ISNULL(CHARINDEX(N'E', UPPER(ws.AttributeValue)), 0) > 0     -- CHARINDEX uses 1-based indexing  
            AND ws.ErrorCode IS NULL;  
  
        --Flag attributes with incorrect data type  
        IF (@IsAzure = 0)  
        BEGIN  
            -- SQL CLR is supported.  
            UPDATE ws  
            SET  ErrorCode = @ErrorCode_InvalidAttributeValueForDataType  
                ,ErrorObjectType = @ObjectType_MemberAttribute  
            FROM #MemberAttributeWorkingSet AS ws  
            INNER JOIN #AttributeDefinition AS att  
            ON att.AttributeID = ws.AttributeID  
            WHERE   ISNULL(att.DataType_ID, @AttributeDataType_NotSpecified) = @AttributeDataType_DateTime  
                AND LEN(ISNULL(ws.AttributeValue, N'')) > 0  
                AND ISNULL(mdq.IsDateTime2(ws.AttributeValue), 1) = 0  
                AND ws.ErrorCode IS NULL;  
        END ELSE  
        BEGIN  
            -- SQL CLR is not supported. Use a slower TSQL equivalent by checking one row at a time in a loop.  
            -- TODO: Consider removing this ELSE block when SQL Azure adds support for SQL CLR  
  
            -- Find all working set rows that change the value of a datetime attribute.  
            DECLARE @DateTimeAttributeRowIndexes TABLE  
            (  
                 ID INT PRIMARY KEY  
                ,NewAttributeValue NVARCHAR(MAX) COLLATE DATABASE_DEFAULT  
            );  
            INSERT INTO @DateTimeAttributeRowIndexes  
            SELECT  
                 ws.Row_ID  
                ,ws.AttributeValue  
            FROM #MemberAttributeWorkingSet AS ws  
            INNER JOIN #AttributeDefinition AS att  
            ON att.AttributeID = ws.AttributeID  
            WHERE   att.DataType_ID = @AttributeDataType_DateTime  
                AND LEN(ISNULL(ws.AttributeValue, N'')) > 0  
                AND ws.ErrorCode IS NULL;  
  
            -- Loop through each datetime attribute working set row, and ensure the new value is a datetime2.  
            DECLARE @IsDateTime2 BIT;  
            WHILE EXISTS (SELECT 1 FROM @DateTimeAttributeRowIndexes)  
            BEGIN  
                -- Get the next row  
                SELECT TOP 1  
                     @Row_ID = ID  
                    ,@NewAttributeValue = NewAttributeValue  
                FROM @DateTimeAttributeRowIndexes  
                DELETE FROM @DateTimeAttributeRowIndexes WHERE ID = @Row_ID;  
  
                SET @IsDateTime2 = 0;  
                EXEC mdq.udpIsDateTime2 @NewAttributeValue, @IsDateTime2 OUTPUT  
                IF COALESCE(@IsDateTime2, 0) = 0  
                BEGIN  
                    UPDATE #MemberAttributeWorkingSet  
                    SET  ErrorCode = @ErrorCode_InvalidAttributeValueForDataType  
                        ,ErrorObjectType = @ObjectType_MemberAttribute  
                    WHERE Row_ID = @Row_ID  
                END;  
            END;-- WHILE  
        END  
  
        --Flag attributes with incorrect links.  
        UPDATE ws  
        SET  ErrorCode = @ErrorCode_InvalidAttributeValueForDataType  
            ,ErrorObjectType = @ObjectType_MemberAttribute  
        FROM #MemberAttributeWorkingSet AS ws  
        INNER JOIN #AttributeDefinition AS att  
        ON ws.AttributeID = att.AttributeID  
        WHERE   att.DataType_ID = @AttributeDataType_Link  
            AND att.AttributeType_ID = @AttributeType_FreeForm  
            AND LEN(ISNULL(ws.AttributeValue, N'')) > 0  
            AND ISNULL(mdq.IsLink(ws.AttributeValue), 1) = 0  
            AND ws.ErrorCode IS NULL;  
  
    END; -- IF @ValidateDataTypes  
  
    ----------------------------------------------------------------------------------------  
    -- Lookup DBA member IDs  
    ----------------------------------------------------------------------------------------  
    IF @HasDba = 1  
    BEGIN  
        IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Get Dba Ids.'  
  
        SET @SQL = @TruncationGuard + N'  
            UPDATE ws  
            SET AttributeValueMapped = dba.ID  
            FROM #MemberAttributeWorkingSet ws  
            INNER JOIN #AttributeDefinition AS att  
            ON      ws.AttributeID = att.AttributeID  
                AND att.Dba_Entity_ID > 0  
            LEFT JOIN (' + @TableColumnsUpdateDbaIdsDefn + N') dba  
            ON      ws.AttributeValue = dba.Code  
                AND ws.AttributeID = dba.AttributeID  
            WHERE ws.ErrorCode IS NULL;  
        ';  
        --IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT @SQL;  
        EXEC sp_executesql @SQL, N'@Version_ID INT', @Version_ID;  
  
        ---------------------------------------------------------------------------------------------------------------------  
        -- Get the ids of all attribute working set rows that are changing the value of a self-referencing DBA to a new member  
        -- that is being created in this sproc call. These rows will need to have their AttributeValueMapped column set to the  
        -- ID of the newly-created member after the members are created and before the attribute values are set.  
        ---------------------------------------------------------------------------------------------------------------------  
        CREATE TABLE #DbaReferencesToNewMembers  
        (  
             AttributeRowID     INT PRIMARY KEY  
            ,ChildMemberRowID   INT  
            ,ParentMemberRowID  INT  
        );  
        CREATE INDEX #ix_DbaReferencesToNewMembers_ChildMemberRowID ON #DbaReferencesToNewMembers(ChildMemberRowID);  
        CREATE INDEX #ix_DbaReferencesToNewMembers_ParentMemberRowID ON #DbaReferencesToNewMembers(ParentMemberRowID);  
        IF (@MemberType_ID = @MemberType_Leaf) -- Only leaf members can be DBA values.  
        BEGIN  
            WITH childMembersCte AS -- This references all DBA rows that references a member of the same entity, where the referenced member doesn't (yet) exist.  
            (  
                SELECT  
                     ws.Row_ID          AS AttributeRowID  
                    ,ws.MemberRowID  
                    ,ws.AttributeValue  AS NewParentCode  
                FROM #MemberAttributeWorkingSet ws  
                INNER JOIN #AttributeDefinition att     -- Only look at self-referencing DBA value assignments  
                ON      ws.AttributeID = att.AttributeID  
                    AND att.Dba_Entity_ID = @Entity_ID  
                WHERE   ws.ErrorCode IS NULL -- Exclude rows that have already been tagged with an error.  
                    AND ws.AttributeValue IS NOT NULL -- Exclude rows that change the attribute value to null.  
                    AND ws.AttributeValueMapped IS NULL -- Exclude rows that reference an existing member.  
            )  
            INSERT INTO #DbaReferencesToNewMembers  
            (  
                 AttributeRowID  
                ,ChildMemberRowID  
                ,ParentMemberRowID -- Note that if this column is null, then the DBA references an invalid member.  
            )  
            SELECT  
                 child.AttributeRowID  
                ,child.MemberRowID  
                ,parent.Row_ID  
            FROM childMembersCte child  
            LEFT JOIN #MembersWorkingSet parent  
            ON      child.NewParentCode = parent.MemberCode  
                AND parent.ErrorCode IS NULL;  
        END;  
  
  
        --Flag any invalid Dba values  
        UPDATE ws  
        SET  ws.ErrorCode = @ErrorCode_InvalidAttributeValueForMember  
            ,ws.ErrorObjectType = @ObjectType_MemberAttribute  
        FROM #MemberAttributeWorkingSet ws  
        LEFT JOIN #DbaReferencesToNewMembers selfRef  
        ON ws.Row_ID = selfRef.AttributeRowID  
        WHERE   ws.AttributeValue IS NOT NULL  
            AND ws.AttributeValueMapped IS NULL  
            AND ws.ErrorCode IS NULL  
            -- Don't add an error if the DBA references a member being created in this  sproc call  
            AND selfRef.ParentMemberRowID IS NULL -- If null, then the DBA does not reference a new member about to be created.  
  
        -- Prune self-referencing DBA rows that reference an invalid member.  
        DELETE FROM #DbaReferencesToNewMembers WHERE ParentMemberRowID IS NULL;  
  
        --Check DBA Member Permissions.  Mark any members the user doesn't have permission to.  
        IF @ModelPermission != @Permission_Admin  
        BEGIN  
            DECLARE @DbaTempTable TABLE  
            (  
                 RowNumber INT IDENTITY (1, 1) PRIMARY KEY CLUSTERED NOT NULL  
                ,Dba_Entity_ID INT NOT NULL  
            );  
  
            --Get the distinct list of Dba Entities.  
            INSERT INTO @DbaTempTable  
            SELECT DISTINCT att.Dba_Entity_ID  
            FROM #MemberAttributeWorkingSet ws  
            INNER JOIN #AttributeDefinition att  
            ON      att.AttributeID = ws.AttributeID  
                AND att.Dba_Entity_ID > 0  
            WHERE ws.ErrorCode IS NULL;  
  
            DECLARE  
                 @DbaEntityID INT  
                ,@DbaUseMemberSecurity INT  
                ,@Counter INT = 1  
                ,@MaxCounter INT = (SELECT MAX(RowNumber) FROM @DbaTempTable);  
  
            --Loop through each Dba Entity checking the user's permissions to the Dba members.  
            WHILE @Counter <= @MaxCounter  
            BEGIN  
                SELECT @DbaEntityID = Dba_Entity_ID FROM @DbaTempTable WHERE [RowNumber] = @Counter ;  
  
                SET @DbaUseMemberSecurity = 0;  
                IF @ModelPermission != @Permission_Admin  
                BEGIN  
                    SET @DbaUseMemberSecurity = mdm.udfUseMemberSecurity (@User_ID, @DbaEntityID, @Version_ID, @MemberType_Leaf);  
                END  
  
                --Check DBA Member Permissions.  Mark any members the user doesn't have permission to.  
                IF @DbaUseMemberSecurity = 1  
                BEGIN  
  
                    DELETE FROM @MemberIds;  
                    INSERT INTO @MemberIds (ID, MemberType_ID)  
                    SELECT DISTINCT  
                         CONVERT(INT, ws.AttributeValueMapped) --Contains the Dba Member ID.  
                        ,@MemberType_ID  
                    FROM #MemberAttributeWorkingSet ws  
                    INNER JOIN #AttributeDefinition att  
                    ON      att.AttributeID = ws.AttributeID  
                        AND att.Dba_Entity_ID = @DbaEntityID  
                    WHERE   ws.AttributeValueMapped IS NOT NULL  
                        AND ws.ErrorCode IS NULL;  
  
                    --Get member permissions  
                    DELETE FROM @MemberPermissions;  
                    INSERT INTO @MemberPermissions  
                    EXEC mdm.udpSecurityMembersResolverGet @User_ID, @Version_ID, @DbaEntityID, @MemberIds  
  
                    --Mark any member attribute values that don't have permissions  
                    UPDATE ws  
                    SET ErrorCode = @ErrorCode_NoPermissionForThisOperationOnThisObject,  
                        ErrorObjectType = @ObjectType_MemberCode  
                    FROM #MemberAttributeWorkingSet ws  
                    INNER JOIN #AttributeDefinition att  
                    ON ws.AttributeID = att.AttributeID  
                    LEFT JOIN @MemberPermissions prm  
                    ON ws.AttributeValueMapped = CONVERT(NVARCHAR, prm.ID) -- Convert to NVARCHAR avoids potential errors from the AttributeValueMapped column being implicitly converted to INT  
                    WHERE   att.Dba_Entity_ID = @DbaEntityID  
                        AND ISNULL(prm.Privilege_ID, @Permission_Deny) = @Permission_Deny  
                        AND ws.AttributeValueMapped IS NOT NULL -- don't add errors for rows that change the DBA to null  
                        AND ws.ErrorCode IS NULL;  
                END;  
                SET @Counter += 1;  
            END;  
        END;  
    END; -- IF @HasDba  
  
    ----------------------------------------------------------------------------------------------  
    --Check for any attribute value changes for the Code attribute.  Requires special handling.  
    ----------------------------------------------------------------------------------------------  
    IF EXISTS(SELECT 1 FROM #MemberAttributeWorkingSet WHERE AttributeID = @AttributeID_Code AND ErrorCode IS NULL)  
    BEGIN  
        ----------------------------------------------------------------------------------------  
        -- Check for empty Codes.  
        ----------------------------------------------------------------------------------------  
        IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Check for empty Codes.';  
        UPDATE #MemberAttributeWorkingSet  
        SET  ErrorCode = @ErrorCode_InvalidBlankMemberCode  
            ,ErrorObjectType = @ObjectType_MemberAttribute  
        WHERE   AttributeID = @AttributeID_Code  
            AND NULLIF(AttributeValue, N'') IS NULL  
            AND ErrorCode IS NULL;  
  
        ----------------------------------------------------------------------------------------  
        -- Check for reserved words in the MemberCode.  
        ----------------------------------------------------------------------------------------  
        IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Check for reserved words in the MemberCode.';  
        UPDATE ws  
        SET  ErrorCode = @ErrorCode_ReservedWord  
            ,ErrorObjectType = @ObjectType_MemberAttribute  
        FROM #MemberAttributeWorkingSet ws  
        INNER JOIN mdm.udfItemReservedWordsGet(12/*Leaf member*/) rw  
            ON UPPER(ws.AttributeValue) = UPPER(rw.ReservedWord)  
        WHERE   ws.AttributeID = @AttributeID_Code  
            AND ws.ErrorCode IS NULL;  
  
        ----------------------------------------------------------------------------------------  
        -- Check for duplicate MemberCodes values in the working set.  
        ----------------------------------------------------------------------------------------  
        IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Check for duplicate MemberCodes values in the working set.';  
        WITH duplicateCodes AS  
        (  
            SELECT AttributeValue AS MemberCode  
            FROM #MemberAttributeWorkingSet  
            WHERE   AttributeID = @AttributeID_Code  
                AND ErrorCode IS NULL  
            GROUP BY AttributeValue  
            HAVING COUNT(*) > 1  
        )  
        UPDATE ws  
        SET  ErrorCode = @ErrorCode_DuplicateInputMemberCodes  
            ,ErrorObjectType = @ObjectType_MemberAttribute  
        FROM #MemberAttributeWorkingSet AS ws  
        INNER JOIN duplicateCodes AS dup  
        ON ws.AttributeValue = dup.MemberCode  
        WHERE   ws.AttributeID = @AttributeID_Code  
            AND ws.ErrorCode IS NULL;  
  
        ----------------------------------------------------------------------------------------  
        -- Check for conflicts with existing MemberCodes.  
        ----------------------------------------------------------------------------------------  
        IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Check for conflicts with existing MemberCodes.'  
        -- TODO: Consider refactoring to support the scenario of swapping the codes of two existing members within the same call (should be allowed, but the check as written will fail it)  
        SET @SQL = @ExistingCodesCteSQL + N'  
            ,oldAndNewCodesCte AS  
            (  
                SELECT  
                     Code  
                    ,MUID  
                FROM existingCodesCte  
                WHERE Status_ID = 1 -- Only look at the codes of active members (reuse of soft-deleted member codes is allowed). DO NOT replace this hardcoded number with a var. It would be bad for perf.  
  
                UNION -- not UNION ALL because deduplication is needed  
  
                SELECT -- Joining with the new members prevents a constraint violation when a merge operation creates a new member and tries to update an existing member''s code to the same value as the new member.  
                     MemberCode AS Code  
                    ,MemberMUID AS MUID  
                FROM #MembersWorkingSet  
                WHERE ErrorCode IS NULL  
            )  
            UPDATE ws  
            SET  ErrorCode = @ErrorCode_MemberCodeExists  
                ,ErrorObjectType = @ObjectType_MemberAttribute  
            FROM #MemberAttributeWorkingSet AS ws  
            INNER JOIN oldAndNewCodesCte c  
            ON ws.AttributeValue = c.Code  
            INNER JOIN #MembersWorkingSet mws  
            ON ws.MemberRowID = mws.Row_ID  
            WHERE   ws.AttributeID = @AttributeID_Code  
                AND (mws.MemberMUID IS NULL OR c.MUID <> mws.MemberMUID) -- Changing a member''s code to the same value is a no-op, not an error.  
                AND ws.ErrorCode IS NULL;  
            ';  
        EXEC sp_executesql @SQL,  
          N'@Version_ID INT, @ErrorCode_MemberCodeExists INT, @ObjectType_MemberAttribute INT,  @AttributeID_Code INT',  
            @Version_ID,     @ErrorCode_MemberCodeExists,     @ObjectType_MemberAttribute,      @AttributeID_Code;  
  
    END; --Code special handling  
  
    ----------------------------------------------------------------------------------------  
    -- Map any NULL attribute values to the special value.  
    ----------------------------------------------------------------------------------------  
    IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Map any NULL attribute values to the special value.'  
    UPDATE ws  
    SET AttributeValueMapped = m.SysNullValue  
    FROM #MemberAttributeWorkingSet AS ws  
    INNER JOIN #AttributeDefinition AS att  
    ON      ws.AttributeID = att.AttributeID  
        AND ws.AttributeValue IS NULL  
    INNER JOIN #SysNullDataTypeMap m  
    ON      att.AttributeType_ID = m.AtributeType_ID  
        AND att.DataType_ID = m.DataType_ID  
  
    ----------------------------------------------------------------------------------------  
    --Get current attribute values prior to update  
    ----------------------------------------------------------------------------------------  
    DECLARE @LookupPriorValues BIT = 0;  
    IF      @SaveMode <> @SaveMode_Create -- Don't bother looking up prior values when creating new members (the prior values will always be null)  
        AND NULLIF(@AttributeIdList, N'') IS NOT NULL  
    BEGIN  
        IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Get current attribute values prior to update.'  
        SET @LookupPriorValues = 1;  
  
        DECLARE @LookupPriorDBACodes BIT = CASE WHEN @TransactionLogType = @TransactionLogType_Attribute AND @HasDba = 1 AND @Changeset_ID IS NULL THEN 1 ELSE 0 END-- Don't need to bother joining with the domain entity tables to lookup member codes unless attribute transaction logging is being used  
  
        SET @SQL = CONCAT(@TruncationGuard, N'  
        WITH changingMembersCte AS -- The IDs of all existing members being changed.  
        (  
            SELECT DISTINCT  
                 mws.Row_ID MemberRowID  
                ,mws.MemberID  
            FROM #MembersWorkingSet mws  
            INNER JOIN #MemberAttributeWorkingSet aws  
            ON mws.Row_ID = aws.MemberRowID  
            WHERE   mws.MemberID IS NOT NULL -- Exclude new members, which will have a null MemberID at this point.  
                AND aws.ErrorCode IS NULL  
        )  
        ,currentValuesCte AS -- The current attribute values that may be about to change.  
        (  
            SELECT  
                 cm.MemberRowID', CASE WHEN @LookupPriorDBACodes = 1   
                                        THEN @ViewColumnsUnPivotDefn -- lookup in the view to get domain member Codes  
                                        ELSE @TableColumnsUnPivotDefn   
                                        END, N'  
            FROM mdm.', CASE WHEN @LookupPriorDBACodes = 1   
                                THEN @MemberViewName -- lookup in the view to get domain member Codes  
                                ELSE @MemberTableName  
                                END, N' AS m  
            INNER JOIN changingMembersCte cm  
            ON      m.Version_ID = @Version_ID  
                AND m.ID = cm.MemberID  
        )  
        ,', CASE WHEN @LookupPriorDBACodes = 1  
                THEN N'priorNonDBACte'  
                ELSE N'priorPivotCte' END, N' AS  
        (  
            SELECT  
                 MemberRowID  
                ,AttributeID  
                ,AttributeValue  
            FROM currentValuesCte  
            UNPIVOT   
            (AttributeValue FOR AttributeID IN (', @AttributeIdList, N')) AS up  
        )', CASE WHEN @LookupPriorDBACodes = 1  
                THEN CONCAT(N'  
        ,priorDBACodeCte AS  
        (  
            SELECT  
                 MemberRowID  
                ,SUBSTRING(Attribute_ID_Code, 1, CHARINDEX(N''_'', Attribute_ID_Code, 1) - 1) AttributeID  
                ,DBACode  
            FROM currentValuesCte  
            UNPIVOT   
            (DBACode FOR Attribute_ID_Code IN (', @AttributeIdListWithDBACode, N')) AS up  
        )  
        ,priorPivotCte AS  
        (  
            SELECT   
                 p.MemberRowID  
                ,p.AttributeID  
                ,p.AttributeValue  
                ,dba.DBACode  
            FROM priorNonDBACte p  
            LEFT JOIN priorDBACodeCte dba  
            ON      p.MemberRowID = dba.MemberRowID  
                AND p.AttributeID = dba.AttributeID  
        )') END, N'  
        UPDATE ws  
        SET  PriorValue = CASE att.AttributeType_ID  
                WHEN @AttributeType_DBA THEN ', CASE WHEN @LookupPriorDBACodes = 1 THEN N'prior.DBACode' ELSE N'NULL' END, N'  
                ELSE prior.AttributeValue END   
            ,PriorValueMapped = prior.AttributeValue -- Only set this column for non-file attributes  
            ,PriorFileId = CASE att.AttributeType_ID  
                WHEN @AttributeType_File THEN prior.AttributeValue -- Only set this column for file attributes  
                ELSE PriorFileId END  
        FROM #MemberAttributeWorkingSet AS ws  
        INNER JOIN priorPivotCte prior  
        ON      ws.MemberRowID = prior.MemberRowID  
            AND ws.AttributeID = prior.AttributeID  
        COLLATE DATABASE_DEFAULT  
        INNER JOIN #AttributeDefinition att  
        ON ws.AttributeID = att.AttributeID  
        ');  
  
        --IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT @SQL;  
        EXEC sp_executesql @SQL, N'@Version_ID INT, @AttributeType_DBA INT, @AttributeType_File INT', @Version_ID, @AttributeType_DBA, @AttributeType_File;  
    END  
  
    --------------------------------------------------  
    -- Determine whether the attribute has changed.  
    --------------------------------------------------  
    IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Determine whether the attribute has changed.'  
  
    IF @SaveMode = @SaveMode_Create  
    BEGIN  
        -- Set the change tracking mask (IsChanged was previously set).  
        UPDATE aws  
        SET ChangeTrackingMask = COALESCE(POWER(2, att.ChangeTrackingGroup_ID - 1), 0)  
        FROM #MemberAttributeWorkingSet aws  
        INNER JOIN #AttributeDefinition att  
        ON aws.AttributeID = att.AttributeID  
        WHERE   aws.ErrorCode IS NULL  
            AND ISNULL(att.ChangeTrackingGroup_ID, 0) > 0;  
    END  
    ELSE  
    BEGIN  
        UPDATE aws  
        SET IsChanged =  
            CASE  
                WHEN mws.MemberID IS NULL OR mws.MemberID = 0 THEN 1-- When creating new members (the member ID won't be set yet), then assume the value has changed.  
                WHEN CASE att.AttributeType_ID  
                        WHEN @AttributeType_DBA THEN COALESCE(  
                                NULLIF(NULLIF(aws.AttributeValueMapped, 0), aws.PriorValueMapped)  
                            ,NULLIF(aws.PriorValueMapped, NULLIF(aws.AttributeValueMapped, 0))  
                            ,CASE WHEN NULLIF(aws.AttributeValueMapped, 0) IS NULL THEN aws.AttributeValue ELSE NULL END) -- If the DBA references a new member, then mark it as changed  
                        ELSE COALESCE(NULLIF(aws.AttributeValue, aws.PriorValue), NULLIF(aws.PriorValue, aws.AttributeValue)) END IS NOT NULL  
                    THEN 1  
                ELSE 0 END  
            ,ChangeTrackingMask = COALESCE(POWER(2, att.ChangeTrackingGroup_ID - 1), 0)  
        FROM #MemberAttributeWorkingSet aws  
        INNER JOIN #AttributeDefinition att  
        ON aws.AttributeID = att.AttributeID  
        INNER JOIN #MembersWorkingSet mws  
        ON aws.MemberRowID = mws.Row_ID  
        WHERE aws.ErrorCode IS NULL;  
  
        IF @Changeset_ID IS NULL  
        BEGIN  
            IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Remove unchanged attribute values from #MemberAttributeWorkingSet'  
            DELETE FROM #MemberAttributeWorkingSet WHERE IsChanged = 0;  
        END  
    END  
  
    ---------------------------------------------------------------------------------  
    -- Check for circular relationships in recursive derived hierarchies.  
    ---------------------------------------------------------------------------------  
    IF @HasDba = 1  
    BEGIN  
        /*  
            The hierarchy creation logic checks to make sure that a circular relationship does not exist when adding a recursive level. So,  
            the current state of the hierarchy should be free of circular relationships. The below algorithm is optimized for this. However,  
            in the unlikely event that a circular relationship somehow did get through validation checking and into the data, the below algorithm  
            will still work (it will return the correct result without crashing or getting into an infinite loop or recursion).  
        */  
        ---------------------------------------------------------------------------------  
        -- Determine if an attribute is changing that would impact member placement within any recursive derived hierarchies.  
        ---------------------------------------------------------------------------------  
        IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Determine if the entity participates in any recursive derived hierarchies.'  
        DECLARE @RecursiveDerivedHierarchyInfo TABLE  
        (  
             Row_ID              INT IDENTITY(1,1) PRIMARY KEY  
            ,AttributeID         INT  
            ,AttributeColumnName SYSNAME COLLATE DATABASE_DEFAULT  
        );  
        INSERT INTO @RecursiveDerivedHierarchyInfo (AttributeID, AttributeColumnName)  
        SELECT DISTINCT  
             att.AttributeID  
            ,att.TableColumn  
        FROM  #AttributeDefinition att  
        INNER JOIN mdm.tblDerivedHierarchyDetail d  
        ON      att.AttributeID = d.Foreign_ID  
            AND d.ForeignType_ID = 1 -- Attribute  
        WHERE att.Dba_Entity_ID = @Entity_ID -- If the attribute's entity is the same as its domain entity, then a recursive derived hierarchy is being changed.  
  
        IF EXISTS (SELECT 1 FROM @RecursiveDerivedHierarchyInfo)  
        BEGIN  
            IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Checking for circular relationships in recursive derived hierarchies.';  
  
            SELECT  
                 @Counter = 1  
                ,@MaxCounter = MAX(Row_ID)  
            FROM @RecursiveDerivedHierarchyInfo  
  
            DECLARE  
                 @RecursiveHierarchyAttribute_ID        INT  
                ,@RecursiveHierarchyAttributeColumnName SYSNAME;  
  
            -- Create a temp table for holding new parent (DBA value) assignments.  
            CREATE TABLE #NewParentAssignments  
            (  
                 WorkingSetRow_ID   INT PRIMARY KEY  
                ,ChildID            INT UNIQUE  
                ,NewParentID        INT  
            )  
            CREATE NONCLUSTERED INDEX #ix_NewParentAssignments_NewParentID ON #NewParentAssignments(NewParentID);  
  
            -- Create a temp table for holding combined (old updated with new) parent assignments.  
            CREATE TABLE #CombinedParentAssignments  
            (  
                 ChildID  INT PRIMARY KEY  
                ,ParentID INT  
            );  
            CREATE NONCLUSTERED INDEX #ix_CombinedParentAssignments_ParentID ON #CombinedParentAssignments(ParentID);  
  
            -- Loop through each recursive derived hierarchy.  
            WHILE @Counter <= @MaxCounter  
            BEGIN  
                -- Get hierarchy info.  
                SELECT  
                     @RecursiveHierarchyAttribute_ID = AttributeID  
                    ,@RecursiveHierarchyAttributeColumnName = AttributeColumnName  
                FROM @RecursiveDerivedHierarchyInfo  
                WHERE Row_ID = @Counter;  
  
                -- Get new parent assignments  
                DELETE FROM #NewParentAssignments;  
                INSERT INTO #NewParentAssignments  
                SELECT  
                     ws.Row_ID AS WorkingSetRow_ID  
                    --,mws.MemberCode AS ChildCode  
                     ,COALESCE(mws.MemberID, -mws.Row_ID) AS ChildID -- -- If the child doesn't already exist (is being created in this sproc call), then use the negative Row_ID as a pseudo-member ID. Negative, so that it doesn't conflict with existing member IDs.  
                    --,ws.AttributeValue AS NewParentCode  
                     ,COALESCE(ws.AttributeValueMapped, -newMem.ParentMemberRowID) AS NewParentID -- If the new parent doesn't already exist (is being created in this sproc call), then use the negative Row_ID as a pseudo-member ID. Negative, so that it doesn't conflict with existing member IDs.  
                FROM #MemberAttributeWorkingSet ws  
                INNER JOIN #MembersWorkingSet mws  
                ON ws.MemberRowID = mws.Row_ID  
  
                LEFT JOIN #DbaReferencesToNewMembers newMem  
                ON ws.Row_ID = newMem.AttributeRowID  
  
                WHERE   ws.ErrorCode IS NULL  
                    AND ws.AttributeID = @RecursiveHierarchyAttribute_ID;  
  
                -- Combined the new parent (DBA value) assignments with the old.  
                DELETE FROM #CombinedParentAssignments;  
                SET @SQL = @TruncationGuard + N'  
                -- Get existing parent assignments from the table.  
                WITH existingParentAssignmentsCte AS  
                (  
                    SELECT DISTINCT  
                         ID AS ChildID  
                        ,' + @RecursiveHierarchyAttributeColumnName + N' AS OldParentID  
                    FROM mdm.' + @MemberTableName + N'  
                    WHERE Version_ID = @Version_ID  
                )  
  
                -- Combine the new and old parent assignments.  
                ,combinedParentAssignmentsCte AS  
                (  
                    SELECT  
                         COALESCE(new.ChildID, old.ChildID) AS ChildID  
  
                         -- The new parent assignment (if provided) takes precedence over the old. Cannot use COALESCE here because the new parent might be NULL.  
                        ,CASE WHEN new.ChildID IS NULL THEN old.OldParentID ELSE new.NewParentID END AS ParentID  
                    FROM #NewParentAssignments new  
                    FULL JOIN existingParentAssignmentsCte old  
                    ON new.ChildID = old.ChildID  
                )  
                INSERT INTO #CombinedParentAssignments  
                SELECT  
                     ChildID  
                    ,ParentID  
                FROM combinedParentAssignmentsCte  
                WHERE ParentID IS NOT NULL; -- Exclude NULL parents for efficiency, since they cannot be part of a circular relationship.  
                ';  
                --IF @Debug = 1 PRINT @SQL  
                EXEC sp_executesql @SQL, N'@Version_ID INT, @Entity_ID INT', @Version_ID, @Entity_ID;  
  
                -- Recursively find all new ancestors of the members being moved, checking for circular relationships.  
                WITH ancestorsCte AS  
                (  
                    -- Start with only those members whose pending DBA value changes would move them to a  
                    -- different parent (and potentially cause a circular relationship).  
                    SELECT  
                         WorkingSetRow_ID  
                        ,ChildID AS MemberID  
                        ,NewParentID AS AncestorID  
                        ,0 AS RecursionLevel  
                        ,CASE WHEN ChildID = NewParentID THEN 1 ELSE 0 END AS IsCircular -- If a member is its own parent, then it is part of a circular relationship.  
                    FROM #NewParentAssignments  
  
                    UNION ALL  
  
                    -- Recursively find all new ancestors of the members being moved.  
                    SELECT  
                         cte.WorkingSetRow_ID  
                        ,cte.MemberID  
                        ,p.ParentID AS AncestorID  
                        ,cte.RecursionLevel + 1  
                        ,CASE WHEN cte.MemberID = p.ParentID THEN 1 ELSE 0 END AS IsCircular -- If a member is its own ancestor, then it is part of a circular relationship.  
                    FROM ancestorsCte cte  
                    INNER JOIN #CombinedParentAssignments p  
                    ON cte.AncestorID = p.ChildID  
                    WHERE   cte.RecursionLevel < 99 -- Protects against "The statement terminated. The maximum recursion 100 has been exhausted before statement completion" error.  
                        AND cte.IsCircular = 0 -- Stop when a circular relationship is found.  
                )  
  
                -- Get the IDs of the working set rows that would cause circular relationships.  
                ,circularRelationshipsCte AS  
                (  
                    SELECT DISTINCT WorkingSetRow_ID  
                    FROM ancestorsCte  
                    WHERE IsCircular = 1  
                )  
  
                -- Add errors for any circular relationships found.  
                UPDATE ws  
                SET  ErrorCode = @ErrorCode_MemberCausesCircularReference  
                    ,ErrorObjectType = @ObjectType_MemberAttribute  
                FROM #MemberAttributeWorkingSet ws  
                INNER JOIN circularRelationshipsCte cte  
                ON ws.Row_ID = cte.WorkingSetRow_ID;  
  
                SET @Counter += 1;  
            END; -- WHILE  
        END; -- IF recursive hierarchy exists  
    END; -- IF @HasDba  
  
  
    -------------------------------------------------------------------------------------------  
    -- Conflict  
    -- Check if the attribute value changed from the requested revision  
    -- If the transaction log type is attribute or none, returns conflict error if the member has be changed.  
    -- If the transaction log type is member, check if updating attribute value has be changed.  
    -------------------------------------------------------------------------------------------  
    IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Determine whether the attribute has change conflict.'  
    IF @SaveMode <> @SaveMode_Create  
       AND @Changeset_ID IS NULL -- Skip merge conflicts for pending changes  
       AND NULLIF(@AttributeIdList, N'') IS NOT NULL  
       AND EXISTS (SELECT 1 FROM #MembersWorkingSet WHERE RevisionID IS NOT NULL)  
    BEGIN  
        IF @HistoryTableName IS NULL  
        BEGIN  
            SET @SQL = CONCAT(N'  
            WITH changedMembers AS -- The IDs of all existing members were changed  
            (  
                SELECT DISTINCT  
                     mws.Row_ID MemberRowID  
                FROM #MembersWorkingSet mws  
                INNER JOIN mdm.', @MemberTableName, N' m  
                ON m.ID = mws.MemberID AND m.Version_ID = @Version_ID  
                WHERE mws.RevisionID IS NOT NULL AND mws.RevisionID <> m.LastChgTS  
            )  
            UPDATE ws  
            SET  ErrorCode = ', @ErrorCode_MemberMergeConflict, N'  
                ,ErrorObjectType = ', @ObjectType_MemberAttribute, N'  
            FROM #MemberAttributeWorkingSet AS ws  
            INNER JOIN changedMembers cm  
            ON      ws.MemberRowID = cm.MemberRowID');  
  
            --IF @Debug = 1 PRINT @SQL;  
            EXEC sp_executesql @SQL, N'@Version_ID INT', @Version_ID;  
        END  
        ELSE  
        BEGIN  
            SET @SQL = CONCAT(N'  
            WITH changedMembers AS -- The IDs of all existing members were changed  
            (  
                SELECT  
                     mws.Row_ID MemberRowID  
                     ,mws.MemberID MemberID  
                     ,mws.RevisionID RevisionID  
                FROM #MembersWorkingSet mws  
                INNER JOIN mdm.', @MemberTableName, N' m  
                ON m.ID = mws.MemberID AND m.Version_ID = @Version_ID  
                WHERE mws.RevisionID IS NOT NULL AND mws.RevisionID <> m.LastChgTS  
            )  
            ,currentValuesCte AS -- The current attribute values of the changed member  
            (  
                SELECT  
                     cm.MemberRowID', @TableColumnsUnPivotDefn, N'  
                FROM mdm.' + @MemberTableName + N' AS m  
                INNER JOIN changedMembers cm  
                ON m.ID = cm.MemberID AND m.Version_ID = @Version_ID  
            )  
            ,currentValues AS  
            (  
                SELECT  
                     MemberRowID  
                    ,up.AttributeID  
                    ,up.AttributeValue  
                FROM currentValuesCte  
                UNPIVOT  
                (AttributeValue FOR AttributeID IN (', @AttributeIdList, N')) AS up  
            )  
            ,originalValuesCte AS -- The original attribute values of the changed member  
            (  
                SELECT  
                    cm.MemberRowID', @TableColumnsUnPivotDefn, N'  
                    ,ROW_NUMBER() OVER(  
                        PARTITION BY cm.MemberID  
                        ORDER BY hs.ID DESC) AS rank  
                FROM mdm.', @HistoryTableName, N' AS hs  
                INNER JOIN changedMembers cm  
                ON hs.', @MemberIDColumn, ' = cm.MemberID AND hs.Version_ID = @Version_ID AND hs.ID >= cm.RevisionID  
            )  
            ,originalValues AS  
            (  
                SELECT  
                     MemberRowID  
                    ,up.AttributeID  
                    ,up.AttributeValue  
                FROM (SELECT * FROM originalValuesCte WHERE rank = 1) o  
                UNPIVOT  
                (AttributeValue FOR AttributeID IN (', @AttributeIdList, N')) AS up  
            )  
            UPDATE ws  
            SET  ErrorCode = ', @ErrorCode_AttributeMergeConflict, N'  
                ,ErrorObjectType = ', @ObjectType_MemberAttribute, N'  
            FROM #MemberAttributeWorkingSet AS ws  
            INNER JOIN currentValues c  
            ON ws.MemberRowID = c.MemberRowID AND ws.AttributeID = c.AttributeID  
            INNER JOIN originalValues o  
            ON ws.MemberRowID = o.MemberRowID AND ws.AttributeID = o.AttributeID  
            WHERE c.AttributeValue <> o.AttributeValue');  
  
            --IF @Debug = 1 PRINT @SQL;  
            EXEC sp_executesql @SQL, N'@Version_ID INT', @Version_ID;  
        END  
    END  
  
  
    -- Check for attribute filter value inconsistencies. This check should be done after all other attribute checks, because of dependencies that cross attribute changes (i.e. attribute A filters B filters C ...)  
    IF @HasDba = 1 AND @MemberType_ID = @MemberType_Leaf -- filters are only supported for leaf members  
    BEGIN  
        -- Get relationships between all attributes that participate in filters, either as parent or child  
        CREATE TABLE #AttributeFilter  
        (  
             ChildAttribute_ID                  INT PRIMARY KEY  
            ,ChildColumnName                    SYSNAME COLLATE DATABASE_DEFAULT  
            ,ParentAttribute_ID                 INT NOT NULL  
            ,FilterParentColumnName             SYSNAME COLLATE DATABASE_DEFAULT  
            ,FilterHierarchyEntityTableName     SYSNAME COLLATE DATABASE_DEFAULT  
            ,FilterHierarchyParentColumName     SYSNAME COLLATE DATABASE_DEFAULT  
            ,FilterHierarchyM2MChildColumnName  SYSNAME COLLATE DATABASE_DEFAULT NULL  
        )  
        INSERT INTO #AttributeFilter  
        SELECT  
             a.ID                               AS ChildAttribute_ID  
            ,a.TableColumn                      AS ChildColumnName  
            ,a.FilterParentAttribute_ID         AS ParentAttribute_ID  
            ,parentAttribute.TableColumn        AS FilterParentColumnName  
            ,levelEntity.EntityTable            AS FilterHierarchyEntityTableName  
            ,levelParentAttribute.TableColumn   AS FilterHierarchyParentColumName  
            ,m2mChildAttribute.TableColumn      AS FilterHierarchyM2MChildColumnName  
        FROM mdm.tblAttribute a  
        LEFT JOIN #AttributeDefinition adChild -- JOIN to see if the child attribute is being changed  
        ON a.ID = adChild.AttributeID  
        LEFT JOIN #AttributeDefinition adParent -- JOIN to see if the parent attribute is being changed  
        ON a.FilterParentAttribute_ID = adParent.AttributeID  
        INNER JOIN mdm.tblAttribute parentAttribute  
        ON a.FilterParentAttribute_ID = parentAttribute.ID  
        INNER JOIN mdm.tblDerivedHierarchyDetail filterLevel  
        ON a.FilterHierarchyDetail_ID = filterLevel.ID  
        INNER JOIN mdm.tblAttribute levelParentAttribute  
        ON filterLevel.Foreign_ID = levelParentAttribute.ID  
        INNER JOIN mdm.tblEntity levelEntity  
        ON levelParentAttribute.Entity_ID = levelEntity.ID  
        LEFT JOIN mdm.tblAttribute m2mChildAttribute  
        ON filterLevel.ManyToManyChildAttribute_ID = m2mChildAttribute.ID  
        WHERE   a.Entity_ID = @Entity_ID  
            AND a.MemberType_ID = @MemberType_ID  
            AND ISNULL(adChild.AttributeID, adParent.AttributeID) IS NOT NULL -- ignore filters where neither the parent nor the child values are being changed in this operation  
  
        CREATE TABLE #FilterError  
        (  
             MemberRow_ID           INT  
            ,ChildAttributeRow_ID   INT  
            ,ParentAttributeRow_ID  INT  
        )  
        CREATE UNIQUE CLUSTERED INDEX #ix_FilterError_ChildAttributeRow_ID_ParentAttributeRow_ID ON #FilterError(ChildAttributeRow_ID, ParentAttributeRow_ID)  
  
        SET @SQL = N'';  
        SELECT @SQL += CONCAT(@TruncationGuard, CASE WHEN @SQL = N'' THEN N'  
INSERT INTO #FilterError  
' ELSE N'  
UNION ALL -- not UNION ALL because deduplication is needed' END, N'  
SELECT  
     mws.Row_ID             MemberRow_ID  
    ,newChildValue.Row_ID   ChildAttributeRow_ID  
    ,newParentValue.Row_ID  ParentAttributeRow_ID  
FROM #MembersWorkingSet mws', CASE WHEN @SaveMode <> @SaveMode_Create THEN CONCAT(N'  
LEFT JOIN mdm.', QUOTENAME(@MemberTableName), N' en -- Join with entity table to get current values (LEFT JOIN, because the member might not already exist)  
ON      @Version_ID = en.Version_ID  
    AND mws.MemberID = en.ID') END, N'  
LEFT JOIN #MemberAttributeWorkingSet newChildValue -- LEFT, rather than INNER, JOIN because not all attribute values may be specified  
ON      mws.Row_ID = newChildValue.MemberRowID  
    AND newChildValue.AttributeID = ', ChildAttribute_ID, N'  
    AND newChildValue.ErrorCode IS NULL -- ignore new child values that already have an error  
LEFT JOIN #MemberAttributeWorkingSet newParentValue -- LEFT, rather than INNER, JOIN because not all attribute values may be specified  
ON      mws.Row_ID = newParentValue.MemberRowID  
    AND newParentValue.AttributeID = ', ParentAttribute_ID, N'  
    AND newParentValue.ErrorCode IS NULL -- ignore new parent values that already have an error  
LEFT JOIN mdm.', QUOTENAME(FilterHierarchyEntityTableName), N' filter-- join with filter hierarchy entity table  
ON      @Version_ID = filter.Version_ID  
    AND ', CASE WHEN @SaveMode <> @SaveMode_Create THEN N'ISNULL(' END, N'newChildValue.AttributeValueMapped', CASE WHEN @SaveMode <> @SaveMode_Create THEN CONCAT(N', en.', QUOTENAME(ChildColumnName), N')') END, N' = filter.', QUOTENAME(COALESCE(FilterHierarchyM2MChildColumnName, N'ID')), N'  
    AND ISNULL(', CASE WHEN @SaveMode <> @SaveMode_Create THEN N'ISNULL(' END, N'newParentValue.AttributeValueMapped', CASE WHEN @SaveMode <> @SaveMode_Create THEN CONCAT(N', en.', QUOTENAME(FilterParentColumnName), N')') END,  N', 0) = ISNULL(filter.', QUOTENAME(FilterHierarchyParentColumName), N', 0)  
WHERE   mws.ErrorCode IS NULL  
    AND ISNULL(newChildValue.AttributeID, newParentValue.AttributeID) IS NOT NULL -- ignore members where neither the parent nor the child is being changed  
    AND NULLIF(', CASE WHEN @SaveMode <> @SaveMode_Create THEN N'ISNULL(' END, N'newChildValue.AttributeValueMapped', CASE WHEN @SaveMode <> @SaveMode_Create THEN CONCAT(N', en.', QUOTENAME(ChildColumnName), N')') END, N', 0) IS NOT NULL -- null child values are always valid  
    AND filter.ID IS NULL  -- could not find a match in the filter table',   
    CASE WHEN FilterHierarchyM2MChildColumnName IS NOT NULL THEN CONCAT(N'  
    AND (NULLIF(', CASE WHEN @SaveMode <> @SaveMode_Create THEN N'ISNULL(' END, N'newParentValue.AttributeValueMapped', CASE WHEN @SaveMode <> @SaveMode_Create THEN CONCAT(N', en.', QUOTENAME(FilterParentColumnName), N')') END, N', 0) IS NOT NULL') END,   
    CASE WHEN FilterHierarchyM2MChildColumnName IS NOT NULL THEN CONCAT(N'-- M2M level: not finding a filter row match is okay if the parent is null  
         OR EXISTS( SELECT 1                                                -- The child is under another parent  
                    FROM mdm.', QUOTENAME(FilterHierarchyEntityTableName), N' filter  
                    WHERE   @Version_ID = filter.Version_ID    
                        AND ', CASE WHEN @SaveMode <> @SaveMode_Create THEN N'ISNULL(' END, N'newChildValue.AttributeValueMapped', CASE WHEN @SaveMode <> @SaveMode_Create THEN CONCAT(N', en.', QUOTENAME(ChildColumnName), N')') END, N' = filter.', QUOTENAME(COALESCE(FilterHierarchyM2MChildColumnName, N'ID')), N'    
                        AND filter.', QUOTENAME(FilterHierarchyParentColumName), N' IS NOT NULL))  
        ') END)    
        FROM #AttributeFilter  
  
        IF @SQL <> N''  
        BEGIN  
            IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT @SQL  
            EXEC sp_executesql @SQL, N'@Version_ID INT', @Version_ID;  
  
            UPDATE aws  
            SET  ErrorCode = @ErrorCode_AttributeValueNotCompatibleWithFilter   
                ,ErrorObjectType = @ObjectType_MemberAttribute  
            FROM #MemberAttributeWorkingSet aws  
            INNER JOIN #FilterError e  
            ON     aws.Row_ID = e.ChildAttributeRow_ID  
                OR aws.Row_ID = e.ParentAttributeRow_ID  
            WHERE aws.ErrorCode IS NULL  
  
            IF @TransactionBehavior = @TransactionBehavior_BestEffort -- Add errors for related rows, to prevent them from being saved and possibly creating data inconsistency  
            BEGIN  
                -- Get the IDs of all attributes that participate in a filter relationship, either as parent and/or child  
                DECLARE @FilterParticipant TABLE  
                (     
                    Attribute_ID INT PRIMARY KEY  
                )  
                INSERT INTO @FilterParticipant(Attribute_ID)  
                SELECT ChildAttribute_ID AS Attribute_ID FROM #AttributeFilter  
                UNION -- not "UNION ALL" because deduplication is needed  
                SELECT ParentAttribute_ID AS Attribute_ID FROM #AttributeFilter  
  
                UPDATE aws  
                SET  ErrorCode = @ErrorCode_PossiblyImpactedByIncompatibleFilteredValue -- BestEffort only: The attribute itself doesn't necessarily have an incompatible value, but because of filter chaining it is possible this value could be impacted. So to be safe, just fail it.  
                    ,ErrorObjectType = @ObjectType_MemberAttribute  
                FROM #MemberAttributeWorkingSet aws  
                INNER JOIN @FilterParticipant fp -- only set errors for attribute values changes that participate in filter relationships  
                ON aws.AttributeID = fp.Attribute_ID   
                INNER JOIN #FilterError e  
                ON aws.MemberRowID = e.MemberRow_ID  
                WHERE   aws.ErrorCode IS NULL  
  
            END -- IF BestOffort  
        END -- IF @SQL is not empty  
    END -- IF Leaf with DBAs  
  
    -------------------------------------------------------------------------------------------  
    -- If the caller has specified all-or-nothing transaction behavior, then when a member has  
    -- an error in any working set, invalidate in all working sets any error-free rows that pertain  
    -- to that member.  
    -------------------------------------------------------------------------------------------  
    IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Check transaction behavior.';  
    IF @TransactionBehavior = @TransactionBehavior_AllOrNothingByMember  
    BEGIN  
        -- Get the MUIDs of all members that have any errors  
        DECLARE @MembersWithErrors TABLE  
        (  
            MemberRowID INT PRIMARY KEY CLUSTERED NOT NULL  
        );  
        INSERT INTO @MembersWithErrors (MemberRowID)  
        SELECT  
            Row_ID AS MemberRowID  
        FROM #MembersWorkingSet  
        WHERE ErrorCode IS NOT NULL  
  
        UNION -- not "UNION ALL" because deduplication is needed  
  
        SELECT DISTINCT  
            MemberRowID  
        FROM #MemberAttributeWorkingSet  
        WHERE ErrorCode IS NOT NULL  
  
        IF @HasDba = 1  
        BEGIN  
        -- TODO: look for errors in the collection working set  
        ---------------------------------------------------------------------------------------------------------------------  
        -- Add special handling for self-referencing DBA attributes (i.e. domain entity id = @Entity_ID). Add errors and  
        -- update the @MemberWithErrors table for attributes that are trying to reference members that will not  
        -- be created due to errors.  
        ---------------------------------------------------------------------------------------------------------------------  
        IF EXISTS(SELECT 1 FROM #DbaReferencesToNewMembers)  
        BEGIN  
            DECLARE @NewErrors TABLE  
            (  
                 AttributeRowID INT PRIMARY KEY  
                ,MemberRowID    INT  
            );  
  
            -- Prune the members with newly-found errors from the table of self referencing DBAs.  
            DELETE sr  
            FROM #DbaReferencesToNewMembers sr  
            INNER JOIN @MembersWithErrors er  
            ON sr.ChildMemberRowID = er.MemberRowID  
  
            DECLARE @Continue BIT = CASE WHEN EXISTS(SELECT 1 FROM #DbaReferencesToNewMembers) THEN 1 ELSE 0 END;  
  
            WHILE (@Continue = 1)  
            BEGIN  
                -- Prune the members with newly-found errors from the table of self referencing DBAs.  
                DELETE sr  
                OUTPUT deleted.AttributeRowID, deleted.ChildMemberRowID  
                INTO @NewErrors(AttributeRowID, MemberRowID)  
                FROM #DbaReferencesToNewMembers sr  
                INNER JOIN @MembersWithErrors er  
                ON sr.ParentMemberRowID = er.MemberRowID;  
  
                -- Set a flag to indicate if any new errors were found. This will mean needing to continue through the loop another time to check for new errors.  
                SET @Continue = CASE WHEN EXISTS(SELECT 1 FROM @NewErrors) THEN 1 ELSE 0 END;  
  
                IF @Continue = 1  
                BEGIN  
                    -- Add errors to the attribute working set rows pertaining to the newly found errors.  
                    UPDATE ws  
                    SET  ErrorCode = @ErrorCode_InvalidAttributeValueForMember -- The new member creation is going to fail, so it cannot be referenced as a DBA.  
                        ,ErrorObjectType = @ObjectType_MemberAttribute  
                    FROM #MemberAttributeWorkingSet ws  
                    INNER JOIN @NewErrors newError  
                    ON ws.Row_ID = newError.AttributeRowID;  
  
                    -- Copy the new errors into the main errors table.  
                    INSERT INTO @MembersWithErrors  
                    SELECT MemberRowID FROM @NewErrors  
  
                    DELETE FROM @NewErrors;  
                END; -- IF new errors found  
            END; -- WHILE  
            END; -- IF #DbaReferencesToNewMembers has rows  
        END; -- IF @HasDBA  
  
        IF EXISTS (SELECT 1 FROM @MembersWithErrors)  
        BEGIN  
            -- Mark new members working set rows to be ignored.  
            UPDATE ws  
                SET ErrorCode = @ErrorCode_FailedDueToAllOrNothingErrorPropagation  
            FROM #MembersWorkingSet ws  
            INNER JOIN @MembersWithErrors er  
            ON ws.Row_ID = er.MemberRowID  
            WHERE ws.ErrorCode IS NULL; -- Only delete rows without errors  
  
            -- Mark attribute value working set rows to be ignored.  
            UPDATE ws  
                SET ErrorCode = @ErrorCode_FailedDueToAllOrNothingErrorPropagation  
            FROM #MemberAttributeWorkingSet ws  
            INNER JOIN @MembersWithErrors er  
            ON ws.MemberRowID = er.MemberRowID  
            WHERE ws.ErrorCode IS NULL; -- Only delete rows without errors  
  
            -- TODO: flag rows in the collection working set  
        END;  
    END; -- IF @TransactionBehavior_AllOrNothingByMember  
  
    --------------------------------------------------  
    -- Error reporting.  
    --------------------------------------------------  
  
    ----------------------------------------------------------------------------------------  
    -- Update MemberCode for any member attribute change errors that are associated with a successful member code change  
    -- so that the updated member code is returned to the consumer.  
    ----------------------------------------------------------------------------------------  
    IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Update MemberCode for any member attribute change errors that are associated with a successful member code change.';  
    WITH cteCodeChgs AS  
    (  
        SELECT  
             MemberRowID  
            ,AttributeValue AS NewCode  
        FROM #MemberAttributeWorkingSet  
        WHERE   AttributeID = @AttributeID_Code  
            AND ErrorCode IS NULL  
    )  
    UPDATE ws  
    SET ws.MemberCode = cde.NewCode  
    FROM #MembersWorkingSet ws  
    INNER JOIN cteCodeChgs cde  
    ON      ws.Row_ID = cde.MemberRowID  
        AND ws.ErrorCode IS NOT NULL;  
  
    --------------------------------------------------  
    -- Load all errors into a temp table.  
    --------------------------------------------------  
    IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Load all errors into a temp table.';  
  
    -- Member errors  
    CREATE TABLE #Errors  
    (  
         ErrorCode INT NULL  
        ,ErrorParameters NVARCHAR(MAX) NULL  
        ,ErrorObjectType TINYINT NULL  
        ,MemberID INT NULL  
        ,MemberMUID UNIQUEIDENTIFIER NULL  
        ,MemberCode NVARCHAR(MAX) COLLATE DATABASE_DEFAULT NULL  
        ,MemberName NVARCHAR(MAX) COLLATE DATABASE_DEFAULT NULL  
        ,AttributeMUID UNIQUEIDENTIFIER NULL  
        ,AttributeName NVARCHAR(MAX) COLLATE DATABASE_DEFAULT NULL  
    )  
  
    INSERT INTO #Errors  
    (  
         ErrorCode  
        ,ErrorParameters  
        ,ErrorObjectType  
        ,MemberID  
        ,MemberMUID  
        ,MemberCode  
        ,MemberName  
        ,AttributeMUID  
        ,AttributeName  
    )  
    SELECT  
         ErrorCode  
        ,ErrorParameters  
        ,ErrorObjectType  
        ,MemberID  
        ,MemberMUID  
        ,MemberCode  
        ,MemberName  
        ,ErrorAttributeMUID AS AttributeMUID  
        ,ErrorAttributeName AS AttributeName  
    FROM #MembersWorkingSet  
    WHERE NULLIF(ErrorCode  
                ,@ErrorCode_FailedDueToAllOrNothingErrorPropagation -- This error should not be returned to the user. It is for internal use only.  
                ) IS NOT NULL  
  
    UNION ALL  
  
    -- Attribute value errors.  
    SELECT  
         ws.ErrorCode  
        ,ws.ErrorParameters  
        ,ws.ErrorObjectType  
        ,mws.MemberID  
        ,mws.MemberMUID  
        ,mws.MemberCode  
        ,mws.MemberName  
        ,att.AttributeMUID  
        ,att.AttributeName  
    FROM #MemberAttributeWorkingSet ws  
    LEFT JOIN #MembersWorkingSet mws  
    ON ws.MemberRowID = mws.Row_ID  
    LEFT JOIN #AttributeDefinition att  
    ON ws.AttributeID = att.AttributeID  
    WHERE NULLIF(ws.ErrorCode  
                ,@ErrorCode_FailedDueToAllOrNothingErrorPropagation -- This error should not be returned to the user. It is for internal use only.  
                ) IS NOT NULL  
  
    -- TODO: Union with any collection errors.  
  
    IF (@ErrorReportingType & @ErrorReportingType_Return) > 0  
    BEGIN  
        IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Return errors.';  
        SELECT  
            ErrorCode,  
            ErrorParameters,  
            ErrorObjectType,  
            MemberID,  
            MemberMUID,  
            MemberCode,  
            MemberName,  
            AttributeMUID,  
            AttributeName  
        FROM #Errors;  
    END;  
  
    IF (@ErrorReportingType & @ErrorReportingType_Xml) > 0  
    BEGIN  
        IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Add errors to XML out param.';  
        SET @Errors = CONVERT(XML,  
            (SELECT  
                 ErrorCode  
                ,ErrorParameters  
                ,ErrorObjectType  
                ,MemberID  
                ,MemberMUID  
                ,MemberCode  
                ,MemberName  
                ,AttributeMUID  
                ,AttributeName  
            FROM #Errors FOR XML PATH(N'Error')));  
    END;  
  
    IF (@ErrorReportingType & @ErrorReportingType_Raise) > 0  
    BEGIN  
        IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Raise first error.';  
        -- Raise an error for the first error in the working set.  
        DECLARE @FirstErrorMessage NVARCHAR(MAX) = NULL;  
        SELECT TOP 1  
            @FirstErrorMessage = CONCAT(N'MDSERR', ErrorCode, N'<error message placeholder, will be replaced by localized string in C# layer>', CASE WHEN ErrorParameters IS NOT NULL THEN CONCAT(N'|', ErrorParameters) END)  
        FROM #Errors;  
  
        IF @FirstErrorMessage IS NOT NULL  
        BEGIN  
            SET @FirstErrorMessage = REPLACE(@FirstErrorMessage, '%', '%%')-- escape out format specifier  
            RAISERROR(@FirstErrorMessage, 16, 1);  
            RETURN;-- Return, to abort the entire batch.  
        END;  
    END;  
  
    IF @TransactionBehavior = @TransactionBehavior_AllOrNothingByBatch  
        AND EXISTS(SELECT 1 FROM #Errors)  
    BEGIN  
        IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'At least one error was found, so abort the whole batch.';  
       -- At least one error was found, so abort the whole batch (i.e. return without changing any member tables).  
        RETURN 0;  
    END;  
  
  
    ------------------------------------------------------------------------------------------------------------  
    -- All validation checks have completed, so begin writing data from the working sets to the member tables  
    ------------------------------------------------------------------------------------------------------------  
    IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Validation checks complete, start transaction.';  
    --Start transaction, being careful to check if we are nested  
    DECLARE @TranCounter INT = @@TRANCOUNT;  
    IF @TranCounter > 0  
    BEGIN  
        SAVE TRANSACTION TX;  
    END ELSE  
    BEGIN  
        BEGIN TRANSACTION;  
    END;  
  
    BEGIN TRY  
  
        DECLARE @CurrentTime DATETIME2(3) = GETUTCDATE();  
  
        ----------------------------------------------------------------------------------------  
        -- Handle CodeGen-enabled entities.  
        ----------------------------------------------------------------------------------------  
        IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'If the entity is code gen enabled, populate null member codes.';  
        IF @CodeGenEnabled = 1  
        BEGIN  
            --Gather up the valid user provided codes  
            DECLARE @CodesToProcess mdm.MemberCodes;  
            INSERT @CodesToProcess (MemberCode)  
            SELECT MemberCode  
            FROM #MembersWorkingSet          -- new members  
            WHERE   MemberCode IS NOT NULL  
                AND MemberID IS NULL -- exclude pre-existing members, which will have a non-NULL MemberID at this point  
                AND ErrorCode IS NULL  
            UNION -- not "UNION ALL" because deduplication is needed  
            SELECT AttributeValue AS MemberCode  
            FROM #MemberAttributeWorkingSet     -- code attribute changes  
            WHERE   ErrorCode IS NULL  
                AND AttributeID = @AttributeID_Code;  
  
            --Process the user-provided codes to update the code gen info table with the largest one.  
            EXEC mdm.udpProcessCodes @Entity_ID, @CodesToProcess;  
  
            -- When creating leaf members, replace null member codes with autogenerated values.  
            IF      @SaveMode = @SaveMode_Create -- CodeGen only applies to the create operation (not merge)  
                AND @MemberType_ID = @MemberType_Leaf -- CodeGen only applies to leaf members  
            BEGIN  
                DECLARE @NumberOfCodeToGenerate INT = (SELECT COUNT(*) FROM #MembersWorkingSet WHERE MemberCode IS NULL AND ErrorCode IS NULL);  
  
                IF @NumberOfCodeToGenerate > 0  
                BEGIN  
                    DECLARE  
                         @AllocatedRangeStart BIGINT  
                        ,@AllocatedRangeEnd BIGINT;  
                    EXEC mdm.udpGenerateCodeRange   @Entity_ID = @Entity_ID,  
                                                    @NumberOfCodesToGenerate = @NumberOfCodeToGenerate,  
                                                    @CodeRangeStart = @AllocatedRangeStart OUTPUT,  
                                                    @CodeRangeEnd = @AllocatedRangeEnd OUTPUT;  
  
                    DECLARE @AllocatedCodeCounter BIGINT = @AllocatedRangeStart - 1;  
  
                    --Generate any codes the user did not provide  
                    UPDATE #MembersWorkingSet  
                    SET  @AllocatedCodeCounter = @AllocatedCodeCounter + 1  
                        ,MemberCode = CONVERT(NVARCHAR(250), @AllocatedCodeCounter)  
                    WHERE   MemberCode IS NULL  
                        AND ErrorCode IS NULL;  
                END; -- IF @NumberOfCodeToGenerate > 0  
            END; -- IF @MemberType_ID = @MemberType_Leaf  
        END; -- IF @CodeGenEnabled = 1  
  
        -- Replace NULL member MUIDs with new ones.  
        UPDATE #MembersWorkingSet  
        SET MemberMUID = NEWID()  
        WHERE   ErrorCode IS NULL  
            AND MemberMUID IS NULL;  
  
        IF @Changeset_ID IS NULL  
        BEGIN  
            ----------------------------------------------------------------------------------------  
            --Insert new members into the appropriate entity table.  
            ----------------------------------------------------------------------------------------  
            IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Insert new members into the appropriate entity table.';  
            --IDs of new members created.  
            CREATE TABLE #NewMembers  
            (  
                 MemberRowID        INT PRIMARY KEY  
                ,MemberMUID         UNIQUEIDENTIFIER  
                ,MemberID           INT  
                ,MemberCode         NVARCHAR(250) COLLATE DATABASE_DEFAULT  
                ,MemberName         NVARCHAR(250) COLLATE DATABASE_DEFAULT  
            );  
  
            IF @SaveMode IN (@SaveMode_Create, @SaveMode_Merge)  
            BEGIN  
  
                -- Insert the new members into the member table.  
                SET @SQL = CONCAT(@TruncationGuard, N'  
                    MERGE mdm.', @MemberTableName, N'  
                    USING  
                    (  
                        SELECT  
                             mws.Row_ID  
                            ,mws.MemberName  
                            ,mws.MemberCode  
                            ,mws.MemberMUID  
                        FROM #MembersWorkingSet mws  
                        WHERE   mws.ErrorCode IS NULL  
                            AND mws.MemberID IS NULL -- Already existing members (in a Merge operations) will have a non-null MemberID  
                    ) ws  
                    ON (1 = 0) -- An arbitrary condition that is always false, so that the NOT MATCHED block will always be hit.  
                    WHEN NOT MATCHED THEN  
                    INSERT  
                    (  
                         Version_ID  
                        ,Status_ID  
                        ,Name  
                        ,Code',  
                        CASE WHEN @MemberType_ID = @MemberType_Collection THEN N'  
                        ,[Owner_ID]' END, N'  
                        ,EnterDTM  
                        ,EnterUserID  
                        ,EnterVersionID  
                        ,LastChgDTM  
                        ,LastChgUserID  
                        ,LastChgVersionID  
                        ,MUID  
                    )  
                    VALUES  
                    (  
                         @Version_ID  
                        ,', @MemberStatus_Active, N'  
                        ,ws.MemberName  
                        ,ws.MemberCode',  
                        CASE WHEN @MemberType_ID = @MemberType_Collection THEN N'  
                        ,@User_ID' END, N'  
                        ,@CurrentTime  
                        ,@User_ID  
                        ,@Version_ID  
                        ,@CurrentTime  
                        ,@User_ID  
                        ,@Version_ID  
                        ,ws.MemberMUID  
                    )  
                    OUTPUT  
                         ws.Row_ID  
                        ,inserted.MUID  
                        ,inserted.ID  
                        ,inserted.Code  
                        ,inserted.Name  
                    INTO #NewMembers (MemberRowID, MemberMUID, MemberID, MemberCode, MemberName)  
                    ;  
                    ');  
  
                --IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT(@SQL);  
                EXEC sp_executesql @SQL,  
                    N'@User_ID INT, @Version_ID INT, @CurrentTime DATETIME2(3)',  
                      @User_ID,     @Version_ID,     @CurrentTime;  
  
                ----------------------------------------------------------------------------------------  
                --Update working sets with new member Ids.  
                ----------------------------------------------------------------------------------------  
                IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Update working sets with new member Ids.';  
                UPDATE ws  
                SET  ws.MemberID = nm.MemberID  
                    ,ws.IsNewMember = 1  
                FROM #MembersWorkingSet ws  
                INNER JOIN #NewMembers nm  
                ON ws.Row_ID = nm.MemberRowID;  
  
                ----------------------------------------------------------------------------------------  
                -- If DBA working set rows reference one of the newly created members (this is possible when the DBA's domain entity  
                -- is the same as the current entity), set their AttributeValueMapped column to the newly-created member's ID.  
                ----------------------------------------------------------------------------------------  
                IF      @HasDba = 1  
                    AND @MemberType_ID = @MemberType_Leaf -- Only leaf members can be DBA values.  
                BEGIN  
                    IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Set DBA attributes'' AttributeValueMapped column to the newly-created member IDs.';  
                    UPDATE ws  
                    SET ws.AttributeValueMapped = nm.MemberID  
                    FROM #MemberAttributeWorkingSet ws  
                    INNER JOIN #DbaReferencesToNewMembers sr  
                    ON ws.Row_ID = sr.AttributeRowID  
                    INNER JOIN #NewMembers nm  
                    ON sr.ParentMemberRowID = nm.MemberRowID;  
                END;  
            END; -- Add new rows to member table  
            -- TODO: update collection working sets.  
  
            ----------------------------------------------------------------------------------------  
            -- Add new Leaf members to all mandatory explicit hierarchies, underneath each hierarchy's ROOT node.  
            ----------------------------------------------------------------------------------------  
            CREATE TABLE #MandatoryExplicitHierarchyIds  
            (  
                ID INT PRIMARY KEY  
            );  
            IF      @IsHierarchyEnabled = 1  
                AND @MemberType_ID = @MemberType_Leaf  
                AND EXISTS(SELECT 1 FROM #NewMembers)  
            BEGIN  
                IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Get the IDs of all mandatory explicit hierarchies.';  
                -- Get the IDs of all mandatory explicit hierarchies.  
                INSERT INTO #MandatoryExplicitHierarchyIds  
                SELECT ID  
                FROM mdm.tblHierarchy  
                WHERE   [Entity_ID] = @Entity_ID  
                    AND IsMandatory = 1;  
  
                IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Add new Leaf members to all mandatory explicit hierarchies.';  
                SET @SQL = CONCAT(@TruncationGuard, N'  
                INSERT INTO mdm.', @HierarchyTableName, N'  
                (  
                     Version_ID  
                    ,Status_ID  
                    ,Hierarchy_ID  
                    ,Parent_HP_ID  
                    ,ChildType_ID  
                    ,Child_EN_ID  
                    ,Child_HP_ID  
                    ,SortOrder  
                    ,LevelNumber  
                    ,EnterDTM  
                    ,EnterUserID  
                    ,EnterVersionID  
                    ,LastChgDTM  
                    ,LastChgUserID  
                    ,LastChgVersionID  
                )  
                SELECT  
                     @Version_ID  
                    ,', @MemberStatus_Active, N'  
                    ,h.ID  
                    ,NULL --Parent_HP_ID  
                    ,', @MemberType_Leaf, N' -- ChildType_ID  
                    ,nm.MemberID --Child_EN_ID  
                    ,NULL --Child_HP_ID  
                    ,0 -- SortOrder, adds the new members to the top because it is better for perf than adding them at the bottom (which would require computing the current maximum sort order, which can be expensive). Users can reorder members later, if desired.  
                    ,-1 -- LevelNumber  
                    ,@CurrentTime  
                    ,@User_ID  
                    ,@Version_ID  
                    ,@CurrentTime  
                    ,@User_ID  
                    ,@Version_ID  
                FROM #NewMembers nm  
                CROSS JOIN #MandatoryExplicitHierarchyIds h  
                ');  
                --IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT(@SQL);  
                EXEC sp_executesql @SQL,  
                    N'@User_ID INT, @Version_ID INT, @Entity_ID INT, @CurrentTime DATETIME2(3)',  
                      @User_ID,     @Version_ID,     @Entity_ID,     @CurrentTime;  
  
            END;  
  
            ----------------------------------------------------------------------------------------  
            -- Update attribute values.  
            ----------------------------------------------------------------------------------------  
            DECLARE @HasAttributeChanges BIT = CASE WHEN EXISTS(SELECT 1 FROM #MemberAttributeWorkingSet WHERE ErrorCode IS NULL) THEN 1 ELSE 0 END;  
            IF @HasAttributeChanges = 1  
            BEGIN  
                ----------------------------------------------------------------------------------------  
                -- Pivot and update entity member table.  
                ----------------------------------------------------------------------------------------  
                IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Pivot and update entity member table.';  
                -- ctePivotRowMerge  
                -- Given this input:  
                --  MemberRowID     AttributeID    AttributeValueMapped  
                --  --------        -------------   --------------------  
                --  1                 10               ABC  
                --  1                 11               1111  
                --  1                 12               Foo  
                --  Pivots to this:  
                --  MemberRowID       [10]             [11]            [12]  
                --  --------        ----------      ----------      ----------  
                --  1                 ABC              1111            Foo  
    SET @SQL = CONCAT(@TruncationGuard, N'  
;WITH ctePivotRowMerge AS  
(  
    SELECT  
         MemberRowID  
        ,SUM(DISTINCT ChangeTrackingMask) ChangeTrackingMask  
        ', @AttributeValueMappedAsColumns, N'  
    FROM #MemberAttributeWorkingSet  
    PIVOT  
    (  
        MAX(AttributeValueMapped)  
        FOR AttributeID IN (', @AttributeIdList, N')  
    ) AS P  
    WHERE   ErrorCode IS NULL  
    GROUP BY MemberRowID  
)  
UPDATE m  
SET  
     ValidationStatus_ID    = @ValidationStatus  
    ,LastChgDTM             = @CurrentTime  
    ,LastChgUserID          = @User_ID  
    ,LastChgVersionID       = @Version_ID'  
    --Update the ChangeTrackingMask only for Leaf  
    --member types (collections do not support this functionality)  
    ,CASE WHEN @MemberType_ID = @MemberType_Leaf THEN N'  
    ,m.ChangeTrackingMask = updates.ChangeTrackingMask ' END,  
    @TableColumnsUpdateDefn, N'{0}  
FROM #MembersWorkingSet mws  
INNER JOIN ctePivotRowMerge updates  
ON mws.Row_ID = updates.MemberRowID  
INNER JOIN mdm.', QUOTENAME(@MemberTableName), N' AS m  
ON      m.Version_ID = @Version_ID   
    AND m.ID = mws.MemberID{1};')  
  
                IF @TransactionLogType = @TransactionLogType_Member  
                BEGIN  
                    SET @SQL = CONCAT(@TruncationGuard, N'  
-- New member attribute, history output is not needed.',  
                        REPLACE(  
                            REPLACE(@SQL,   
                                N'{0}', N''),  
                            N'{1}', N'  
    AND mws.IsNewMember = 1'), N'  
  
-- Existing member attribute, history output is needed, based on @LogFlag.',  
                        REPLACE(  
                            REPLACE(@SQL, N'{0}', CASE @TransactionLogType WHEN @TransactionLogType_Member THEN @GetMemeberHistoryOutputQuery ELSE N'' END),  
                            N'{1}', N'  
    AND mws.IsNewMember = 0'));  
  
                END ELSE  
                BEGIN  
                    SET @SQL = REPLACE(REPLACE(@SQL, N'{0}', N''), N'{1}', N'');  
                END  
  
                IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT @SQL;  
                SET @ValidationStatus =  @ValidationStatus_AwaitingRevalidation;  
                EXEC sp_executesql @SQL, N'@Version_ID INT, @ValidationStatus INT, @CurrentTime DATETIME2(3), @User_ID INT, @SysNull_Text NVARCHAR(1), @SysNull_Number DECIMAL(38,0), @SysNull_DateTime DATETIME2(3), @SysNull_ForeignKey INT',  
                                           @Version_ID,     @ValidationStatus,      @CurrentTime,             @User_ID,     @SysNull_Text,              @SysNull_Number,               @SysNull_DateTime,              @SysNull_ForeignKey;  
  
                ----------------------------------------------------------------------------------------  
                --Update any existing validation issues associated with members whose code has changed  
                --to ensure they reference the new member code.  
                ----------------------------------------------------------------------------------------  
                IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Update any existing validation issues associated with members whose code has changed.';  
                SET @SQL = @TruncationGuard + N'  
                UPDATE v  
                SET v.MemberCode = ws.AttributeValue  
                FROM #MemberAttributeWorkingSet AS ws  
                INNER JOIN [mdm].' + QUOTENAME(@ValidationLogTableName) + N' AS v  
                ON ws.PriorValue = v.MemberCode  
                WHERE   ws.AttributeID = @AttributeID_Code  
                    AND v.MemberType_ID = @MemberType_ID  
                    AND v.Version_ID = @Version_ID  
                    AND ws.ErrorCode IS NULL;  
                ';  
                EXEC sp_executesql @SQL, N'@AttributeID_Code INT, @MemberType_ID TINYINT, @Version_ID INT',  
                                           @AttributeID_Code,     @MemberType_ID,         @Version_ID;  
  
                ----------------------------------------------------------------------------------------  
                --Check for Inheritance Business Rules and update dependent members validation status.  
                ----------------------------------------------------------------------------------------  
                IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Check for Inheritance Business Rules and update dependent members validation status.';  
                IF @DoInheritanceRuleCheck = 1  
                BEGIN  
                    DECLARE @BRInherit TABLE  
                    (  
                         RowNumber                      INT IDENTITY(1,1) NOT NULL  
                        ,DependentAttributeColumnName   SYSNAME COLLATE DATABASE_DEFAULT NOT NULL  
                        ,DependentEntityTable           SYSNAME COLLATE DATABASE_DEFAULT NULL  
                        ,DependentAttributeName         SYSNAME COLLATE DATABASE_DEFAULT NULL  
                        ,DependentAttributeID           INT NULL  
                    );  
  
                    --DBA Inheritance  
                    INSERT INTO @BRInherit (DependentEntityTable, DependentAttributeColumnName)  
                    SELECT DISTINCT  
                         depEnt.EntityTable  
                        ,i.ChildAttributeColumnName  
                    FROM mdm.viw_SYSTEM_BUSINESSRULES_ATTRIBUTE_INHERITANCE_HIERARCHY i  
                    INNER JOIN #AttributeDefinition att  
                    ON i.ParentAttributeName = att.AttributeName  
                    INNER JOIN #MemberAttributeWorkingSet ws  
                    ON att.AttributeID = ws.AttributeID  
                    INNER JOIN mdm.tblEntity depEnt  
                    ON i.ChildEntityID = depEnt.ID  
                    WHERE   ws.ErrorCode IS NULL  
                        AND i.ParentEntityID = @Entity_ID;  
  
                    IF EXISTS(SELECT 1 FROM @BRInherit)  
                    BEGIN  
                        DECLARE  
                             @DependentEntityTableName      NVARCHAR(MAX)  
                            ,@DependentAttributeColumnName  NVARCHAR(MAX);  
                        SELECT  
                             @Counter = 1  
                            ,@MaxCounter = MAX(RowNumber)  
                        FROM @BRInherit;  
  
                        --Loop through each Dba Entity updating the dependent members' validation status.  
                        WHILE @Counter <= @MaxCounter  
                        BEGIN  
                            SELECT  
                                 @DependentEntityTableName = DependentEntityTable  
                                ,@DependentAttributeColumnName = DependentAttributeColumnName  
                             FROM @BRInherit  
                             WHERE [RowNumber] = @Counter ;  
  
                            --Update immediate dependent member table's validation status.  
                            SET @SQL = @TruncationGuard + N'  
                                UPDATE dep  
                                SET dep.ValidationStatus_ID = @ValidationStatus_AwaitingDependentMemberRevalidation  
                                FROM  mdm.' + @DependentEntityTableName + N' dep  
                                INNER JOIN #MembersWorkingSet mws  
                                ON dep.' + @DependentAttributeColumnName + N' = mws.MemberID  
                                INNER JOIN #MemberAttributeWorkingSet aws  
                                ON mws.Row_ID = aws.MemberRowID  
                                WHERE   dep.Version_ID = @Version_ID  
                                    AND aws.ErrorCode IS NULL;  
                                ';  
  
                            --IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT @SQL;  
                            EXEC sp_executesql @SQL,  
                                N'@Version_ID INT, @ValidationStatus_AwaitingDependentMemberRevalidation INT',  
                                 @Version_ID,      @ValidationStatus_AwaitingDependentMemberRevalidation;  
  
                            SET @Counter += 1;  
  
                        END; -- WHILE  
                    END; -- IF @DependentEntityTable  
                END; --IF @DoInheritanceRuleCheck  
  
                ----------------------------------------------------------------------------------------  
                -- File Type attribute  
                -- Remove old record from mdm.tblFile for updates since the new record is being inserted  
                -- in Business Logic Save.  
                ----------------------------------------------------------------------------------------  
                IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'File Type attribute.';  
                IF @HasFile = 1  
                BEGIN  
                    -- Get the IDs of files which should not be deleted  
                    CREATE TABLE #FileIDsToKeep  
                    (  
                        ID INT  
                    );  
  
                    DECLARE @GetFileIdsSQL NVARCHAR(MAX) = mdm.udfFileIDReferencesGetSQL(@Entity_ID, NULL, NULL, 0)  
                    IF LEN(@GetFileIdsSQL) > 0  
                    BEGIN  
                        SET @GetFileIdsSQL = CONCAT(N'INSERT INTO #FileIDsToKeep(ID) ', @GetFileIdsSQL);  
                        EXEC sp_executesql @GetFileIdsSQL;  
                    END;  
  
                    -- IDs of file want to delete  
                    DECLARE @File_ID mdm.IdList;  
                    INSERT INTO @File_ID  
                    SELECT f.ID  
                    FROM mdm.tblFile f  
                    INNER JOIN #MemberAttributeWorkingSet ws  
                    ON ws.PriorFileId = f.ID  
                    INNER JOIN #AttributeDefinition att  
                    ON ws.AttributeID = att.AttributeID  
                    WHERE   ws.ErrorCode IS NULL  
                        AND att.AttributeType_ID = @AttributeType_File;  
  
                    -- Remove file which need to be kept from list  
                    DELETE f  
                    FROM @File_ID f  
                    WHERE EXISTS (Select ftk.ID  
                    FROM #FileIDsToKeep ftk  
                    WHERE f.ID = ftk.ID)  
  
                    EXEC mdm.udpFilesDelete @File_ID = @File_ID, @CorrelationID = @CorrelationID;  
                END;  
            END; -- @HasAttributeChanges = 1  
  
            IF @TransactionLogType = @TransactionLogType_Member  
            BEGIN  
                ----------------------------------------------------------------------------------------  
                --Insert annotation  
                ----------------------------------------------------------------------------------------  
                IF EXISTS(SELECT 1 FROM #MembersWorkingSet WHERE TransactionAnnotation IS NOT NULL AND ErrorCode IS NULL)  
                BEGIN  
                    SET @SQL = CONCAT(N'  
                        INSERT mdm.', @MemberAnnotationTableName, N' (Version_ID, Revision_ID, Comment, EnterUserID, LastChgUserID)  
                        SELECT @Version_ID, m.LastChgTS, mws.TransactionAnnotation, @User_ID, @User_ID  
                        FROM #MembersWorkingSet mws  
                        INNER JOIN mdm.' + @MemberTableName + N' m ON mws.MemberID = m.ID  
                        WHERE mws.TransactionAnnotation IS NOT NULL AND mws.ErrorCode IS NULL;');  
  
                    --PRINT(@SQL);  
                    EXEC sp_executesql @SQL, N'@User_ID INT, @Version_ID INT', @User_ID, @Version_ID;  
                END  
  
                IF EXISTS(SELECT 1 FROM #MemberAttributeWorkingSet WHERE TransactionAnnotation IS NOT NULL AND ErrorCode IS NULL)  
                BEGIN  
                    SET @SQL = CONCAT(N'  
                        INSERT mdm.', @MemberAnnotationTableName, N' (Version_ID, Revision_ID, Comment, EnterUserID, LastChgUserID)  
                        SELECT @Version_ID, m.LastChgTS, ws.TransactionAnnotation, @User_ID, @User_ID  
                        FROM #MemberAttributeWorkingSet ws  
                        INNER JOIN #MembersWorkingSet mws ON mws.Row_ID = ws.MemberRowID  
                        INNER JOIN mdm.' + @MemberTableName + N' m ON mws.MemberID = m.ID  
                        WHERE ws.TransactionAnnotation IS NOT NULL AND ws.ErrorCode IS NULL;');  
  
                    --PRINT(@SQL);  
                    EXEC sp_executesql @SQL, N'@User_ID INT, @Version_ID INT', @User_ID, @Version_ID;  
                END  
            END -- IF @TransactionType = @TransactionType_Row  
            ELSE IF @TransactionLogType = @TransactionLogType_Attribute  
            BEGIN  
                ----------------------------------------------------------------------------------------  
                --Log transactions.  
                ----------------------------------------------------------------------------------------  
                IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Log new member transactions.';  
  
                CREATE TABLE #TransactionAnnotations  
                (  
                     TransactionID  INT  
                    ,Annotation     NVARCHAR(500) COLLATE DATABASE_DEFAULT   
                );  
  
                ----------------------------------------------------------------------------------------  
                -- Log member add transactions.  
                ----------------------------------------------------------------------------------------  
                IF EXISTS(SELECT 1 FROM #NewMembers)  
                BEGIN  
                    -- Note that using a MERGE instead of an INSERT statement allows the TransactionAnnotation column to be  
                    -- matched with the TransactionID using the OUTPUT statement, rather than having to do an additional  
                    -- (potentially expensive) JOIN on the transaction table.  
                    SET @SQL = CONCAT(N'  
                    MERGE [mdm].', QUOTENAME(@TransactionTableName), N'  
                    USING  
                    (  
                        SELECT  
                             nm.MemberID  
                            ,nm.MemberMUID  
                            ,nm.MemberCode  
                            ,ws.TransactionAnnotation  
                        FROM #NewMembers nm  
                        INNER JOIN #MembersWorkingSet ws  
                        ON nm.MemberRowID = ws.Row_ID  
                    ) ws  
                    ON (1 = 0) -- An arbitrary condition that is always false, so that the NOT MATCHED block will always be hit.  
                    WHEN NOT MATCHED THEN  
                    INSERT  
                    (  
                         Version_ID  
                        ,TransactionType_ID  
                        ,OriginalTransaction_ID  
                        ,Hierarchy_ID  
                        ,[Entity_ID]  
                        ,Attribute_ID  
                        ,Member_ID  
                        ,Member_MUID  
                        ,MemberType_ID  
                        ,MemberCode  
                        ,OldValue  
                        ,OldCode  
                        ,NewValue  
                        ,NewCode  
                        ,EnterDTM  
                        ,EnterUserID  
                        ,LastChgDTM  
                        ,LastChgUserID  
                    )  
                    VALUES  
                    (  
                         @Version_ID  
                        ,@TransactionType_Create --TransactionType_ID  
                        ,0 --OriginalTransaction_ID  
                        ,NULL-- Hierarchy_ID  
                        ,@Entity_ID  
                        ,NULL -- Attribute_ID  
                        ,ws.MemberID  
                        ,ws.MemberMUID  
                        ,@MemberType_ID  
                        ,ws.MemberCode  
                        ,N'''' --OldValue  
                        ,N'''' --OldCode  
                        ,N'''' --NewValue  
                        ,N'''' --NewCode  
                        ,@CurrentTime  
                        ,@User_ID  
                        ,@CurrentTime  
                        ,@User_ID  
                    )  
                    OUTPUT                       inserted.ID,   ws.TransactionAnnotation  
                    INTO #TransactionAnnotations(TransactionID, Annotation) -- Note: it wouldn''t be appropriate to output directly into annotation table here because we want to filter out empty annotations  
                    ;  
                    ');  
                    EXEC sp_executesql @SQL, N'@Version_ID INT, @TransactionType_Create INT, @Entity_ID INT, @MemberType_ID TINYINT, @CurrentTime DATETIME2(3), @User_ID INT',  
                                               @Version_ID,     @TransactionType_Create,     @Entity_ID,     @MemberType_ID,         @CurrentTime,              @User_ID;  
  
                    ----------------------------------------------------------------------------------------  
                    -- Log Leaf members added to the ROOT node of mandatory explicit hierarchies.  
                    ----------------------------------------------------------------------------------------  
                    IF EXISTS(SELECT 1 FROM #MandatoryExplicitHierarchyIds)  
                    BEGIN  
                        IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Log Leaf members added to the ROOT node of mandatory explicit hierarchies.';  
                        DECLARE @RootCode NVARCHAR(10) = N'ROOT'; -- The member code of the top-level explicit hierarchy node.  
  
                        SET @SQL = CONCAT(N'  
                        MERGE [mdm].', QUOTENAME(@TransactionTableName), N'  
                        USING  
                        (  
                            SELECT  
                                 nm.MemberID  
                                ,nm.MemberMUID  
                                ,nm.MemberCode  
                                ,ws.TransactionAnnotation  
                                ,h.ID [HierarchyID]  
                            FROM #NewMembers nm  
                            INNER JOIN #MembersWorkingSet ws  
                            ON nm.MemberRowID = ws.Row_ID  
                            CROSS JOIN #MandatoryExplicitHierarchyIds h  
                        ) ws  
                        ON (1 = 0) -- An arbitrary condition that is always false, so that the NOT MATCHED block will always apply.  
                        WHEN NOT MATCHED THEN  
                        INSERT  
                        (  
                             Version_ID  
                            ,TransactionType_ID  
                            ,OriginalTransaction_ID  
                            ,Hierarchy_ID  
                            ,[Entity_ID]  
                            ,Member_ID  
                            ,Member_MUID  
                            ,MemberType_ID  
                            ,MemberCode  
                            ,OldValue  
                            ,OldCode  
                            ,NewValue  
                            ,NewCode  
                            ,EnterDTM  
                            ,EnterUserID  
                            ,LastChgDTM  
                            ,LastChgUserID  
                        )  
                        VALUES  
                        (  
                             @Version_ID  
                            ,@TransactionType_HierarchyParentSet  
                            ,0 -- OriginalTransaction_ID  
                            ,ws.[HierarchyID]  
                            ,@Entity_ID  
                            ,ws.MemberID  
                            ,ws.MemberMUID  
                            ,@MemberType_ID  
                            ,ws.MemberCode  
                            ,0 -- OldValue  
                            ,@RootCode -- OldCode  
                            ,0 -- NewValue  
                            ,@RootCode -- NewCode  
                            ,@CurrentTime  
                            ,@User_ID  
                            ,@CurrentTime  
                            ,@User_ID  
                        )  
                        OUTPUT                       inserted.ID,   ws.TransactionAnnotation  
                        INTO #TransactionAnnotations(TransactionID, Annotation);  
                        ');  
                        EXEC sp_executesql @SQL, N'@Version_ID INT, @TransactionType_HierarchyParentSet INT, @Entity_ID INT, @MemberType_ID TINYINT, @RootCode NVARCHAR(10), @CurrentTime DATETIME2(3), @User_ID INT',  
                                                    @Version_ID,     @TransactionType_HierarchyParentSet,     @Entity_ID,     @MemberType_ID,         @RootCode,              @CurrentTime,              @User_ID;  
  
                    END; -- IF exists mandatory explicit hierarchies.  
                END;-- IF added new members.  
  
                ----------------------------------------------------------------------------------------  
                -- Log attribute value change transactions.  
                ----------------------------------------------------------------------------------------  
                IF @HasAttributeChanges = 1  
                BEGIN  
                    IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Log attribute value change transactions.';  
  
                    SET @SQL = N'  
                    MERGE [mdm].' + QUOTENAME(@TransactionTableName) + N'  
                    USING  
                    (  
                        SELECT  
                             mws.MemberID  
                            ,mws.MemberMUID  
                            ,mws.MemberCode  
                            ,aws.AttributeID  
                            ,aws.PriorValueMapped  
                            ,aws.PriorValue  
                            ,aws.AttributeValueMapped  
                            ,aws.AttributeValue  
                            ,aws.TransactionAnnotation  
                        FROM #MemberAttributeWorkingSet aws  
                        INNER JOIN #MembersWorkingSet mws  
                        ON aws.MemberRowID = mws.Row_ID  
                        WHERE aws.ErrorCode IS NULL  
                    ) ws  
                    ON (1 = 0) -- An arbitrary condition that is always false, so that the NOT MATCHED block will always apply.  
                    WHEN NOT MATCHED THEN  
                    INSERT  
                    (  
                         Version_ID  
                        ,TransactionType_ID  
                        ,OriginalTransaction_ID  
                        ,Hierarchy_ID  
                        ,[Entity_ID]  
                        ,Attribute_ID  
                        ,Member_ID  
                        ,Member_MUID  
                        ,MemberType_ID  
                        ,MemberCode  
                        ,OldValue  
                        ,OldCode  
                        ,NewValue  
                        ,NewCode  
                        ,EnterDTM  
                        ,EnterUserID  
                        ,LastChgDTM  
                        ,LastChgUserID  
                    )  
                    VALUES  
                    (  
                         @Version_ID  
                        ,@TransactionType_Update -- TransactionType_ID  -- Attribute value change  
                        ,0 -- OriginalTransaction_ID  
                        ,NULL --HierarchyID  
                        ,@Entity_ID  
                        ,ws.AttributeID  
                        ,ws.MemberID  
                        ,ws.MemberMUID  
                        ,@MemberType_ID  
                        ,ws.MemberCode  
                        ,ws.PriorValueMapped -- OldValue  
                        ,ws.PriorValue     -- OldCode  
                        ,ws.AttributeValueMapped -- NewValue  
                        ,ws.AttributeValue     --NewCode  
                        ,@CurrentTime  
                        ,@User_ID  
                        ,@CurrentTime  
                        ,@User_ID  
                    )  
                    OUTPUT                       inserted.ID,   ws.TransactionAnnotation  
                    INTO #TransactionAnnotations(TransactionID, Annotation);  
                    ';  
                    EXEC sp_executesql @SQL, N'@Version_ID INT, @TransactionType_Update INT, @Entity_ID INT, @MemberType_ID TINYINT, @CurrentTime DATETIME2(3), @User_ID INT',  
                                               @Version_ID,     @TransactionType_Update,     @Entity_ID,     @MemberType_ID,         @CurrentTime,              @User_ID;  
                END;  
                ----------------------------------------------------------------------------------------  
                --Add any transaction annotations.  
                ----------------------------------------------------------------------------------------  
                IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Add any transaction annotations.';  
  
                SET @SQL = N'  
                INSERT INTO [mdm].' + QUOTENAME(@TransactionAnnotationTableName) + N'  
                (  
                     Version_ID  
                    ,Transaction_ID  
                    ,Comment  
                    ,EnterUserID  
                    ,EnterDTM  
                    ,LastChgDTM  
                    ,LastChgUserID  
                )  
                SELECT  
                     @Version_ID  
                    ,TransactionID  
                    ,Annotation  
                    ,@User_ID  
                    ,@CurrentTime  
                    ,@CurrentTime  
                    ,@User_ID  
                FROM #TransactionAnnotations  
                WHERE NULLIF(Annotation, N'''') IS NOT NULL  
                ';  
                EXEC sp_executesql @SQL, N'@Version_ID INT, @CurrentTime DATETIME2(3), @User_ID INT',  
                                           @Version_ID,     @CurrentTime,              @User_ID;  
            END -- IF @TransactionType = @TransactionType_Column  
  
            ----------------------------------------------------------------------------------------  
            -- Update the member security (MS) tables(s) as appropriate for the new/updated members.  
            --  
            -- Note that this is being done after writing to the log table, to avoid having the  
            -- Service Broker asynchronously kick off an expensive update to the MS table while the  
            -- expensive (but synchronous) log write is happening and slowing it down.  
            ----------------------------------------------------------------------------------------  
            IF @MemberType_ID = @MemberType_Leaf -- Member security only applies to Leaf members.  
            BEGIN  
                DECLARE @NeedToUpdateMemberSecurity BIT = 0;  
  
                ----------------------------------------------------------------------------------------  
                -- If member security applies to the current user then add rows to the MS table for new members, so that the creating user can access them.  
                ----------------------------------------------------------------------------------------  
                IF @MemberSecurity = 1  
                    AND EXISTS(SELECT 1 FROM #NewMembers)  
                BEGIN  
                    IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Add the appropriate member security records for new members.';  
                    -- Get the role for the user  
                    SELECT @SecurityRoleID = Role_ID  
                    FROM mdm.tblSecurityAccessControl  
                    WHERE   Principal_ID = @User_ID  
                        AND PrincipalType_ID = 1 /*User*/;  
  
                    -- Role ID can be null for a user when user permissions are inherited only from a group. The permission for the member added  
                    -- should be set to update for the user. This requires that the security role be added for the user.  
                    -- Correct security permissions are applied when the member security update batch process is run by the Service Broker.  
                    IF (@SecurityRoleID IS NULL)  
                    BEGIN  
                        DECLARE @Principal_Name NVARCHAR (100) = (SELECT UserName FROM mdm.tblUser WHERE ID = @User_ID);  
  
                        INSERT INTO mdm.tblSecurityRole  
                        (  
                             [Name]  
                            ,EnterUserID  
                            ,LastChgUserID  
                        )  
                        VALUES  
                        (  
                             CONCAT(N'Role for UserAccount ', @Principal_Name)  
                            ,@User_ID  
                            ,@User_ID  
                        );  
                        SET @SecurityRoleID = SCOPE_IDENTITY() ;  
  
                        INSERT INTO mdm.tblSecurityAccessControl  
                        (  
                             PrincipalType_ID  
                            ,Principal_ID  
                            ,Role_ID  
                            ,[Description]  
                            ,EnterUserID  
                            ,LastChgUserID  
                        )  
                        VALUES  
                        (  
                             @PrincipalType_User  
                            ,@User_ID  
                            ,@SecurityRoleID  
                            ,LEFT(@Principal_Name + N'UserAccount ', 110)  
                            ,@User_ID  
                            ,@User_ID  
                        );  
  
                        -- Since insert tblSecurityAccessControl will effect for security related views. Send the performance queue in this case. But only in this case.   
                        SET @PerformanceQueueSaveFlag = 1;  
                    END; -- IF (@SecurityRoleID IS NULL)  
  
                    -- Add records to the MS table for the user which created the members so the members will be visible to the creator  
                    SET @SQL = CONCAT(@TruncationGuard, N'  
                        INSERT INTO mdm.', @SecurityTableName, N'  
                        (  
                             Version_ID  
                            ,User_ID  
                            ,ID  
                            ,AccessPermission  
                        )  
                        SELECT  
                             @Version_ID  
                            ,@User_ID  
                            ,nm.MemberID  
                            ,', @AccessPermission_All, N'  
                        FROM #NewMembers AS nm  
                        ;');  
                    EXEC sp_executesql @SQL ,N'@Version_ID INT, @User_ID INT'  
                                            ,@Version_ID,       @User_ID;  
  
                    SET @NeedToUpdateMemberSecurity = 1;  
                END  -- IF new members created and current user has member security  
  
                IF @HasAttributeChanges = 1  
                BEGIN  
                    IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Determine if member security needs to be updated.';  
                    -- Determine if member security needs to be updated because either  
                    --  1. a DBA has been updated and that DBA's domain entity is a  
                    -- part of a derived hierarchy that has a member security permission, or  
                    --  2. New member(s) have been added and the current entity is part of a derived hierarchy with member security.  
                    --  
                    WITH changedDbaEntityId AS -- The domain entities of the domain-based attributes that have been updated.  
                    (  
                        SELECT DISTINCT  
                            att.Dba_Entity_ID AS [Entity_ID]  
                        FROM #MemberAttributeWorkingSet ws  
                        INNER JOIN #AttributeDefinition att  
                        ON ws.AttributeID = att.AttributeID  
                        WHERE   ws.ErrorCode IS NULL  
                            AND att.AttributeType_ID = @AttributeType_DBA  
                        UNION -- not "UNION ALL" because deduplication is needed  
  
                        -- Include the current Entity if new members were added.  
                        SELECT @Entity_ID  
                        WHERE EXISTS(SELECT 1 FROM #NewMembers)  
                    ),  
                    securedLevels AS -- The derived hierarchies that have member security, with their topmost level to which a member security assignment applies.  
                    (  
                        SELECT  
                             sram.DerivedHierarchy_ID  
                            ,MIN(CASE sram.Member_ID WHEN 0 THEN -1 ELSE lvl.LevelNumber END) AS LevelNumber -- If Member_ID is zero, then the permission applies to the ROOT (level -1) of the  hierarchy  
                        FROM mdm.tblSecurityRoleAccessMember sram  
                        LEFT JOIN mdm.viw_SYSTEM_SCHEMA_HIERARCHY_DERIVED_LEVELS lvl  
                        ON      sram.DerivedHierarchy_ID = lvl.Hierarchy_ID -- Explicit hierarchy member permissions are ignored since this sproc won't change EH parent-child relationships.  
                            AND sram.Version_ID = @Version_ID  
                            AND lvl.[Entity_ID] = sram.[Entity_ID]  
                        GROUP BY sram.DerivedHierarchy_ID  
                    ),  
                    securedEntityId AS -- The domain entities to which security applies  
                    (  
                        SELECT DISTINCT  
                            lvl.[Entity_ID]  
                        FROM mdm.viw_SYSTEM_SCHEMA_HIERARCHY_DERIVED_LEVELS lvl  
                        INNER JOIN securedLevels sec  
                        ON      lvl.Hierarchy_ID = sec.DerivedHierarchy_ID  
                            AND lvl.[Entity_ID] > 0  
                            AND lvl.LevelNumber > sec.LevelNumber -- Only domain entities underneath a member security assignment require the MS table to be recalculated  
                    ),  
                    updateNeeded AS  
                    (  
                        SELECT TOP 1  
                            1 UpdateNeeded  
                        FROM changedDbaEntityId dba  
                        INNER JOIN securedEntityId ent  
                        ON dba.[Entity_ID] = ent.[Entity_ID]  
                    )  
                    SELECT  
                        @NeedToUpdateMemberSecurity = UpdateNeeded  
                    FROM updateNeeded;  
                END; -- DBA changes  
  
                IF (@NeedToUpdateMemberSecurity = 1)  
                BEGIN  
                    ----------------------------------------------------------------------------------------  
                    -- Put a message onto the Service Broker queue to process member security.  
                    ----------------------------------------------------------------------------------------  
                    IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Put a message onto the Service Broker queue to process member security.';  
                    EXEC mdm.udpSecurityMemberQueueSave  
                        @User_ID    = NULL,-- update member security for all users  
                        @Version_ID = @Version_ID,  
                        @Entity_ID  = @Entity_ID;  
                END;  
  
            END; -- IF @MemberType_ID = @MemberType_Leaf  
  
            ----------------------------------------------------------------------------------------  
            --Done creating/updating members. Update the entity.  
            ----------------------------------------------------------------------------------------  
            IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Update the entity audit info.';  
            UPDATE mdm.tblEntity  
            SET  LastChgDTM = @CurrentTime  
                ,LastChgUserID = @User_ID  
                ,LastChgVersionID = @Version_ID  
            WHERE ID = @Entity_ID;  
  
            --------------------------------------------------  
            -- Return created members, if requested.  
            --------------------------------------------------  
            IF @ReturnCreatedMembers = 1  
            BEGIN  
                IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Return created members.';  
                SELECT  
                     MemberID  
                    ,MemberMUID  
                    ,MemberCode  
                    ,MemberName  
                FROM #NewMembers;  
            END;  
        END -- End update member table  
        ELSE  
        BEGIN  -- Begin update PD table  
            -- Insert the new members into the pending table.  
            IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Insert the new members into the pending table.';  
            SET @SQL = CONCAT(N'  
                INSERT mdm.', @PendingTableName, N'  
                (  
                     Version_ID  
                    ,CS_ID  
                    ,EN_ID  
                    ,Status_ID  
                    ,Name  
                    ,Code  
                    ,EnterDTM  
                    ,EnterUserID  
                    ,LastChgDTM  
                    ,LastChgUserID  
                    ,Revision_ID  
                    ,MUID  
                )  
                SELECT  
                    @Version_ID  
                    ,@Changeset_ID  
                    ,ws.MemberID  
                    ,', @MemberStatus_Active, '  
                    ,CASE WHEN ws.MemberID IS NULL THEN ws.MemberName ELSE NULL END  
                    ,CASE WHEN ws.MemberID IS NULL THEN ws.MemberCode ELSE NULL END  
                    ,@CurrentTime  
                    ,@User_ID  
                    ,@CurrentTime  
                    ,@User_ID  
                    ,MIN_ACTIVE_ROWVERSION() + ws.Row_ID - 1  
                    ,ws.MemberMUID  
                    FROM #MembersWorkingSet ws  
                    LEFT JOIN mdm.', @PendingTableName, N' m  
                    ON ws.MemberMUID = m.MUID AND m.Version_ID = @Version_ID AND m.CS_ID = @Changeset_ID  
                    WHERE ws.ErrorCode IS NULL  
                        AND m.MUID IS NULL;');  
  
            EXEC sp_executesql @SQL,  
                    N'@User_ID INT, @Version_ID INT, @Changeset_ID INT, @CurrentTime DATETIME2(3)',  
                      @User_ID,     @Version_ID,     @Changeset_ID,     @CurrentTime;  
  
            IF @ReturnCreatedMembers = 1  
            BEGIN  
                SELECT  
                     0 MemberID  
                    ,MemberMUID  
                    ,MemberCode  
                    ,MemberName  
                FROM #MembersWorkingSet  
                WHERE MemberID IS NULL  
                    AND ErrorCode IS NULL;  
            END;  
  
            IF EXISTS(SELECT 1 FROM #MemberAttributeWorkingSet WHERE ErrorCode IS NULL)  
            BEGIN  
                IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Update pending table.';  
                SET @SQL = CONCAT(N'  
;WITH ctePivotRowMerge AS  
(  
    SELECT  
         MemberRowID  
        ', @AttributeValueMappedAsColumns, N'  
    FROM #MemberAttributeWorkingSet  
    PIVOT  
    (  
        MAX(AttributeValueMapped)  
        FOR AttributeID IN (', @AttributeIdList, N')  
    ) AS P  
    WHERE   ErrorCode IS NULL  
    GROUP BY MemberRowID  
),  
ctePivotRowIsChanged AS  
(  
    SELECT  
         MemberRowID  
        ', @AttributeValueMappedAsColumns, N'  
    FROM (  
        SELECT MemberRowID, AttributeID, ErrorCode, CONVERT(TINYINT, IsChanged) IsChanged  
        FROM #MemberAttributeWorkingSet  
    ) source  
    PIVOT  
    (  
        MAX(IsChanged)  
        FOR AttributeID IN (', @AttributeIdList, N')  
    ) AS P  
    WHERE   ErrorCode IS NULL  
    GROUP BY MemberRowID  
)  
UPDATE m  
SET  
     LastChgDTM = @CurrentTime  
    ,LastChgUserID = @User_ID  
    ', @TableColumnsUpdateDefn, N'  
FROM #MembersWorkingSet mws  
INNER JOIN ctePivotRowMerge updates  
ON mws.Row_ID = updates.MemberRowID  
INNER JOIN ctePivotRowIsChanged isChanged  
ON mws.Row_ID = isChanged.MemberRowID  
INNER JOIN mdm.', QUOTENAME(@PendingTableName), N' AS m  
ON      m.Version_ID = @Version_ID   
    AND m.MUID = mws.MemberMUID  
    AND m.CS_ID = @Changeset_ID;')  
  
                IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT @SQL;  
  
                EXEC sp_executesql @SQL,  
                    N'@User_ID INT, @Version_ID INT, @Changeset_ID INT, @CurrentTime DATETIME2(3), @SysNull_Text NVARCHAR(1), @SysNull_Number DECIMAL(38,0), @SysNull_DateTime DATETIME2(3), @SysNull_ForeignKey INT',  
                      @User_ID,     @Version_ID,     @Changeset_ID,     @CurrentTime,              @SysNull_Text,              @SysNull_Number,               @SysNull_DateTime,              @SysNull_ForeignKey;  
            END;  
        END -- End update PD table  
  
        --------------------------------------------------  
        -- Commit transaction only if not nested.  
        --------------------------------------------------  
        IF @TranCounter = 0  
        BEGIN  
            IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Commit the transaction.';  
            COMMIT TRANSACTION;  
        END;  
  
        IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'Done.';  
  
        -- Send the message  
        IF @PerformanceQueueSaveFlag = 1  
        BEGIN  
	        EXEC mdm.udpPerformanceQueueSave;  
        END  
  
         RETURN 1;  
  
    END TRY  
    BEGIN CATCH  
  
        -- Get error info.  
        DECLARE  
            @ErrorMessage NVARCHAR(4000),  
            @ErrorSeverity INT,  
            @ErrorState INT,  
            @ErrorNumber INT,  
            @ErrorLine INT,  
            @ErrorProcedure NVARCHAR(126);  
        EXEC mdm.udpGetErrorInfo  
            @ErrorMessage = @ErrorMessage OUTPUT,  
            @ErrorSeverity = @ErrorSeverity OUTPUT,  
            @ErrorState = @ErrorState OUTPUT,  
            @ErrorNumber = @ErrorNumber OUTPUT,  
            @ErrorLine = @ErrorLine OUTPUT,  
            @ErrorProcedure = @ErrorProcedure OUTPUT  
  
        SET @ErrorMessage = CONCAT(@ErrorMessage, N', @ErrorNumber = ', @ErrorNumber, N', @ErrorProcedure = "', @ErrorProcedure, N'", line ', @ErrorLine);  
  
        -- Roll back the transaction.  
        IF @Debug = 1  
        BEGIN  
            DECLARE @LogMessage NVARCHAR(MAX) = N'Roll back the transaction. Error message: ' + COALESCE(@ErrorMessage, N'NULL');  
            /*EXEC mdm.udpLogMessage*/ PRINT @LogMessage;  
        END;  
  
        IF @TranCounter = 0 ROLLBACK TRANSACTION;  
        ELSE IF XACT_STATE() <> -1 ROLLBACK TRANSACTION TX;  
  
        RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);  
  
    END CATCH;  
  
    IF @Debug = 1 /*EXEC mdm.udpLogMessage*/ PRINT N'udpEntityMembersSave ended.'  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpEntityMembersUpdate]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
Description: Bulk updates entity member attribute values.  Input member attribute values are supplied in the form of a  
             Entity-Attribute-Value (EAV) table.  Through the use of the UNPIVOT and PIVOT commands this sproc is able  
             to update the entity member table in one UPDATE statment.  
  
Permission:  
---         MemberType, Attribute,    Member  
-- Create,  Create,     Create,       N/A  
-- Update,  N/A,        Update,       Update  
-- Merge,   Create,     CreateUpdate, Update  
-- Get,     N/A,        Read,         Read  
-- Delete   Delete,     N/A,          Delete  
  
The following are assumed validated prior to calling and are not validated here:  
    * User  
    * Version  
    * Entity  
    * Member Type  
  
    --Parameters  
    DECLARE  
        @User_ID                    INT = 1,  
        @Version_ID                    INT = 20,  
        @Entity_ID                    INT = 31,  
        @MemberType_ID                INT = 1,  
        @MemberAttributes            mdm.MemberAttributes,  
  
    --Sample parameter values  
    --No DBAs  
    INSERT INTO @MemberAttributes (MemberCode, AttributeName, AttributeValue)  
    VALUES  
         (N'A', N'ModelName', N'ABC')  
        ,(N'A', N'StandardCost', N'236.79')  
        ,(N'B', N'ModelName', N'ABC')  
        ,(N'A', N'StandardCost', N'143.65')  
    ;  
  
    With DBAs  
    INSERT INTO @MemberAttributes (MemberCode, AttributeName, AttributeValue)  
    VALUES  
         (N'A', N'ModelName', N'DEF')  
        ,(N'A', N'Color', N'Black')  
        ,(N'A', N'SubCategory', N'14')  
        ,(N'A', N'StandardCost', N'136.79')  
  
        ,(N'B', N'ModelName', N'DEF')  
        ,(N'B', N'Color', N'Black')  
        ,(N'B', N'SubCategory', N'14')  
        ,(N'A', N'StandardCost', N'343.65')  
    ;  
  
    Get all existing products.  Attributes: SubCategory, Color, StandardCost, ModelName  
    WITH cte AS (  
        SELECT  
            Code,  
            CONVERT(NVARCHAR(MAX),SubCategory) AS SubCategory,  
            CONVERT(NVARCHAR(MAX),Color) AS Color,  
            CONVERT(NVARCHAR(MAX),StandardCost) AS StandardCost,  
            CONVERT(NVARCHAR(MAX),ModelName) AS ModelName  
        FROM mdm.viw_SYSTEM_7_31_CHILDATTRIBUTES AS m  
        WHERE m.Version_ID = @Version_ID  
    )  
    INSERT INTO @MemberAttributes (MemberCode, AttributeName, AttributeValue)  
    SELECT Code, priorPivot.AttributeName, priorPivot.AttributeValue  
    FROM  (  
        select Code, U.AttributeName, U.AttributeValue  
        FROM cte  
        UNPIVOT  
        (AttributeValue FOR AttributeName IN (SubCategory, Color, StandardCost, ModelName))    AS U  
        ) priorPivot;  
  
EXEC mdm.udpEntityMembersUpdate @User_ID, @Version_ID, @Entity_ID, @MemberType_ID, @MemberAttributes, 1, 0;  
  
--For new members where we want to ignore prior values  
EXEC mdm.udpEntityMembersUpdate @User_ID, @Version_ID, @Entity_ID, @MemberType_ID, @MemberAttributes, 1, 0, 1;  
  
*/  
CREATE PROCEDURE [mdm].[udpEntityMembersUpdate]  
(  
    @User_ID                    INT,  
    @Version_ID                 INT,  
    @Entity_ID                  INT,  
    @MemberType_ID              TINYINT,  
    @MemberAttributes           mdm.MemberAttributes READONLY,  
    @LogFlag                    INT = NULL, --1 = Log anything else = NotLog  
    @DoInheritanceRuleCheck     BIT = NULL, -- Only set to 1 from C#  
    --This flag instructs udpEntityMembersUpdate to not try and retrieve prior values for the attributes  
    --being updated. We turn this on when calling this SPROC during an update because we know there will  
    --be no prior values to retrieve  
    @IgnorePriorValues          BIT = 0,  
    @ValidateDataTypes          BIT = 1, -- Do not set to 0 unless the data types have been validated before calling this sproc. Otherwise, unhandled convert errors may be thrown.  
    @ShouldReturnMembersWithErrorsAsXml  BIT = 0, -- Default to not return the xml  
    @Return_MembersWithErrors   XML = NULL OUTPUT    ,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE  
         @TableName                         SYSNAME  
        ,@AnnotationTableName               SYSNAME  
        ,@GetHistoryOutputQuery             NVARCHAR(MAX)  
        ,@ViewName                          SYSNAME  
        ,@TableColumn                       SYSNAME  
        ,@SQL                               NVARCHAR(MAX) = N''  
        ,@ValidationStatus                  INT  
        ,@Model_ID                          INT  
        ,@EntityTable                       SYSNAME  
        ,@HierarchyParentTable              SYSNAME  
        ,@CollectionTable                   SYSNAME  
        ,@IsCollectionEnabled               BIT  
        ,@IsHierarchyEnabled                BIT  
        ,@RequireApproval                   BIT  
        ,@HasDba                            BIT  
        ,@HasFile                           BIT  
        ,@RecursiveHierarchy_ID             INT = 0  
        ,@RecursiveHierarchyAttribute_ID    INT = 0  
        ,@RecursiveHierarchyMaxLevel        INT = 0  
        ,@DependentEntityTable              SYSNAME  
        ,@DependentAttributeName            SYSNAME  
        ,@DependentAttributeColumnName      SYSNAME  
        ,@ErrorCode                         INT  
        ,@ErrorObjectType                   INT  
        ,@Counter                           INT = 1  
        ,@MaxCounter                        INT  
  
        ,@TransactionLogType            TINYINT  
        ,@TransactionLogType_Attribute  TINYINT = 1  
        ,@TransactionLogType_Member     TINYINT = 2  
        ,@TransactionLogType_None       TINYINT = 3  
  
        --Member Types  
        ,@MemberType_Leaf               TINYINT = 1  
        ,@MemberType_Consolidated       TINYINT = 2  
        ,@MemberType_Collection         TINYINT = 3  
  
        --Attribute Types  
        ,@AttributeType_FreeForm        INT = 1  
        ,@AttributeType_DBA             INT = 2  
        ,@AttributeType_File            INT = 4  
  
        --Attribute DataTypes  
        ,@AttributeDataType_Text        INT = 1  
        ,@AttributeDataType_Number      INT = 2  
        ,@AttributeDataType_DateTime    INT = 3  
        ,@AttributeDataType_Link        INT = 6  
  
        --Table column SQL snippets  
        ,@TableColumns                  NVARCHAR(MAX) = N''  
        ,@TableColumnsDba               NVARCHAR(MAX) = N''  
        ,@TableColumnsFile              NVARCHAR(MAX) = N''  
        ,@TableColumnsPivotDefn         NVARCHAR(MAX) = N''  
        ,@TableColumnsUnPivotDefn       NVARCHAR(MAX) = N''  
        ,@TableColumnsUnPivotDbaDefn    NVARCHAR(MAX) = N''  
        ,@TableColumnsUnPivotFileDefn   NVARCHAR(MAX) = N''  
        ,@TableColumnsUpdateDefn        NVARCHAR(MAX) = N''  
        ,@TableColumnsUpdateDbaIdsDefn  NVARCHAR(MAX) = N''  
  
        --Validation Statuses  
        ,@ValidationStatus_Succeeded                            INT = 3  
        ,@ValidationStatus_AwaitingRevalidation                 INT = 4  
        ,@ValidationStatus_AwaitingDependentMemberRevalidation  INT = 5  
  
        --Error ObjectTypes  
        ,@ObjectType_MemberCode         INT = 12  
        ,@ObjectType_MemberAttribute    INT = 22  
  
        --Error Codes  
        ,@ErrorCode_ReservedWord                                INT = 110006  
        ,@ErrorCode_AttributeValueLengthGreaterThanMaximum      INT = 110017  
        ,@ErrorCode_NoPermissionForThisOperationOnThisObject    INT = 120003  
        ,@ErrorCode_DuplicateInputMemberCodes                   INT = 210001  
        ,@ErrorCode_InvalidMemberCode                           INT = 300002  
        ,@ErrorCode_MemberCodeExists                            INT = 300003  
        ,@ErrorCode_InvalidAttribute                            INT = 300010  
        ,@ErrorCode_ReadOnlyAttribute                           INT = 300014  
        ,@ErrorCode_MemberCausesCircularReference               INT = 300020  
        ,@ErrorCode_InvalidFlatEntityForMemberCreate            INT = 310021  
        ,@ErrorCode_InvalidBlankMemberCode                      INT = 310022  
        ,@ErrorCode_InvalidAttributeValueForDataType            INT = 310033  
        ,@ErrorCode_InvalidAttributeValueForMember              INT = 310042  
  
        ,@UseMemberSecurity             BIT = 0  
        ,@DBAUseMemberSecurity          BIT = 0  
        ,@IsAdmin                       BIT = 0  
  
        --Permission  
        ,@MemberType_Permission         TINYINT  
        ,@Permission_None               INT = 0  
        ,@Permission_Deny               INT = 1  
        ,@Permission_Access             INT = 4  
        ,@Permission_Inferred           INT = 99  
  
        ,@AccessPermission_None        TINYINT = 0  
        ,@AccessPermission_Read        TINYINT = 0  
        ,@AccessPermission_Create      TINYINT = 1  
        ,@AccessPermission_Update      TINYINT = 2  
        ,@AccessPermission_All         TINYINT = 7  
  
        ,@MemberIds                        mdm.MemberId  
  
        --Special value that input attribute NULL values get mapped to.  
        ,@SysNull_Text          NVARCHAR(50) = CONCAT(N'#SysNull#-', NEWID()) --Adding a GUID to guarantee uniqueness.  
        ,@SysNull_Number        INT = CONVERT(INT, -2147483648) --Lower bound of INT  
        ,@SysNull_DateTime      DATETIME2(3) = GETUTCDATE() --Get current date and time  
  
        --Values to track recursive derived hierarchy circular reference issues  
        ,@CircularReferenceErrors INT = 0  
  
        --Store the current time for use in this SPROC  
        ,@CurrentTime           DATETIME2(3) = GETUTCDATE()  
  
        --Transaction type for entity member update  
        ,@TransactionType_Update INT = 3  
  
        --Is the entity code gen enabled  
        ,@CodeGenEnabled BIT = 0  
  
        ,@GuidEmpty                     UNIQUEIDENTIFIER = CAST(0x0 AS UNIQUEIDENTIFIER)  
  
        --Transaction and annotation table names  
        ,@TransactionTableName              SYSNAME  
        ,@TransactionAnnotationTableName    SYSNAME  
        ,@ValidationLogTableName            SYSNAME  
    ;  
    DECLARE @MemberPermissions AS TABLE (ID INT, MemberType_ID INT, Privilege_ID INT, AccessPermission TINYINT);  
    DECLARE @SysNullDataTypeMap AS TABLE (AtributeType_ID INT, DataType_ID INT, SysNullName NVARCHAR(20), SysNullValue NVARCHAR(60));  
  
    ----------------------------------------------------------------------------------------  
    --Temporary tables  
    --  These must be temp tables vs. table variables because we need to reference them  
    --  in dynamic SQL.  
    ----------------------------------------------------------------------------------------  
    --Working set and the final results to be returned.  
    CREATE TABLE #MemberAttributeWorkingSet  
        (  
          Row_ID                INT IDENTITY(1,1) NOT NULL  
         ,Member_ID             INT NULL  
         ,Member_MUID           UNIQUEIDENTIFIER NULL  
         ,MemberCode            NVARCHAR(250) COLLATE DATABASE_DEFAULT NULL  
         ,MemberName            NVARCHAR(MAX) COLLATE DATABASE_DEFAULT NULL  
         ,Attribute_ID          INT NULL  
         ,AttributeName         NVARCHAR(100) COLLATE DATABASE_DEFAULT NULL  
         ,AttributeValue        NVARCHAR(MAX) COLLATE DATABASE_DEFAULT NULL  
         ,AttributeValueMapped  NVARCHAR(MAX) COLLATE DATABASE_DEFAULT NULL  
         ,PriorValue            NVARCHAR(MAX) COLLATE DATABASE_DEFAULT NULL  
         ,PriorValueMapped      NVARCHAR(MAX) COLLATE DATABASE_DEFAULT NULL  
         ,PriorFileId           NVARCHAR(MAX) COLLATE DATABASE_DEFAULT NULL  
         ,IsChanged             BIT NULL  
         ,ChangeTrackingMask    INT NULL  
         ,ErrorCode             INT NULL  
         ,ErrorObjectType       INT NULL  
         ,TransactionAnnotation NVARCHAR(MAX) COLLATE DATABASE_DEFAULT NULL  
        );  
        CREATE NONCLUSTERED INDEX #ix_MemberAttributeWorkingSet_Member_ID ON #MemberAttributeWorkingSet(Member_ID);  
        CREATE NONCLUSTERED INDEX #ix_MemberAttributeWorkingSet_MemberCode ON #MemberAttributeWorkingSet(MemberCode);  
        CREATE NONCLUSTERED INDEX #ix_MemberAttributeWorkingSet_AttributeName ON #MemberAttributeWorkingSet(AttributeName);  
  
    --Store attribute definitions for attributes being updated.  
    CREATE TABLE #AttributeDefinition  
        (  
          Row_ID                        INT IDENTITY(1,1) NOT NULL  
         ,AttributeName                 NVARCHAR(100) COLLATE DATABASE_DEFAULT NULL  
         ,Attribute_ID                  INT NULL  
         ,Attribute_MUID                UNIQUEIDENTIFIER NULL  
         ,IsSystem                      BIT  
         ,AttributeType_ID              TINYINT NULL  
         ,DataType_ID                   TINYINT NULL  
         ,DataTypeInformation           INT NULL  
         ,Dba_Entity_ID                 INT NULL  
         ,Dba_Entity_Table_Name         SYSNAME COLLATE DATABASE_DEFAULT NULL  
         ,ChangeTrackingGroup_ID        INT NULL  
         ,TableColumn                   SYSNAME COLLATE DATABASE_DEFAULT NULL  
         ,TableColumnPivotDefn          NVARCHAR(MAX) COLLATE DATABASE_DEFAULT NULL  
         ,TableColumnUnPivotDefn        NVARCHAR(MAX) COLLATE DATABASE_DEFAULT NULL  
         ,TableColumnUnPivotDbaDefn     NVARCHAR(MAX) COLLATE DATABASE_DEFAULT NULL  
         ,TableColumnUnPivotFileDefn    NVARCHAR(MAX) COLLATE DATABASE_DEFAULT NULL  
         ,TableColumnUpdateDefn         NVARCHAR(MAX) COLLATE DATABASE_DEFAULT NULL  
         ,TableColumnUpdateDbaIdsDefn   NVARCHAR(MAX) COLLATE DATABASE_DEFAULT NULL  
        );  
        CREATE UNIQUE CLUSTERED INDEX #ix_AttributeDefinition_Attribute_ID ON #AttributeDefinition(Attribute_ID);  
        CREATE UNIQUE NONCLUSTERED INDEX #ix_AttributeDefinition_AttributeName ON #AttributeDefinition(AttributeName);  
  
    ----------------------------------------------------------------------------------------  
    -- Insert attribute values into working set.  
    -- Trim codes, attribute names, etc.  
    ----------------------------------------------------------------------------------------  
    INSERT INTO #MemberAttributeWorkingSet  
        (MemberCode, Member_MUID, AttributeName, AttributeValue, AttributeValueMapped, TransactionAnnotation)  
    SELECT  
         NULLIF(LTRIM(RTRIM(MemberCode)), N'')  
        ,NULLIF(MemberMUID, @GuidEmpty)  
        ,NULLIF(LTRIM(RTRIM(AttributeName)), N'')  
        ,LTRIM(RTRIM(AttributeValue))  
        ,LTRIM(RTRIM(AttributeValue))  
        ,NULLIF(LTRIM(RTRIM(TransactionAnnotation)), N'')  
    FROM @MemberAttributes  
  
     ----------------------------------------------------------------------------------------  
    --Get Entity information.  
    ----------------------------------------------------------------------------------------  
  
    SELECT  
         @EntityTable = EntityTable  
        ,@HierarchyParentTable = HierarchyParentTable  
        ,@CollectionTable = CollectionTable  
        ,@IsCollectionEnabled = CASE WHEN CollectionTable IS NULL THEN 0 ELSE 1 END  
        ,@IsHierarchyEnabled  = CASE WHEN HierarchyTable  IS NULL THEN 0 ELSE 1 END  
        ,@Model_ID = Model_ID  
        ,@TransactionLogType = CASE @LogFlag WHEN 1 THEN TransactionLogType ELSE @TransactionLogType_None END  
        ,@RequireApproval = RequireApproval  
    FROM  
        mdm.tblEntity WHERE ID = @Entity_ID;  
  
    IF @RequireApproval = 1 AND @MemberType_ID = @MemberType_Leaf  
    BEGIN  
        RAISERROR('MDSERR300023|The entity requires approval for leaf member changes.', 16, 1);  
        RETURN;  
    END;  
  
    --Get transaction and annotation table names  
    SET @ValidationLogTableName = mdm.udfGetValidationLogTableName(@Model_ID);  
  
    SELECT @ViewName = mdm.udfViewNameGetByID(@Entity_ID, @MemberType_ID, 0, 0);  
  
    ----------------------------------------------------------------------------------------  
    --Check to see if the entity has a hierarchy  
    ----------------------------------------------------------------------------------------  
  
    IF     (@IsCollectionEnabled = 0 AND @MemberType_ID = @MemberType_Collection)  
        OR (@IsHierarchyEnabled = 0  AND @MemberType_ID = @MemberType_Consolidated)  
    BEGIN  
        UPDATE #MemberAttributeWorkingSet  
            SET ErrorCode = @ErrorCode_InvalidFlatEntityForMemberCreate,  
                ErrorObjectType = @ObjectType_MemberCode  
        WHERE ErrorCode IS NULL;  
    END  
  
    --Figure out whether code generation is enabled  
    DECLARE @result INT;  
    EXEC @result = mdm.udpIsCodeGenEnabled @Entity_ID;  
    SET @CodeGenEnabled = CONVERT(BIT, @result);  
  
    IF @MemberType_ID =  @MemberType_Leaf  
    BEGIN  
        SELECT @TableName = @EntityTable;  
    END  
    ELSE  
    IF @MemberType_ID =  @MemberType_Consolidated  
    BEGIN  
        SELECT @TableName = @HierarchyParentTable;  
    END  
    ELSE  
    IF @MemberType_ID =  @MemberType_Collection  
    BEGIN  
        SELECT @TableName = @CollectionTable;  
    END  
  
    IF @TransactionLogType = @TransactionLogType_Member  
    BEGIN  
        SET @AnnotationTableName = CONVERT(SYSNAME, @TableName + N'_AN');  
        SET @GetHistoryOutputQuery = mdm.udfGetHistoryOutputQuery(@Entity_ID, @MemberType_ID, NULL, NULL);  
    END  
    ELSE IF @TransactionLogType = @TransactionLogType_Attribute  
    BEGIN  
        SET @TransactionTableName = mdm.udfGetTransactionTableName(@Model_ID);  
        SET @TransactionAnnotationTableName = mdm.udfGetTransactionAnnotationTableName(@Model_ID);  
    END  
  
    ----------------------------------------------------------------------------------------  
    --Load SysNull Datatype mappings.  Have to have separate INSERT statements because  
    --SysNullValue contains different datatypes.  
    ----------------------------------------------------------------------------------------  
    INSERT INTO @SysNullDataTypeMap (AtributeType_ID, DataType_ID, SysNullName, SysNullValue) VALUES (@AttributeType_FreeForm, @AttributeDataType_Text, N'@SysNull_Text', @SysNull_Text)  
    INSERT INTO @SysNullDataTypeMap (AtributeType_ID, DataType_ID, SysNullName, SysNullValue) VALUES (@AttributeType_FreeForm, @AttributeDataType_Number, N'@SysNull_Number', CONVERT(NVARCHAR(60), @SysNull_Number))  
    INSERT INTO @SysNullDataTypeMap (AtributeType_ID, DataType_ID, SysNullName, SysNullValue) VALUES (@AttributeType_FreeForm, @AttributeDataType_DateTime, N'@SysNull_DateTime', CONVERT(NVARCHAR(60), @SysNull_DateTime))  
    INSERT INTO @SysNullDataTypeMap (AtributeType_ID, DataType_ID, SysNullName, SysNullValue) VALUES (@AttributeType_FreeForm, @AttributeDataType_Link, N'@SysNull_Text', @SysNull_Text)  
    INSERT INTO @SysNullDataTypeMap (AtributeType_ID, DataType_ID, SysNullName, SysNullValue) VALUES (@AttributeType_DBA, @AttributeDataType_Text,N'@SysNull_Number' , CONVERT(NVARCHAR(60), @SysNull_Number))  
    INSERT INTO @SysNullDataTypeMap (AtributeType_ID, DataType_ID, SysNullName, SysNullValue) VALUES (@AttributeType_File, @AttributeDataType_Link, N'@SysNull_Number', CONVERT(NVARCHAR(60), @SysNull_Number))  
  
    ----------------------------------------------------------------------------------------  
    --Get attribute definitions  
    ----------------------------------------------------------------------------------------  
  
    ;WITH cteUniqueAttributeNames AS  
    (  
        SELECT DISTINCT AttributeName FROM #MemberAttributeWorkingSet  
    )  
    INSERT INTO #AttributeDefinition  
    (  
        Attribute_ID,  
        Attribute_MUID,  
        IsSystem,  
        AttributeName,  
        AttributeType_ID,  
        DataType_ID,  
        DataTypeInformation,  
        Dba_Entity_ID,  
        Dba_Entity_Table_Name,  
        ChangeTrackingGroup_ID,  
        TableColumn,  
        TableColumnPivotDefn,  
        TableColumnUnPivotDefn,  
        TableColumnUnPivotDbaDefn,  
        TableColumnUpdateDbaIdsDefn,  
        TableColumnUpdateDefn,  
        TableColumnUnPivotFileDefn  
    )  
    SELECT DISTINCT  
         att.Attribute_ID  
        ,att.Attribute_MUID  
        ,att.Attribute_IsSystem  
        ,att.Attribute_Name  
        ,att.Attribute_Type_ID  
        ,att.Attribute_DataType_ID  
        ,att.Attribute_DataType_Information  
        ,att.Attribute_DBAEntity_ID  
        ,dbaEnt.EntityTable  
        ,att.Attribute_ChangeTrackingGroup  
        ,att.Attribute_Column  
        ,N'MAX(' + Quotename(att.Attribute_Name) + N') AS ' + att.Attribute_Column -- TableColumnPivotDefn  
        ,N'CONVERT(NVARCHAR(MAX),' + Quotename(att.Attribute_Name) + N') AS ' + Quotename(att.Attribute_Name) -- TableColumnUnPivotDefn  
        ,CASE  
            WHEN att.Attribute_Type_ID = @AttributeType_DBA  
            THEN N'CONVERT(NVARCHAR(MAX),' + Quotename(att.Attribute_Name + N'.ID') + N') AS ' + Quotename(att.Attribute_Name)  
            ELSE N''  
         END -- TableColumnUnPivotDbaDefn  
        ,CASE  
            WHEN att.Attribute_Type_ID = @AttributeType_DBA  
            THEN N'SELECT ID, Code, ' + CONVERT(NVARCHAR(20), att.Attribute_ID) + N' AS Attribute_ID FROM mdm.' + dbaEnt.EntityTable + N' WHERE Version_ID = @Version_ID AND Status_ID = 1'  
            ELSE N''  
         END -- TableColumnUpdateDbaIdsDefn  
        ,CASE  
            WHEN att.Attribute_Name = N'Code'  
            THEN N'm.' + att.Attribute_Column + N'=COALESCE(updates.' + att.Attribute_Column + N',m.' + att.Attribute_Column + N')'  
  
            --Special handling for Owner_ID on collection members because in tblAttribute this  
            --attribute is registered as text. However, the column itself is an int. If we don't  
            --add this handling, the ELSE logic will try and put SysNull_Text as the relevant null value. We  
            --don't care about null values because the user can't possibly supply a null value (there will always  
            --be at least one user on the application)  
            WHEN att.Attribute_Name = N'Owner_ID' AND @MemberType_ID = 3  
            THEN N'm.' + att.Attribute_Column + N'=COALESCE(updates.' + att.Attribute_Column + N',m.' + att.Attribute_Column + N')'  
  
            ELSE  
                N'm.' + att.Attribute_Column + N'=NULLIF(COALESCE(updates.' + att.Attribute_Column + N', m.' + att.Attribute_Column + '),' + m.SysNullName + N')'  
         END -- TableColumnUpdateDefn  
         ,CASE  
            WHEN att.Attribute_Type_ID = @AttributeType_File  
            THEN N'CONVERT(NVARCHAR(MAX),' + Quotename(att.Attribute_Name + N'.ID') + N') AS ' + Quotename(att.Attribute_Name)  
            ELSE N''  
          END -- TableColumnUnPivotFileDefn  
    FROM  
        cteUniqueAttributeNames AS ws  
    INNER JOIN mdm.viw_SYSTEM_SCHEMA_ATTRIBUTES att  
        ON att.Attribute_Name = ws.AttributeName  
        AND att.Entity_ID = @Entity_ID  
        AND att.Attribute_MemberType_ID = @MemberType_ID  
    INNER JOIN @SysNullDataTypeMap m  
        ON m.AtributeType_ID = att.Attribute_Type_ID  
        AND m.DataType_ID = att.Attribute_DataType_ID  
    LEFT JOIN mdm.tblEntity dbaEnt  
        ON dbaEnt.ID = att.Attribute_DBAEntity_ID;  
  
    ----------------------------------------------------------------------------------------  
    --Update working set with Attribute_IDs  
    --Also update any DBA attribute values that were sent in as empty strings to NULL  
    ----------------------------------------------------------------------------------------  
  
    UPDATE ws SET  
           ws.Attribute_ID = att.Attribute_ID,  
           ws.AttributeValue =       CASE WHEN att.AttributeType_ID = @AttributeType_DBA THEN NULLIF(ws.AttributeValue, N'') ELSE ws.AttributeValue END,  
           ws.AttributeValueMapped = CASE WHEN att.AttributeType_ID = @AttributeType_DBA THEN NULLIF(ws.AttributeValue, N'') ELSE ws.AttributeValueMapped END  
    FROM #MemberAttributeWorkingSet AS ws  
    INNER JOIN #AttributeDefinition AS att  
        ON  ws.AttributeName = att.AttributeName;  
  
    --If any Attribute_IDs are null then the attribute name is invalid.  
    UPDATE ws SET  
           ErrorCode = @ErrorCode_InvalidAttribute,  
           ErrorObjectType = @ObjectType_MemberAttribute  
    FROM #MemberAttributeWorkingSet AS ws  
    WHERE ws.Attribute_ID IS NULL  
    AND ErrorCode IS NULL;  
  
    ----------------------------------------------------------------------------------------  
    --Get Member IDs  
    ----------------------------------------------------------------------------------------  
    SET @SQL = N'  
        UPDATE ws  
        SET Member_ID = m.ID, MemberName = m.Name, Member_MUID = m.MUID, MemberCode = m.Code  
        FROM mdm.' + @TableName + N' AS m  
        INNER JOIN #MemberAttributeWorkingSet AS ws  
            ON (ws.MemberCode IS NULL OR ws.MemberCode = m.Code)  
                AND (ws.Member_MUID IS NULL OR ws.Member_MUID = m.MUID)  
                AND m.Version_ID = @Version_ID  
        WHERE COALESCE(m.Status_ID,0) = 1;'; --WHERE includes only active members (e.g. does not include soft deleted members)  
    --PRINT(@SQL);  
    EXEC sp_executesql @SQL, N'@Version_ID INT', @Version_ID;  
  
    -- Invalid member code check  
    UPDATE #MemberAttributeWorkingSet  
        SET ErrorCode = @ErrorCode_InvalidMemberCode,  
            ErrorObjectType = @ObjectType_MemberAttribute  
    WHERE Member_ID IS NULL  
  
    ----------------------------------------------------------------------------------------  
    --Check security  
    ----------------------------------------------------------------------------------------  
    --Check Object Permissions.  Mark any attributes the user doesn't have permission to.  
  
    SELECT @MemberType_Permission = Privilege_ID,  
        @IsAdmin = IsAdmin  
    FROM mdm.viw_SYSTEM_SECURITY_USER_MEMBERTYPE  
    WHERE [User_ID] = @User_ID  
        AND [Entity_ID] = @Entity_ID  
        AND ID = @MemberType_ID;  
      
    IF @IsAdmin != 1  
    BEGIN  
        SET @MemberType_Permission = COALESCE(@MemberType_Permission, @Permission_Deny);  
        SET @UseMemberSecurity = mdm.udfUseMemberSecurity(@User_ID, @Entity_ID, @Version_ID, @MemberType_ID);  
  
        IF @MemberType_Permission = @Permission_Deny  
        BEGIN  
            UPDATE #MemberAttributeWorkingSet  
            SET ErrorCode = @ErrorCode_NoPermissionForThisOperationOnThisObject,  
                ErrorObjectType = @ObjectType_MemberCode;  
        END  
        ELSE  
        BEGIN  
            DECLARE @RequiredAttributeAccessPermission TINYINT = @AccessPermission_Update  
            UPDATE ws  
            SET  
                ErrorCode =  
                    CASE COALESCE(attsec.Privilege_ID, 0)  
                        WHEN @Permission_Access THEN CASE attsec.AccessPermission & @AccessPermission_Update WHEN @AccessPermission_Update THEN NULL ELSE @ErrorCode_ReadOnlyAttribute END  
                        WHEN @Permission_Inferred THEN @ErrorCode_ReadOnlyAttribute  
                        WHEN @Permission_Deny THEN @ErrorCode_InvalidAttribute  
                        WHEN @Permission_None THEN @ErrorCode_InvalidAttribute  
                    END  
                ,ErrorObjectType = @ObjectType_MemberAttribute  
            FROM #MemberAttributeWorkingSet AS ws  
            LEFT JOIN mdm.viw_SYSTEM_SECURITY_USER_ATTRIBUTE attsec  
                ON ws.Attribute_ID = attsec.ID AND attsec.User_ID = @User_ID  
            WHERE ws.ErrorCode IS NULL AND NOT (COALESCE(attsec.Privilege_ID, @Permission_Deny) = @Permission_Access AND (COALESCE(attsec.AccessPermission, @AccessPermission_None) & @RequiredAttributeAccessPermission) = @RequiredAttributeAccessPermission)  
  
            --Check Member Permissions.  Mark any members the user doesn't have permission to.  
            IF @UseMemberSecurity = 1  
            BEGIN  
                INSERT INTO @MemberIds (ID, MemberType_ID)  
                SELECT  
                    DISTINCT  
                     ws.Member_ID  
                    ,@MemberType_ID  
                FROM #MemberAttributeWorkingSet ws  
                WHERE Member_ID IS NOT NULL  
                AND ErrorCode IS NULL;  
  
                INSERT INTO @MemberPermissions  
                EXEC mdm.udpSecurityMembersResolverGet @User_ID, @Version_ID, @Entity_ID, @MemberIds  
  
                DECLARE @RequiredMemberAccessPermission TINYINT = @AccessPermission_Update  
  
                UPDATE ws  
                SET ErrorCode = @ErrorCode_NoPermissionForThisOperationOnThisObject,  
                    ErrorObjectType = @ObjectType_MemberCode  
                FROM #MemberAttributeWorkingSet ws  
                INNER JOIN @MemberPermissions prm  
                    ON ws.Member_ID = prm.ID  
                WHERE NOT (COALESCE(prm.Privilege_ID, @Permission_Deny) = @Permission_Access AND (COALESCE(prm.AccessPermission, @AccessPermission_None) & @RequiredMemberAccessPermission) = @RequiredMemberAccessPermission);  
            END  
        END;  
    END  
  
    --Exit now if we have no members to update because user doesn't have necessary security or  
    --user doesn't have necessary permission to any attribute or all attributes are invalid.  
    IF ((SELECT COUNT(*) FROM #MemberAttributeWorkingSet WHERE ErrorCode IS NULL) = 0) OR  
       ((SELECT COUNT(*) FROM #MemberAttributeWorkingSet WHERE Attribute_ID IS NOT NULL) = 0) OR  
       ((SELECT COUNT(*) FROM #MemberAttributeWorkingSet WHERE Member_ID IS NOT NULL) = 0)  
    BEGIN  
        SELECT DISTINCT  
             ws.Member_ID  
            ,ws.MemberCode  
            ,ws.MemberName  
            ,ad.Attribute_MUID  
            ,ws.AttributeName  
            ,ws.ErrorCode  
            ,ws.ErrorObjectType  
        FROM #MemberAttributeWorkingSet ws  
        LEFT OUTER JOIN #AttributeDefinition ad  
            ON ws.Attribute_ID = ad.Attribute_ID  
        WHERE ErrorCode IS NOT NULL  
        RETURN(0);  
    END  
  
    IF EXISTS(SELECT 1 FROM #AttributeDefinition WHERE Dba_Entity_ID > 0)  
        SELECT @HasDba = 1  
    ELSE  
        SELECT @HasDba = 0; -- Can skip DBA processing  
  
    IF EXISTS(SELECT 1 FROM #AttributeDefinition WHERE AttributeType_ID = @AttributeType_File)  
        SELECT @HasFile = 1  
    ELSE  
        SELECT @HasFile = 0 -- No file attributes to update  
  
    ----------------------------------------------------------------------------------------  
    --Set column name strings.  
    ----------------------------------------------------------------------------------------  
    SELECT @TableColumns += ',' + Quotename(AttributeName) FROM #AttributeDefinition ORDER BY Attribute_ID;  
    SELECT @TableColumns = RIGHT(@TableColumns, LEN(@TableColumns)-1) -- remove leading comma;  
    SELECT @TableColumnsPivotDefn +=  N',' + TableColumnPivotDefn FROM #AttributeDefinition ORDER BY Attribute_ID;  
    SELECT @TableColumnsUnPivotDefn +=  N',' + TableColumnUnPivotDefn FROM #AttributeDefinition ORDER BY Attribute_ID;  
    SELECT @TableColumnsUpdateDefn +=  N',' + TableColumnUpdateDefn FROM #AttributeDefinition ORDER BY Attribute_ID;  
    If @HasDba = 1 BEGIN  
        SELECT @TableColumnsDba += ',' + Quotename(AttributeName) FROM #AttributeDefinition WHERE Dba_Entity_ID > 0 ORDER BY Attribute_ID;  
        SELECT @TableColumnsDba = RIGHT(@TableColumnsDba, LEN(@TableColumnsDba)-1) -- remove leading comma;  
        SELECT @TableColumnsUpdateDbaIdsDefn += N' UNION ' + TableColumnUpdateDbaIdsDefn FROM #AttributeDefinition WHERE Dba_Entity_ID > 0 ORDER BY Attribute_ID;  
        SELECT @TableColumnsUpdateDbaIdsDefn = RIGHT(@TableColumnsUpdateDbaIdsDefn, LEN(@TableColumnsUpdateDbaIdsDefn)-7) -- remove leading comma;  
        SELECT @TableColumnsUnPivotDbaDefn +=  N',' + TableColumnUnPivotDbaDefn FROM #AttributeDefinition WHERE Dba_Entity_ID > 0 ORDER BY Attribute_ID;  
    END  
    IF @HasFile = 1 BEGIN  
        SELECT @TableColumnsFile += N',' + Quotename(AttributeName) FROM #AttributeDefinition WHERE AttributeType_ID = @AttributeType_File ORDER BY Attribute_ID;  
        SELECT @TableColumnsFile = RIGHT(@TableColumnsFile, LEN(@TableColumnsFile)-1) -- remove leading comma;  
        SELECT @TableColumnsUnPivotFileDefn +=  N',' + TableColumnUnPivotFileDefn FROM #AttributeDefinition WHERE AttributeType_ID = @AttributeType_File ORDER BY Attribute_ID;  
    END  
  
    --Debug  
    --SELECT @TableColumns AS TableColumns;  
    --SELECT @TableColumnsPivotDefn AS TableColumnsPivotDefn;  
    --SELECT @TableColumnsUnPivotDefn AS TableColumnsUnPivotDefn;  
    --SELECT @TableColumnsUnPivotDbaDefn AS TableColumnsUnPivotDbaDefn;  
    --SELECT @TableColumnsUpdateDefn AS TableColumnsUpdateDefn;  
    --SELECT @TableColumnsUpdateDbaIdsDefn AS TableColumnUpdateDbaIdsDefn;  
    --SELECT * FROM #AttributeDefinition;  
    --SELECT * FROM #MemberAttributeWorkingSet;  
  
    --Start transaction, being careful to check if we are nested  
    DECLARE @TranCounter INT;  
    SET @TranCounter = @@TRANCOUNT;  
    IF @TranCounter > 0 SAVE TRANSACTION TX;  
    ELSE BEGIN TRANSACTION;  
  
        BEGIN TRY  
        ----------------------------------------------------------------------------------------  
        -- Validate working set.  
        ----------------------------------------------------------------------------------------  
        IF (@ValidateDataTypes = 1)  
        BEGIN  
            --Flag FreeForm and Link attributes where the value length exceeds the maximum length allowed.  
            UPDATE ws SET  
                   ErrorCode = @ErrorCode_AttributeValueLengthGreaterThanMaximum,  
                   ErrorObjectType = @ObjectType_MemberAttribute  
            FROM #MemberAttributeWorkingSet AS ws  
            INNER JOIN #AttributeDefinition AS att  
                ON  ws.Attribute_ID = att.Attribute_ID  
                AND att.AttributeType_ID = @AttributeType_FreeForm  
                AND att.DataType_ID IN (@AttributeDataType_Text, @AttributeDataType_Link)  
                AND LEN(ws.AttributeValue) > att.DataTypeInformation  
                AND ErrorCode IS NULL;  
  
            DECLARE @SqlAzureEngineEdition INT = 5;  
            DECLARE  
                 @IsAzure BIT = CASE SERVERPROPERTY(N'EngineEdition') WHEN @SqlAzureEngineEdition THEN 1 ELSE 0 END  
                ,@NewAttributeValue NVARCHAR(MAX)  
                ,@Row_ID INT  
  
            --Flag attributes with incorrect numeric types  
            IF (@IsAzure = 0)  
            BEGIN  
                -- SQL CLR is supported  
  
                UPDATE ws SET  
                       ErrorCode = CASE mdq.IsNumber(ws.AttributeValue) WHEN 0 THEN  
                        @ErrorCode_InvalidAttributeValueForDataType ELSE -- 'Error - The AttributeValue must be a number.'  
                        @ErrorCode_InvalidAttributeValueForMember END,  -- 'Error - The AttributeValue is too long.'  
                       ErrorObjectType = @ObjectType_MemberAttribute  
                FROM #MemberAttributeWorkingSet AS ws  
                INNER JOIN #AttributeDefinition AS att  
                    ON  ws.Attribute_ID = att.Attribute_ID  
                    AND att.AttributeType_ID = @AttributeType_FreeForm  
                    AND att.DataType_ID = @AttributeDataType_Number  
                    AND ws.AttributeValue IS NOT NULL  
                    AND CASE -- using a CASE statement here ensures Boolean short-circuiting. If the value isn't numeric then trying to convert it to float will crash  
                        WHEN mdq.IsNumber(ws.AttributeValue) <> 1 THEN 1  
                        WHEN mdq.IsNumber(STR(CONVERT(FLOAT, ws.AttributeValue), 38 - att.DataTypeInformation, att.DataTypeInformation)) <> 1 THEN 1  
                        ELSE 0 END = 1  
                    AND ErrorCode IS NULL;  
  
            END ELSE  
            BEGIN  
                -- SQL CLR is not supported. Use a slower TSQL equivalent by checking one row at a time in a loop.  
                -- TODO: Consider removing this ELSE block when SQL Azure adds support for SQL CLR  
  
                -- Find all working set rows that change the value of a numeric attribute.  
                DECLARE @NumericAttributeRowIndexes TABLE  
                (  
                     ID INT PRIMARY KEY  
                    ,NewAttributeValue NVARCHAR(MAX) COLLATE DATABASE_DEFAULT  
                    ,DataTypeInformation INT  
                );  
                INSERT INTO @NumericAttributeRowIndexes  
                SELECT  
                     ws.Row_ID  
                    ,ws.AttributeValue  
                    ,att.DataTypeInformation  
                FROM #MemberAttributeWorkingSet AS ws  
                INNER JOIN #AttributeDefinition AS att  
                    ON  ws.Attribute_ID = att.Attribute_ID  
                WHERE  
                        att.AttributeType_ID = @AttributeType_FreeForm  
                    AND att.DataType_ID = @AttributeDataType_Number  
                    AND ws.AttributeValue IS NOT NULL  
                    AND ws.ErrorCode IS NULL;  
  
                -- Loop through each numeric attribute working set row, and ensure the new value is numeric.  
                DECLARE  
                     @IsNumeric BIT  
                    ,@DataTypeInformation INT;  
                WHILE EXISTS (SELECT 1 FROM @NumericAttributeRowIndexes)  
                BEGIN  
                    -- Get the next row  
                    SELECT TOP 1  
                         @Row_ID = ID  
                        ,@NewAttributeValue = NewAttributeValue  
                        ,@DataTypeInformation = DataTypeInformation  
                    FROM @NumericAttributeRowIndexes  
                    DELETE FROM @NumericAttributeRowIndexes WHERE ID = @Row_ID;  
  
                    SET @IsNumeric = 0;  
                    SET @ErrorCode = NULL;  
                    EXEC mdq.udpIsNumber @NewAttributeValue, @IsNumeric OUTPUT  
                    IF COALESCE(@IsNumeric, 0) = 0  
                    BEGIN  
                        SET @ErrorCode = @ErrorCode_InvalidAttributeValueForDataType; -- 'Error - The AttributeValue must be a number.'  
                    END ELSE  
                    BEGIN  
                        -- The new value is numeric, but ensure it is not too long  
                        SET @NewAttributeValue = STR(CONVERT(FLOAT, @NewAttributeValue), 38 - @DataTypeInformation, @DataTypeInformation);  
                        SET @IsNumeric = 0;  
                        EXEC mdq.udpIsNumber @NewAttributeValue, @IsNumeric OUTPUT  
                        IF COALESCE(@IsNumeric, 0) = 0  
                        BEGIN  
                            SET @ErrorCode = @ErrorCode_InvalidAttributeValueForMember; -- 'Error - The AttributeValue is too long.'  
                        END;  
                    END;  
  
                    IF @ErrorCode IS NOT NULL  
                    BEGIN  
                        UPDATE #MemberAttributeWorkingSet  
                        SET  
                             ErrorCode = @ErrorCode  
                            ,ErrorObjectType = @ObjectType_MemberAttribute  
                        WHERE Row_ID = @Row_ID  
                    END  
                END;-- WHILE  
            END;  
  
            -- Numeric data types in scientific notation format cannot be directly converted to type  
            -- DECIMAL, so convert them to fixed-point notation.  
            UPDATE ws SET  
                AttributeValueMapped =  
                -- the CASE condition is redundant with part of the JOIN clause, but it is necessary because even when false the query will still  
                -- sometimes evaluate the right-hand side of this assignment, which can cause a "failure to convert NVARCHAR to float" error.  
                    CASE COALESCE(ws.ErrorCode, N'')  
                        WHEN N'' THEN STR(CONVERT(FLOAT, ws.AttributeValue), 38 - att.DataTypeInformation, att.DataTypeInformation)  
                        ELSE  ws.AttributeValue  
                    END  
            FROM #MemberAttributeWorkingSet AS ws  
            INNER JOIN #AttributeDefinition AS att  
                ON  ws.Attribute_ID = att.Attribute_ID  
                AND att.DataType_ID = @AttributeDataType_Number  
                AND CHARINDEX(N'E', UPPER(ws.AttributeValue)) > 0     -- CHARINDEX uses 1-based indexing  
                AND AttributeValue IS NOT NULL  
                AND ErrorCode IS NULL;  
  
            --Flag attributes with incorrect date type  
            --@DataType_ID = 3 BEGIN --DATETIME  
            IF (@IsAzure = 0)  
            BEGIN  
                -- SQL CLR is supported  
  
                UPDATE ws  
                    SET ErrorCode = @ErrorCode_InvalidAttributeValueForDataType,  
                       ErrorObjectType = @ObjectType_MemberAttribute  
                FROM #MemberAttributeWorkingSet AS ws  
                INNER JOIN #AttributeDefinition AS att  
                ON att.Attribute_ID = ws.Attribute_ID  
                AND att.DataType_ID = @AttributeDataType_DateTime  
                AND LEN(COALESCE(ws.AttributeValue, N'')) > 0  
                AND mdq.IsDateTime2(ws.AttributeValue) = 0  
                AND ws.ErrorCode IS NULL;  
  
            END ELSE  
            BEGIN  
                -- SQL CLR is not supported. Use a slower TSQL equivalent by checking one row at a time in a loop.  
                -- TODO: Consider removing this ELSE block when SQL Azure adds support for SQL CLR  
  
                -- Find all working set rows that change the value of a datetime attribute.  
                DECLARE @DateTimeAttributeRowIndexes TABLE  
                (  
                        ID INT PRIMARY KEY  
                    ,NewAttributeValue NVARCHAR(MAX) COLLATE DATABASE_DEFAULT  
                );  
                INSERT INTO @DateTimeAttributeRowIndexes  
                SELECT  
                        ws.Row_ID  
                    ,ws.AttributeValue  
                FROM #MemberAttributeWorkingSet AS ws  
                INNER JOIN #AttributeDefinition AS att  
                ON att.Attribute_ID = ws.Attribute_ID  
                WHERE  
                        att.DataType_ID = @AttributeDataType_DateTime  
                    AND LEN(COALESCE(ws.AttributeValue, N'')) > 0  
                    AND ws.ErrorCode IS NULL;  
  
                -- Loop through each datetime attribute working set row, and ensure the new value is a datetime2.  
                DECLARE @IsDateTime2 BIT;  
                WHILE EXISTS (SELECT 1 FROM @DateTimeAttributeRowIndexes)  
                BEGIN  
                    -- Get the next row  
                    SELECT TOP 1  
                            @Row_ID = ID  
                        ,@NewAttributeValue = NewAttributeValue  
                    FROM @DateTimeAttributeRowIndexes  
                    DELETE FROM @DateTimeAttributeRowIndexes WHERE ID = @Row_ID;  
  
                    SET @IsDateTime2 = 0;  
                    EXEC mdq.udpIsDateTime2 @NewAttributeValue, @IsDateTime2 OUTPUT  
                    IF COALESCE(@IsDateTime2, 0) = 0  
                    BEGIN  
                        UPDATE #MemberAttributeWorkingSet  
                        SET  
                                ErrorCode = @ErrorCode_InvalidAttributeValueForDataType  
                            ,ErrorObjectType = @ObjectType_MemberAttribute  
                        WHERE Row_ID = @Row_ID  
                    END;  
                END;-- WHILE  
            END  
  
            --Flag attributes with incorrect links  
            --@DataType_ID = AttributeDataType_Link BEGIN --Link  
            UPDATE ws  
                SET ErrorCode = @ErrorCode_InvalidAttributeValueForDataType,  
                   ErrorObjectType = @ObjectType_MemberAttribute  
            FROM #MemberAttributeWorkingSet AS ws  
            INNER JOIN #AttributeDefinition AS att  
            ON att.Attribute_ID = ws.Attribute_ID  
            AND att.DataType_ID = @AttributeDataType_Link  
            AND att.AttributeType_ID = @AttributeType_FreeForm  
            AND LEN(COALESCE(ws.AttributeValue, N'')) > 0  
            AND mdq.IsLink(ws.AttributeValue) = 0  
            AND ws.ErrorCode IS NULL;  
  
        END; -- IF @ValidateDataTypes  
  
        --Get Dba Ids  
        IF @HasDba = 1 BEGIN  
  
            DECLARE @DbaTempTable TABLE (  
                 RowNumber INT IDENTITY (1, 1) PRIMARY KEY CLUSTERED NOT NULL  
                ,Dba_Entity_ID INT NOT NULL  
            );  
  
            SET @SQL = N'  
                UPDATE ws  
                SET ws.AttributeValueMapped = dba.ID  
                FROM #MemberAttributeWorkingSet ws  
                INNER JOIN #AttributeDefinition AS att  
                    ON ws.Attribute_ID = att.Attribute_ID  
                    AND att.Dba_Entity_ID > 0  
                LEFT OUTER JOIN (' + @TableColumnsUpdateDbaIdsDefn + N') dba  
                ON ws.AttributeValue = dba.Code  
                AND ws.Attribute_ID = dba.Attribute_ID  
                AND ws.ErrorCode IS NULL;  
            ';  
            EXEC sp_executesql @SQL, N'@Version_ID INT', @Version_ID;  
  
            --Flag any invalid Dba values  
            UPDATE ws  
            SET ws.ErrorCode = @ErrorCode_InvalidAttributeValueForMember,  
                ws.ErrorObjectType = @ObjectType_MemberAttribute  
            FROM #MemberAttributeWorkingSet ws  
            WHERE ws.AttributeValue IS NOT NULL  
            AND ws.AttributeValueMapped IS NULL  
            AND ws.ErrorCode IS NULL;  
  
        --Check DBA Member Permissions.  Mark any members the user doesn't have permission to.  
  
            IF @UseMemberSecurity = 1 BEGIN  
                --Get the distinct list of Dba Entities.  
                INSERT INTO @DbaTempTable  
                    SELECT DISTINCT att.Dba_Entity_ID  
                FROM #MemberAttributeWorkingSet ws  
                INNER JOIN #AttributeDefinition att  
                    ON att.Attribute_ID = ws.Attribute_ID  
                    AND att.Dba_Entity_ID > 0  
                WHERE Member_ID IS NOT NULL  
                AND ErrorCode IS NULL;  
  
                DECLARE @DbaEntityID INT;  
                SELECT  
                     @Counter = 1  
                    ,@MaxCounter = MAX(RowNumber)  
                FROM @DbaTempTable;  
  
                DELETE FROM @MemberPermissions;  
  
                --Loop through each Dba Entity checking the user's permissions to the Dba members.  
                WHILE @Counter <= @MaxCounter  
                BEGIN  
                    SELECT @DbaEntityID = Dba_Entity_ID FROM @DbaTempTable WHERE [RowNumber] = @Counter ;  
  
                    --Check DBA Member Permissions.  Mark any members the user doesn't have permission to.  
                    SET @DBAUseMemberSecurity = mdm.udfUseMemberSecurity(@User_ID, @Entity_ID, @Version_ID, @MemberType_Leaf);  
                    IF @DBAUseMemberSecurity = 1  
                    BEGIN  
  
                        DELETE FROM @MemberIds;  
  
                        INSERT INTO @MemberIds (ID, MemberType_ID)  
                        SELECT  
                             CONVERT(INT, ws.AttributeValueMapped) --Contains the Dba Member ID.  
                            ,@MemberType_ID  
                        FROM #MemberAttributeWorkingSet ws  
                        INNER JOIN #AttributeDefinition att  
                            ON att.Attribute_ID = ws.Attribute_ID  
                            AND att.Dba_Entity_ID = @DbaEntityID  
                        WHERE Member_ID IS NOT NULL  
                        AND ErrorCode IS NULL;  
  
                        --Get member permissions  
                        INSERT INTO @MemberPermissions  
                        EXEC mdm.udpSecurityMembersResolverGet @User_ID, @Version_ID, @DbaEntityID, @MemberIds  
  
                        --Mark any member attribute values that don't have permissions  
                        UPDATE ws  
                        SET ErrorCode = @ErrorCode_NoPermissionForThisOperationOnThisObject,  
                            ErrorObjectType = @ObjectType_MemberCode  
                        FROM #MemberAttributeWorkingSet ws  
                        INNER JOIN #AttributeDefinition att  
                            ON att.Dba_Entity_ID = @DbaEntityID  
                            AND att.Attribute_ID = ws.Attribute_ID  
                        INNER JOIN @MemberPermissions prm  
                            ON ws.AttributeValueMapped = CONVERT(NVARCHAR, prm.ID) -- Convert to NVARCHAR avoids potential errors from the AttributeValueMapped column being implicitly converted to INT  
                            AND COALESCE(prm.Privilege_ID, @Permission_Deny) = @Permission_Deny  
                    END;  
  
                    SET @Counter += 1;  
                END    ;  
            END;  
        END;  
  
        --Check for any attribute value changes for the Code attribute.  Requires special handling.  
        IF EXISTS(SELECT 1 FROM #MemberAttributeWorkingSet WHERE AttributeName = N'Code') BEGIN  
  
            --Check for empty Codes  
            UPDATE #MemberAttributeWorkingSet  
             SET ErrorCode = @ErrorCode_InvalidBlankMemberCode,  
                    ErrorObjectType = @ObjectType_MemberAttribute  
            WHERE AttributeName = N'Code'  
            AND (AttributeValue IS NULL OR AttributeValue = N'');  
  
            --Check for reserved words in the MemberCode.  
            UPDATE #MemberAttributeWorkingSet  
            SET    ErrorCode = @ErrorCode_ReservedWord,  
                ErrorObjectType = @ObjectType_MemberAttribute  
            WHERE AttributeName = N'Code'  
            AND mdm.udfItemReservedWordCheck(12, CONVERT(NVARCHAR(250), AttributeValue)) = 1  
            AND ErrorCode IS NULL;  
  
            WITH rawWithCount AS  
            (  
                SELECT  
                    ROW_NUMBER() OVER (PARTITION BY AttributeValue ORDER BY Row_ID) AS RN,  
                    Row_ID  
                FROM #MemberAttributeWorkingSet ws  
                WHERE ws.AttributeName = N'Code'  
            ),  
            duplicateCodeValues AS  
            (  
                SELECT Row_ID FROM rawWithCount WHERE RN > 1  
            )  
            UPDATE ws SET  
               ErrorCode = @ErrorCode_MemberCodeExists,  
               ErrorObjectType = @ObjectType_MemberAttribute  
            FROM #MemberAttributeWorkingSet AS ws  
            INNER JOIN duplicateCodeValues AS dup  
                ON ws.Row_ID = dup.Row_ID;  
  
            --Check for existing MemberCodes.  
            SELECT  
                 @ErrorCode = @ErrorCode_MemberCodeExists  
                ,@ErrorObjectType = @ObjectType_MemberAttribute;  
  
            IF @IsCollectionEnabled = 0 AND @IsHierarchyEnabled = 0  
            BEGIN  
                SET @SQL = N'  
                    UPDATE ws  
                    SET ErrorCode = @ErrorCode_MemberCodeExists,  
                        ErrorObjectType = @ErrorObjectType  
                    FROM #MemberAttributeWorkingSet AS ws  
                    INNER JOIN  mdm.' + @EntityTable + N' AS m  
                    ON      ws.AttributeValue = m.Code  
                        AND ws.AttributeName = N''Code''  
                        AND m.Version_ID = @Version_ID  
                        AND m.Status_ID = 1  
                        AND ws.ErrorCode IS NULL;  
                ';  
                EXEC sp_executesql @SQL, N'@Version_ID INT,@ErrorCode_MemberCodeExists INT, @ErrorObjectType INT',  
                @Version_ID, @ErrorCode_MemberCodeExists, @ErrorObjectType;  
            END  
            ELSE BEGIN  
                SET @SQL = N'  
                    UPDATE ws  
                    SET    ErrorCode = @ErrorCode_MemberCodeExists,  
                        ErrorObjectType = @ErrorObjectType  
                    FROM #MemberAttributeWorkingSet AS ws  
                    INNER JOIN (  
                        SELECT Code FROM mdm.' + @EntityTable + N' WHERE Version_ID = @Version_ID AND Status_ID = 1' +  
                        CASE WHEN @IsHierarchyEnabled = 1 THEN N'  
                        UNION ALL  
                        SELECT Code FROM mdm.' + @HierarchyParentTable + N' WHERE Version_ID = @Version_ID AND Status_ID = 1' ELSE N'' END +  
                        CASE WHEN @IsCollectionEnabled = 1 THEN N'  
                        UNION ALL  
                        SELECT Code FROM mdm.' + @CollectionTable + N'  WHERE Version_ID = @Version_ID AND Status_ID = 1' ELSE N'' END + N'  
                    ) AS existingCodes  
                    ON      ws.AttributeValue = existingCodes.Code  
                        AND ws.AttributeName = N''Code''  
                        AND ws.ErrorCode IS NULL;  
                ';  
                EXEC sp_executesql @SQL, N'@Version_ID INT, @ErrorCode_MemberCodeExists INT, @ErrorObjectType INT',  
                @Version_ID, @ErrorCode_MemberCodeExists, @ErrorObjectType;  
            END  
  
            --Update any existing validation issues associated with this member  
            --to ensure they reference the new member code.  
            SET @SQL = N'  
            UPDATE [mdm].' + QUOTENAME(@ValidationLogTableName) + N'  
            SET MemberCode = AttributeValue  
            FROM #MemberAttributeWorkingSet AS ws  
            INNER JOIN [mdm].' + QUOTENAME(@ValidationLogTableName) + N' AS v  
                ON v.Member_ID = ws.Member_ID  
                AND ws.Member_ID IS NOT NULL  
                AND ws.AttributeName = N''Code''  
                AND v.MemberType_ID = @MemberType_ID  
                AND v.Version_ID = @Version_ID  
                AND ws.ErrorCode IS NULL;  
            ';  
            EXEC sp_executesql @SQL, N'@MemberType_ID INT, @Version_ID INT',  
                                       @MemberType_ID,     @Version_ID;  
  
            --If the entity is code gen enabled we will need to process updated code values  
            IF @CodeGenEnabled = 1  
                BEGIN  
                    --Gather up the valid user provided codes  
                    DECLARE @CodesToProcess mdm.MemberCodes;  
  
                    INSERT @CodesToProcess (MemberCode)  
                    SELECT AttributeValue  
                    FROM #MemberAttributeWorkingSet  
                    WHERE ErrorCode IS NULL AND AttributeName = N'Code';  
  
                    --Process the user-provided codes to update the code gen info table with the largest one  
                    EXEC mdm.udpProcessCodes @Entity_ID, @CodesToProcess;  
                END  
  
        END; --Code special handling  
  
        --Map any NULL attribute values to the special value.  
        UPDATE ws  
        SET AttributeValueMapped = m.SysNullValue  
        FROM #MemberAttributeWorkingSet AS ws  
        INNER JOIN #AttributeDefinition AS att  
            ON  ws.Attribute_ID = att.Attribute_ID  
            AND ws.AttributeValue IS NULL  
        INNER JOIN @SysNullDataTypeMap m  
            ON att.AttributeType_ID = m.AtributeType_ID  
            AND att.DataType_ID = m.DataType_ID  
  
        ----------------------------------------------------------------------------------------  
        --Get current attribute values prior to update  
        ----------------------------------------------------------------------------------------  
        IF @IgnorePriorValues = 0  
        BEGIN  
            SELECT @SQL = N'  
            WITH cte AS (  
                SELECT  
                    ID ' +  
                    @TableColumnsUnPivotDefn +  
            N'    FROM mdm.' + @ViewName + N' AS m  
                WHERE m.Version_ID = @Version_ID  
                AND m.ID IN (SELECT DISTINCT ws.Member_ID FROM #MemberAttributeWorkingSet AS ws WHERE ws.ErrorCode IS NULL)  
            )  
            UPDATE ws  
            SET PriorValue = priorPivot.AttributeValue,  
                PriorValueMapped = priorPivot.AttributeValue  
            FROM #MemberAttributeWorkingSet AS ws  
            INNER JOIN (  
                select ID, U.AttributeName, U.AttributeValue  
                FROM cte  
                UNPIVOT  
                (AttributeValue FOR AttributeName IN (' + @TableColumns + N'))    AS U  
                ) priorPivot  
            ON ws.Member_ID = priorPivot.ID  
            AND ws.AttributeName = priorPivot.AttributeName  
            COLLATE DATABASE_DEFAULT;  
            ';  
  
            --Get prior Dba Ids  
            IF @HasDba = 1 BEGIN  
                SELECT @SQL += N'  
                    WITH cte AS (  
                        SELECT  
                            ID ' +  
                            @TableColumnsUnPivotDbaDefn +  
                    '    FROM mdm.' + @ViewName + N' AS e  
                        WHERE e.Version_ID = @Version_ID  
                        AND e.ID IN (SELECT DISTINCT ws.Member_ID FROM #MemberAttributeWorkingSet AS ws WHERE ws.ErrorCode IS NULL)  
                    )  
                    UPDATE ws  
                    SET PriorValueMapped = priorPivot.AttributeValue  
                    FROM #MemberAttributeWorkingSet AS ws  
                    INNER JOIN #AttributeDefinition AS ad  
                        ON ws.Attribute_ID = ad.Attribute_ID  
                    INNER JOIN (  
                        select ID, U.AttributeName, U.AttributeValue  
                        FROM cte  
                        UNPIVOT  
                        (AttributeValue FOR AttributeName IN (' + @TableColumnsDba + N')) AS U  
                        ) priorPivot  
                    ON ws.Member_ID = priorPivot.ID  
                    AND ws.AttributeName = priorPivot.AttributeName  
                    COLLATE DATABASE_DEFAULT;  
            ';  
            END;  
  
            --Get prior File Ids  
            IF @HasFile = 1 BEGIN  
                SELECT @SQL += N'  
                    WITH cte AS (  
                        SELECT  
                            ID ' +  
                            @TableColumnsUnPivotFileDefn +  
                    '    FROM mdm.' + @ViewName + N' AS e  
                        WHERE e.Version_ID = @Version_ID  
                        AND e.ID IN (SELECT DISTINCT ws.Member_ID FROM #MemberAttributeWorkingSet AS ws WHERE ws.ErrorCode IS NULL)  
                    )  
                    UPDATE ws  
                    SET PriorFileId = priorPivot.AttributeValue  
                    FROM #MemberAttributeWorkingSet AS ws  
                    INNER JOIN #AttributeDefinition AS ad  
                        ON ws.Attribute_ID = ad.Attribute_ID  
                    INNER JOIN (  
                        select ID, U.AttributeName, U.AttributeValue  
                        FROM cte  
                        UNPIVOT  
                        (AttributeValue FOR AttributeName IN (' + @TableColumnsFile + N')) AS U  
                        ) priorPivot  
                    ON ws.Member_ID = priorPivot.ID  
                    AND ws.AttributeName = priorPivot.AttributeName  
                    COLLATE DATABASE_DEFAULT;  
            ';  
            END;  
  
            --PRINT(@SQL);  
            EXEC sp_executesql @SQL, N'@Version_ID INT', @Version_ID;  
        END  
  
        UPDATE ws  
        SET  
            IsChanged = CASE WHEN  
                    @IgnorePriorValues = 0 -- If prior values were not looked up, then assume the value has changed.  
                AND COALESCE(NULLIF(AttributeValue, PriorValue),  NULLIF(PriorValue, AttributeValue)) IS NULL THEN 0 ELSE 1 END,  
            ChangeTrackingMask =  
                CASE WHEN COALESCE( NULLIF(AttributeValue, PriorValue),  NULLIF(PriorValue, AttributeValue)) IS NULL THEN 0  
                ELSE COALESCE(ws.ChangeTrackingMask, 0) | COALESCE(POWER(2,ad.ChangeTrackingGroup_ID - 1), 0)  
            END  
        FROM #MemberAttributeWorkingSet AS ws  
        INNER JOIN #AttributeDefinition AS ad  
            ON ws.Attribute_ID = ad.Attribute_ID;  
  
        ----------------------------------------------------------------------------------------  
        --Pivot and update entity member table  
        ----------------------------------------------------------------------------------------  
        -- ctePivot  
        -- Given this input:  
        --  MemberID        AttributeName    AttributeValueMapped  
        --  --------        -------------   --------------------  
        --  1000            Attribute1        ABC  
        --    1000            Attribute2        1111  
        --    1000            Attribute3        Foo  
  
        --  Pivots to this:  
        --  MemberID        Attribute1      Attribute2      Attribute3  
        --  --------        ----------      ----------      ----------  
        --    1000            ABC                NULL            NULL  
        --    1000            NULL            1111            NULL  
        --    1000            NULL            NULL            Foo  
  
  
        -- ctePivotRowMerge  
        -- Merge the multiple member records INTo one record  
        --  MemberID        Attribute1      Attribute2      Attribute3  
        --  --------        ----------      ----------      ----------  
        --    1000            ABC                1111            Foo  
  
        SELECT @SQL = N'  
        WITH ctePivot AS (  
            SELECT Member_ID, ChangeTrackingMask, ' + @TableColumns + N' FROM #MemberAttributeWorkingSet  
            PIVOT  
            (  
                MAX(AttributeValueMapped)  
                FOR AttributeName IN (' + @TableColumns + N')  
            ) AS P  
            WHERE (ErrorCode IS NULL AND IsChanged = 1)  
        ),  
        ctePivotRowMerge AS (  
            SELECT  
                 Member_ID  
                 ,SUM(DISTINCT ChangeTrackingMask) ChangeTrackingMask ' +  
                 @TableColumnsPivotDefn +  
        N'    FROM ctePivot  
            GROUP BY Member_ID  
        ) '  
  
        SELECT @SQL += N'UPDATE m  
            SET  
                 ValidationStatus_ID    = @ValidationStatus  
                ,LastChgDTM             = @CurrentTime  
                ,LastChgUserID          = @User_ID  
                ,LastChgVersionID       = @Version_ID'  
              --Update the ChangeTrackingMask only for Leaf and Consolidated  
              --member types (collections do not support this functionality)  
              + CASE WHEN @MemberType_ID IN (1,2) THEN N'  
                ,m.ChangeTrackingMask = COALESCE(m.ChangeTrackingMask, 0) | updates.ChangeTrackingMask ' ELSE N'' END  
  
               + @TableColumnsUpdateDefn + CASE @TransactionLogType WHEN @TransactionLogType_Member THEN @GetHistoryOutputQuery ELSE N'' END + N'  
            FROM mdm.' + @TableName + N' AS m  
           INNER JOIN ctePivotRowMerge updates  
                ON m.ID = updates.Member_ID  
              AND m.Version_ID = @Version_ID; '  
  
        --SELECT(@SQL);  
        SET @ValidationStatus = @ValidationStatus_AwaitingRevalidation;  
  
        EXEC sp_executesql @SQL, N'@Version_ID INT, @ValidationStatus INT, @CurrentTime DATETIME2(3), @User_ID INT, @SysNull_Text NVARCHAR(50), @SysNull_Number INT, @SysNull_DateTime DATETIME2(3)',  
            @Version_ID, @ValidationStatus, @CurrentTime, @User_ID, @SysNull_Text, @SysNull_Number, @SysNull_DateTime;  
  
        IF @TransactionLogType = @TransactionLogType_Member  
        BEGIN  
            ----------------------------------------------------------------------------------------  
                --Insert annotation  
            ----------------------------------------------------------------------------------------  
            IF EXISTS(SELECT 1 FROM #MemberAttributeWorkingSet WHERE TransactionAnnotation IS NOT NULL AND ErrorCode IS NULL AND IsChanged = 1)  
            BEGIN  
                SET @SQL = CONCAT(N'  
                    INSERT ', @AnnotationTableName, N' (Version_ID, Revision_ID, Comment, EnterUserID, LastChgUserID)  
                    SELECT @Version_ID, m.LastChgTS, ws.TransactionAnnotation, @User_ID, @User_ID  
                    FROM #MemberAttributeWorkingSet ws  
                    INNER JOIN mdm.' + @TableName + N' m ON ws.Member_ID = m.ID  
                    WHERE ws.TransactionAnnotation IS NOT NULL AND ws.ErrorCode IS NULL AND ws.IsChanged = 1;');  
  
                --PRINT(@SQL);  
                EXEC sp_executesql @SQL,  
                    N'@User_ID INT, @Version_ID INT', @User_ID, @Version_ID;  
            END;  
        END -- IF @TransactionType = @TransactionType_Row  
        ELSE IF @TransactionLogType = @TransactionLogType_Attribute  
        BEGIN  
            ----------------------------------------------------------------------------------------  
            --Add transactions for attribute values that changed.  
            ----------------------------------------------------------------------------------------  
  
            SET @SQL = N'  
            INSERT INTO [mdm].' + QUOTENAME(@TransactionTableName) + N'  
            (  
                Version_ID,  
                TransactionType_ID,  
                OriginalTransaction_ID,  
                Entity_ID,  
                Attribute_ID,  
                Member_ID,  
                Member_MUID,  
                MemberType_ID,  
                MemberCode,  
                OldValue,  
                OldCode,  
                NewValue,  
                NewCode,  
                EnterDTM,  
                EnterUserID,  
                LastChgDTM,  
                LastChgUserID  
            )  
            SELECT  
                @Version_ID AS Version_ID  
                ,@TransactionType_Update AS TransactionType_ID  -- Attribute value change  
                ,0 AS OriginalTransaction_ID  
                ,@Entity_ID AS Entity_ID  
                ,ws.Attribute_ID  
                ,ws.Member_ID  
                ,ws.Member_MUID  
                ,@MemberType_ID AS MemberType_ID  
                ,ws.MemberCode  
                ,ws.PriorValueMapped  
                ,ws.PriorValue  
                ,ws.AttributeValueMapped  
                ,ws.AttributeValue  
                ,@CurrentTime  
                ,@User_ID  
                ,@CurrentTime  
                ,@User_ID  
            FROM #MemberAttributeWorkingSet AS ws  
            WHERE ws.ErrorCode IS NULL  
            AND ws.IsChanged = 1;  
            ';  
            EXEC sp_executesql @SQL, N'@Version_ID INT, @TransactionType_Update INT, @Entity_ID INT, @MemberType_ID TINYINT, @CurrentTime DATETIME2(3), @User_ID INT',  
                                       @Version_ID,     @TransactionType_Update,     @Entity_ID,     @MemberType_ID,         @CurrentTime,              @User_ID;  
  
            ----------------------------------------------------------------------------------------  
            --Add any annotation comments that came in with the update  
            ----------------------------------------------------------------------------------------  
            SET @SQL = N'  
            INSERT INTO [mdm].' + QUOTENAME(@TransactionAnnotationTableName) + N'  
            (  
                Version_ID,  
                Transaction_ID,  
                Comment,  
                EnterUserID,  
                EnterDTM,  
                LastChgDTM,  
                LastChgUserID  
            )  
            SELECT  
                @Version_ID  
                ,Transactions.ID  
                ,ws.TransactionAnnotation  
                ,Transactions.EnterUserID  
                ,Transactions.EnterDTM  
                ,Transactions.LastChgDTM  
                ,Transactions.LastChgUserID  
            FROM #MemberAttributeWorkingSet AS ws  
            LEFT JOIN [mdm].' + QUOTENAME(@TransactionTableName) + ' AS Transactions  
                ON ws.Attribute_ID = Transactions.Attribute_ID  
                AND ws.Member_ID = Transactions.Member_ID  
            WHERE Transactions.Version_ID = @Version_ID  
                AND Transactions.Entity_ID = @Entity_ID  
                AND Transactions.MemberType_ID = @MemberType_ID  
                AND Transactions.EnterUserID = @User_ID  
                AND Transactions.EnterDTM = @CurrentTime  
                AND Transactions.TransactionType_ID = @TransactionType_Update  
                AND ws.TransactionAnnotation IS NOT NULL  
            ';  
            EXEC sp_executesql @SQL, N'@Version_ID INT, @TransactionType_Update INT, @Entity_ID INT, @MemberType_ID TINYINT, @CurrentTime DATETIME2(3), @User_ID INT',  
                                       @Version_ID,     @TransactionType_Update,     @Entity_ID,     @MemberType_ID,         @CurrentTime,              @User_ID;  
        END -- @TransactionType = @TransactionType_Column  
    ----------------------------------------------------------------------------------------  
    --Check for Inheritance Business Rules and update dependent members validation status.  
    ----------------------------------------------------------------------------------------  
        IF @DoInheritanceRuleCheck = 1 BEGIN  
            DECLARE @BRInherit AS TABLE (  
                 RowNumber INT IDENTITY(1,1) NOT NULL  
                ,DependentAttributeColumnName SYSNAME NOT NULL  
                ,DependentEntityTable SYSNAME NULL  
                ,DependentAttributeName SYSNAME NULL  
            );  
  
            --DBA Inheritance  
            INSERT INTO @BRInherit (DependentEntityTable, DependentAttributeColumnName)  
            SELECT DISTINCT  
                 depEnt.EntityTable  
                ,i.ChildAttributeColumnName  
            FROM mdm.viw_SYSTEM_BUSINESSRULES_ATTRIBUTE_INHERITANCE_HIERARCHY i  
            INNER JOIN #MemberAttributeWorkingSet ws  
                ON ws.AttributeName = i.ParentAttributeName  
                AND i.ParentEntityID = @Entity_ID  
            INNER JOIN mdm.tblEntity AS depEnt  
                ON i.ChildEntityID = depEnt.ID;  
  
            IF EXISTS(SELECT 1 FROM @BRInherit) BEGIN  
                SELECT  
                     @ValidationStatus = @ValidationStatus_AwaitingDependentMemberRevalidation  
                    ,@Counter = 1  
                    ,@MaxCounter = MAX(RowNumber)  
                FROM @BRInherit;  
  
                --Loop through each Dba Entity updating the dependent members' validation status.  
                WHILE @Counter <= @MaxCounter  
                BEGIN  
                    SELECT  
                         @DependentEntityTable = DependentEntityTable  
                        ,@DependentAttributeColumnName = DependentAttributeColumnName  
                     FROM @BRInherit WHERE [RowNumber] = @Counter ;  
  
                    --Update immediate dependent member table's validation status.  
                    SELECT @SQL = N'  
                        UPDATE   dep  
                        SET dep.ValidationStatus_ID = @ValidationStatus  
                        FROM  mdm.' + @DependentEntityTable + N' AS dep  
                        INNER JOIN #MemberAttributeWorkingSet AS ws  
                            ON dep.' + @DependentAttributeColumnName + N' = ws.Member_ID  
                            AND dep.Version_ID = @Version_ID  
                            AND dep.ValidationStatus_ID <> @ValidationStatus  
                            AND ws.ErrorCode IS NULL  
                            AND ws.IsChanged = 1;  
                        ';  
  
                    --PRINT @SQL;  
                    EXEC sp_executesql @SQL, N'@Version_ID INT, @ValidationStatus INT', @Version_ID, @ValidationStatus;  
  
                    SET @Counter += 1;  
  
                END; -- WHILE  
            END -- IF @DependentEntityTable  
  
            --Hierarchy Inheritance.  
            --  Only need to do this if a hierarchy parent attribute is being updated.  
            IF @MemberType_ID = @MemberType_Consolidated BEGIN  
                DELETE FROM @BRInherit;  
  
                INSERT INTO @BRInherit (DependentAttributeColumnName, DependentAttributeName)  
                SELECT DISTINCT  
                     i.AttributeColumnName  
                    ,i.AttributeName  
                FROM mdm.viw_SYSTEM_BUSINESSRULES_HIERARCHY_CHANGEVALUE_INHERITANCE i  
                INNER JOIN #MemberAttributeWorkingSet ws  
                    ON ws.AttributeName = i.AttributeName  
                    AND  i.EntityID = @Entity_ID  
                    AND ws.ErrorCode IS NULL  
                    AND ws.IsChanged = 1;  
  
                IF EXISTS(SELECT 1 FROM @BRInherit) BEGIN  
                    SELECT  
                         @Counter = 1  
                        ,@MaxCounter = MAX(RowNumber)  
                    FROM @BRInherit;  
  
                    --Loop through each dependent attribute updating hierarchy members' validation status.  
                    WHILE @Counter <= @MaxCounter  
                    BEGIN  
                        SELECT  
                             @DependentAttributeName = DependentAttributeName  
                         FROM @BRInherit WHERE [RowNumber] = @Counter ;  
  
                        DECLARE @parentIdList mdm.IdList;  
  
                        INSERT INTO @parentIdList (ID)  
                        SELECT Member_ID  
                        FROM #MemberAttributeWorkingSet ws  
                        WHERE ws.AttributeName = @DependentAttributeName  
                        AND ws.ErrorCode IS NULL  
                        AND ws.IsChanged = 1  
  
                        EXEC mdm.udpHierarchyMembersValidationStatusUpdate  
                             @Entity_ID = @Entity_ID  
                            ,@Version_ID = @Version_ID  
                            ,@Hierarchy_ID = NULL  
                            ,@ParentIdList = @parentIdList  
                            ,@ValidationStatus_ID = @ValidationStatus_AwaitingDependentMemberRevalidation  
                            ,@MaxLevel = 0  
                            ,@IncludeParent = 0;  
  
                        SET @Counter += 1;  
  
                    END; -- WHILE  
                END;  -- IF EXISTS  
            END; -- IF @MemberType_ID = Consolidated  
        END --IF @DoInheritanceRuleCheck  
  
        ----------------------------------------------------------------------------------------  
        -- File Type attribute  
        -- Remove old record from mdm.tblFile for updates since the new record is being inserted  
        -- in Business Logic Save.  
        ----------------------------------------------------------------------------------------  
        IF @HasFile = 1 BEGIN  
            DECLARE @File_ID mdm.IdList;  
            INSERT INTO @File_ID  
            SELECT f.ID  
            FROM mdm.tblFile AS f  
            INNER JOIN #MemberAttributeWorkingSet ws  
                ON ws.PriorFileId = f.ID  
                AND ws.ErrorCode IS NULL  
                AND ws.IsChanged = 1  
            INNER JOIN #AttributeDefinition ad  
                ON ad.AttributeType_ID = @AttributeType_File  
                AND ad.Attribute_ID = ws.Attribute_ID;  
  
            EXEC mdm.udpFilesDelete @File_ID = @File_ID, @CorrelationID = @CorrelationID;  
        END  
  
        ----------------------------------------------------------------------------------------  
        --Member Recursive Derived Hierarchy Circular Check  
        ----------------------------------------------------------------------------------------  
        --An example of a recursive derived hierarchy is an Employee --> Manager relationship, where Manager is a DBA based on the  
        --Employee entity.  There may be multiple derived hierarchies that contain the recursive relationship in them however anyone  
        --of them will do.  Only the recursive portion of the hierarchy needs to be checked.  That portion of the hierarchy is  
        --obtained by filtering the PARENTCHILD_DERIVED view by the @Entity_ID parameter.  
        --  
        --We call the [udpCircularReferenceMemberCodesGet] SPROC to figure out whether the member codes being updated are  
        --part of a circular reference after the update. If that is the case, this transaction will eventually be rolled back. The  
        --reason we can't do this before the transaction is processed is because there is no way to reliably predict whether the  
        --updates the user is putting through will result in a circular reference. Also note that at this time we only do  
        --this check for the member codes being updated, NOT the whole hierarchy. While we could do that, the operation would be  
        --too expensive to perform on every update.  
  
        --Determine if a recursive derived hierarchy is in play.  There may be multiple but just grab the first one.  
  
        SELECT TOP 1  
             @RecursiveHierarchy_ID  = d.DerivedHierarchy_ID  
            ,@RecursiveHierarchyAttribute_ID = att.Attribute_ID  
        FROM mdm.tblDerivedHierarchyDetail d  
        INNER JOIN #AttributeDefinition att  
            ON att.Dba_Entity_ID = @Entity_ID  
            AND att.Attribute_ID = d.Foreign_ID  
            AND d.ForeignParent_ID = att.Dba_Entity_ID  
  
        IF @RecursiveHierarchy_ID > 0 BEGIN  
            --There is a recursive derived hierarchy in play therefore we need to check the DBA values for circular references.  
  
            DECLARE @CircularReferenceCodeList TABLE  
            (  
                MemberCode            NVARCHAR(MAX) COLLATE DATABASE_DEFAULT NULL  
            );  
  
            --Call [udpCircularReferenceMemberCodesGet] and get the number of circular reference errors and the member codes  
            --that participate in the circular reference  
            INSERT INTO @CircularReferenceCodeList EXEC @CircularReferenceErrors = [mdm].[udpCircularReferenceMemberCodesGet]  
                                                            @Model_ID = @Model_ID,  
                                                            @RecursiveHierarchy_ID = @RecursiveHierarchy_ID,  
                                                            @MemberAttributes = @MemberAttributes;  
  
            --If we found circular references, go ahead and update the error code on the relevant member code/attribute rows  
            IF @CircularReferenceErrors > 0  
                UPDATE WS  
                    SET ErrorCode = @ErrorCode_MemberCausesCircularReference,  
                        ErrorObjectType = @ObjectType_MemberAttribute  
                    FROM #MemberAttributeWorkingSet WS  
                    JOIN @CircularReferenceCodeList ErrorCodeList ON ErrorCodeList.MemberCode = WS.MemberCode  
                    WHERE WS.Attribute_ID = @RecursiveHierarchyAttribute_ID  
        END;  
  
        -- Determine if member security needs to be updated. This is true if a DBA has been updated and that DBA's domain entity is a  
        -- part of a derived hierarchy that has a member security permission.  
        DECLARE @NeedToUpdateMemberSecurity BIT= 0;  
        WITH changedDbaEntityId AS -- The domain entities of the domain-based attributes that have been updated.  
        (  
            SELECT DISTINCT  
                ad.Dba_Entity_ID AS Entity_ID  
            FROM #MemberAttributeWorkingSet maws  
            INNER JOIN #AttributeDefinition ad  
                ON  
                    maws.Attribute_ID = ad.Attribute_ID AND  
                    maws.ErrorCode IS NULL AND  
                    maws.IsChanged = 1 AND  
                    ad.AttributeType_ID = @AttributeType_DBA  
        ),  
        securedLevels AS -- The derived hierarchies that have member security, with their topmost level to which a member security assignment applies.  
        (  
            SELECT  
                sram.DerivedHierarchy_ID,  
                MIN(CASE sram.Member_ID WHEN 0 THEN -1 ELSE lvl.LevelNumber END) AS LevelNumber -- If Member_ID is zero, then the permission applies to the ROOT (level -1) of the  hierarchy  
            FROM mdm.tblSecurityRoleAccessMember sram  
            LEFT JOIN mdm.viw_SYSTEM_SCHEMA_HIERARCHY_DERIVED_LEVELS lvl  
            ON  
                sram.DerivedHierarchy_ID = lvl.Hierarchy_ID AND -- Explicit hierarchy member permissions are ignored since this sproc won't change EH parent-child relationships.  
                sram.Version_ID = @Version_ID AND  
                lvl.[Entity_ID] = sram.Entity_ID  
            GROUP BY sram.DerivedHierarchy_ID  
        ),  
        securedEntityId AS -- The domain entities to which security applies  
        (  
            SELECT DISTINCT  
                lvl.[Entity_ID]  
            FROM mdm.viw_SYSTEM_SCHEMA_HIERARCHY_DERIVED_LEVELS lvl  
            INNER JOIN securedLevels sec  
                ON  
                    lvl.Hierarchy_ID = sec.DerivedHierarchy_ID AND  
                    lvl.[Entity_ID] > 0 AND  
                    lvl.LevelNumber > sec.LevelNumber -- Only domain entities underneath a member security assignment require the MS table to be recalculated  
        ),  
        updateNeeded AS  
        (  
            SELECT  
                TOP 1  
                1 UpdateNeeded  
            FROM changedDbaEntityId dba  
            INNER JOIN securedEntityId ent  
                ON dba.Entity_ID = ent.Entity_ID  
        )  
        SELECT  
            @NeedToUpdateMemberSecurity = UpdateNeeded  
        FROM updateNeeded  
  
        IF (@NeedToUpdateMemberSecurity = 1)  
        BEGIN  
            --Put a msg onto the SB queue to process member security  
            EXEC mdm.udpSecurityMemberQueueSave  
                @User_ID    = NULL,-- update member security for all users  
                @Version_ID = @Version_ID,  
                @Entity_ID  = @Entity_ID;  
        END;  
  
        --Update MemberCode for any member attribute change errors that are associated with a successful member code change  
        --because we need to return the updated member code to the consumer.  
        WITH cteCodeChgs AS  
        (  
            SELECT Member_ID, AttributeValue  
            FROM #MemberAttributeWorkingSet  
            WHERE AttributeName = N'Code'  
              AND ErrorCode IS NULL  
        )  
        UPDATE ws  
            SET ws.MemberCode = CONVERT(NVARCHAR(250), cde.AttributeValue)  
        FROM #MemberAttributeWorkingSet AS ws  
        INNER JOIN cteCodeChgs AS cde  
            ON ws.Member_ID = cde.Member_ID  
            AND ws.ErrorCode IS NOT NULL;  
  
        IF (@ShouldReturnMembersWithErrorsAsXml = 1)  
        BEGIN  
            -- Return as XML the list of all members (codes) with errors  
            SELECT @Return_MembersWithErrors = CONVERT(XML, (  
            SELECT MemberCode, MemberMUID FROM  
                (  
                    SELECT DISTINCT  
                        ws.MemberCode AS MemberCode  
                        ,ws.Member_MUID AS MemberMUID  
                    FROM #MemberAttributeWorkingSet ws  
                    WHERE ErrorCode IS NOT NULL  
                ) AS DistinctErrors  
                FOR XML PATH('Error')  
                )  
            )  
        END  
  
        --Return any errors  
        SELECT DISTINCT  
             ws.Member_ID  
            ,ws.MemberCode  
            ,ws.MemberName  
            ,ws.Member_MUID  
            ,ad.Attribute_MUID  
            ,ws.AttributeName  
            ,ws.ErrorCode  
            ,ws.ErrorObjectType  
        FROM #MemberAttributeWorkingSet ws  
        LEFT OUTER JOIN #AttributeDefinition ad  
            ON ws.Attribute_ID = ad.Attribute_ID  
        WHERE ErrorCode IS NOT NULL;  
  
        --If there have been circular reference errors, run the rollback logic  
        IF @CircularReferenceErrors > 0  
            BEGIN  
                IF @TranCounter = 0 ROLLBACK TRANSACTION;  
                ELSE IF XACT_STATE() <> -1 ROLLBACK TRANSACTION TX;  
            END  
        ELSE IF @TranCounter = 0 COMMIT TRANSACTION; --Commit only if we are not nested  
  
        RETURN(0);  
  
    END TRY  
    --Compensate as necessary  
    BEGIN CATCH  
  
        -- Get error info.  
        DECLARE  
            @ErrorMessage NVARCHAR(4000),  
            @ErrorSeverity INT,  
            @ErrorState INT,  
            @ErrorNumber INT,  
            @ErrorLine INT,  
            @ErrorProcedure NVARCHAR(126);  
        EXEC mdm.udpGetErrorInfo  
            @ErrorMessage = @ErrorMessage OUTPUT,  
            @ErrorSeverity = @ErrorSeverity OUTPUT,  
            @ErrorState = @ErrorState OUTPUT,  
            @ErrorNumber = @ErrorNumber OUTPUT,  
            @ErrorLine = @ErrorLine OUTPUT,  
            @ErrorProcedure = @ErrorProcedure OUTPUT  
  
        SET @ErrorMessage = CONCAT(@ErrorMessage, N', @ErrorNumber = ', @ErrorNumber, N', @ErrorProcedure = "', @ErrorProcedure, N'", line ', @ErrorLine);  
  
        IF @TranCounter = 0 ROLLBACK TRANSACTION;  
        ELSE IF XACT_STATE() <> -1 ROLLBACK TRANSACTION TX;  
  
        RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);  
  
        RETURN(@ErrorNumber);  
  
    END CATCH;  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpEntityMetaTablesDelete]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    EXEC mdm.udpEntityMetaTablesDelete 1;  
    select * from mdm.tblEntity;  
  
/******************************************************************************  
*  
** Desc:  The stored procedure will delete the following associated meta data tables  
          for an Entity:  
  
          _EN  
          _MS  
          _HP  
          _HR  
          _CM  
          _CN  
  
** Processing Steps:  
        1.  The existence of each table will be check first  
        2.  If the table exists, the drop statement will be executed.  
**  
** Parameters: @Entity_ID    INT  
**  
** Restart:  
        Restart at the beginning. No code modifications required.  
**  
** Tables Used:  
**        tbl_Modelxx_Entityzz_EN  (where xx is the model Id and zz is the Entity Id)  
**        tbl_Modelxx_Entityzz_HP  
**        tbl_Modelxx_Entityzz_HR  
**        tbl_Modelxx_Entityzz_CM  
**        tbl_Modelxx_Entityzz_CN  
**  
** Return values:  
        = 0 Success  
        = 1 Failure  
**  
** Called By:  
        udpEntityDelete  
**  
** Calls:  
        None  
**  
*******************************************************************************/  
*/  
  
CREATE PROCEDURE [mdm].[udpEntityMetaTablesDelete]  
(  
    @Entity_ID        INT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    --Start transaction, being careful to check if we are nested  
    DECLARE @TranCounter INT;  
    SET @TranCounter = @@TRANCOUNT;  
    IF @TranCounter > 0 SAVE TRANSACTION TX;  
    ELSE BEGIN TRANSACTION;  
  
    BEGIN TRY  
  
        DECLARE @SQL                        NVARCHAR(MAX),  
                @IsCollectionEnabled        BIT,  
                @IsHierarchyEnabled         BIT,  
                @EntityTable                SYSNAME,  
                @EntityHistoryTable         SYSNAME,  
                @EntityAnnotationTable      SYSNAME,  
                @EntityPendingTable         SYSNAME,  
                @EntitySecurityTable        SYSNAME,  
                @HierarchyTable             SYSNAME,  
                @HierarchyHistoryTable      SYSNAME,  
                @HierarchyAnnotationTable   SYSNAME,  
                @HierarchyParentTable       SYSNAME,  
                @HierarchyParentHistoryTable        SYSNAME,  
                @HierarchyParentAnnotationTable     SYSNAME,  
                @HierarchyParentSecurityTable       SYSNAME,  
                @CollectionTable            SYSNAME,  
                @CollectionHistoryTable     SYSNAME,  
                @CollectionAnnotationTable  SYSNAME,  
                @CollectionMemberTable      SYSNAME,  
                @CollectionMemberHistoryTable       SYSNAME,  
                @CollectionMemberAnnotationTable    SYSNAME,  
                @LeafStagingTable           SYSNAME,  
                @ConsolidatedStagingTable   SYSNAME,  
                @RelationshipStagingTable   SYSNAME,  
                @ConstraintName             SYSNAME,  
                @TempID                     INT,  
                @TempTableName              SYSNAME;  
  
        DECLARE @TableFKConstraints         TABLE  
                    ([ID] [INT]             IDENTITY (1, 1) Primary KEY CLUSTERED NOT NULL,  
                    TableName               SYSNAME,  
                    ConstraintName          SYSNAME);  
  
        --Set variables.  
        SET @SQL = N'';  
  
        SELECT  
            @EntityTable = EntityTable,  
            @EntityHistoryTable = CONCAT(EntityTable, N'_HS'),  
            @EntityAnnotationTable = CONCAT(EntityTable, N'_AN'),  
            @EntityPendingTable = CONCAT(EntityTable, N'_PD'),  
            @EntitySecurityTable = CAST(EntityTable + '_MS' AS SYSNAME),  
            @HierarchyTable = HierarchyTable,  
            @HierarchyHistoryTable = CONCAT(HierarchyTable, N'_HS'),  
            @HierarchyAnnotationTable = CONCAT(HierarchyTable, N'_AN'),  
            @HierarchyParentTable = HierarchyParentTable,  
            @HierarchyParentHistoryTable = CONCAT(HierarchyParentTable, N'_HS'),  
            @HierarchyParentAnnotationTable = CONCAT(HierarchyParentTable, N'_AN'),  
            @HierarchyParentSecurityTable = CAST(HierarchyParentTable + '_MS' AS SYSNAME),  
            @CollectionTable = CollectionTable,  
            @CollectionHistoryTable = CONCAT(CollectionTable, N'_HS'),  
            @CollectionAnnotationTable = CONCAT(CollectionTable, N'_AN'),  
            @CollectionMemberTable = CollectionMemberTable,  
            @CollectionMemberHistoryTable = CONCAT(CollectionMemberTable, N'_HS'),  
            @CollectionMemberAnnotationTable = CONCAT(CollectionMemberTable, N'_AN'),  
            @IsCollectionEnabled = CASE WHEN CollectionTable IS NULL THEN 0 ELSE 1 END,  
            @IsHierarchyEnabled  = CASE WHEN HierarchyTable  IS NULL THEN 0 ELSE 1 END  
        FROM  
            mdm.tblEntity  
        WHERE  
            ID = @Entity_ID;  
  
        --Get staging table names.  
        SELECT  
            @LeafStagingTable = COALESCE(StagingLeafTable, N''),  
            @ConsolidatedStagingTable = COALESCE(StagingConsolidatedTable, N''),  
            @RelationshipStagingTable = COALESCE(StagingRelationshipTable, N'')  
        FROM  
            mdm.viw_SYSTEM_SCHEMA_ENTITY WHERE ID = @Entity_ID;  
  
        -- Get all the foreign key constraints for the entity table - EN  
        DECLARE @EntityTableObjectID INT = object_id(N'mdm.' + QUOTENAME(@EntityTable));  
        INSERT INTO @TableFKConstraints  
                        SELECT  schema_name(schema_id) + '.' + QUOTENAME(object_name(parent_object_id)),  
                                s.[name]  
                        FROM sys.foreign_keys s  
                        WHERE referenced_object_id = @EntityTableObjectID;  
  
        -- Get all the foreign key constraints for the secutity table - MS  
        DECLARE @EntitySecurityTableObjectID INT = object_id(N'mdm.' + QUOTENAME(@EntitySecurityTable));  
        INSERT INTO @TableFKConstraints  
                        SELECT  schema_name(schema_id) + '.' + QUOTENAME(object_name(parent_object_id)),  
                                s.[name]  
                        FROM sys.foreign_keys s  
                        WHERE referenced_object_id = @EntitySecurityTableObjectID;  
  
                -- Get all the foreign key constraints for the secutity table - MS  
        DECLARE @HierarchyParentSecurityTableObjectID INT = object_id(N'mdm.' + QUOTENAME(@HierarchyParentSecurityTable));  
        INSERT INTO @TableFKConstraints  
                        SELECT  schema_name(schema_id) + '.' + QUOTENAME(object_name(parent_object_id)),  
                                s.[name]  
                        FROM sys.foreign_keys s  
                        WHERE referenced_object_id = @HierarchyParentSecurityTableObjectID;  
  
        -- Get all the foreign key constraints for the hierarchy table - HR  
        DECLARE @HierarchyTableObjectID INT = object_id(N'mdm.' + QUOTENAME(@HierarchyTable));  
        INSERT INTO @TableFKConstraints  
                        SELECT  schema_name(schema_id) + '.' + QUOTENAME(object_name(parent_object_id)),  
                                s.[name]  
                        FROM sys.foreign_keys s  
                        WHERE referenced_object_id = @HierarchyTableObjectID;  
  
        -- Get all the foreign key constraints for the hierarchy parent table - HP  
        DECLARE @HierarchyParentTableObjectID INT = object_id(N'mdm.' + QUOTENAME(@HierarchyParentTable));  
        INSERT INTO @TableFKConstraints  
                        SELECT  schema_name(schema_id) + '.' + QUOTENAME(object_name(parent_object_id)),  
                                s.[name]  
                        FROM sys.foreign_keys s  
                        WHERE referenced_object_id = @HierarchyParentTableObjectID;  
  
        -- Get all the foreign key constraints for the collection table - CN  
        DECLARE @CollectionTableObjectID INT = object_id(N'mdm.' + QUOTENAME(@CollectionTable));  
        INSERT INTO @TableFKConstraints  
                        SELECT  schema_name(schema_id) + '.' + QUOTENAME(object_name(parent_object_id)),  
                                s.[name]  
                        FROM sys.foreign_keys s  
                        WHERE referenced_object_id = @CollectionTableObjectID;  
  
        -- Get all the foreign key constraints for the collection member table - CM  
        DECLARE @CollectionMemberTableObjectID INT = object_id(N'mdm.' + QUOTENAME(@CollectionMemberTable));  
        INSERT INTO @TableFKConstraints  
                        SELECT  schema_name(schema_id) + '.' + QUOTENAME(object_name(parent_object_id)),  
                                s.[name]  
                        FROM sys.foreign_keys s  
                        WHERE referenced_object_id = @CollectionMemberTableObjectID;  
  
        -- Delete all the constraints first  
        DECLARE @Counter INT = 1 ;  
        DECLARE @MaxCounter INT = (SELECT MAX(ID) FROM @TableFKConstraints);  
        SET @Counter =1;  
        WHILE @Counter <= @MaxCounter  
        BEGIN  
            SELECT @TempID = ID, @TempTableName = TableName, @ConstraintName = ConstraintName  
                FROM @TableFKConstraints WHERE ID = @Counter;  
  
            SET @SQL = @SQL + N'ALTER TABLE ' + @TempTableName +  
                        ' DROP CONSTRAINT ' + @ConstraintName + N';'  
  
            SET @Counter = @Counter +1;  
        END  
  
        --Drop the related entity table  
        IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES t WHERE t.TABLE_SCHEMA = N'mdm' AND t.TABLE_NAME = @EntityPendingTable)  
        BEGIN  
        SET @SQL += N'  
            DROP TABLE mdm.' + QUOTENAME(@EntityPendingTable) + ';';  
        END  
        IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES t WHERE t.TABLE_SCHEMA = N'mdm' AND t.TABLE_NAME = @EntityAnnotationTable)  
        BEGIN  
        SET @SQL += N'  
            DROP TABLE mdm.' + QUOTENAME(@EntityAnnotationTable) + ';';  
        END  
        IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES t WHERE t.TABLE_SCHEMA = N'mdm' AND t.TABLE_NAME = @EntityHistoryTable)  
        BEGIN  
        SET @SQL += N'  
            DROP TABLE mdm.' + QUOTENAME(@EntityHistoryTable) + ';';  
        END  
        IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES t WHERE t.TABLE_SCHEMA = N'mdm' AND t.TABLE_NAME = @EntityTable)  
        BEGIN  
        SET @SQL += N'  
            DROP TABLE mdm.' + QUOTENAME(@EntityTable) + ';';  
        END  
        IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES t WHERE t.TABLE_SCHEMA = N'mdm' AND t.TABLE_NAME = @EntitySecurityTable)  
        BEGIN  
        SET @SQL += N'  
            DROP TABLE mdm.' + QUOTENAME(@EntitySecurityTable) + ';';  
        END  
        IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES t WHERE t.TABLE_SCHEMA = N'stg' AND t.TABLE_NAME = @LeafStagingTable)  
        BEGIN  
        SET @SQL += N'  
            DROP TABLE stg.' + QUOTENAME(@LeafStagingTable) + ';';  
        END  
  
        -- Drop the related hierarchy, hierarchy parent, collection and collection member tables if the Entity has them  
        -- Drop the related HierarchyParent table for Entity Based Staging  
  
        IF @IsCollectionEnabled = 1  
        BEGIN  
            IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES t WHERE t.TABLE_SCHEMA = N'mdm' AND t.TABLE_NAME = @CollectionAnnotationTable)  
            BEGIN  
            SET @SQL += N'  
                DROP TABLE mdm.' + QUOTENAME(@CollectionAnnotationTable) + ';';  
            END  
            IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES t WHERE t.TABLE_SCHEMA = N'mdm' AND t.TABLE_NAME = @CollectionHistoryTable)  
            BEGIN  
            SET @SQL += N'  
                DROP TABLE mdm.' + QUOTENAME(@CollectionHistoryTable) + ';';  
            END  
            IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES t WHERE t.TABLE_SCHEMA = N'mdm' AND t.TABLE_NAME = @CollectionTable)  
            BEGIN  
            SET @SQL += N'  
                DROP TABLE mdm.' + QUOTENAME(@CollectionTable) + ';';  
            END  
            IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES t WHERE t.TABLE_SCHEMA = N'mdm' AND t.TABLE_NAME = @CollectionMemberAnnotationTable)  
            BEGIN  
            SET @SQL += N'  
                DROP TABLE mdm.' + QUOTENAME(@CollectionMemberAnnotationTable) + ';';  
            END  
            IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES t WHERE t.TABLE_SCHEMA = N'mdm' AND t.TABLE_NAME = @CollectionMemberHistoryTable)  
            BEGIN  
            SET @SQL += N'  
                DROP TABLE mdm.' + QUOTENAME(@CollectionMemberHistoryTable) + ';';  
            END  
            IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES t WHERE t.TABLE_SCHEMA = N'mdm' AND t.TABLE_NAME = @CollectionMemberTable)  
            BEGIN  
            SET @SQL += N'  
                DROP TABLE mdm.' + QUOTENAME(@CollectionMemberTable) + ';';  
            END  
        END;  
  
        IF @IsHierarchyEnabled = 1  
        BEGIN  
            IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES t WHERE t.TABLE_SCHEMA = N'stg' AND t.TABLE_NAME = @ConsolidatedStagingTable)  
            BEGIN  
            SET @SQL += N'  
                DROP TABLE stg.' + QUOTENAME(@ConsolidatedStagingTable) + ';';  
            END  
            IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES t WHERE t.TABLE_SCHEMA = N'stg' AND t.TABLE_NAME = @RelationshipStagingTable)  
            BEGIN  
            SET @SQL += N'  
                DROP TABLE stg.' + QUOTENAME(@RelationshipStagingTable) + ';';  
            END  
            IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES t WHERE t.TABLE_SCHEMA = N'mdm' AND t.TABLE_NAME = @HierarchyAnnotationTable)  
            BEGIN  
            SET @SQL += N'  
                DROP TABLE mdm.' + QUOTENAME(@HierarchyAnnotationTable) + ';';  
            END  
            IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES t WHERE t.TABLE_SCHEMA = N'mdm' AND t.TABLE_NAME = @HierarchyHistoryTable)  
            BEGIN  
            SET @SQL += N'  
                DROP TABLE mdm.' + QUOTENAME(@HierarchyHistoryTable) + ';';  
            END  
            IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES t WHERE t.TABLE_SCHEMA = N'mdm' AND t.TABLE_NAME = @HierarchyParentSecurityTable)  
            BEGIN  
            SET @SQL += N'  
                DROP TABLE mdm.' + QUOTENAME(@HierarchyParentSecurityTable) + ';';  
            END  
            IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES t WHERE t.TABLE_SCHEMA = N'mdm' AND t.TABLE_NAME = @HierarchyTable)  
            BEGIN  
            SET @SQL += N'  
                DROP TABLE mdm.' + QUOTENAME(@HierarchyTable) + ';';  
            END  
                        IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES t WHERE t.TABLE_SCHEMA = N'mdm' AND t.TABLE_NAME = @HierarchyParentAnnotationTable)  
            BEGIN  
            SET @SQL += N'  
                DROP TABLE mdm.' + QUOTENAME(@HierarchyParentAnnotationTable) + ';';  
            END  
            IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES t WHERE t.TABLE_SCHEMA = N'mdm' AND t.TABLE_NAME = @HierarchyParentHistoryTable)  
            BEGIN  
            SET @SQL += N'  
                DROP TABLE mdm.' + QUOTENAME(@HierarchyParentHistoryTable) + ';';  
            END  
            IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES t WHERE t.TABLE_SCHEMA = N'mdm' AND t.TABLE_NAME = @HierarchyParentTable)  
            BEGIN  
            SET @SQL += N'  
                DROP TABLE mdm.' + QUOTENAME(@HierarchyParentTable) + ';';  
            END  
        END;  
  
        EXEC sp_executesql @SQL;  
  
        --Commit only if we are not nested  
        IF @TranCounter = 0 COMMIT TRANSACTION;  
        RETURN(0);  
  
    END TRY  
    --Compensate as necessary  
    BEGIN CATCH  
  
        -- Get error info.  
        DECLARE  
            @ErrorMessage NVARCHAR(4000),  
            @ErrorSeverity INT,  
            @ErrorState INT,  
            @ErrorNumber INT,  
            @ErrorLine INT,  
            @ErrorProcedure NVARCHAR(126);  
        EXEC mdm.udpGetErrorInfo  
            @ErrorMessage = @ErrorMessage OUTPUT,  
            @ErrorSeverity = @ErrorSeverity OUTPUT,  
            @ErrorState = @ErrorState OUTPUT,  
            @ErrorNumber = @ErrorNumber OUTPUT,  
            @ErrorLine = @ErrorLine OUTPUT,  
            @ErrorProcedure = @ErrorProcedure OUTPUT  
  
        SET @ErrorMessage = CONCAT(@ErrorMessage, N', @ErrorNumber = ', @ErrorNumber, N', @ErrorProcedure = "', @ErrorProcedure, N'", line ', @ErrorLine);  
  
  
        IF @TranCounter = 0 ROLLBACK TRANSACTION;  
        ELSE IF XACT_STATE() <> -1 ROLLBACK TRANSACTION TX;  
  
        RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);  
  
        RETURN(1);  
  
    END CATCH;  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpEntitySave]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    --Create new Entity  
    DECLARE @Return_ID INT, @Return_MUID UNIQUEIDENTIFIER;  
    EXEC mdm.udpEntitySave @User_ID = 1, @Model_ID = 5, @EntityName = N'Test11', @EditMode = 0, @Return_ID = @Return_ID OUTPUT, @Return_MUID = @Return_MUID OUTPUT;  
    SELECT @Return_ID, @Return_MUID;  
    SELECT * FROM mdm.tblEntity WHERE ID = @Return_ID;  
  
    --Create new Entity with code gen turned ON  
    DECLARE @Return_ID INT, @Return_MUID UNIQUEIDENTIFIER;  
    EXEC mdm.udpEntitySave @User_ID = 1, @Model_ID = 5, @EntityName = N'Test11', @CodeGenSeed = 1, @EditMode = 0, @Return_ID = @Return_ID OUTPUT, @Return_MUID = @Return_MUID OUTPUT;  
    SELECT @Return_ID, @Return_MUID;  
    SELECT * FROM mdm.tblEntity WHERE ID = @Return_ID;  
  
    --Update existing Entity  
    DECLARE @Return_ID INT, @Return_MUID UNIQUEIDENTIFIER;  
    EXEC mdm.udpEntitySave @User_ID = 1, @Model_ID = 5, @Entity_ID = 1, @EntityName = N'Test11 New', @EditMode = 1, @Return_ID = @Return_ID OUTPUT, @Return_MUID = @Return_MUID OUTPUT;  
    SELECT @Return_ID, @Return_MUID;  
    SELECT * FROM mdm.tblEntity WHERE ID = @Return_ID;  
*/  
CREATE PROCEDURE [mdm].[udpEntitySave]  
(  
    @User_ID                INT,  
    @Model_ID               INT, -- caller should validate  
    @Version_ID             INT = NULL, -- used for audit info. When NULL, the highest value for the model will be used  
    @Entity_ID              INT = NULL,  
    @Entity_MUID            UNIQUEIDENTIFIER = NULL,  
    @EntityName             NVARCHAR(50),  
    @Description            NVARCHAR(500) = NULL,  
    @IsBase                 BIT = NULL,  
    @StagingBase            NVARCHAR(60) = N'',  
    @CodeGenSeed            INT = NULL,  
    @EditMode               TINYINT = 0, --0: Create, 1: Update, 4: Clone, defaults to Create  
    @DataCompression        TINYINT = NULL,  
    @TransactionLogType     TINYINT = 0, -- 0: NotSpecified, 1: Column, 2: Row, 3: None  
    @RequireApproval        BIT = NULL,-- caller should validate, NULL: NotSpecified, 0: does not require approval, 1: requires entity admin approval  
    @IsSync                 BIT = 0,  
    @RecreateStagingProc    BIT = 1, -- In can be useful, for efficiency, to turn this off for batch metadata changes   
    @Return_DidNameChange   BIT = NULL OUTPUT,  
    @Return_ID              INT = NULL OUTPUT,  
    @Return_MUID            UNIQUEIDENTIFIER = NULL OUTPUT, --Also an input parameter for clone operations  
    @CorrelationID          UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE @SQL                        NVARCHAR(MAX),  
            @CurrentDTM                 DATETIME2(3),  
            @EntityTable                SYSNAME,  
            @SecurityTable              SYSNAME,  
            @StagingTable               SYSNAME,  
            @HistoryTable               SYSNAME,  
            @AnnotationTable            SYSNAME,  
            @PendingTable               SYSNAME,  
            @TableOptions               NVARCHAR(MAX) = N'',  
            @IndexOptions               NVARCHAR(MAX) = N'',  
            @StagingTableOptions        NVARCHAR(MAX) = N'',  
            @StagingIndexOptions        NVARCHAR(MAX) = N'',  
            @TranCommitted              INT = 0, -- 0: Not committed, 1: Committed.  
            @IsHierarchyEnabled         BIT,  
  
            -- This pseudo-constant is for use in string concatenation operations to prevent string truncation. When concatenating two or more strings,  
            -- if none of the strings is an NVARCHAR(MAX) or an NVARCHAR constant that is longer than 4,000 characters, then the resulting string  
            -- will be silently truncated to 4,000 characters. Concatenating with this empty NVARCHAR(MAX), is sufficient to prevent truncation.  
            -- See http://connect.microsoft.com/SQLServer/feedback/details/283368/nvarchar-max-concatenation-yields-silent-truncation.  
            @TruncationGuard            NVARCHAR(MAX) = N'',  
  
            @Status_Active              TINYINT = 1,  
  
            @TransactionLogType_NotSpecified    TINYINT = 0,  
            @TransactionLogType_Attribute       TINYINT = 1,  
  
            @LeafSproc                          SYSNAME,  
            @ConsolidatedSproc                  SYSNAME,  
            @RelationshipSproc                  SYSNAME,  
            @RelationshipStagingTable           SYSNAME,  
            @LeafStagingTable                   SYSNAME,  
            @ConsolidatedStagingTable           SYSNAME,  
            @MemberErrorViewName                SYSNAME,  
            @RelationErrorViewName              SYSNAME,  
            @CurrentStagingBase                 NVARCHAR(MAX) = N'',  
            @CurrentDataCompression             TINYINT = 0,  
            @CurrentEntityName                  NVARCHAR(MAX),  
            @CurrentEntityStagingBaseName       NVARCHAR(MAX),  
            @CurrentEntityTable                 SYSNAME,  
            @CurrentHierarchyTable              SYSNAME,  
            @CurrentHierarchyParentTable        SYSNAME,  
            @CurrentCollectionTable             SYSNAME,  
            @CurrentCollectionMemberTable       SYSNAME,  
            @CurrentTransactionLogType          TINYINT,  
            @TableName                          SYSNAME,  
            @UsedBy                             NVARCHAR(MAX),  
            @CurrentDescription                 NVARCHAR(MAX),  
            @CurrentCodeGenSeed                 INT = NULL,  
            @GuidEmpty                          UNIQUEIDENTIFIER = CAST(0x0 AS UNIQUEIDENTIFIER),  
            @EditMode_Create                    TINYINT = 0,  
            @EditMode_Update                    TINYINT = 1,  
            @EditMode_Clone                     TINYINT = 4,  
            @ExistingEntity_MUID                UNIQUEIDENTIFIER = NULL,  
            @ExistingEntity_ID                  INT = NULL,  
            @ObjectType_Model                   INT = 1,  
            @IsModelAdmin                       INT = NULL;  
  
    --Initialize output parameters and local variables  
  
    SELECT  
        @Description = NULLIF(LTRIM(RTRIM(@Description)), N''),  
        @Return_ID = NULL,  
        @CurrentDTM = GETUTCDATE(),  
        @Model_ID = NULLIF(@Model_ID, 0),  
        @Entity_MUID = NULLIF(@Entity_MUID, @GuidEmpty),  
        @Entity_ID = NULLIF(@Entity_ID, 0),  
        @EntityName = NULLIF(LTRIM(RTRIM(@EntityName)), N''),  
        @IsBase = COALESCE(@IsBase, 0);  
  
    -- If TransactionLogType is not specified, use default type @TransactionLogType_Attribute  
    IF @TransactionLogType = @TransactionLogType_NotSpecified  
    BEGIN  
        SET @TransactionLogType = @TransactionLogType_Attribute;  
    END;  
  
    --On error, return NULL results  
    SELECT @Return_ID = NULL, @Return_MUID = NULL;  
  
    --Test for invalid EditMode  
    IF @EditMode IS NULL OR @EditMode NOT IN (@EditMode_Create, @EditMode_Update, @EditMode_Clone)  
    BEGIN  
        RAISERROR('MDSERR100010|The Parameters are not valid.', 16, 1);  
        RETURN;  
    END; --if  
  
    --The user is not a model admin  
    IF @Model_ID = 0  
    BEGIN  
        RAISERROR('MDSERR120003|The user does not have permission or the object ID is not valid.', 16, 1);  
        RETURN;  
    END;  
  
    --Get the latest Model Version  
    IF @Version_ID IS NULL  
    BEGIN  
        SELECT @Version_ID = MAX(ID)  
        FROM mdm.tblModelVersion  
        WHERE Model_ID = @Model_ID;  
    END  
  
    --If we are in the Update or Clone mode get the missing pieces of the identifier  
    IF @EditMode IN (@EditMode_Update, @EditMode_Clone)  
    BEGIN  
        --Only use the name if neither MUID nor ID are available. This is important because we don't want  
        --to look up by name if the name is what the user is trying to update.  
        IF @Entity_ID IS NULL AND @Entity_MUID IS NULL  
        BEGIN  
            SELECT TOP 1  
                @ExistingEntity_ID =  ID,  
                @ExistingEntity_MUID = MUID  
            FROM mdm.tblEntity  
            WHERE  
                [Name] = @EntityName AND  
                Model_ID = @Model_ID;  
        END  
        --Use the Entity ID and MUID to look up the full identifier  
        ELSE  
        BEGIN  
            SELECT  
                @ExistingEntity_ID =  ID,  
                @ExistingEntity_MUID = MUID  
            FROM mdm.tblEntity  
            WHERE  
                (@Entity_ID IS NULL OR ID = @Entity_ID) AND  
                (@Entity_MUID IS NULL OR MUID = @Entity_MUID) AND  
                Model_ID = @Model_ID;  
        END  
  
        --If we are in the Clone mode we need to figure out whether we are creating or updating  
        IF @EditMode = @EditMode_Clone  
        BEGIN  
            --If there is no existing model then set the edit mode to Create  
            IF @ExistingEntity_MUID IS NULL AND @ExistingEntity_ID IS NULL  
            BEGIN  
                SET @EditMode = @EditMode_Create;  
                SET @Entity_ID = NULL;  
            END  
            --If there is an existing entity then set the edit mode to Update  
            ELSE  
            BEGIN  
                SET @EditMode = @EditMode_Update;  
                SET @Entity_ID = @ExistingEntity_ID;  
                SET @Entity_MUID = @ExistingEntity_MUID;  
            END  
        END  
        --If we are in Update mode and could not find a matching existing model we need to raise an error and quit now  
        ELSE IF @EditMode = @EditMode_Update  
        BEGIN  
            IF @ExistingEntity_ID IS NULL OR @ExistingEntity_MUID IS NULL  
            BEGIN  
                RAISERROR('MDSERR110007|The ID is not valid.', 16, 1);  
                RETURN;  
            END  
            ELSE  
            BEGIN  
                SET @Entity_ID = @ExistingEntity_ID;  
                SET @Entity_MUID = @ExistingEntity_MUID;  
            END  
        END  
  
        IF      @EditMode = @EditMode_Update  
            AND @IsSync = 0  
        BEGIN  
            IF EXISTS(SELECT 1 FROM mdm.tblSyncRelationship WHERE TargetEntity_ID = @Entity_ID)-- This query is in a nested IF statement, rather than in the parent IF statement, for efficiency because SQL does not guarantee Boolean short circuiting.  
            BEGIN  
                RAISERROR('MDSERR200213|The entity cannot be saved. It is the target of a sync relationship.', 16, 1);  
                RETURN;  
            END  
        END  
    END  
  
    --If the edit mode is Create. This code also needs to execute if the user sent in EditMode clone which ended up becoming Create (hence the IF instead of ELSE IF)  
    IF @EditMode = @EditMode_Create  
    BEGIN  
        --Set Entity ID to null. We don't care what came in.  
        SET @Entity_ID = NULL;  
  
        --If Entity_MUID is not null then we need to ensure it does not already exist (since this is a create)  
        IF @Entity_MUID IS NOT NULL AND EXISTS(SELECT 1 FROM mdm.tblEntity WHERE MUID = @Entity_MUID)  
        BEGIN  
            RAISERROR('MDSERR110007|The ID is not valid.', 16, 1);  
            RETURN;  
        END  
    END  
  
  
    --Test for invalid parameters  
    IF (@Version_ID IS NULL) --Invalid @Version_ID (via invalid @Model_ID)  
        OR (@Entity_ID IS NULL AND @EntityName IS NULL) --@EntityName cannot be NULL for inserts  
        OR (@Entity_ID IS NOT NULL AND NOT EXISTS(SELECT ID FROM mdm.tblEntity WHERE Model_ID = @Model_ID AND ID = @Entity_ID)) --Invalid @Entity_ID (or wrong @Model_ID)  
    BEGIN  
        SELECT @Entity_ID = NULL, @Return_MUID = NULL, @EntityName = NULL;  
        RAISERROR('MDSERR100010|The Parameters are not valid.', 16, 1);  
        RETURN;  
    END; --if  
  
    --Check the name of the entity for duplicates  
    IF EXISTS  
    (  
        SELECT 1   
        FROM mdm.tblEntity  
        WHERE  
            @EntityName = Name AND  
            (@Entity_MUID IS NULL OR MUID <> @Entity_MUID) AND  
            Model_ID = @Model_ID  
    )  
    BEGIN  
        RAISERROR('MDSERR110003|The name already exists. Type a different name.', 16, 1);  
        RETURN;  
    END  
  
  
    --Start transaction, being careful to check if we are nested  
    DECLARE @TranCounter INT;  
    SET @TranCounter = @@TRANCOUNT;  
    IF @TranCounter > 0 SAVE TRANSACTION TX;  
    ELSE BEGIN TRANSACTION;  
  
    BEGIN TRY  
  
        SET @StagingBase = LTRIM(RTRIM(@StagingBase));  
  
        --Update/Insert Entity details  
        IF @EditMode = @EditMode_Update  
        BEGIN --Update Entity  
  
           ---------------------------------------------------------  
            ---------            Update Entity             ----------  
            ---------------------------------------------------------  
  
            --Don't bother doing anything if the @EntityName is NULL  
            IF @EntityName IS NOT NULL  
            BEGIN  
                SELECT  @CurrentEntityName = Name,  
                        @CurrentEntityStagingBaseName = StagingBase,  
                        @CurrentDescription = [Description],  
                        @CurrentStagingBase = StagingBase  
                FROM mdm.tblEntity  
                WHERE ID = @Entity_ID;  
  
                --Check if code gen is enabled  
                DECLARE @result INT;  
                EXEC @result = mdm.udpIsCodeGenEnabled @Entity_ID;  
                DECLARE @CodeGenEnabled BIT =  CONVERT(BIT, @result);  
  
                --Check the current code gen seed  
                IF @CodeGenEnabled = 1  
                BEGIN  
                    SELECT @CurrentCodeGenSeed = Seed  
                    FROM mdm.tblCodeGenInfo  
                    WHERE EntityId = @Entity_ID;  
                END  
  
                --Update details in Entity table  
                UPDATE mdm.tblEntity   
                SET  
                    [Name] = @EntityName,  
                    [Description] = @Description,  
                    IsBase = @IsBase,  
                    LastChgDTM = @CurrentDTM,  
                    LastChgUserID = @User_ID,  
                    LastChgVersionID = @Version_ID  
                WHERE  
                    ID = @Entity_ID;  
  
                --If the user did not send in a code gen seed we might need to turn code gen off  
                IF @CodeGenSeed IS NULL  
                BEGIN  
                    --If code gen is enabled on this entity turn it off  
                    IF @CodeGenEnabled = 1  
                    BEGIN  
                        DELETE FROM mdm.tblCodeGenInfo  
                        WHERE EntityId = @Entity_ID;  
                    END  
                END ELSE  
                BEGIN  
                    --If code gen is already enabled on this entity just update the seed  
                    IF @CodeGenEnabled = 1  
                    BEGIN  
                        UPDATE mdm.tblCodeGenInfo  
                        SET Seed = @CodeGenSeed  
                        WHERE EntityId = @Entity_ID;  
                    END ELSE  
                    --If code gen needs to be enabled  
                    BEGIN  
                        --Turn it on  
                        DECLARE @ExistingMaxValue BIGINT = NULL;  
                        EXEC @ExistingMaxValue = mdm.udpGetMaxCodeValue @Entity_ID = @Entity_ID;  
                        INSERT INTO mdm.tblCodeGenInfo (EntityId, Seed, LargestCodeValue)  
                        VALUES (@Entity_ID, @CodeGenSeed, @ExistingMaxValue);  
                    END  
                END  
  
                --If StagingBase is specified, check if it is changed.  
                IF COALESCE(@StagingBase, N'') <> N''  
                BEGIN  
                    SELECT  
                        @IsHierarchyEnabled  = CASE WHEN HierarchyTable  IS NULL THEN 0 ELSE 1 END,  
                        @LeafSproc = N'[stg].' + QUOTENAME(N'udp_' + StagingBase + N'_Leaf'),  
                        @ConsolidatedSproc = N'[stg].' + QUOTENAME(N'udp_' + StagingBase + N'_Consolidated'),  
                        @RelationshipSproc = N'[stg].' + QUOTENAME(N'udp_' + StagingBase + N'_Relationship'),  
                        @LeafStagingTable = N'[stg].' + QUOTENAME(StagingBase + N'_Leaf'),  
                        @ConsolidatedStagingTable = N'[stg].' + QUOTENAME(StagingBase + N'_Consolidated'),  
                        @RelationshipStagingTable = N'[stg].' + QUOTENAME(StagingBase + N'_Relationship'),  
                        @MemberErrorViewName = N'[stg].' + QUOTENAME(N'viw_' + StagingBase + N'_MemberErrorDetails'),  
                        @RelationErrorViewName = N'[stg].' + QUOTENAME(N'viw_' + StagingBase + N'_RelationshipErrorDetails')  
                    FROM  
                        mdm.tblEntity WHERE ID = @Entity_ID;  
  
                    -- When the entity is a system entity @CurrentStagingBase is NULL.  
                    -- In this case the user cannot change the StagingBase.  
                    IF COALESCE(@CurrentStagingBase, N'') <> N'' AND @CurrentStagingBase <> @StagingBase  
                    BEGIN  
                        --If the specified StagingBase is not unique, get the unique name from the first 50 characters of @StagingBase.  
                        IF EXISTS (SELECT 1 FROM mdm.tblEntity WHERE StagingBase = @StagingBase) BEGIN  
                            SELECT @StagingBase = mdm.udfUniqueStagingBaseGet(LEFT(@StagingBase, 50))  
                        END; --IF  
  
                        -- Update StagingBase  
                        UPDATE mdm.tblEntity   
                        SET StagingBase = @StagingBase  
                        WHERE ID = @Entity_ID;  
  
                        -- Update staging table names and staging stored procedure names.  
                          
                        SET @SQL = CONCAT(@TruncationGuard, @SQL, N'    
                        -- Change leaf staging table name.    
                        IF  EXISTS (SELECT 1 FROM sys.objects WHERE object_id = OBJECT_ID(N', QUOTENAME(@LeafStagingTable, N'''') , N') AND type = (N''U''))  
                        EXEC sp_rename N' , QUOTENAME(@LeafStagingTable, N'''') , N', N' , QUOTENAME((CONCAT(@StagingBase , N'_Leaf')), N'''') , N'  
  
                        -- Change leaf staging stored procedure name.    
                        IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N', QUOTENAME(@LeafSproc, N'''') , N') AND type in (N''P'', N''PC''))    
                        EXEC sp_rename N' , QUOTENAME(@LeafSproc, N'''') , N', N' , QUOTENAME(CONCAT(N'[stg].' , QUOTENAME(CONCAT(N'udp_' , @StagingBase , N'_Leaf'))), N'''')  , N'  
  
                        -- Change staging view name    
                        IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N' , QUOTENAME(@MemberErrorViewName, N'''') , N') AND type in (N''V''))  
                        EXEC sp_rename N' , QUOTENAME(@MemberErrorViewName, N'''') , N', N' , QUOTENAME(CONCAT(N'[stg].' , QUOTENAME(CONCAT(N'viw_' , @StagingBase , N'_MemberErrorDetails'))), N'''') ,  
  
                        CASE WHEN @IsHierarchyEnabled = 1 THEN CONCAT(N'    
                        -- Change consolidated staging table name.    
                        IF  EXISTS (SELECT 1 FROM sys.objects WHERE object_id = OBJECT_ID(N' , QUOTENAME(@ConsolidatedStagingTable, N'''') , N') AND type = (N''U''))    
                        EXEC sp_rename N' , QUOTENAME(@ConsolidatedStagingTable, N'''') , N', N' , QUOTENAME((CONCAT(@StagingBase , N'_Consolidated')), N'''') , N'    
    
                        IF  EXISTS (SELECT 1 FROM sys.objects WHERE object_id = OBJECT_ID(N' , QUOTENAME(@RelationshipStagingTable, N'''') , N') AND type = (N''U''))   
                        EXEC sp_rename N' , QUOTENAME(@RelationshipStagingTable, N'''') , N', N' , QUOTENAME((CONCAT(@StagingBase , N'_Relationship')), N'''') , N'  
    
                        -- Change consolidated staging stored procedure name.    
                        IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N' , QUOTENAME(@ConsolidatedSproc, N'''') , N') AND type in (N''P'', N''PC''))    
                        EXEC sp_rename N' , QUOTENAME(@ConsolidatedSproc, N'''') , N', N' , QUOTENAME(CONCAT(N'[stg].' , QUOTENAME(CONCAT(N'udp_' , @StagingBase , N'_Consolidated'))), N'''') , N'    
    
                        IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N' , QUOTENAME(@RelationshipSproc, N'''') , N') AND type in (N''P'', N''PC''))    
                        EXEC sp_rename N' , QUOTENAME(@RelationshipSproc, N'''') , N', N' , QUOTENAME(CONCAT(N'[stg].' , QUOTENAME(CONCAT(N'udp_' , @StagingBase , N'_Relationship'))), N'''') , N'    
    
                        IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N' , QUOTENAME(@RelationErrorViewName, N'''') , N') AND type = N''V'')    
                        EXEC sp_rename N' , QUOTENAME(@RelationErrorViewName, N'''') , N', N' , QUOTENAME(CONCAT(N'[stg].' , QUOTENAME(CONCAT(N'viw_' , @StagingBase , N'_RelationshipErrorDetails'))), N''''))  
                            END);  
                        EXEC sp_executesql @SQL;    
                    END; --IF  
                END; --IF  
  
                --If DataCompression is specified, check if it is changed.  
                IF @DataCompression IS NOT NULL BEGIN  
                   SELECT  
                       @CurrentDataCompression = DataCompression,  
                       @CurrentStagingBase = StagingBase,  
                       @CurrentEntityTable = EntityTable,  
                       @CurrentHierarchyTable = HierarchyTable,  
                       @CurrentHierarchyParentTable = HierarchyParentTable,  
                       @CurrentCollectionTable = CollectionTable,  
                       @CurrentCollectionMemberTable = CollectionMemberTable  
                   FROM  
                       mdm.tblEntity WHERE ID = @Entity_ID;  
                   IF @DataCompression <> @CurrentDataCompression  
                   BEGIN  
  
                       -- Update all entity tables  
                       SET @TableName = N'[mdm].' + QUOTENAME(@CurrentEntityTable);  
                       EXEC [mdm].[udpChangeTableDataCompressionType] @TableName, @DataCompression;  
                       SET @TableName = N'[mdm].' + QUOTENAME(@CurrentHierarchyTable);  
                       EXEC [mdm].[udpChangeTableDataCompressionType] @TableName, @DataCompression;  
                       SET @TableName = N'[mdm].' + QUOTENAME(@CurrentHierarchyParentTable);  
                       EXEC [mdm].[udpChangeTableDataCompressionType] @TableName, @DataCompression;  
                       SET @TableName = N'[mdm].' + QUOTENAME(@CurrentCollectionTable);  
                       EXEC [mdm].[udpChangeTableDataCompressionType] @TableName, @DataCompression;  
                       SET @TableName = N'[mdm].' + QUOTENAME(@CurrentCollectionMemberTable);  
                       EXEC [mdm].[udpChangeTableDataCompressionType] @TableName, @DataCompression;  
                       SET @TableName = N'[stg].' + QUOTENAME(@CurrentStagingBase + N'_Leaf');  
                       EXEC [mdm].[udpChangeTableDataCompressionType] @TableName, @DataCompression;  
                       SET @TableName = N'[stg].' + QUOTENAME(@CurrentStagingBase + N'_Consolidated');  
                       EXEC [mdm].[udpChangeTableDataCompressionType] @TableName, @DataCompression;  
                       SET @TableName = N'[stg].' + QUOTENAME(@CurrentStagingBase + N'_Relationship');  
                       EXEC [mdm].[udpChangeTableDataCompressionType] @TableName, @DataCompression;  
                       SET @TableName = N'[stg].' + QUOTENAME(@CurrentEntityTable + N'_HS');  
                       EXEC [mdm].[udpChangeTableDataCompressionType] @TableName, @DataCompression;  
                       SET @TableName = N'[stg].' + QUOTENAME(@CurrentEntityTable + N'_AN');  
                       EXEC [mdm].[udpChangeTableDataCompressionType] @TableName, @DataCompression;  
                       SET @TableName = N'[stg].' + QUOTENAME(@CurrentEntityTable + N'_PD');  
                       EXEC [mdm].[udpChangeTableDataCompressionType] @TableName, @DataCompression;  
                       SET @TableName = N'[stg].' + QUOTENAME(@CurrentEntityTable + N'_WI');  
                       EXEC [mdm].[udpChangeTableDataCompressionType] @TableName, @DataCompression;  
                       SET @TableName = N'[mdm].' + QUOTENAME(@CurrentEntityTable + N'_MS');  
                       EXEC [mdm].[udpChangeTableDataCompressionType] @TableName, @DataCompression;  
  
                       -- Update DataCompression  
                       UPDATE mdm.tblEntity  
                       SET DataCompression = @DataCompression  
                       WHERE ID = @Entity_ID;  
                   END  
                END; --IF  
  
                --If TransactionLogType is specified, check if it is changed.  
                IF @TransactionLogType IS NOT NULL  
                BEGIN  
                    SELECT  
                       @CurrentTransactionLogType = TransactionLogType,  
                       @CurrentEntityTable = EntityTable,  
                       @CurrentHierarchyTable = HierarchyTable  
                    FROM mdm.tblEntity   
                    WHERE ID = @Entity_ID;  
  
                    IF @TransactionLogType <> @CurrentTransactionLogType  
                    BEGIN  
                        -- Update DataCompression  
                        UPDATE mdm.tblEntity  
                        SET TransactionLogType = @TransactionLogType  
                        WHERE ID = @Entity_ID;  
                    END;  
  
                    IF @RecreateStagingProc = 1  
                    BEGIN  
                        IF @CurrentEntityTable IS NOT NULL  
                        BEGIN  
                            EXEC mdm.udpEntityStagingCreateLeafStoredProcedure @Entity_ID;  
                        END;  
  
                        IF @CurrentHierarchyTable IS NOT NULL  
                        BEGIN  
                            EXEC mdm.udpEntityStagingCreateConsolidatedStoredProcedure @Entity_ID;  
                            EXEC mdm.udpEntityStagingCreateRelationshipStoredProcedure @Entity_ID;  
                        END;  
                    END  
                END; --IF  
  
                IF @RequireApproval IS NOT NULL  
                BEGIN  
                    UPDATE mdm.tblEntity  
                    SET RequireApproval = @RequireApproval  
                    WHERE ID = @Entity_ID;  
                END  
            END; --if  
  
            --Populate output parameters  
            SELECT @Return_MUID = MUID FROM mdm.tblEntity WHERE ID = @Entity_ID;  
  
        END  
        ELSE  
        BEGIN  
            --------------------------------------------------  
            ---------        Create New Entity        --------  
            --------------------------------------------------  
  
            --Accept an explicit MUID (for clone operations) or generate a new one  
            SET @Return_MUID = ISNULL(@Entity_MUID, NEWID());  
  
            --If the StagingBase is not specified, get the unique name.  
            IF COALESCE(@StagingBase, N'') = N''   
            BEGIN  
                SET @StagingBase = mdm.udfUniqueStagingBaseGet(@EntityName)  
            END ELSE   
            BEGIN  
                --If the specified StagingBase is not unique, get the unique name from the first 50 characters of @StagingBase.  
                IF EXISTS (SELECT 1 FROM mdm.tblEntity WHERE StagingBase = @StagingBase)   
                BEGIN  
                    SELECT @StagingBase = mdm.udfUniqueStagingBaseGet(LEFT(@StagingBase, 50))  
                END --IF  
            END --IF  
  
            SET @StagingTable = @StagingBase + N'_Leaf';  
  
            SET @TableOptions = mdm.udfGetTableOptions(@DataCompression, @Model_ID);  
            SET @IndexOptions = mdm.udfGetIndexOptions(@DataCompression, @Model_ID);  
            SET @StagingTableOptions = mdm.udfGetTableOptions(@DataCompression, NULL);  
            SET @StagingIndexOptions = mdm.udfGetIndexOptions(@DataCompression, NULL);  
  
            SET @RequireApproval = COALESCE(@RequireApproval, 0);  
  
            PRINT CONCAT(SYSDATETIME(), N', udpEntitySave: Inserting entity ', @EntityName);  
  
            --Insert details into Entity table  
            INSERT INTO mdm.tblEntity  
            (  
                Model_ID,  
                [Name],  
                [Description],  
                EntityTable,  
                IsBase,  
                MUID,  
                EnterDTM,  
                EnterUserID,  
                EnterVersionID,  
                LastChgDTM,  
                LastChgUserID,  
                LastChgVersionID,  
                StagingBase,  
                DataCompression,  
                TransactionLogType,  
                RequireApproval  
            )   
            VALUES   
            (  
                @Model_ID,  
                @EntityName,  
                @Description,  
                N'', --Temporary TableName values which we will update in the next step  
                @IsBase,  
                @Return_MUID,  
                @CurrentDTM,  
                @User_ID,  
                @Version_ID,  
                @CurrentDTM,  
                @User_ID,  
                @Version_ID,  
                @StagingBase,  
                ISNULL(@DataCompression, 0),  
                @TransactionLogType,  
                @RequireApproval  
            );  
  
            --Save the identity value  
            SET @Entity_ID =  SCOPE_IDENTITY();  
  
            --If the user provided a seed value then we need to turn on code gen  
            IF @CodeGenSeed IS NOT NULL  
            BEGIN  
                --Insert a row into the code gen info table to track numeric codes  
                INSERT INTO mdm.tblCodeGenInfo  
                (  
                    EntityId,  
                    Seed  
                )  
                VALUES  
                (  
                    @Entity_ID,  
                    @CodeGenSeed  
                );  
            END;  
  
            --Generate table names  
            WITH cte(prefix) AS (SELECT CONCAT(N'tbl_', @Model_ID, N'_', @Entity_ID))  
            SELECT  
                @EntityTable = prefix + N'_EN',  
                @SecurityTable = prefix + N'_EN_MS',  
                @HistoryTable = prefix + N'_EN_HS',  
                @AnnotationTable = prefix + N'_EN_AN',  
                @PendingTable = prefix + N'_EN_PD'  
            FROM cte;  
  
            --Store table names  
            UPDATE mdm.tblEntity   
            SET  
                EntityTable = @EntityTable  
            WHERE ID = @Entity_ID;  
  
            --Create the Entity (EN) table  
            SET @SQL = CONCAT(@TruncationGuard, N'  
  
            CREATE TABLE mdm.', QUOTENAME(@EntityTable), N'  
            (  
                --Identity  
                Version_ID          INT NOT NULL,  
                ID                  INT IDENTITY (1, 1) NOT NULL,  
  
                --Status  
                Status_ID           TINYINT NOT NULL CONSTRAINT ', QUOTENAME(N'df_' + @EntityTable + N'_Status_ID'), N' DEFAULT ', @Status_Active, N',  
                ValidationStatus_ID TINYINT NOT NULL CONSTRAINT ', QUOTENAME(N'df_' + @EntityTable  + N'_ValidationStatus_ID'), N' DEFAULT 0,  
  
                --Info  
                [Name]              NVARCHAR(250) NULL,  
                Code                NVARCHAR(250) NOT NULL,  
  
                --Change Tracking  
                ChangeTrackingMask  INT NOT NULL CONSTRAINT ', QUOTENAME(N'df_' + @EntityTable  + N'_ChangeTrackingMask'), N' DEFAULT 0,  
  
                --Auditing  
                EnterDTM            DATETIME2(3) NOT NULL CONSTRAINT ', QUOTENAME(N'df_' + @EntityTable  + N'_EnterDTM'), N' DEFAULT GETUTCDATE(),  
                EnterUserID         INT NOT NULL,  
                EnterVersionID      INT NOT NULL,  
                LastChgDTM          DATETIME2(3) NOT NULL CONSTRAINT ', QUOTENAME(N'df_' + @EntityTable  + N'_LastChgDTM'), N' DEFAULT GETUTCDATE(),  
                LastChgUserID       INT NOT NULL,  
                LastChgVersionID    INT NOT NULL,  
                LastChgTS           ROWVERSION NOT NULL,  
                AsOf_ID             INT NULL,  
                MUID                UNIQUEIDENTIFIER NOT NULL CONSTRAINT ', QUOTENAME(N'df_' + @EntityTable + N'_MUID'), N' DEFAULT NEWID(),  
  
                --Create PRIMARY KEY constraint  
                CONSTRAINT ', QUOTENAME(N'pk_' + @EntityTable), N'  
                    PRIMARY KEY CLUSTERED (Version_ID, ID)  
  
                -- Note: the values of the Status_ID column should fall between 1 and 2. The ValidationStatus_ID column should be between 0 and 5. However,  
                -- we do not enforce this via db constraint because it would slow down table writes and only trusted MDS sproc code should be writing to those columns.  
            )  
            ', @TableOptions, N'  
  
            --Ensure uniqueness of [Code] for active members.  
            CREATE UNIQUE NONCLUSTERED INDEX ', QUOTENAME(N'ux_' + @EntityTable + N'_Version_ID_Code_Active'), N'  
                ON mdm.', QUOTENAME(@EntityTable), N'(Version_ID, Code)  
                WHERE Status_ID = ', @Status_Active, N'  
                ', @IndexOptions, N';  
  
            --Index [Code] and [Name] for performance. Indexing [Code] for all members (active or not) improves EBS Purge perf, which matches against all member Code values, not just active members.  
            CREATE NONCLUSTERED INDEX ', QUOTENAME(N'ix_' + @EntityTable + N'_Version_ID_Code_Name'), N'  
                ON mdm.', QUOTENAME(@EntityTable), N'(Version_ID, Code, Name)  
                ', @IndexOptions, N';  
  
            --Index Status_ID and ValidationStatus_ID for performance (queried together in udpVersionValidationStatusGet)  
            CREATE NONCLUSTERED INDEX ', QUOTENAME(N'ix_' + @EntityTable + N'_Version_ID_Status_ID_ValidationStatus_ID'), N'  
                ON mdm.', QUOTENAME(@EntityTable), N'(Version_ID, Status_ID, ValidationStatus_ID)  
                ', @IndexOptions, N';  
  
            --Index [LastChgDTM] for performance  
            CREATE NONCLUSTERED INDEX ', QUOTENAME(N'ix_' + @EntityTable + N'_Version_ID_LastChgDTM'), N'  
                ON mdm.' + QUOTENAME(@EntityTable) + N'(Version_ID, LastChgDTM)  
                ', @IndexOptions, N';  
  
            --Ensure uniqueness of [MUID]  
            CREATE UNIQUE NONCLUSTERED INDEX ', QUOTENAME(N'ux_' + @EntityTable + N'_Version_ID_MUID'), N'  
                ON mdm.', QUOTENAME(@EntityTable), N'(Version_ID, MUID)  
                ', @IndexOptions, N';  
  
            --Required for VersionCopy operations  
            CREATE NONCLUSTERED INDEX ', QUOTENAME(N'ix_' + @EntityTable + N'_Version_ID_AsOf_ID_Status_ID'), N'  
                ON mdm.', QUOTENAME(@EntityTable), N'(Version_ID, AsOf_ID, Status_ID)  
                INCLUDE ([ID])  
                WHERE [AsOf_ID] IS NOT NULL  
                ', @IndexOptions, N';  
  
            --Create the History (_EN_HS) table  
            CREATE TABLE mdm.', QUOTENAME(@HistoryTable), N'  
            (  
                Version_ID          INT NOT NULL,  
                ID                  BIGINT NOT NULL,  
  
                EN_ID               INT NOT NULL,  
  
                --Status  
                Status_ID           TINYINT NOT NULL,  
  
                --Info  
                [Name]              NVARCHAR(250) NULL,  
                Code                NVARCHAR(250) NOT NULL,  
  
                --Auditing  
                EnterDTM            DATETIME2(3) NOT NULL,  
                EnterUserID         INT NOT NULL,  
                LastChgDTM          DATETIME2(3) NOT NULL,  
                LastChgUserID       INT NOT NULL,  
                MUID                UNIQUEIDENTIFIER NOT NULL,  
  
                --Create PRIMARY KEY constraint  
                CONSTRAINT ', QUOTENAME(N'pk_' + @HistoryTable), N'  
                    PRIMARY KEY CLUSTERED (Version_ID, ID)  
  
                --Cannot have foreign key (Version_ID, EN_ID) on EN table, because HS table is used in OUTPUT clause  
            )  
            ', @TableOptions, N'  
  
            -- Required by udpEntityMemberHistoriesGet and type2 view  
            CREATE NONCLUSTERED INDEX ', QUOTENAME(N'ix_' + @HistoryTable + N'_Version_ID_EN_ID_EnterDTM_LastChgDTM'), N'  
                ON mdm.', QUOTENAME(@HistoryTable), N'(Version_ID, EN_ID, EnterDTM, LastChgDTM)  
                INCLUDE(Name, Code) -- Required by type 2 view  
                ', @IndexOptions, N';  
  
            --Create the Annotation (_EN_AN) table  
            CREATE TABLE mdm.', QUOTENAME(@AnnotationTable), N'  
            (  
                Version_ID          INT NOT NULL,  
                ID                  INT IDENTITY(1, 1) NOT NULL,  
  
                Revision_ID         BIGINT NOT NULL,  
  
                [Comment]           [NVARCHAR](500) NULL,  
  
                --Auditing  
                EnterDTM            DATETIME2(3) NOT NULL CONSTRAINT ', QUOTENAME(N'df_' + @AnnotationTable  + N'_EnterDTM'), N' DEFAULT GETUTCDATE(),  
                EnterUserID         INT NOT NULL,  
                LastChgDTM          DATETIME2(3) NOT NULL CONSTRAINT ', QUOTENAME(N'df_' + @AnnotationTable  + N'_LastChgDTM'), N' DEFAULT GETUTCDATE(),  
                LastChgUserID       INT NOT NULL,  
                LastChgTS           ROWVERSION NOT NULL,  
  
                --Create PRIMARY KEY constraint  
                CONSTRAINT ', QUOTENAME(N'pk_' + @AnnotationTable), N'  
                    PRIMARY KEY CLUSTERED (Version_ID, ID)  
            )  
            ', @TableOptions, N'  
  
            -- Required for udpEntityMemberAnnotationsGet operations  
            CREATE NONCLUSTERED INDEX ', QUOTENAME(N'ix_' + @AnnotationTable + N'_Version_ID_Revision_ID'), N'  
                ON mdm.' + QUOTENAME(@AnnotationTable) + N'(Version_ID, Revision_ID)  
                ', @IndexOptions, N';  
  
            --Create the PendingChanges (_EN_PD) table  
            CREATE TABLE mdm.', QUOTENAME(@PendingTable), N'  
            (  
                Version_ID          INT NOT NULL,  
                ID                  INT IDENTITY(1, 1) NOT NULL,  
  
                CS_ID               INT NOT NULL,  
                EN_ID               INT NULL,  
  
                --Status  
                Status_ID           TINYINT NOT NULL,  
  
                --Info  
                [Name]              NVARCHAR(250) NULL,  
                Code                NVARCHAR(250) NULL,  
  
                --Auditing  
                EnterDTM            DATETIME2(3) NOT NULL CONSTRAINT ', QUOTENAME(N'df_' + @PendingTable  + N'_EnterDTM'), N' DEFAULT GETUTCDATE(),  
                EnterUserID         INT NOT NULL,  
                LastChgDTM          DATETIME2(3) NOT NULL CONSTRAINT ', QUOTENAME(N'df_' + @PendingTable  + N'_LastChgDTM'), N' DEFAULT GETUTCDATE(),  
                LastChgUserID       INT NOT NULL,  
                LastChgTS           ROWVERSION NOT NULL,  
                Revision_ID         BIGINT NOT NULL,  
                MUID                UNIQUEIDENTIFIER NOT NULL,  
  
                --Create PRIMARY KEY constraint  
                CONSTRAINT ', QUOTENAME(N'pk_' + @PendingTable), N'  
                    PRIMARY KEY CLUSTERED (Version_ID, ID),  
  
                --Create FOREIGN KEY constraints  
                CONSTRAINT ', QUOTENAME(N'fk_' + @PendingTable + N'_' + @EntityTable + '_Version_ID_EN_ID'), N'  
                    FOREIGN KEY (Version_ID, EN_ID) REFERENCES mdm.' + @EntityTable + '(Version_ID, ID)  
                    ON UPDATE NO ACTION  
                    ON DELETE CASCADE  
            )  
            ', @TableOptions, N'  
  
            CREATE NONCLUSTERED INDEX ', QUOTENAME(N'ix_' + @PendingTable + N'_Version_ID_CS_ID_EN_ID'), N'  
                ON mdm.', QUOTENAME(@PendingTable), N'(Version_ID, CS_ID, EN_ID)  
                ', @IndexOptions, N';  
  
            --Create the Member Security (EN_MS) table  
            --There is no IDENTITY() column since this table gets bulk- deleted & inserted frequently  
            CREATE TABLE mdm.', QUOTENAME(@SecurityTable), N'  
            (  
                Version_ID          INT NOT NULL,  
                User_ID             INT NOT NULL,  
                ID                  INT NOT NULL,  
                AccessPermission    TINYINT NOT NULL,  
  
                --Create PRIMARY KEY constraint  
                CONSTRAINT ', QUOTENAME(N'pk_' + @SecurityTable), N'  
                     PRIMARY KEY CLUSTERED (Version_ID, User_ID, ID), -- User_ID comes before ID (udpSecurityMemberProcess joins on Version_ID and User_ID)  
  
                --Create FOREIGN KEY constraints  
                CONSTRAINT ', QUOTENAME(N'fk_' + @SecurityTable + N'_' + @EntityTable + '_Version_ID_ID'), N'  
                    FOREIGN KEY (Version_ID, ID) REFERENCES mdm.' + @EntityTable + '(Version_ID, ID)  
                    ON UPDATE NO ACTION  
                    ON DELETE CASCADE  
            )  
            ', @TableOptions, N'  
  
            -- Create index for the FK, to improve perf of cascaded deletes from EN table.  
            CREATE NONCLUSTERED INDEX ', QUOTENAME(N'ix_' + @SecurityTable + N'_Version_ID_ID'), N'  
                ON mdm.', QUOTENAME(@SecurityTable), N'(Version_ID, ID)  
                ', @IndexOptions, N';  
            ');  
  
            --Execute the dynamic SQL  
            --PRINT(@SQL);  
            EXEC sp_executesql @SQL;  
  
            --Add default columns to Attribute table  
            INSERT INTO mdm.tblAttribute (Entity_ID,SortOrder,DomainEntity_ID,AttributeType_ID,MemberType_ID,IsSystem,IsReadOnly,IsCode,IsName,[Name],DisplayName,TableColumn,DisplayWidth,DataType_ID,DataTypeInformation,InputMask_ID,EnterUserID,EnterVersionID,LastChgUserID,LastChgVersionID)  
            VALUES  
             (@Entity_ID, 1, NULL, 3, 1, 1, 1, 0, 0, N'ID',N'ID',N'ID',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
            ,(@Entity_ID, 2, NULL, 3, 1, 1, 1, 0, 0, N'Version_ID',N'Version_ID',N'Version_ID',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
            ,(@Entity_ID, 4, NULL, 3, 1, 1, 1, 0, 0, N'Status_ID',N'Status_ID',N'Status_ID',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
            ,(@Entity_ID, 5, NULL, 3, 1, 1, 1, 0, 0, N'ValidationStatus_ID',N'ValidationStatus_ID',N'ValidationStatus_ID',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
            ,(@Entity_ID, 6, NULL, 3, 1, 1, 1, 0, 0, N'EnterDTM',N'EnterDTM',N'EnterDTM',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
            ,(@Entity_ID, 7, NULL, 3, 1, 1, 1, 0, 0, N'EnterUserID',N'EnterUserID',N'EnterUserID',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
            ,(@Entity_ID, 8, NULL, 3, 1, 1, 1, 0, 0, N'EnterVersionID',N'EnterVersionID',N'EnterVersionID',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
            ,(@Entity_ID, 9, NULL, 3, 1, 1, 1, 0, 0, N'LastChgDTM',N'LastChgDTM',N'LastChgDTM',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
            ,(@Entity_ID, 10, NULL, 3, 1, 1, 1, 0, 0, N'LastChgUserID',N'LastChgUserID',N'LastChgUserID',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
            ,(@Entity_ID, 11, NULL, 3, 1, 1, 1, 0, 0, N'LastChgVersionID',N'LastChgVersionID',N'LastChgVersionID',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
            ,(@Entity_ID, 12, NULL, 3, 1, 1, 1, 0, 0, N'LastChgTS',N'LastChgTS',N'LastChgTS',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
            ,(@Entity_ID, 13, NULL, 1, 1, 1, 0, 0, 1, N'Name',N'Name',N'Name',250,1,250,1,@User_ID,@Version_ID,@User_ID,@Version_ID)  
            ,(@Entity_ID, 14, NULL, 1, 1, 1, 0, 1, 0, N'Code',N'Code',N'Code',250,1,250,1,@User_ID,@Version_ID,@User_ID,@Version_ID)  
            ,(@Entity_ID, 15, NULL, 3, 1, 1, 1, 0, 0, N'MUID',N'MUID',N'MUID',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
            ,(@Entity_ID, 16, NULL, 3, 1, 1, 1, 0, 0, N'AsOf_ID',N'AsOf_ID',N'AsOf_ID',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
            ,(@Entity_ID, 17, NULL, 3, 1, 1, 0, 0, 0, N'ChangeTrackingMask',N'ChangeTrackingMask',N'ChangeTrackingMask',0,0,NULL,0,@User_ID,@Version_ID,@User_ID,@Version_ID)  
            ;  
  
            EXEC mdm.udpEntityStagingCreateLeafTable  
                 @StagingTableName = @StagingTable  
                ,@TableOptions = @StagingTableOptions  
                ,@IndexOptions = @StagingIndexOptions;  
  
            IF @RecreateStagingProc = 1  
            BEGIN  
                -- Create the leaf member staging stored procedure.  
                EXEC mdm.udpEntityStagingCreateLeafStoredProcedure @Entity_ID  
            END  
        END; --if  
  
        --Recreate the views  
        EXEC mdm.udpCreateViews @Model_ID, @Entity_ID;  
        EXEC mdm.udpEntityStagingCreateErrorDetailViews @Entity_ID;  
  
        --Return values  
        SET @Return_ID = @Entity_ID;  
  
        --Commit only if we are not nested  
        IF @TranCounter = 0  
        BEGIN  
            COMMIT TRANSACTION;  
            --Set @TranCommitted as 1 (committed).  
            SET @TranCommitted = 1;  
        END -- IF  
  
        -- Return indicating whether the entity name was updated.  This is used in the API to determine if business rules should be refreshed.  
        IF  @EditMode = @EditMode_Update AND  
            (@CurrentEntityName <> COALESCE(@EntityName, @CurrentEntityName) OR  
            (@CurrentEntityStagingBaseName <> CASE WHEN LEN(@StagingBase) > 0 THEN @StagingBase ELSE @CurrentEntityStagingBaseName END))  
        BEGIN  
            SET @Return_DidNameChange = 1;  
        END  
        ELSE  
        BEGIN  
            SET @Return_DidNameChange = 0;  
        END  
  
        -- Send the message  
	    EXEC mdm.udpPerformanceQueueSave;  
  
        RETURN(0);  
  
    END TRY  
    --Compensate as necessary  
    BEGIN CATCH  
  
        -- Get error info.  
        DECLARE  
            @ErrorMessage NVARCHAR(4000),  
            @ErrorSeverity INT,  
            @ErrorState INT,  
            @ErrorNumber INT,  
            @ErrorLine INT,  
            @ErrorProcedure NVARCHAR(126);  
        EXEC mdm.udpGetErrorInfo  
            @ErrorMessage = @ErrorMessage OUTPUT,  
            @ErrorSeverity = @ErrorSeverity OUTPUT,  
            @ErrorState = @ErrorState OUTPUT,  
            @ErrorNumber = @ErrorNumber OUTPUT,  
            @ErrorLine = @ErrorLine OUTPUT,  
            @ErrorProcedure = @ErrorProcedure OUTPUT  
  
        SET @ErrorMessage = CONCAT(@ErrorMessage, N', @ErrorNumber = ', @ErrorNumber, N', @ErrorProcedure = "', @ErrorProcedure, N'", line ', @ErrorLine);  
  
        IF @TranCommitted = 0 -- Don't rollback when the transaction has been committed.  
        BEGIN  
            IF @TranCounter = 0 ROLLBACK TRANSACTION;  
            ELSE IF XACT_STATE() <> -1 ROLLBACK TRANSACTION TX;  
        END; -- IF  
  
        RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);  
  
        RETURN;  
  
    END CATCH;  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpEntityStagingAllBatchesByModelGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
-- This SProc returns two tables:  
-- 1. The amount of batches that would have returned if there was no paging  
-- 2. Returns all the processed and unprocessed batches and their summary information  
-- in a specific model  
-- It does this using the view on all batches in the system with an ID  
-- and the SProc that gets all the batch tags in the staging tables.  
-- The results are sorted first by uncompleted batches, and then by the ProcessEnd date  
--  
-- This SPRoc allows for filtering based on model and should/should not include  
-- batches that have been marked as cleared, as well as paging support.  
-- Example run:  
-- EXEC mdm.udpEntityStagingAllBatchesByModelGet @Model_ID=2  
-- Example output:  
/*  
--Table[0]  
3  
--Table[1]  
1    4    ThirdTag_DifferentEntity    21    Function    2    3    Version 2    2    2010-11-02 01:26:34.870    2010-11-02 01:26:36.727    1    0  
2    3    SecondTag                    20    Department    2    4    Version 3    2    2010-11-02 01:26:29.340    2010-11-02 01:26:33.483    0    0  
3    2    MyBatchTag                    20    Department    2    4    Version 3    2    2010-11-02 01:04:28.510    2010-11-02 01:04:33.317    0    0  
*/   
CREATE PROCEDURE [mdm].[udpEntityStagingAllBatchesByModelGet]  
(  
    @Model_ID               INT,  
    @IncludeClearedBatches  BIT = 0,  
    @PageNumber             INT = 1,  
    @PageSize               INT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    -- Stage temporary results received from the different data inputs into this table  
    DECLARE @results TABLE  
    (  
        RowNumber           INT IDENTITY(1,1)       NOT NULL,  
        Batch_ID            INT                     NULL,  
        BatchTag            NVARCHAR(50)            NOT NULL,  
        Entity_MUID         UNIQUEIDENTIFIER        NOT NULL,  
        MemberTypeID        INT                     NULL,  
        Version_MUID        UNIQUEIDENTIFIER        NULL,  
        VersionName         NVARCHAR(250)           NULL,  
        [Status]            TINYINT                 NOT NULL,  
        ProcessStart        DATETIME                NULL,  
        ProcessEnd          DATETIME                NULL,  
        -- HasCompletedDate column will help sort the results first by those  
        -- that are not yet completed (NULL ProcessEnd field) and then those that are  
        HasCompletedDate    BIT                        NOT NULL,  
        MemberCount         INT                     DEFAULT 0,  
        RowsInError         INT                     DEFAULT 0,  
        ErrorView           NVARCHAR(MAX)           NULL,  
        StagingTable        sysname                 NULL  
    )  
  
    DECLARE @unprocessedBatches TABLE  
    (  
        BatchTag        NVARCHAR(50)        NOT NULL,  
        [Status]        TINYINT             NOT NULL,  
        MemberTypeID    INT                 NOT NULL,  
        Entity_MUID     UNIQUEIDENTIFIER    NOT NULL,  
        MemberCount     INT                 NOT NULL  
    )  
  
    DECLARE  
        --Member Types (Constant)  
        @MemberType_Leaf                INT = 1,  
        @MemberType_Consolidated        INT = 2,  
        @MemberType_Hierarchy           INT = 4,  
  
        -- Counters for loop  
        @Counter                INT = 1,    
        @MaxCounter             INT,  
        -- Used in the loop to store temporary batch information  
        @CountedBatch_ID        INT,  
        @CountedStagingTable    sysname,  
        @SQL                    NVARCHAR(MAX),  
        @MemberCount            INT,  
      
        -- Paging Information  
        @StartRow   INT,  
        @LastRow    INT  
  
    -- Get the "processed" batches and insert into temporary results table  
    INSERT INTO @results  
    (  
        Batch_ID,  
        BatchTag,  
        Entity_MUID,  
        MemberTypeID,  
        Version_MUID,  
        VersionName,  
        [Status],  
        ProcessStart,  
        ProcessEnd,  
        HasCompletedDate,  
        MemberCount,  
        RowsInError,  
        ErrorView,  
        StagingTable  
    )  
    SELECT  
        Batch_ID,  
        BatchTag,  
        MUID AS Entity_MUID,  
        MemberTypeID,  
        Version_MUID,  
        VersionName,  
        [Status],  
        ProcessStart,  
        ProcessEnd,  
        CASE   
                WHEN ProcessEnd IS NULL THEN    0  
                ELSE                            1  
        END,  
        TotalRows,  
        RowsInError,  
        CASE     
                WHEN (MemberTypeID = @MemberType_Hierarchy) THEN N'SELECT * from [stg].' + QUOTENAME(N'viw_' + Entity.StagingBase  + N'_RelationshipErrorDetails') + ' WHERE Batch_ID = ' + CAST(Batch.Batch_ID AS NVARCHAR(MAX))  
                ELSE                                             N'SELECT * from [stg].' + QUOTENAME(N'viw_' + Entity.StagingBase  + N'_MemberErrorDetails') + ' WHERE Batch_ID = ' + CAST(Batch.Batch_ID AS NVARCHAR(MAX))  
        END,  
        CASE  
                WHEN (MemberTypeID = @MemberType_Consolidated)  THEN    N'stg.' + QUOTENAME(Entity.StagingConsolidatedTable)  
                WHEN (MemberTypeID = @MemberType_Hierarchy)     THEN    N'stg.' + QUOTENAME(Entity.StagingRelationshipTable)  
                ELSE                                                    N'stg.' + QUOTENAME(Entity.StagingLeafTable)  
        END  
    FROM  
        mdm.viw_EntityStagingBatchesAllProcessed    AS Batch  
    JOIN mdm.viw_SYSTEM_SCHEMA_ENTITY               AS Entity  
        ON (Batch.Entity_ID = Entity.ID)  
    WHERE   
        Batch.Model_ID = @Model_ID AND  
        -- Filter out "cleared" batches if the IncludeClearedBatches is false  
        ((@IncludeClearedBatches = 1) OR ([Status] != 5))   
  
    -- If the member count is not set (the timing between inserting a record to tblStgBatch and setting   
    -- the member count), count the members of the batch tag and update the count into the @results table.  
    SET @MaxCounter = (SELECT MAX(RowNumber) FROM @results)  
  
    WHILE @Counter <= @MaxCounter    
        BEGIN    
            SELECT TOP 1    
                @CountedBatch_ID = Batch_ID,  
                @CountedStagingTable = StagingTable,  
                @MemberCount = MemberCount  
            FROM @results    
            WHERE RowNumber = @Counter  
  
            IF ISNULL(@MemberCount, 0) = 0 -- The member count has not been set.   
            BEGIN  
                SET @SQL = N'  
                    SELECT  
                        @MemberCount = COUNT(*)  
                    FROM  
                        ' + @CountedStagingTable + '  
                    WHERE  
                        Batch_ID = ' + CAST(@CountedBatch_ID AS NVARCHAR(MAX)) + '  
                '  
  
                exec sp_executesql @SQL,  N'@MemberCount INT OUTPUT', @MemberCount OUTPUT;  
  
                UPDATE  
                    @results  
                SET  
                    MemberCount = @MemberCount  
                WHERE  
                    Batch_ID = @CountedBatch_ID  
  
            END; --IF  
  
            SET @Counter = @Counter + 1  
  
        END -- WHILE  
      
    -- Get all the unprocessed batches and put into this variable table.  
    -- An unprocessed batch, meaning one we only found in the staging tables  
    -- but not in the tblStgBatch table, will only have basic information  
    INSERT INTO @unprocessedBatches EXEC mdm.udpEntityStagingUnprocessedBatchesGet @Model_ID  
  
    -- Take the results from both queries and combine them into the @results table  
    -- To allow users to reuse batch tags don't merge the results based on the batch tag.   
    INSERT   
        INTO @results   
        (BatchTag,   
        [Status],   
        Entity_MUID,   
        MemberTypeID,   
        HasCompletedDate,   
        MemberCount)  
        SELECT BatchTag,   
            [Status],   
            Entity_MUID,   
            MemberTypeID,   
            0,   
            MemberCount  
        FROM @unprocessedBatches;  
      
    ---- All "unprocessed" batches by definition don't have a complete date, as they haven't even started.  
    
    -- In first datatable, return the amount of batches that would have returned if there was no paging  
    SELECT  
        COUNT(*)    AS  BatchCount  
    FROM  
        @results  
  
    -- Set paging variables  
    -- Set defaults for invalid arguments for paging. (Which gets all records)  
    IF @PageSize < 1 SET @PageSize = NULL  
    IF @PageNumber < 1 SET @PageNumber = 1  
    -- The first and last row (inclusive) to return  
    IF (@PageSize IS NOT NULL)  
    BEGIN  
        SET @StartRow = (@PageNumber - 1) * (@PageSize);    
        SET @LastRow = @StartRow + @PageSize - 1  
    END  
  
    -- In the second datatable return the batches' information  
    -- Use an inner select query to order the rows, give them a unique row_number, and then page  
    -- the results using this number  
    SELECT *  
    FROM  
    (  
        SELECT  
            -- Give each row a unique number. First the ones that don't have a completed date, then the last ones to finish  
            Row_Number() OVER(ORDER BY HasCompletedDate ASC, ProcessEnd DESC) AS RowIndex,  
            Batch_ID,  
            BatchTag,  
            Entity_MUID,  
            Entity.Name AS EntityName,  
            MemberTypeID,  
            Version_MUID,  
            VersionName,  
            [Status],  
            ProcessStart,  
            ProcessEnd,  
            RowsInError,  
            MemberCount,  
            ErrorView  
        FROM  
            @results AS Batch  
        INNER JOIN  mdm.tblEntity AS Entity  
            ON Batch.Entity_MUID = Entity.MUID  
    ) AS ResultSet  
    WHERE  
        (@PageSize IS NULL) OR  
        (ResultSet.RowIndex BETWEEN @StartRow AND @LastRow)  
END -- PROC
GO
/****** Object:  StoredProcedure [mdm].[udpEntityStagingBatchTableCleanup]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    EXEC mdm.udpEntityStagingBatchTableCleanup 7, '2014-10-24';  
    SELECT * FROM mdm.tbl_7_TR where LastChgDTM,  '2014-10-24';  
*/  
CREATE PROCEDURE [mdm].[udpEntityStagingBatchTableCleanup]  
(  
    @Model_ID    INT,  
    @CleanupOlderThanDate  DATE,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS N'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON  
  
    DECLARE  
        @SQL                    NVARCHAR(MAX)  
        ,@Entity_ID             INT  
  
    BEGIN TRY  
  
        --Temporary table to hold all batches we want to clean  
        CREATE TABLE #BatchTable  
        (  
            RowNumber INT IDENTITY(1, 1) NOT NULL PRIMARY KEY  
            ,Batch_ID INT NOT NULL  
            ,Entity_ID INT NOT NULL  
        );  
  
       --Get all the batches you want to delete  
  
        INSERT INTO #BatchTable  
        SELECT sb.ID  
            ,sb.Entity_ID  
        FROM [mdm].tblStgBatch sb  
            INNER JOIN [mdm].tblEntity ent  
            ON sb.Entity_ID = ent.ID  
            WHERE ent.Model_ID = @Model_ID  
            AND sb.LastRunEndDTM <= @CleanupOlderThanDate  
  
        DECLARE @Batch_ID INT,  
                @LeafStagingTable sysname,  
                @ConsolidatedStagingTable sysname,  
                @RelationshipStagingTable sysname;  
  
        DECLARE c CURSOR FOR SELECT DISTINCT Entity_ID From #BatchTable GROUP BY Entity_ID  
                OPEN c  
                FETCH NEXT FROM c INTO @Entity_ID  
  
            WHILE @@Fetch_Status=0  
            BEGIN  
  
                SELECT  
                @LeafStagingTable = CASE WHEN StagingLeafTable IS NULL THEN N''  
                                        ELSE '[stg].' + QUOTENAME(StagingLeafTable)  
                                    END,  
                @ConsolidatedStagingTable = CASE WHEN StagingConsolidatedTable IS NULL THEN N''  
                                                ELSE 'stg.' + QUOTENAME(StagingConsolidatedTable)  
                                            END,  
                @RelationshipStagingTable = CASE WHEN StagingRelationshipTable IS NULL THEN N''  
                                                ELSE 'stg.' + QUOTENAME(StagingRelationshipTable)  
                                            END  
                FROM  
                    mdm.viw_SYSTEM_SCHEMA_ENTITY WHERE ID = @Entity_ID;  
  
                SET @SQL = 'DELETE FROM '+ @LeafStagingTable + ' FROM '+ @LeafStagingTable + ' sTbl INNER JOIN #BatchTable bt  
                    ON sTbl.Batch_ID = bt.Batch_ID  
                    WHERE bt.Entity_ID = @Entity_ID';  
                    print @SQL  
                EXEC sp_executesql @SQL, N'@Entity_ID INT', @Entity_ID  
  
                IF LEN(ISNULL(@ConsolidatedStagingTable, N'')) <> 0  
                BEGIN  
                    SET @SQL = 'DELETE FROM '+ @ConsolidatedStagingTable + ' FROM '+ @ConsolidatedStagingTable + ' sTbl INNER JOIN #BatchTable bt  
                    ON sTbl.Batch_ID = bt.Batch_ID  
                    WHERE bt.Entity_ID = @Entity_ID';  
                    print @SQL  
                    EXEC sp_executesql @SQL, N'@Entity_ID INT', @Entity_ID  
                END  
  
                IF LEN(ISNULL(@RelationshipStagingTable, N'')) <> 0  
                BEGIN  
                    SET @SQL = 'DELETE FROM '+ @RelationshipStagingTable + ' FROM '+ @RelationshipStagingTable + ' sTbl INNER JOIN #BatchTable bt  
                    ON sTbl.Batch_ID = bt.Batch_ID  
                    WHERE bt.Entity_ID = @Entity_ID';  
                    print @SQL  
                    EXEC sp_executesql @SQL, N'@Entity_ID INT', @Entity_ID  
                END  
  
                SET @SQL = 'DELETE FROM [mdm].tblStgBatch FROM [mdm].tblStgBatch sTbl INNER JOIN #BatchTable bt  
                    ON sTbl.ID = bt.Batch_ID  
                    WHERE bt.Entity_ID = @Entity_ID';  
                    print @SQL  
                    EXEC sp_executesql @SQL, N'@Entity_ID INT', @Entity_ID  
  
  
                FETCH NEXT FROM c INTO @Entity_ID  
            END  
  
        CLOSE c  
        DEALLOCATE c  
    RETURN(0);  
    END TRY  
    --Compensate as necessary  
    BEGIN CATCH  
  
        -- Get error info.  
        DECLARE  
            @ErrorMessage NVARCHAR(4000),  
            @ErrorSeverity INT,  
            @ErrorState INT,  
            @ErrorNumber INT,  
            @ErrorLine INT,  
            @ErrorProcedure NVARCHAR(126);  
        EXEC mdm.udpGetErrorInfo  
            @ErrorMessage = @ErrorMessage OUTPUT,  
            @ErrorSeverity = @ErrorSeverity OUTPUT,  
            @ErrorState = @ErrorState OUTPUT,  
            @ErrorNumber = @ErrorNumber OUTPUT,  
            @ErrorLine = @ErrorLine OUTPUT,  
            @ErrorProcedure = @ErrorProcedure OUTPUT  
  
        SET @ErrorMessage = CONCAT(@ErrorMessage, N', @ErrorNumber = ', @ErrorNumber, N', @ErrorProcedure = "', @ErrorProcedure, N'", line ', @ErrorLine);  
  
        RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);  
  
        RETURN(1);  
  
    END CATCH;  
  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpEntityStagingCreateConsolidatedStoredProcedure]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpEntityStagingCreateConsolidatedStoredProcedure]  
(  
    @Entity_ID    INT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE @SQL                        NVARCHAR(MAX) = N'',  
            @SQLNonDBAColumns           NVARCHAR(MAX) = N'',  
            @SQLDBAColumns              NVARCHAR(MAX) = N'',  
            @SQLNonDBA                  NVARCHAR(MAX) = N'',  
            @SQLDBA                     NVARCHAR(MAX) = N'',  
            @SQLDBAJoin                 NVARCHAR(MAX) = N'',  
            @SQLDBACheck                NVARCHAR(MAX) = N'',  
            @EntityTable                SYSNAME = N'',  
            @CollectionTable            SYSNAME = N'',  
            @HierarchyParentTable       SYSNAME = N'',  
            @HierarchyRelationshipTable SYSNAME = N'',  
            @CurrentTableColumn         SYSNAME = N'',  
            @CurrentTableColumnNoQuote  SYSNAME = N'',  
            @CurrentViewColumn          NVARCHAR(120) = N'', --specifically made to be less than 128 for truncation reasons  
            @CurrentAttributeName       NVARCHAR(100) = N'',  
            @CurrentDomainTable         SYSNAME = N'',  
            @CurrentDomainEntity_ID     INT,  
            @CurrentAttributeType_ID    TINYINT,  
            @CurrentDataType_ID         TINYINT,  
            @SQLMergeOptimisticNonDBA   NVARCHAR(MAX) = N'',  
            @SQLMergeOptimisticDBA      NVARCHAR(MAX) = N'',  
            @SQLMergeOverwriteNonDBA    NVARCHAR(MAX) = N'',  
            @SQLMergeOverwriteDBA       NVARCHAR(MAX) = N'',  
            @SQLAttributeTypeErrorCheck NVARCHAR(MAX) = N'',  
            @StagingBase                NVARCHAR(60),  
            @StagingConsolidatedTable   SYSNAME,  
            @StagingConsolidatedTableWithEscapedQuotes  SYSNAME,  -- Contains same value as @StagingConsolidatedTable, but with the single quotes escaped out. This should be used when using the staging name inside of a dynamic SQL statement that is nested inside another dynamic SQL statement.  
            @SQLAttributeValueSetMergeOverwrite         NVARCHAR(MAX) = N'',  
            @SQLAttributeValueSetMergeOptimistic        NVARCHAR(MAX) = N'',  
  
            --Entity member status  
            @MemberStatus_Active        NVARCHAR(1) = N'1',  
            @MemberStatus_Deactivated   NVARCHAR(1) = N'2',  
  
            -- This pseudo-constant is for use in string concatenation operations to prevent string truncation. When concatenating two or more strings,  
            -- if none of the strings is an NVARCHAR(MAX) or an NVARCHAR constant that is longer than 4,000 characters, then the resulting string  
            -- will be silently truncated to 4,000 characters. Concatenating with this empty NVARCHAR(MAX), is sufficient to prevent truncation.  
            -- See http://connect.microsoft.com/SQLServer/feedback/details/283368/nvarchar-max-concatenation-yields-silent-truncation.  
            @TruncationGuard            NVARCHAR(MAX) = N'',  
  
            -- attribute type constant  
            @AttributeType_File         INT = 4,  
  
            @Model_ID                   INT,  
            @TranOldColumn              NVARCHAR(MAX) = N'',  
            @TranNewColumn              NVARCHAR(MAX) = N'',  
            @TranDeletedColumn          NVARCHAR(MAX) = N'',  
            @TranBlankColumn            NVARCHAR(MAX) = N'',  
            @TranInsertedColumn         NVARCHAR(MAX) = N'',  
  
            --Transaction and annotation table names  
            @TransactionTableName       SYSNAME,  
            @HPHistoryOutputQuery       NVARCHAR(MAX) = N'',  
            @HRHistoryOutputQuery       NVARCHAR(MAX) = N'',  
  
            @MemberType_Consolidated    TINYINT = 2,  
            @MemberType_Hierarchy       TINYINT = 4,  
  
            -- Transaction log type constants  
            @TransactionLogType            TINYINT,  
            @TransactionLogType_Attribute  TINYINT = 1,  
            @TransactionLogType_Member     TINYINT = 2,  
            @TransactionLogType_None       TINYINT = 3;  
  
            DECLARE @TempTable TABLE(  
            ViewColumn                  NVARCHAR(100) COLLATE DATABASE_DEFAULT,  
            TableColumn                 NVARCHAR(128) COLLATE DATABASE_DEFAULT NOT NULL,  
            AttributeType_ID            TINYINT NOT NULL,  
            DataType_ID                 TINYINT NOT NULL,  
            DomainEntity_ID             INT NULL,  
            DomainTable                 NVARCHAR(128) COLLATE DATABASE_DEFAULT NULL,  
            SortOrder                   INT);  
  
    --Initialize the variables  
  
    SELECT  @EntityTable = QUOTENAME(EntityTable),  
            @CollectionTable = QUOTENAME(CollectionTable),  
            @HierarchyParentTable = QUOTENAME(HierarchyParentTable),  
            @HierarchyRelationshipTable = QUOTENAME(HierarchyTable),  
            @Model_ID = Model_ID,  
            @StagingBase = StagingBase,  
            @StagingConsolidatedTable = QUOTENAME(IsNULL(StagingConsolidatedTable, N'')),  
            @TransactionLogType = TransactionLogType  
    FROM mdm.viw_SYSTEM_SCHEMA_ENTITY  
    WHERE ID = @Entity_ID;  
  
    -- Escape out the single quotes in the staging table name and put it into another var that will be used for referencing the table name from nested dynamic SQL.  
    SET @StagingConsolidatedTableWithEscapedQuotes = QUOTENAME(@StagingConsolidatedTable, N'''');  
    -- Remove the leading and trailing single quotes that the above QUOTENAME added (we only want the escaped quotes within the table name)  
    SET @StagingConsolidatedTableWithEscapedQuotes = SUBSTRING(@StagingConsolidatedTableWithEscapedQuotes, 2, LEN(@StagingConsolidatedTableWithEscapedQuotes) - 2);  
  
    IF @TransactionLogType = @TransactionLogType_Member  
    BEGIN  
        SET @HPHistoryOutputQuery = mdm.udfGetHistoryOutputQuery(@Entity_ID, @MemberType_Consolidated, N'@User_ID', N'@Now');  
        SET @HRHistoryOutputQuery = mdm.udfGetHistoryOutputQuery(@Entity_ID, @MemberType_Hierarchy, N'@User_ID', N'@Now');  
    END  
    ELSE  
    BEGIN  
        --Load the transaction and annotation table names  
        SET @TransactionTableName = mdm.udfGetTransactionTableName(@Model_ID);  
    END  
  
    -- In case when the entity is a system entity (StagingBase is not specified)  
    -- simply don't create the staging SProc (don't raise an error).  
    IF COALESCE(@StagingBase, N'') = N''  
    BEGIN  
        RETURN;  
    END;  
  
    --If the consolidated staging SProc exists drop it.  
    EXEC mdm.udpEntityStagingDeleteStoredProcedures @Entity_ID, 2  
  
    SET @SQL = @TruncationGuard + N'CREATE PROCEDURE [stg].' + QUOTENAME(N'udp_' + @StagingBase + N'_Consolidated') + N'  
@VersionName NVARCHAR(50), @LogFlag INT=0, @BatchTag NVARCHAR(50)=N'''', @Batch_ID INT=NULL, @UserName NVARCHAR(100) = NULL, @User_ID INT = 0  
WITH EXECUTE AS ''mds_schema_user''  
AS  
BEGIN  
SET NOCOUNT ON;  
  
DECLARE @Model_ID                   INT,  
@Version_ID                 INT,  
@Hierarchy_ID               INT,  
@HierarchyParent_ID         INT,  
@IsMandatory                BIT,  
@VersionStatus_ID           INT,  
@VersionStatus_Committed    INT = 3,  
@Entity_ID                  INT,  
@MemberCount                INT = 0,  
@ErrorCount                 INT = 0,  
@NewBatch_ID                INT = 0,  
@GetNewBatch_ID             INT = 0,  
@Member_ID                  INT,  
@CurrentHierarchy_ID        INT,  
@CurrentHierarchy_Name      NVARCHAR(50),  
@Now                        DATETIME2,  
  
-- member type constant  
@ConsolidatedMemberTypeID   INT = 2,  
  
-- attribute type constants  
@FreeformTypeId             INT = 1,  
@DomainTypeId               INT = 2,  
@SystemTypeId               INT = 3,  
  
-- transaction type constants  
@StatusChangedId            INT = 2,  
@AttributeChangedId         INT = 3,  
  
-- staging datastatus constants  
@StatusDefault              INT = 0,  
@StatusOK                   INT = 1,  
@StatusError                INT = 2,  
@StatusProcessing           INT = 3,  
  
-- error return code constants  
@UserIDError                INT = 1,  
@VersionNameError           INT = 3,  
@UserPermissionError        INT = 4,  
@VersionStatusError         INT = 5,  
@NoRecordToProcessError     INT = 6,  
@BatchIDAndBatchTagSpecifiedError INT = 7,  
@BatchStatusError           INT = 8,  
@OtherRuntimeError          INT = 9,  
  
-- bacth status constants  
@QueuedToRun                INT = 1,  
@NotRunning                 INT = 2,  
@Running                    INT = 3,  
@QueueToClear               INT = 4,  
@Cleared                    INT = 5,  
@AllExceptCleared           INT = 6,  
@Completed                  INT = 7,  
  
-- GetNewBatch_ID constants  
@BatchIDFound               INT = 0,  
@BatchIDNotFound            INT = 1,  
@BatchIDForBatchTagNotFound INT = 2,  
  
--Import Type Constans  
@IT_MergeOptimistic         INT = 0,  
@IT_Insert                  INT = 1,  
@IT_MergeOverwrite          INT = 2,  
@IT_Delete                  INT = 3,  
@IT_Purge                   INT = 4,  
@IT_Max                     INT = 4,  
  
--FK Constraint Removal  
@FKEntity_ID                INT,  
@FKMemberType_ID            INT,  
@FKMemberCode               NVARCHAR(250),  
@FKMember_ID                INT,  
@EntityName                 NVARCHAR(100),  
@EntityTable                SYSNAME,  
@AttributeName              NVARCHAR(100),  
@AttributeColumn            SYSNAME,  
@MemberType_ID              INT,  
@MemberCode                 NVARCHAR(250),  
@ImportType                 TINYINT,  
@TableColumn                NVARCHAR(128),  
@TableName                  SYSNAME,  
@FKSQL                      NVARCHAR(MAX) = N'''',  
  
--Special attribute values  
@NULLNumber                 DECIMAL(38,0) = -98765432101234567890,  
@NULLText                   NVARCHAR(10) = N''~NULL~'',  
@NULLDateTime               NVARCHAR(30) = N''5555-11-22T12:34:56'',  
  
--Change Tracking Group  
@ChangedAttributeName       NVARCHAR(100),  
@ConsolidatedAttributeName  NVARCHAR(100),  
@ChangeTrackingGroup        INT,  
@SQLCTG                     NVARCHAR(MAX),  
@ChangedAttributeType_ID    TINYINT,  
@ChangedAttributeDomainEntityTableName SYSNAME,  
@AttributeType_Domain       TINYINT = 2,  
  
--Transaction Log Types  
@MemberCreateTransaction        INT = 1,  
@MemberStatusSetTransaction     INT = 2,  
@MemberAttributeSetTransaction  INT = 3,  
@HierarchyParentSetTransaction  INT = 4,  
  
--Validation status  
@NewAwaitingValidation      INT = 0,  
@AwaitingRevalidation       INT = 4,  
  
--Code generation  
@AllowCodeGen               BIT = 0,  
  
--XACT_STATE() constancts  
@UncommittableTransaction    INT = -1;  
  
DECLARE @TABLECTG TABLE  
(  
    ID                  INT IDENTITY (1, 1) NOT NULL,  
    AttributeName       NVARCHAR(100) COLLATE DATABASE_DEFAULT,  
    AttributeColumnName SYSNAME,  
    AttributeID         INT,  
    ChangeTrackingID    INT,  
    AttributeType_ID    TINYINT,  
    DomainEntityTableName SYSNAME NULL  
);  
  
DECLARE @TableHP TABLE  
(  
    HierarchyParent_ID  INT,  
    IsMandatory         BIT  
);  
  
DECLARE @TableHierarchy TABLE  
(  
    Hierarchy_ID        INT,  
    Hierarchy_Name      NVARCHAR(50) COLLATE DATABASE_DEFAULT  
);  
  
SET @Model_ID = ' + CONVERT(NVARCHAR(25),@Model_ID) + N'  
SET @Entity_ID = ' + CONVERT(NVARCHAR(25),@Entity_ID) + N'  
  
-- @UserName overwrites @User_ID  
IF @UserName IS NOT NULL  
BEGIN  
    SET @User_ID = mdm.udfUserIDGetByUserName(@UserName)  
    IF @User_ID IS NULL  
    BEGIN  
        RAISERROR(''MDSERR500041|The UserName is unknown.'', 16, 1);  
        RETURN @UserIDError;  
    END  
END  
  
-- Check for invalid Version Name.  
IF @VersionName IS NULL RETURN @VersionNameError;  
  
-- Set @AllowCodeGen (1: Code generation is allowed for the entity. 0: Code generation is not allowed for the entity)  
EXEC @AllowCodeGen = mdm.udpIsCodeGenEnabled @Entity_ID;  
  
IF LEN(@BatchTag) > 0 AND @Batch_ID IS NOT NULL BEGIN  
    RAISERROR(''MDSERR310043|The Batch Tag and the Batch ID cannot be specified at the same time.'', 16, 1);  
    RETURN @BatchIDAndBatchTagSpecifiedError;  
END; --IF  
  
SELECT @Version_ID = ID, @VersionStatus_ID = Status_ID FROM mdm.tblModelVersion WHERE Model_ID = @Model_ID AND [Name] = @VersionName  
  
IF @Version_ID IS NULL BEGIN  
    RAISERROR(''MDSERR100036|The version name is not valid.'', 16, 1);  
    RETURN @VersionNameError;  
END; --IF  
  
    --Ensure that Version is not committed  
IF (@VersionStatus_ID = @VersionStatus_Committed) BEGIN  
    RAISERROR(''MDSERR310040|Data cannot be loaded into a committed version.'', 16, 1);  
    RETURN @VersionStatusError;  
END;  
  
--Check if there is any record to process.  
IF LEN(@BatchTag) > 0 BEGIN  
    SELECT @MemberCount = COUNT(ID) FROM [stg].' + @StagingConsolidatedTable + N'  
        WHERE BatchTag = @BatchTag AND ImportStatus_ID = @StatusDefault;  
    IF @MemberCount = 0    BEGIN  
        RETURN @NoRecordToProcessError;  
    END; -- IF  
END; -- IF  
ELSE BEGIN  
    IF @Batch_ID IS NOT NULL BEGIN  
        SELECT @MemberCount = COUNT(ID) FROM [stg].' + @StagingConsolidatedTable + N'  
            WHERE Batch_ID = @Batch_ID AND ImportStatus_ID = @StatusDefault;  
        IF @MemberCount = 0    BEGIN  
            RETURN @NoRecordToProcessError;  
        END; -- IF  
    END; -- IF  
END; -- IF  
  
-- If neither @BatchTag nor @Batch_ID is specified assume that a blank @BatchTag is specified.  
  
IF @Batch_ID IS NULL AND LEN(@BatchTag) = 0 BEGIN  
    SELECT @MemberCount = COUNT(ID) FROM [stg].' + @StagingConsolidatedTable + N'  
        WHERE (BatchTag IS NULL OR BatchTag = N'''') AND ImportStatus_ID = @StatusDefault;  
    IF @MemberCount = 0    BEGIN  
        RETURN @NoRecordToProcessError;  
    END; -- IF  
END; -- IF  
  
--Check if there is any record with an invalid status.  
IF LEN(@BatchTag) > 0 BEGIN  
-- Determine if there is a running batch with the given batch tag.  
DECLARE @IsBatchTagRunning BIT =  
    CASE WHEN EXISTS (SELECT 1  
                    FROM mdm.tblStgBatch  
                    WHERE  
                        BatchTag = @BatchTag  
                    AND Status_ID = @Running)  
    THEN 1 ELSE 0 END;  
  
IF      @IsBatchTagRunning = 1  
    AND EXISTS (SELECT 1  
            FROM [stg].' + @StagingConsolidatedTable + N'  
            WHERE   BatchTag = @BatchTag  
                AND ImportStatus_ID = @StatusDefault)  
BEGIN  
        RAISERROR(''MDSERR310029|The status of the specified batch is not valid.'', 16, 1);  
        RETURN @BatchStatusError;  
    END; -- IF  
END; -- IF  
  
IF @Batch_ID IS NOT NULL  BEGIN  
DECLARE @BatchStatus_ID INT = (SELECT Status_ID FROM mdm.tblStgBatch WHERE ID = @Batch_ID);  
IF @BatchStatus_ID IN (@Running, @QueueToClear, @Cleared)  
    AND EXISTS (  
        SELECT ID  
        FROM [stg].' + @StagingConsolidatedTable + N'  
        WHERE   Batch_ID = @Batch_ID  
            AND ImportStatus_ID = @StatusDefault)  
BEGIN  
        RAISERROR(''MDSERR310029|The status of the specified batch is not valid.'', 16, 1);  
        RETURN @BatchStatusError;  
    END; -- IF  
END; -- IF  
  
--Start transaction, being careful to check if we are nested  
DECLARE @TranCounter INT;  
SET @TranCounter = @@TRANCOUNT;  
IF @TranCounter > 0 SAVE TRANSACTION TX;  
ELSE BEGIN TRANSACTION;  
  
BEGIN TRY  
  
IF @Batch_ID IS NOT NULL  BEGIN  
    IF NOT EXISTS (SELECT ID FROM mdm.tblStgBatch WHERE ID = @Batch_ID AND Status_ID NOT IN (@Running, @QueueToClear, @Cleared)  
                    AND Version_ID = @Version_ID AND Entity_ID = @Entity_ID AND MemberType_ID = 2) BEGIN  
        SET @GetNewBatch_ID = @BatchIDNotFound  
    END; --IF  
END; --IF  
ELSE BEGIN  
    -- Check if udpEntityStagingFlagForProcessing already assigned a new batch ID (in this case the status is QueuedToRun).  
    SELECT TOP 1 @Batch_ID = ID FROM mdm.tblStgBatch  
        WHERE BatchTag = @BatchTag AND Status_ID = @QueuedToRun  
        AND Version_ID = @Version_ID AND Entity_ID = @Entity_ID AND MemberType_ID = @ConsolidatedMemberTypeID  
        ORDER BY ID DESC  
  
    IF @Batch_ID IS NULL BEGIN  
        SET @GetNewBatch_ID = @BatchIDForBatchTagNotFound  
    END; --IF  
    ELSE BEGIN  
    -- Set the member count  
        UPDATE mdm.tblStgBatch  
        SET TotalMemberCount = @MemberCount  
        WHERE BatchTag = @BatchTag AND Status_ID = @QueuedToRun  
                    AND Version_ID = @Version_ID AND Entity_ID = @Entity_ID AND MemberType_ID = @ConsolidatedMemberTypeID  
    END; --IF  
END; --IF  
  
  
IF @GetNewBatch_ID IN (@BatchIDNotFound, @BatchIDForBatchTagNotFound) BEGIN  
-- Create a new batch ID.  
    INSERT INTO mdm.tblStgBatch  
    (MUID  
    ,Version_ID  
    ,Status_ID  
    ,BatchTag  
    ,Entity_ID  
    ,MemberType_ID  
    ,TotalMemberCount  
    ,ErrorMemberCount  
    ,TotalMemberAttributeCount  
    ,ErrorMemberAttributeCount  
    ,TotalMemberRelationshipCount  
    ,ErrorMemberRelationshipCount  
    ,LastRunStartDTM  
    ,LastRunStartUserID  
    ,LastRunEndDTM  
    ,LastRunEndUserID  
    ,LastClearedDTM  
    ,LastClearedUserID  
    ,EnterDTM  
    ,EnterUserID)  
    SELECT  
        NEWID(),  
        @Version_ID,  
        @Running,  
        @BatchTag,  
        @Entity_ID,  
        2,  
        @MemberCount,  
        NULL,  
        NULL,  
        NULL,  
        NULL,  
        NULL,  
        GETUTCDATE(),  
        @User_ID,  
        NULL,  
        NULL,  
        NULL,  
        NULL,  
        GETUTCDATE(),  
        @User_ID  
  
    SELECT @NewBatch_ID = SCOPE_IDENTITY();  
  
    -- Update batch ID.  
  
    IF @GetNewBatch_ID = @BatchIDNotFound BEGIN  
        UPDATE [stg].' + @StagingConsolidatedTable + N'  
            SET Batch_ID = @NewBatch_ID  
            WHERE Batch_ID = @Batch_ID AND ImportStatus_ID = @StatusDefault  
    END; --IF  
    ELSE BEGIN  
        UPDATE [stg].' + @StagingConsolidatedTable + N'  
            SET Batch_ID = @NewBatch_ID  
            WHERE BatchTag = @BatchTag AND ImportStatus_ID = @StatusDefault  
    END; --IF  
  
    SET @Batch_ID = @NewBatch_ID;  
END --IF  
ELSE BEGIN  
    -- Set the status of the batch as Running.  
    UPDATE mdm.tblStgBatch  
        SET Status_ID = @Running,  
            TotalMemberCount = @MemberCount,  
            LastRunStartDTM = GETUTCDATE(),  
            LastRunStartUserID = @User_ID  
        WHERE ID = @Batch_ID  
END; --IF  
'  
  
    INSERT INTO @TempTable  
    SELECT  
        ViewColumn,  
        TableColumn,  
        AttributeType_ID,  
        DataType_ID,  
        DomainEntity_ID,  
        DomainTable,  
        SortOrder  
    FROM  
        mdm.udfEntityAttributesGetList(@Entity_ID, 2)  
    WHERE IsSystem <> 1 -- Exclude system attributes.  
    ORDER BY  
        SortOrder ASC;  
  
    WHILE EXISTS(SELECT 1 FROM @TempTable) BEGIN  
  
        SELECT TOP 1  
            @CurrentViewColumn = QUOTENAME(ViewColumn),  
            @CurrentAttributeName = ViewColumn,  
            @CurrentTableColumn = QUOTENAME(TableColumn),  
            @CurrentTableColumnNoQuote = TableColumn,  
            @CurrentAttributeType_ID = AttributeType_ID,  
            @CurrentDataType_ID =  DataType_ID,  
            @CurrentDomainEntity_ID = DomainEntity_ID,  
            @CurrentDomainTable = DomainTable  
        FROM @TempTable  
        ORDER BY SortOrder;  
  
        IF @CurrentDomainEntity_ID IS NULL BEGIN -- Non DBA  
            SET @SQLNonDBAColumns += N'  
                ,' + @CurrentTableColumn + N' --' + @CurrentViewColumn;  
  
            -- When the data type is text and the value is @NULLText (~NULL~) set NULL.  
            -- When the data type is number and the value is @NULLNumber (-98765432101234567890) set NULL.  
            -- When the data type is DateTime and the value is @NULLDateTime (5555-11-22T12:34:56) set NULL.  
  
            SET @SQLAttributeValueSetMergeOverwrite = CASE  
                                    WHEN @CurrentDataType_ID IN (1 /*Text*/, 6 /*Link*/) THEN  
                                        N'NULLIF(stgp.' + @CurrentViewColumn + N',@NULLText)'  
                                    WHEN @CurrentDataType_ID = 2 THEN -- Data type is Number  
                                        N'NULLIF(stgp.' + @CurrentViewColumn + N',@NULLNumber)'  
                                    WHEN @CurrentDataType_ID = 3 THEN -- Data type is DateTime  
                                        N'NULLIF(stgp.' + @CurrentViewColumn + N',@NULLDateTime)'  
                                    ELSE  
                                        N'stgp.' + @CurrentViewColumn  
                                    END;  
  
            IF LEN(COALESCE(@SQLNonDBA, N'')) > 0  
            BEGIN -- Not at the beginning.  
                SET @SQLNonDBA += N',  
';  
            END;  
            SET @SQLNonDBA += @SQLAttributeValueSetMergeOverwrite;  
  
            -- Even in case of merge optimistic set NULL when the value is @NULLText, @NULLNumber, or @NULLDateTime depending on the data type.  
            SET @SQLAttributeValueSetMergeOptimistic = CASE  
                                    WHEN @CurrentDataType_ID IN (1 /*Text*/, 6 /*Link*/) THEN  
                                        N'CASE WHEN stgp.' + @CurrentViewColumn + N' = @NULLText THEN NULL  
                                               WHEN stgp.' + @CurrentViewColumn + N' IS NULL THEN hp.'  + @CurrentTableColumn + N'  
                                               ELSE stgp.' + @CurrentViewColumn + N'  
                                          END '  
                                    WHEN @CurrentDataType_ID = 2 THEN -- Data type is Number  
                                        N'CASE WHEN stgp.' + @CurrentViewColumn + N' = @NULLNumber THEN NULL  
                                               WHEN stgp.' + @CurrentViewColumn + N' IS NULL THEN hp.'  + @CurrentTableColumn + N'  
                                               ELSE stgp.' + @CurrentViewColumn + N'  
                                          END '  
                                    WHEN @CurrentDataType_ID = 3 THEN -- Data type is DateTime  
                                        N'CASE WHEN stgp.' + @CurrentViewColumn + N' = @NULLDateTime THEN NULL  
                                               WHEN stgp.' + @CurrentViewColumn + N' IS NULL THEN hp.'  + @CurrentTableColumn + N'  
                                               ELSE stgp.' + @CurrentViewColumn + N'  
                                          END '  
                                    ELSE  
                                        N'stgp.' + @CurrentViewColumn  
                                    END;  
  
            SET @SQLMergeOptimisticNonDBA += N',' + @CurrentTableColumn + N' = ' + @SQLAttributeValueSetMergeOptimistic;  
            SET @SQLMergeOverwriteNonDBA += N',' + @CurrentTableColumn + N' = ' + @SQLAttributeValueSetMergeOverwrite;  
  
            SET @TranOldColumn += N'  
            ,' + @CurrentTableColumnNoQuote + N' NVARCHAR(MAX) COLLATE DATABASE_DEFAULT NULL ';  
  
            SET @TranDeletedColumn += N', CONVERT(NVARCHAR(MAX), deleted.' + @CurrentTableColumn + N') ';  
            SET @TranBlankColumn += N', NULL ';  
  
            SET @TranNewColumn += N'  
            ,New_' + @CurrentTableColumnNoQuote + N' NVARCHAR(MAX) COLLATE DATABASE_DEFAULT NULL ';  
  
            SET @TranInsertedColumn += N', CONVERT(NVARCHAR(MAX), inserted.' + @CurrentTableColumn + N') ';  
  
        END  
        ELSE BEGIN -- DBA  
            SET @SQLDBAColumns = @SQLDBAColumns + N'  
                ,' + @CurrentTableColumn + N' --' + @CurrentViewColumn;  
  
            IF LEN(COALESCE(@SQLDBA, N'')) > 0  
            BEGIN -- Not at the beginning.  
                SET @SQLDBA += N','  
            END;  
            SET @SQLDBA += N'CASE WHEN stgp.' + @CurrentViewColumn + N' = @NULLText THEN NULL ELSE ' + @CurrentViewColumn + N'.ID END';  
  
            -- Even in case of merge optimistic set NULL when the value is @NULLText.  
            SET @SQLMergeOptimisticDBA += N',' + @CurrentTableColumn + N' = CASE WHEN stgp.' + @CurrentViewColumn + N' = @NULLText THEN NULL  
            ELSE ISNULL(' + @CurrentViewColumn + N'.ID, hp.' + @CurrentTableColumn + N') END  
            ';  
  
            SET @SQLMergeOverwriteDBA += N',' + @CurrentTableColumn + N' = CASE WHEN stgp.' + @CurrentViewColumn + N' = @NULLText THEN NULL  
            ELSE ' + @CurrentViewColumn + N'.ID END  
            ';  
  
            SET @TranOldColumn += N'  
            ,' + @CurrentTableColumnNoQuote + N' NVARCHAR(MAX) COLLATE DATABASE_DEFAULT NULL ';  
  
            SET @TranDeletedColumn += N', CONVERT(NVARCHAR(MAX), deleted.' + @CurrentTableColumn + N') ';  
  
            SET @TranBlankColumn += N', NULL ';  
  
            SET @TranNewColumn += N'  
            ,New_' + @CurrentTableColumnNoQuote + N' NVARCHAR(MAX) COLLATE DATABASE_DEFAULT NULL ';  
  
            SET @TranInsertedColumn += N', CONVERT(NVARCHAR(MAX), inserted.' + @CurrentTableColumn + N') ';  
  
            -- In case when there are multiple DBAs using the same entity table use @CurrentViewColumn as  
            -- an alias to each entity table to avoid SQL error.  
            SET @SQLDBAJoin = @SQLDBAJoin + N'  
    LEFT JOIN mdm.' + @CurrentDomainTable + N' ' + @CurrentViewColumn + N'  
    ON stgp.' + @CurrentViewColumn + N' = ' + @CurrentViewColumn + N'.Code  
        AND ' + @CurrentViewColumn + N'.Status_ID = ' + @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/ + N' -- Active  
        AND ' + N' ' + @CurrentViewColumn + N'.Version_ID = @Version_ID  
            '  
  
            SET @SQLDBACheck += @TruncationGuard + N'  
            -- Error 210003 The attribute value references a member that does not exist or is inactive. Binary Location 2^2:  
            UPDATE stgp  
            SET ErrorCode = ErrorCode | 4  
        OUTPUT inserted.Batch_ID, inserted.Code, N' + QUOTENAME(@CurrentViewColumn, N'''') + N', inserted.' + @CurrentViewColumn + N', 210003  
                INTO [mdm].[tblStgErrorDetail] (Batch_ID, Code, AttributeName, AttributeValue, UniqueErrorCode)  
            FROM [stg].' + @StagingConsolidatedTable + N' stgp  
                LEFT OUTER JOIN mdm.' + @CurrentDomainTable + N' dm  
                ON stgp.' + @CurrentViewColumn + N' = dm.Code  
                AND dm.Status_ID = ' + @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/ + N' -- Active  
                AND dm.Version_ID = @Version_ID  
            WHERE stgp.ImportType NOT IN (@IT_Delete,@IT_Purge)  
            AND LEN(COALESCE(NULLIF(stgp.' + @CurrentViewColumn + N',  @NULLText), N'''')) > 0  
            AND stgp.Batch_ID = @Batch_ID  
            AND stgp.ImportStatus_ID = @StatusDefault  
            AND dm.Code IS NULL;  
            ';  
        END; -- IF  
  
        IF @CurrentAttributeType_ID = @AttributeType_File  
        BEGIN  
            SET @SQLAttributeTypeErrorCheck += @TruncationGuard + N'  
            --Error 200066 Binary Location 2^18: The file attribute cannot be saved  
            --If the user tries to set any value in a file attribute when the Import type is  
            --Merge Optimistic, Merge Overwrite or Insert, set the error code.  
            UPDATE [stg].' + @StagingConsolidatedTable + N'  
            SET ErrorCode = ErrorCode | 262144  
            WHERE ImportStatus_ID = @StatusDefault AND Batch_ID = @Batch_ID  
            AND ImportType IN (@IT_MergeOptimistic, @IT_MergeOverwrite, @IT_Insert)  
            AND ' + @CurrentViewColumn + N' IS NOT NULL  
  
            ';  
        END; -- IF  
  
        DELETE FROM @TempTable WHERE QUOTENAME(ViewColumn) = @CurrentViewColumn;  
  
    END; --WHILE  
  
    SET @SQL += @TruncationGuard + CONCAT(N'  
  
    --Error Check all staged members  
    --Error 210001 Binary Location 2^1: Multiple Records for the same member record  
    UPDATE stgp  
    SET ErrorCode = stgp.ErrorCode | 2  
    FROM [stg].', @StagingConsolidatedTable, N' stgp  
    INNER JOIN [stg].', @StagingConsolidatedTable, N' stgp2  
    ON      stgp.Code = stgp2.Code  
        AND stgp.ID <> stgp2.ID  
        AND stgp.Batch_ID = stgp2.Batch_ID  
    WHERE   stgp.ImportStatus_ID = @StatusDefault  
        AND stgp.Batch_ID = @Batch_ID') +  
  
@SQLDBACheck + N'  
  
    --Error 210032 Binary Location 2^4: HierarchyName is missing or is not valid.  
    --Check if the HierarchyName is missing.  
    UPDATE [stg].' + @StagingConsolidatedTable + N'  
        Set ErrorCode = ErrorCode | 16  
        Where LEN(COALESCE(HierarchyName, N'''')) = 0 AND ImportStatus_ID = @StatusDefault AND Batch_ID = @Batch_ID;  
  
    --Check if the HierarchyName is valid.  
    UPDATE stgp  
    SET ErrorCode = ErrorCode | 16  
    FROM [stg].' + @StagingConsolidatedTable + N' stgp  
        LEFT OUTER JOIN mdm.tblHierarchy hr  
        ON stgp.HierarchyName = hr.Name AND hr.Entity_ID = @Entity_ID  
    WHERE hr.ID IS NULL  
        AND stgp.ImportStatus_ID = @StatusDefault AND stgp.Batch_ID = @Batch_ID;  
  
    --Error 210035 Binary Location 2^5: Code is Mandatory  
    -- Code generation is not available for Consolidated members (it is available for leaf members only).  
    UPDATE [stg].' + @StagingConsolidatedTable + N'  
        SET ErrorCode = ErrorCode | 32  
        WHERE IsNull(Code, N'''') = N'''' AND ImportStatus_ID = @StatusDefault AND Batch_ID = @Batch_ID;  
  
    --Error 210041 Binary Location 2^6: ROOT is not a valid MemberCode  
    UPDATE [stg].' + @StagingConsolidatedTable + N'  
        SET ErrorCode = ErrorCode | 64  
        WHERE UPPER(Code) = N''ROOT'' AND ImportStatus_ID = @StatusDefault AND Batch_ID = @Batch_ID;  
  
    --Error 210042 Binary Location 2^7: MDMUnused is not a valid MemberCode  
    UPDATE [stg].' + @StagingConsolidatedTable + N'  
        SET ErrorCode = ErrorCode | 128  
        WHERE UPPER(Code) = N''MDMUNUSED'' AND ImportStatus_ID = @StatusDefault AND Batch_ID = @Batch_ID;'  
+ @SQLAttributeTypeErrorCheck + N'  
  
    --Error 300002 Binary Location 2^8: The member code is not valid (delete)  
    UPDATE stgp  
    SET ErrorCode = ErrorCode | 256  
    FROM [stg].' + @StagingConsolidatedTable + N' stgp  
    LEFT JOIN mdm.' + @HierarchyParentTable + N' hp  
    ON      stgp.Code = hp.Code  
        AND hp.Version_ID = @Version_ID  
        AND hp.Status_ID = ' + @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/ + N' -- Active  
    WHERE stgp.ImportType = @IT_Delete  
        AND stgp.ImportStatus_ID = @StatusDefault  
        AND stgp.Batch_ID = @Batch_ID  
        AND hp.ID IS NULL   
  
    --Error 300002 Binary Location 2^8: The member code is not valid (purge)   
    --Note: do not combine this query with the previous query. It would be bad for perf  
    UPDATE stgp  
    SET ErrorCode = ErrorCode | 256  
    FROM [stg].' + @StagingConsolidatedTable + N' stgp  
    LEFT JOIN mdm.' + @HierarchyParentTable + N' hp  
    ON      stgp.Code = hp.Code  
        AND hp.Version_ID = @Version_ID  
    WHERE stgp.ImportType = @IT_Purge  
        AND stgp.ImportStatus_ID = @StatusDefault  
        AND stgp.Batch_ID = @Batch_ID  
        AND hp.ID IS NULL   
  
    --Error 300003 Binary Location 2^9: The Member code already exists  
    --Verify uniqueness of the code against the entity table  
    UPDATE sc  
        SET ErrorCode = ErrorCode | 512  
        FROM [stg].' + @StagingConsolidatedTable + N' sc  
    INNER JOIN mdm.' + @EntityTable + N' AS tSource  
    ON sc.Code = tSource.Code  
    WHERE   tSource.Status_ID = ' + @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/ + N' -- Active  
        AND tSource.Version_ID = @Version_ID  
        AND sc.ImportType IN (@IT_Insert, @IT_MergeOptimistic, @IT_MergeOverwrite)  
        AND sc.ImportStatus_ID = @StatusDefault  
        AND sc.Batch_ID = @Batch_ID;  
  
    --Error 300003 Binary Location 2^9: The Member code already exists  
    --Verify uniqueness of the new code against the entity table  
    UPDATE sc  
        SET ErrorCode = ErrorCode | 512  
        FROM [stg].' + @StagingConsolidatedTable + N' sc  
    INNER JOIN mdm.' + @EntityTable + N' AS tSource  
    ON sc.NewCode = tSource.Code  
    WHERE   tSource.Status_ID = ' + @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/ + N' -- Active  
        AND tSource.Version_ID = @Version_ID  
        AND sc.ImportType IN (@IT_MergeOptimistic, @IT_MergeOverwrite)  
        AND sc.ImportStatus_ID = @StatusDefault  
        AND sc.Batch_ID = @Batch_ID;  
  
    --Error 300003 Binary Location 2^9: The Member code already exists  
    --Verify uniqueness of Code against the Hierarchy Parent table  
    UPDATE sc  
        SET ErrorCode = ErrorCode | 512  
        FROM [stg].' + @StagingConsolidatedTable + N' sc  
            INNER JOIN mdm.' + @HierarchyParentTable + N' AS tSource ON sc.Code = tSource.Code  
    WHERE   tSource.Status_ID = ' + @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/ + N' -- Active  
        AND tSource.Version_ID = @Version_ID  
        AND sc.ImportType = @IT_Insert  
        AND sc.ImportStatus_ID = @StatusDefault  
        AND sc.Batch_ID = @Batch_ID;  
  
    --Error 300003 Binary Location 2^9: The Member code already exists  
    --Verify uniqueness of the new code against the Hierarchy Parent table  
    UPDATE sc  
        SET ErrorCode = ErrorCode | 512  
        FROM [stg].' + @StagingConsolidatedTable + N' sc  
    INNER JOIN mdm.' + @HierarchyParentTable + N' AS tSource  
    ON sc.NewCode = tSource.Code  
    WHERE   tSource.Status_ID = ' + @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/ + N' -- Active  
        AND tSource.Version_ID = @Version_ID  
        AND sc.ImportType IN (@IT_MergeOptimistic, @IT_MergeOverwrite)  
        AND sc.ImportStatus_ID = @StatusDefault  
        AND sc.Batch_ID = @Batch_ID;  
  
     --Error 210058 Binary Location 2^10: Invalid ImportType  
    UPDATE [stg].' + @StagingConsolidatedTable + N'  
        SET ErrorCode = ErrorCode | 1024  
        WHERE ImportType > @IT_Max AND ImportStatus_ID = @StatusDefault AND Batch_ID = @Batch_ID;'  
  
IF LEN(COALESCE(@CollectionTable, N'')) > 0 BEGIN  
    SET @SQL += @TruncationGuard + N'  
    --Error 300003 Binary Location 2^9: The Member code already exists  
    --Verify uniqueness of code against the collection table  
    UPDATE sc  
        SET ErrorCode = ErrorCode | 512  
        FROM [stg].' + @StagingConsolidatedTable + N' sc  
    INNER JOIN mdm.' + @CollectionTable + N' AS tSource  
    ON sc.Code = tSource.Code  
    WHERE   tSource.Status_ID = ' + @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/ + N' -- Active  
        AND tSource.Version_ID = @Version_ID  
        AND sc.ImportType IN (@IT_Insert, @IT_MergeOptimistic, @IT_MergeOverwrite)  
        AND sc.ImportStatus_ID = @StatusDefault  
        AND sc.Batch_ID = @Batch_ID;  
  
    --Error 300003 Binary Location 2^9: The Member code already exists  
    --Verify uniqueness of the new code against the collection table  
    UPDATE sc  
        SET ErrorCode = ErrorCode | 512  
        FROM [stg].' + @StagingConsolidatedTable + N' sc  
    INNER JOIN mdm.' + @CollectionTable + N' AS tSource  
    ON sc.NewCode = tSource.Code  
    WHERE   tSource.Status_ID = ' + @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/ + N' -- Active  
        AND tSource.Version_ID = @Version_ID  
        AND sc.ImportType IN (@IT_MergeOptimistic, @IT_MergeOverwrite)  
        AND sc.ImportStatus_ID = @StatusDefault  
        AND sc.Batch_ID = @Batch_ID;  
    '  
 END; -- IF  
  
 --Get the Attributes for the Entity.  
SET @SQL += @TruncationGuard + N'  
    IF @AllowCodeGen = 1  
    BEGIN  
        --Gather up the valid user provided codes.  
        DECLARE @CodesToProcess mdm.MemberCodes;  
  
        INSERT @CodesToProcess (MemberCode)  
        SELECT Code FROM [stg].' + @StagingConsolidatedTable + N'  
        WHERE ErrorCode = 0 AND ImportStatus_ID = @StatusDefault  
            AND Batch_ID = @Batch_ID AND Code IS NOT NULL;  
  
        INSERT @CodesToProcess (MemberCode)  
        SELECT NewCode FROM [stg].' + @StagingConsolidatedTable + N'  
        WHERE ErrorCode = 0 AND ImportStatus_ID = @StatusDefault  
            AND Batch_ID = @Batch_ID AND NewCode IS NOT NULL;  
  
        --Process the user-provided codes to update the code gen info table with the largest one.  
        EXEC mdm.udpProcessCodes @Entity_ID, @CodesToProcess;  
  
    END; --IF'  
  
IF @TransactionLogType = @TransactionLogType_Attribute  
BEGIN  
    SET @SQL += @TruncationGuard + N'  
    --Table for transaction log  
    CREATE TABLE #TRANLOG  
    (  
         MemberID    INT  
        ,MemberMUID  UNIQUEIDENTIFIER  
        ,Code       NVARCHAR(250) COLLATE DATABASE_DEFAULT  
        ,New_Code    NVARCHAR(250) COLLATE DATABASE_DEFAULT  
        ,Name       NVARCHAR(250) COLLATE DATABASE_DEFAULT NULL  
        ,New_Name    NVARCHAR(250) COLLATE DATABASE_DEFAULT NULL  
    ' + @TranOldColumn + @TranNewColumn + N'  
    );'  
END  
  
SET @SQL += @TruncationGuard + N'  
    --Set ImportStatus on all records with at least one error  
    UPDATE [stg].' + @StagingConsolidatedTable + N'  
        SET ImportStatus_ID = @StatusError  
        WHERE ErrorCode > 0 AND ImportStatus_ID = @StatusDefault AND Batch_ID = @Batch_ID;  
  
    --Process Insert all new error free records into MDS internal table  
    UPDATE stgp  
        SET ImportStatus_ID = @StatusProcessing  
        FROM [stg].' + @StagingConsolidatedTable + N' stgp  
    LEFT JOIN  mdm.' + @HierarchyParentTable + N' hp  
    ON      stgp.Code = hp.Code  
        AND hp.Status_ID = ' + @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/ + N' -- Active  
        AND hp.Version_ID = @Version_ID  
    WHERE   stgp.Batch_ID = @Batch_ID  
            AND stgp.ImportType in (@IT_MergeOptimistic,@IT_Insert,@IT_MergeOverwrite)  
            AND stgp.ImportStatus_ID = @StatusDefault  
            AND hp.Code IS NULL;'  
  
IF @TransactionLogType != @TransactionLogType_Attribute  
BEGIN  
    SET @SQL += @TruncationGuard + N'  
    INSERT INTO mdm.' + @HierarchyParentTable + N'  
    (  
        Version_ID,  
        Status_ID,  
        ValidationStatus_ID,  
        Name,  
        Code,  
        Hierarchy_ID,  
        EnterDTM,  
        EnterUserID,  
        EnterVersionID,  
        LastChgDTM,  
        LastChgUserID,  
        LastChgVersionID'  
    + COALESCE(@SQLNonDBAColumns, N'') + COALESCE(@SQLDBAColumns, N'') + N'  
    )  
    SELECT  
        @Version_ID,  
        1,  
        @NewAwaitingValidation,  
        stgp.Name,  
        stgp.Code,  
        hr.ID,  
        GETUTCDATE(),  
        @User_ID,  
        @Version_ID,  
        GETUTCDATE(),  
        @User_ID,  
        @Version_ID' +  
        CASE  
            WHEN LEN(COALESCE(@SQLNonDBA, N'') + COALESCE(@SQLDBA, N'')) = 0 THEN N''  
            WHEN LEN(COALESCE(@SQLNonDBA, N'')) > 0 AND LEN(COALESCE(@SQLDBA, N'')) > 0 THEN N',' + COALESCE(@SQLNonDBA, N'') + N',' + COALESCE(@SQLDBA, N'')  
            ELSE N',' + COALESCE(@SQLNonDBA, N'') + COALESCE(@SQLDBA, N'')  
        END  
        + N'  
        FROM [stg].' + @StagingConsolidatedTable + N' stgp  
    INNER JOIN mdm.tblHierarchy hr  
        ON stgp.HierarchyName = hr.Name AND hr.Entity_ID = ' + CONVERT(NVARCHAR(30), @Entity_ID) + N' ' + COALESCE(@SQLDBAJoin, N'') + N'  
        WHERE stgp.ImportStatus_ID = @StatusProcessing AND stgp.Batch_ID = @Batch_ID;';  
END  
ELSE  
BEGIN  
    SET @SQL += @TruncationGuard + N'  
    IF @LogFlag != 1  
    BEGIN  
    INSERT INTO mdm.' + @HierarchyParentTable + N'  
    (  
        Version_ID,  
        Status_ID,  
        ValidationStatus_ID,  
        Name,  
        Code,  
        Hierarchy_ID,  
        EnterDTM,  
        EnterUserID,  
        EnterVersionID,  
        LastChgDTM,  
        LastChgUserID,  
        LastChgVersionID'  
    + COALESCE(@SQLNonDBAColumns, N'') + COALESCE(@SQLDBAColumns, N'') + N'  
    )  
    SELECT  
        @Version_ID,  
        1,  
        @NewAwaitingValidation,  
        stgp.Name,  
        stgp.Code,  
        hr.ID,  
        GETUTCDATE(),  
        @User_ID,  
        @Version_ID,  
        GETUTCDATE(),  
        @User_ID,  
        @Version_ID' +  
        CASE  
            WHEN LEN(COALESCE(@SQLNonDBA, N'') + COALESCE(@SQLDBA, N'')) = 0 THEN N''  
            WHEN LEN(COALESCE(@SQLNonDBA, N'')) > 0 AND LEN(COALESCE(@SQLDBA, N'')) > 0 THEN N',' + COALESCE(@SQLNonDBA, N'') + N',' + COALESCE(@SQLDBA, N'')  
            ELSE N',' + COALESCE(@SQLNonDBA, N'') + COALESCE(@SQLDBA, N'')  
        END  
        + N'  
        FROM [stg].' + @StagingConsolidatedTable + N' stgp  
    INNER JOIN mdm.tblHierarchy hr  
        ON stgp.HierarchyName = hr.Name AND hr.Entity_ID = ' + CONVERT(NVARCHAR(30), @Entity_ID) + N' ' + COALESCE(@SQLDBAJoin, N'') + N'  
        WHERE stgp.ImportStatus_ID = @StatusProcessing AND stgp.Batch_ID = @Batch_ID;  
    END  
    ELSE  
    BEGIN  
        INSERT INTO mdm.' + @HierarchyParentTable + N'  
        (  
            Version_ID,  
            Status_ID,  
            ValidationStatus_ID,  
            Name,  
            Code,  
            Hierarchy_ID,  
            EnterDTM,  
            EnterUserID,  
            EnterVersionID,  
            LastChgDTM,  
            LastChgUserID,  
            LastChgVersionID'  
        + COALESCE(@SQLNonDBAColumns, N'') + COALESCE(@SQLDBAColumns, N'') + N'  
        )  
    OUTPUT inserted.ID, inserted.MUID, inserted.Code, inserted.Code, inserted.Name, inserted.Name ' + @TranBlankColumn + @TranInsertedColumn + N'  
            INTO #TRANLOG  
        SELECT  
            @Version_ID,  
            1,  
            @NewAwaitingValidation,  
            stgp.Name,  
            stgp.Code,  
            hr.ID,  
            GETUTCDATE(),  
            @User_ID,  
            @Version_ID,  
            GETUTCDATE(),  
            @User_ID,  
            @Version_ID' +  
            CASE  
                WHEN LEN(COALESCE(@SQLNonDBA, N'') + COALESCE(@SQLDBA, N'')) = 0 THEN N''  
                WHEN LEN(COALESCE(@SQLNonDBA, N'')) > 0 AND LEN(COALESCE(@SQLDBA, N'')) > 0 THEN N',' + COALESCE(@SQLNonDBA, N'') + N',' + COALESCE(@SQLDBA, N'')  
                ELSE N',' + COALESCE(@SQLNonDBA, N'') + COALESCE(@SQLDBA, N'')  
            END  
            + N'  
            FROM [stg].' + @StagingConsolidatedTable + N' stgp  
            JOIN mdm.tblHierarchy hr  
            ON stgp.HierarchyName = hr.Name AND hr.Entity_ID = ' + CONVERT(NVARCHAR(30), @Entity_ID) + N' ' + COALESCE(@SQLDBAJoin, N'') + N'  
            WHERE stgp.ImportStatus_ID = @StatusProcessing AND stgp.Batch_ID = @Batch_ID;  
    END; -- IF  
    ';  
END  
  
SET @SQL += @TruncationGuard + N'  
    -- After the insertion add HR records for each mandatory hierarchies  
  
    INSERT INTO @TableHierarchy  
    SELECT DISTINCT ID AS Hierarchy_ID, [Name] AS Hierarchy_Name FROM mdm.tblHierarchy WHERE Entity_ID = ' + CONVERT(NVARCHAR(30), @Entity_ID) + N'  
  
        WHILE EXISTS(SELECT 1 FROM @TableHierarchy) BEGIN  
  
            SELECT TOP 1  
                @CurrentHierarchy_ID = Hierarchy_ID,  
                @CurrentHierarchy_Name = Hierarchy_Name  
            FROM @TableHierarchy;  
  
        -- Add the member to the root of the hierarchy.  
  
            INSERT INTO mdm.' + @HierarchyRelationshipTable + N'  
            (  
                [Version_ID]  
                ,[Status_ID]  
                ,[ValidationStatus_ID]  
                ,[Hierarchy_ID]  
                ,[Parent_HP_ID]  
                ,[ChildType_ID]  
                ,[Child_EN_ID]  
                ,[Child_HP_ID]  
                ,[SortOrder]  
                ,[LevelNumber]  
                ,[EnterDTM]  
                ,[EnterUserID]  
                ,[EnterVersionID]  
                ,[LastChgDTM]  
                ,[LastChgUserID]  
                ,[LastChgVersionID]  
            )  
            SELECT  
            @Version_ID,  
            1,  
            @NewAwaitingValidation,  
            @CurrentHierarchy_ID,  
            NULL,  
            2,  
            NULL,  
            hp.ID,  
            0,  
            0,  
            GETUTCDATE(),  
            @User_ID,  
            @Version_ID,  
            GETUTCDATE(),  
            @User_ID,  
            @Version_ID  
            FROM [stg].' + @StagingConsolidatedTable + N' stgp  
            INNER JOIN mdm.' + @HierarchyParentTable + N' hp  
        ON      stgp.Code = hp.Code  
            AND hp.Status_ID = ' + @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/ + N' -- Active  
            AND hp.Version_ID = @Version_ID  
            AND stgp.HierarchyName = @CurrentHierarchy_Name  
            WHERE stgp.ImportStatus_ID = @StatusProcessing AND stgp.Batch_ID = @Batch_ID;'  
  
IF @TransactionLogType = @TransactionLogType_Attribute  
BEGIN  
    SET @SQL += @TruncationGuard + N'  
            IF @LogFlag = 1  
            BEGIN  
                -- Record addition of the members to the ROOT node of the hierarchy.  
                -- OldCode and NewCode are set to ROOT (this is the same as the existing transaction log).  
                INSERT INTO [mdm].' + QUOTENAME(@TransactionTableName) + N'  
                (  
                    Version_ID,  
                    TransactionType_ID,  
                    OriginalTransaction_ID,  
                    Hierarchy_ID,  
                    Entity_ID,  
                    Member_ID,  
                Member_MUID,  
                    MemberType_ID,  
                    MemberCode,  
                    OldValue,  
                    OldCode,  
                    NewValue,  
                    NewCode,  
                    Batch_ID,  
                    EnterDTM,  
                    EnterUserID,  
                    LastChgDTM,  
                    LastChgUserID  
                )  
                SELECT  
                    @Version_ID, --Version_ID  
                    @HierarchyParentSetTransaction, --TransactionType_ID  
                    0, --OriginalTransaction_ID  
                    @CurrentHierarchy_ID, --Hierarchy_ID  
                    @Entity_ID, --Entity_ID  
                    hp.ID, --Member_ID  
                hp.MUID, --Member_MUID  
                    @ConsolidatedMemberTypeID, --MemberType_ID  
                    stgp.Code,  
                    N''0'', --OldValue  
                    N''ROOT'', --OldCode  
                    N''0'', --NewValue  
                    N''ROOT'', --NewCode  
                    @Batch_ID,  
                    GETUTCDATE(),  
                    @User_ID,  
                    GETUTCDATE(),  
                    @User_ID  
            FROM mdm.' + @HierarchyParentTable + N' hp  
            INNER JOIN [stg].' + @StagingConsolidatedTable + N' stgp  
            ON      hp.Code = stgp.Code  
                AND hp.Status_ID = ' + @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/ + N' -- Active  
                AND hp.Version_ID = @Version_ID  
                    AND stgp.HierarchyName = @CurrentHierarchy_Name  
                    AND stgp.ImportStatus_ID = @StatusProcessing AND stgp.Batch_ID = @Batch_ID  
            END;  
    '  
END  
  
SET @SQL += @TruncationGuard + N'  
            DELETE FROM @TableHierarchy WHERE Hierarchy_ID = @CurrentHierarchy_ID  
        END; -- WHILE  
  
        --Update Change Tracking Groups when the attribute value is not NULL.  
        INSERT INTO @TABLECTG (  
            AttributeID,  
            AttributeName,  
            AttributeColumnName,  
            ChangeTrackingID,  
            AttributeType_ID,  
            DomainEntityTableName  
            )  
        SELECT DISTINCT  
            attr.ID,  
            attr.Name,  
            attr.TableColumn,  
            attr.ChangeTrackingGroup,  
            attr.AttributeType_ID,  
            ent.EntityTable  
        FROM mdm.tblAttribute attr  
        LEFT JOIN mdm.tblEntity ent ON ent.ID = attr.DomainEntity_ID  
        WHERE  
            attr.Entity_ID = ' + CONVERT(NVARCHAR(30), @Entity_ID) + N' AND  
            attr.ChangeTrackingGroup > 0 AND  
            attr.MemberType_ID = 2;  
  
        DECLARE @TrackGroupMax   INT,  
                @TrackGroupCount INT;  
  
        SELECT @TrackGroupMax = COUNT(ID) FROM @TABLECTG;  
  
        SET @TrackGroupCount = 1;  
  
        WHILE @TrackGroupCount <= @TrackGroupMax BEGIN  
            SELECT  
                @ChangeTrackingGroup = ChangeTrackingID,  
                @ChangedAttributeName = AttributeName  
            FROM @TABLECTG  
            WHERE ID = @TrackGroupCount;  
  
            SET @SQLCTG = N''  
        UPDATE hp  
            SET ChangeTrackingMask = ISNULL(ChangeTrackingMask, 0) | ISNULL(POWER(2,@ChangeTrackingGroup -1), 0)  
            FROM mdm.' + @HierarchyParentTable + N' hp  
        INNER JOIN [stg].' + @StagingConsolidatedTableWithEscapedQuotes -- This is being used in a nested dynamic SQL statment, so any single quotes within the table name must be escaped out  
                                                                        + N' stgp  
        ON      hp.Code = stgp.Code  
            AND hp.Status_ID = ' + @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/ + N' -- Active  
            AND hp.Version_ID = @Version_ID  
                AND stgp.ImportStatus_ID = @ImportStatus_ID  
                AND stgp.Batch_ID = @Batch_ID  
                AND stgp.'' + quotename(@ChangedAttributeName) + N'' IS NOT NULL; '';  
  
            EXEC sp_executesql @SQLCTG, N''@ChangeTrackingGroup INT, @Version_ID INT, @ImportStatus_ID INT, @Batch_ID INT'', @ChangeTrackingGroup, @Version_ID, @StatusProcessing, @Batch_ID;  
  
            SET @TrackGroupCount += 1;  
  
        END; -- WHILE';  
  
IF @TransactionLogType = @TransactionLogType_Attribute  
BEGIN  
    SET @SQL += @TruncationGuard + N'  
        IF @LogFlag = 1  
        BEGIN  
            --Log member creation transactions.  
            --In this case OldValue, OldCode, NewValue, and NewCode are blank.  
            INSERT INTO [mdm].' + QUOTENAME(@TransactionTableName) + N'  
            (  
                Version_ID,  
                TransactionType_ID,  
                OriginalTransaction_ID,  
                Hierarchy_ID,  
                Entity_ID,  
                Member_ID,  
            Member_MUID,  
                MemberType_ID,  
                MemberCode,  
                OldValue,  
                OldCode,  
                NewValue,  
                NewCode,  
                Batch_ID,  
                EnterDTM,  
                EnterUserID,  
                LastChgDTM,  
                LastChgUserID  
            )  
            SELECT  
                @Version_ID, --Version_ID  
                @MemberCreateTransaction, --TransactionType_ID  
                0, --OriginalTransaction_ID  
                NULL, --Hierarchy_ID  
                @Entity_ID, --Entity_ID  
                hp.ID, --Member_ID  
            hp.MUID, --Member_MUID  
                @ConsolidatedMemberTypeID, --MemberType_ID  
                stgp.Code,  
                N'''', --OldValue  
                N'''', --OldCode  
                N'''', --NewValue  
                N'''', --NewCode  
                @Batch_ID,  
                GETUTCDATE(),  
                @User_ID,  
                GETUTCDATE(),  
                @User_ID  
        FROM mdm.' + @HierarchyParentTable + N' hp  
        INNER JOIN [stg].' + @StagingConsolidatedTable + N' stgp  
        ON      hp.Code = stgp.Code  
            AND hp.Status_ID = ' + @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/ + N' -- Active  
            AND hp.Version_ID = @Version_ID  
            AND stgp.ImportStatus_ID = @StatusProcessing  
            AND stgp.Batch_ID = @Batch_ID;  
        END;';  
END  
  
SET @SQL += @TruncationGuard + N'  
        -- Inserting records is done. Updated the status.  
  
        UPDATE [stg].' + @StagingConsolidatedTable + '  
            SET ImportStatus_ID = @StatusOK  
            WHERE ImportType in (@IT_MergeOptimistic,@IT_Insert,@IT_MergeOverwrite) AND ImportStatus_ID = @StatusProcessing AND Batch_ID = @Batch_ID;  
  
        -- Set status to process updates.  
    UPDATE stgp  
            SET ImportStatus_ID = @StatusProcessing  
    FROM [stg].' + @StagingConsolidatedTable + N' stgp  
    INNER JOIN mdm.' + @HierarchyParentTable + N' hp  
    ON      stgp.Code = hp.Code  
        AND hp.Status_ID = ' + @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/ + N' -- Active  
    WHERE   stgp.ImportType in (@IT_MergeOptimistic, @IT_MergeOverwrite)  
        AND hp.Version_ID = @Version_ID  
        AND stgp.ImportStatus_ID = @StatusDefault  
        AND stgp.Batch_ID = @Batch_ID;  
'  
  
SET @SQL += @TruncationGuard + N'  
        -- Update change tracking mask.  
        SET @TrackGroupCount = 1;  
  
        WHILE @TrackGroupCount <= @TrackGroupMax BEGIN  
            SELECT  
                @ChangeTrackingGroup = ChangeTrackingID,  
                @ChangedAttributeName = AttributeName,  
                @ConsolidatedAttributeName = AttributeColumnName,  
                @ChangedAttributeType_ID = AttributeType_ID,  
                @ChangedAttributeDomainEntityTableName = DomainEntityTableName  
            FROM @TABLECTG  
            WHERE ID = @TrackGroupCount;  
  
            IF @ChangedAttributeType_ID = @AttributeType_Domain  
        BEGIN  
            -- Update change tracking mask for merge optimistic.  
            SET @SQLCTG = N''  
            UPDATE hp  
            SET hp.ChangeTrackingMask = ISNULL(hp.ChangeTrackingMask, 0) | ISNULL(POWER(2, @ChangeTrackingGroup -1), 0)  
            FROM mdm.' + @HierarchyParentTable + N' hp  
            INNER JOIN [stg].' + @StagingConsolidatedTableWithEscapedQuotes -- This is being used in a nested dynamic SQL statment, so any single quotes within the table name must be escaped out  
                                                                                + N' stgp  
            ON      hp.Code = stgp.Code  
                AND hp.Status_ID = ' + @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/ + N' -- Active  
                AND hp.Version_ID = @Version_ID  
                AND stgp.ImportStatus_ID = @ImportStatus_ID  
                AND stgp.Batch_ID = @Batch_ID  
                AND stgp.ImportType = @ImportType  
                AND stgp.'' + quotename(@ChangedAttributeName) + N'' IS NOT NULL  
            LEFT JOIN [mdm].'' + quotename(@ChangedAttributeDomainEntityTableName) + N'' domain ON domain.Code = stgp.'' + quotename(@ChangedAttributeName) + N''  
            AND domain.Status_ID = ' + @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/ + N' -- Active  
            WHERE  
                COALESCE(NULLIF(domain.ID, hp.'' + quotename(@ConsolidatedAttributeName) + N''), NULLIF(hp.'' + quotename(@ConsolidatedAttributeName) + N'', domain.ID)) IS NOT NULL;  
                '';  
  
            EXEC sp_executesql @SQLCTG, N''@ChangeTrackingGroup INT, @Version_ID INT, @ImportStatus_ID INT, @Batch_ID INT, @ImportType INT'', @ChangeTrackingGroup, @Version_ID, @StatusProcessing, @Batch_ID, @IT_MergeOptimistic;  
  
            -- Update change tracking mask for merge overwrite.  
            SET @SQLCTG = N''  
            UPDATE hp  
            SET hp.ChangeTrackingMask = ISNULL(hp.ChangeTrackingMask, 0) | ISNULL(POWER(2,@ChangeTrackingGroup -1), 0)  
            FROM mdm.' + @HierarchyParentTable + N' hp  
            INNER JOIN [stg].' + @StagingConsolidatedTableWithEscapedQuotes -- This is being used in a nested dynamic SQL statment, so any single quotes within the table name must be escaped out  
                                                                                + N' stgp  
            ON      hp.Code = stgp.Code  
                AND hp.Status_ID = ' + @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/ + N' -- Active  
                AND hp.Version_ID = @Version_ID  
                AND stgp.ImportStatus_ID = @ImportStatus_ID  
                AND stgp.Batch_ID = @Batch_ID  
                AND stgp.ImportType = @ImportType  
            LEFT JOIN [mdm].'' + quotename(@ChangedAttributeDomainEntityTableName) + N'' domain ON domain.Code = stgp.'' + quotename(@ChangedAttributeName) + N''  
            WHERE  
                COALESCE(NULLIF(domain.ID, hp.'' + quotename(@ConsolidatedAttributeName) + N''), NULLIF(hp.'' + quotename(@ConsolidatedAttributeName) + N'', domain.ID)) IS NOT NULL;  
                '';  
  
            EXEC sp_executesql @SQLCTG, N''@ChangeTrackingGroup INT, @Version_ID INT, @ImportStatus_ID INT, @Batch_ID INT, @ImportType INT'', @ChangeTrackingGroup, @Version_ID, @StatusProcessing, @Batch_ID, @IT_MergeOverwrite;  
        END  
        ELSE  
        BEGIN  
            -- Update change tracking mask for merge optimistic.  
            SET @SQLCTG = N''  
            UPDATE hp  
            SET ChangeTrackingMask = ISNULL(ChangeTrackingMask, 0) | ISNULL(POWER(2,@ChangeTrackingGroup -1), 0)  
            FROM mdm.' + @HierarchyParentTable + N' hp  
            INNER JOIN [stg].' + @StagingConsolidatedTableWithEscapedQuotes -- This is being used in a nested dynamic SQL statment, so any single quotes within the table name must be escaped out  
                                                                                + N' stgp  
            ON      hp.Code = stgp.Code  
                AND hp.Status_ID = ' + @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/ + N' -- Active  
                AND hp.Version_ID = @Version_ID  
                AND stgp.ImportStatus_ID = @ImportStatus_ID  
                AND stgp.Batch_ID = @Batch_ID  
                AND stgp.ImportType = @ImportType  
                AND stgp.'' + quotename(@ChangedAttributeName) + N'' IS NOT NULL  
                AND COALESCE(NULLIF(stgp.'' + quotename(@ChangedAttributeName) + N'', hp.'' + quotename(@ConsolidatedAttributeName) + N''), NULLIF(hp.'' + quotename(@ConsolidatedAttributeName) + N'', stgp.'' + quotename(@ChangedAttributeName) + N'')) IS NOT NULL;  
                '';  
  
            EXEC sp_executesql @SQLCTG, N''@ChangeTrackingGroup INT, @Version_ID INT, @ImportStatus_ID INT, @Batch_ID INT, @ImportType INT'', @ChangeTrackingGroup, @Version_ID, @StatusProcessing, @Batch_ID, @IT_MergeOptimistic;  
  
            -- Update change tracking mask for merge overwrite.  
            SET @SQLCTG = N''  
            UPDATE hp  
            SET ChangeTrackingMask = ISNULL(ChangeTrackingMask, 0) | ISNULL(POWER(2,@ChangeTrackingGroup -1), 0)  
            FROM mdm.' + @HierarchyParentTable + N' hp  
            INNER JOIN [stg].' + @StagingConsolidatedTableWithEscapedQuotes -- This is being used in a nested dynamic SQL statment, so any single quotes within the table name must be escaped out  
                                                                                + N' stgp  
            ON      hp.Code = stgp.Code  
                AND hp.Status_ID = ' + @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/ + N' -- Active  
                AND hp.Version_ID = @Version_ID  
                AND stgp.ImportStatus_ID = @ImportStatus_ID  
                AND stgp.Batch_ID = @Batch_ID  
                AND stgp.ImportType = @ImportType  
                AND COALESCE(NULLIF(stgp.'' + quotename(@ChangedAttributeName) + N'', hp.'' + quotename(@ConsolidatedAttributeName) + N''), NULLIF(hp.'' + quotename(@ConsolidatedAttributeName) + N'', stgp.'' + quotename(@ChangedAttributeName) + N'')) IS NOT NULL;  
                '';  
  
            EXEC sp_executesql @SQLCTG, N''@ChangeTrackingGroup INT, @Version_ID INT, @ImportStatus_ID INT, @Batch_ID INT, @ImportType INT'', @ChangeTrackingGroup, @Version_ID, @StatusProcessing, @Batch_ID, @IT_MergeOverwrite;  
        END  
  
            SET @TrackGroupCount += 1;  
  
        END; -- WHILE  
  
        --Process Updates  
        --Process update (Merge Optimistic)  
        SET @Now = GETUTCDATE();  
        IF @LogFlag != 1  
        BEGIN  
            UPDATE hp  
            SET Code = CASE WHEN stgp.[NewCode] IS NULL THEN hp.[Code] ELSE stgp.[NewCode] END  
                ,ValidationStatus_ID = @AwaitingRevalidation  
                ,LastChgDTM = @Now  
                ,LastChgUserID = @User_ID  
                ,LastChgVersionID = @Version_ID  
                ,[Name] = CASE  
                            WHEN stgp.[Name] = @NULLText THEN NULL  
                            WHEN stgp.[Name] IS NULL THEN hp.[Name]  
                            ELSE stgp.[Name]  
                          END  
                ' + COALESCE(@SQLMergeOptimisticDBA, N'') + N'  
                ' + COALESCE(@SQLMergeOptimisticNonDBA, N'') + N'  
            FROM mdm.' + @HierarchyParentTable + N' hp  
            INNER JOIN [stg].' + @StagingConsolidatedTable + N' stgp  
            ON      hp.Code = stgp.Code  
            AND hp.Status_ID = ' + @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/ + N' -- Active  
                AND hp.Version_ID = @Version_ID  
                ' + COALESCE(@SQLDBAJoin, N'') + N'  
                WHERE stgp.ImportType =  @IT_MergeOptimistic  
                    AND stgp.ImportStatus_ID = @StatusProcessing  
                    AND stgp.Batch_ID = @Batch_ID;  
        END  
        ELSE  
        BEGIN  
            -- Insert update information into _HS table.  
            UPDATE hp  
            SET Code = CASE WHEN stgp.[NewCode] IS NULL THEN hp.[Code] ELSE stgp.[NewCode] END  
                ,ValidationStatus_ID = @AwaitingRevalidation  
                ,LastChgDTM = @Now  
                ,LastChgUserID = @User_ID  
                ,LastChgVersionID = @Version_ID  
                ,[Name] = CASE  
                            WHEN stgp.[Name] = @NULLText THEN NULL  
                            WHEN stgp.[Name] IS NULL THEN hp.[Name]  
                            ELSE stgp.[Name]  
                          END  
                ' + COALESCE(@SQLMergeOptimisticDBA, N'') + N'  
                ' + COALESCE(@SQLMergeOptimisticNonDBA, N'') +  
                CASE @TransactionLogType  
                    WHEN @TransactionLogType_Member THEN @HPHistoryOutputQuery  
                    WHEN @TransactionLogType_Attribute THEN N'  
            OUTPUT inserted.ID, inserted.MUID, deleted.Code, inserted.Code, deleted.Name, inserted.Name ' + @TranDeletedColumn + @TranInsertedColumn + N'  
                INTO #TRANLOG'  
                    ELSE N''  
                END  
                 + N'  
            FROM mdm.' + @HierarchyParentTable + N' hp  
            INNER JOIN [stg].' + @StagingConsolidatedTable + N' stgp  
            ON      hp.Code = stgp.Code  
                AND hp.Status_ID = ' + @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/ + N' -- Active  
                AND hp.Version_ID = @Version_ID  
                ' + COALESCE(@SQLDBAJoin, N'') + N'  
                WHERE stgp.ImportType =  @IT_MergeOptimistic  
                    AND stgp.ImportStatus_ID = @StatusProcessing  
                    AND stgp.Batch_ID = @Batch_ID;  
        END; -- IF  
  
        --Process update (Merge Overwrite)  
        SET @Now = GETUTCDATE();  
        IF @LogFlag != 1  
        BEGIN  
            UPDATE hp  
            SET Code = CASE WHEN stgp.[NewCode] IS NULL THEN hp.[Code] ELSE stgp.[NewCode] END  
                ,ValidationStatus_ID = @AwaitingRevalidation  
                ,LastChgDTM = @Now  
                ,LastChgUserID = @User_ID  
                ,LastChgVersionID = @Version_ID  
                ,Name = NULLIF(stgp.[Name], @NULLText)  
                ' + COALESCE(@SQLMergeOverwriteDBA, N'') + N'  
                ' + COALESCE(@SQLMergeOverwriteNonDBA, N'') + N'  
            FROM mdm.' + @HierarchyParentTable + N' hp  
            INNER JOIN [stg].' + @StagingConsolidatedTable + N' stgp  
            ON      hp.Code = stgp.Code  
                AND hp.Status_ID = ' + @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/ + N' -- Active  
                AND hp.Version_ID = @Version_ID  
                ' + COALESCE(@SQLDBAJoin, N'') + N'  
                WHERE stgp.ImportType =  @IT_MergeOverwrite  
                    AND stgp.ImportStatus_ID = @StatusProcessing  
                    AND stgp.Batch_ID = @Batch_ID;  
        END  
        ELSE  
        BEGIN  
            -- Insert update information into _HS table.  
            UPDATE hp  
            SET Code = CASE WHEN stgp.[NewCode] IS NULL THEN hp.[Code] ELSE stgp.[NewCode] END  
                ,ValidationStatus_ID = @AwaitingRevalidation  
                ,LastChgDTM = @Now  
                ,LastChgUserID = @User_ID  
                ,LastChgVersionID = @Version_ID  
                ,Name = NULLIF(stgp.[Name], @NULLText)  
                ' + COALESCE(@SQLMergeOverwriteDBA, N'') + N'  
                ' + COALESCE(@SQLMergeOverwriteNonDBA, N'') +  
                CASE @TransactionLogType  
                    WHEN @TransactionLogType_Member THEN @HPHistoryOutputQuery  
                    WHEN @TransactionLogType_Attribute THEN N'  
            OUTPUT inserted.ID, inserted.MUID, deleted.Code, inserted.Code, deleted.Name, inserted.Name ' + @TranDeletedColumn + @TranInsertedColumn + N'  
                INTO #TRANLOG'  
                    ELSE N''  
                END  
                 + N'  
            FROM mdm.' + @HierarchyParentTable + N' hp  
            INNER JOIN [stg].' + @StagingConsolidatedTable + N' stgp  
            ON      hp.Code = stgp.Code  
                AND hp.Status_ID = ' + @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/ + N' -- Active  
                AND hp.Version_ID = @Version_ID  
                ' + COALESCE(@SQLDBAJoin, N'') + N'  
                WHERE stgp.ImportType =  @IT_MergeOverwrite  
                    AND stgp.ImportStatus_ID = @StatusProcessing  
                    AND stgp.Batch_ID = @Batch_ID;  
        END; --IF';  
  
IF @TransactionLogType = @TransactionLogType_Attribute  
BEGIN  
    SET @SQL += @TruncationGuard + N'  
        IF @LogFlag = 1  
        BEGIN  
            DECLARE @TempTable TABLE(  
                ID              INT,  
                TableColumn     NVARCHAR(128) COLLATE DATABASE_DEFAULT NOT NULL,  
                DomainEntity_ID INT NULL,  
                SortOrder       INT,  
                DomainTable     SYSNAME NULL);  
  
            DECLARE     @CurrentID              INT,  
                        @CurrentTableColumn     NVARCHAR(128),  
                        @CurrentDomainEntity_ID INT,  
                        @CurrentSortOrder       INT,  
                        @CurrentDomainTable     SYSNAME,  
                        @TranSQL                NVARCHAR(MAX) = N'''';  
  
            INSERT INTO @TempTable  
            SELECT  
                A.ID,  
                A.TableColumn,  
                A.DomainEntity_ID,  
                A.SortOrder,  
                E.EntityTable AS DomainTable  
            FROM  
            mdm.tblAttribute A  
            LEFT OUTER JOIN mdm.tblEntity E  
            ON A.DomainEntity_ID = E.ID  
            WHERE A.Entity_ID = @Entity_ID AND A.MemberType_ID = @ConsolidatedMemberTypeID  
            AND (A.IsSystem = 0 OR A.IsCode = 1 OR A.IsName = 1) -- Exclude system attributes other than Code and Name.  
            ORDER BY  
                SortOrder ASC;  
  
            -- For each attribute, set the attribute update information to the Transaction table.  
            WHILE EXISTS(SELECT 1 FROM @TempTable) BEGIN  
                SELECT TOP 1  
                    @CurrentID = ID,  
                    @CurrentTableColumn = TableColumn,  
                    @CurrentDomainEntity_ID = DomainEntity_ID,  
                    @CurrentSortOrder = SortOrder,  
                    @CurrentDomainTable = DomainTable  
                FROM @TempTable  
                ORDER BY SortOrder;  
                -- Get Old and New values from #TRANLOG table and insert into the transaction table.  
  
                IF @CurrentDomainEntity_ID IS NULL -- Handle non DBA  
                BEGIN  
  
                SET @TranSQL = N''  
                INSERT INTO [mdm].' + QUOTENAME(@TransactionTableName) + N'  
                (  
                Version_ID,  
                TransactionType_ID,  
                OriginalTransaction_ID,  
                Hierarchy_ID,  
                Entity_ID,  
                Attribute_ID,  
                Member_ID,  
            Member_MUID,  
                MemberType_ID,  
                MemberCode,  
                OldValue,  
                OldCode,  
                NewValue,  
                NewCode,  
                Batch_ID,  
                EnterDTM,  
                EnterUserID,  
                LastChgDTM,  
                LastChgUserID  
            )  
            SELECT  
                @Version_ID, --Version_ID  
                3, --TransactionType_ID (Member attribute set)  
                0, --OriginalTransaction_ID  
                NULL, --Hierarchy_ID  
                @Entity_ID, --Entity_ID  
                @Attribute_ID, -- Attribute_ID  
                MemberID, --Member_ID  
            MemberMUID, --Member_MUID  
                2, -- Consolidated Member Type ID  
                CASE WHEN ISNULL(Code, N'''''''') = N'''''''' THEN New_Code ELSE Code END,  
                '' + @CurrentTableColumn + N'',  
                '' + @CurrentTableColumn + N'',  
                New_'' + @CurrentTableColumn + N'',  
                New_'' + @CurrentTableColumn + N'',  
                @Batch_ID,  
                GETUTCDATE(),  
                @User_ID,  
                GETUTCDATE(),  
                @User_ID  
            FROM #TRANLOG  
            WHERE COALESCE(NULLIF('' + @CurrentTableColumn + N'', New_'' + @CurrentTableColumn + N''), NULLIF(New_'' + @CurrentTableColumn + N'', '' + @CurrentTableColumn + N'')) IS NOT NULL  
                '';  
  
                    EXEC sp_executesql @TranSQL, N''@Version_ID INT, @Attribute_ID INT, @Entity_ID INT, @Batch_ID INT, @User_ID INT '', @Version_ID, @CurrentID, @Entity_ID, @Batch_ID, @User_ID;  
                END  
                ELSE  
                BEGIN  
                -- Handle DBA  
                -- Get the old code value and the new code value by table join.  
                SET @TranSQL = N''  
            INSERT INTO [mdm].' + QUOTENAME(@TransactionTableName) + N'  
            (  
                Version_ID,  
                TransactionType_ID,  
                OriginalTransaction_ID,  
                Hierarchy_ID,  
                Entity_ID,  
                Attribute_ID,  
                Member_ID,  
            Member_MUID,  
                MemberType_ID,  
                MemberCode,  
                OldValue,  
                OldCode,  
                NewValue,  
                NewCode,  
                Batch_ID,  
                EnterDTM,  
                EnterUserID,  
                LastChgDTM,  
                LastChgUserID  
            )  
            SELECT  
                @Version_ID, --Version_ID  
                3, --TransactionType_ID (Member attribute set)  
                0, --OriginalTransaction_ID  
                NULL, --Hierarchy_ID  
                @Entity_ID, --Entity_ID  
                @Attribute_ID, -- Attribute_ID  
                T.MemberID, --Member_ID  
            T.MemberMUID, --Member_MUID  
                2, -- Consolidated Member Type ID  
                CASE WHEN ISNULL(T.Code, N'''''''') = N'''''''' THEN T.New_Code ELSE T.Code END,  
                T.'' + @CurrentTableColumn + N'',  
                DO.Code,  
                New_'' + @CurrentTableColumn + N'',  
                DN.Code,  
                @Batch_ID,  
                GETUTCDATE(),  
                @User_ID,  
                GETUTCDATE(),  
                @User_ID  
            FROM #TRANLOG T  
            LEFT OUTER JOIN mdm.'' + QUOTENAME(@CurrentDomainTable) + N'' DN  
            ON T.New_'' + @CurrentTableColumn + N'' = DN.ID  
            LEFT OUTER JOIN mdm.'' + QUOTENAME(@CurrentDomainTable) + N'' DO  
            ON T.'' + @CurrentTableColumn + N'' = DO.ID  
            WHERE COALESCE(NULLIF(T.'' + @CurrentTableColumn + N'', T.New_'' + @CurrentTableColumn + N''), NULLIF(T.New_'' + @CurrentTableColumn + N'', T.'' + @CurrentTableColumn + N'')) IS NOT NULL  
                '';  
  
                    EXEC sp_executesql @TranSQL, N''@Version_ID INT, @Attribute_ID INT, @Entity_ID INT, @Batch_ID INT, @User_ID INT '', @Version_ID, @CurrentID, @Entity_ID, @Batch_ID, @User_ID;  
  
                END; --IF  
  
                DELETE FROM @TempTable WHERE ID = @CurrentID;  
  
            END; --WHILE  
  
            TRUNCATE TABLE #TRANLOG;  
  
        END; --IF';  
END;  
  
SET @SQL += @TruncationGuard + N'  
        -- Updating is done. Update the status.  
  
        UPDATE [stg].' + @StagingConsolidatedTable + N'  
        SET ImportStatus_ID = @StatusOK  
        FROM [stg].' + @StagingConsolidatedTable + N'  
        WHERE ImportType in (@IT_MergeOptimistic,@IT_MergeOverwrite) AND ImportStatus_ID = @StatusProcessing AND Batch_ID = @Batch_ID;  
  
        -- Set status to process Delete (soft delete) and Purge (hard delete)  
        UPDATE [stg].' + @StagingConsolidatedTable + N'  
        SET ImportStatus_ID = @StatusProcessing  
        WHERE ImportType IN (@IT_Delete,@IT_Purge) AND ErrorCode = 0  
        AND ImportStatus_ID = @StatusDefault AND Batch_ID = @Batch_ID;  
  
        --Determine if any purge or delete records exist  
        IF Exists(SELECT Code FROM [stg].' + @StagingConsolidatedTable + N'  
        WHERE ImportType IN (@IT_Delete,@IT_Purge) AND ImportStatus_ID = @StatusProcessing AND Batch_ID = @Batch_ID)  
        BEGIN  
            -- Deactivate members in the hierarchy table.  
            -- The same process as the one that mdm.udpMembersStatusSet does when the status is set to inactive.  
  
            SET @Now = GETUTCDATE();  
            IF @LogFlag != 1  
            BEGIN  
                UPDATE hr  
                SET  Status_ID = ' + @MemberStatus_Deactivated + N'  
                    ,LastChgDTM = @Now  
                    ,LastChgUserID = @User_ID  
                    ,LastChgVersionID = @Version_ID  
                    ,LevelNumber = -1  
                FROM mdm.' + @HierarchyRelationshipTable + N' hr  
                INNER JOIN mdm.' + @HierarchyParentTable + N' hp  
                ON      hr.Child_HP_ID = hp.ID  
                    AND hr.Version_ID = @Version_ID  
                    AND hr.ChildType_ID = @ConsolidatedMemberTypeID  
                INNER JOIN [stg].' + @StagingConsolidatedTable + N' stgp  
                ON      hp.Code = stgp.Code  
                    AND hp.Status_ID = ' + @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/ + N' -- Active  
                    AND hp.Version_ID = @Version_ID  
                    AND stgp.ImportStatus_ID = @StatusProcessing  
                    AND stgp.Batch_ID = @Batch_ID  
                    AND stgp.ImportType IN (@IT_Delete, @IT_Purge);  
            END  
            ELSE  
            BEGIN  
                UPDATE hr  
                SET  Status_ID = ' + @MemberStatus_Deactivated + N'  
                    ,LastChgDTM = @Now  
                    ,LastChgUserID = @User_ID  
                    ,LastChgVersionID = @Version_ID  
                    ,LevelNumber = -1' +  
                    CASE @TransactionLogType  
                        WHEN @TransactionLogType_Member THEN @HRHistoryOutputQuery  
                        ELSE N''  
                    END + N'  
                FROM mdm.' + @HierarchyRelationshipTable + N' hr  
                INNER JOIN mdm.' + @HierarchyParentTable + N' hp  
                ON      hr.Child_HP_ID = hp.ID  
                    AND hr.Version_ID = @Version_ID  
                    AND hr.ChildType_ID = @ConsolidatedMemberTypeID  
                INNER JOIN [stg].' + @StagingConsolidatedTable + N' stgp  
                ON      hp.Code = stgp.Code  
                    AND hp.Status_ID = ' + @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/ + N' -- Active  
                    AND hp.Version_ID = @Version_ID  
                    AND stgp.ImportStatus_ID = @StatusProcessing  
                    AND stgp.Batch_ID = @Batch_ID  
                    AND stgp.ImportType IN (@IT_Delete, @IT_Purge);  
            END  
  
            SET @Now = GETUTCDATE();  
            IF @LogFlag != 1  
            BEGIN  
                UPDATE hr  
                SET  Parent_HP_ID = NULL  
                    ,LevelNumber = -1  
                FROM mdm.' + @HierarchyRelationshipTable + N' hr  
                INNER JOIN mdm.' + @HierarchyParentTable + N' hp  
                ON      hr.Parent_HP_ID = hp.ID  
                    AND hr.Version_ID = @Version_ID  
                INNER JOIN [stg].' + @StagingConsolidatedTable + N' stgp  
                ON      hp.Code = stgp.Code  
                    AND hp.Status_ID = ' + @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/ + N' -- Active  
                    AND hp.Version_ID = @Version_ID  
                    AND stgp.ImportStatus_ID = @StatusProcessing  
                    AND stgp.Batch_ID = @Batch_ID  
                    AND stgp.ImportType IN (@IT_Delete, @IT_Purge);  
            END  
            ELSE  
            BEGIN  
                UPDATE hr  
                SET  Parent_HP_ID = NULL  
                    ,LevelNumber = -1' +  
                    CASE @TransactionLogType  
                        WHEN @TransactionLogType_Member THEN @HRHistoryOutputQuery  
                        ELSE N''  
                    END + N'  
                FROM mdm.' + @HierarchyRelationshipTable + N' hr  
                INNER JOIN mdm.' + @HierarchyParentTable + N' hp  
                ON      hr.Parent_HP_ID = hp.ID  
                    AND hr.Version_ID = @Version_ID  
                INNER JOIN [stg].' + @StagingConsolidatedTable + N' stgp  
                ON      hp.Code = stgp.Code  
                    AND hp.Status_ID = ' + @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/ + N' -- Active  
                    AND hp.Version_ID = @Version_ID  
                    AND stgp.ImportStatus_ID = @StatusProcessing  
                    AND stgp.Batch_ID = @Batch_ID  
                    AND stgp.ImportType IN (@IT_Delete, @IT_Purge);  
            END  
  
            -- Before deleting the parent member remove it from the HierarchyTable when it remains to be a child node.  
            SET @Now = GETUTCDATE();  
            IF @LogFlag != 1  
            BEGIN  
                DELETE hr  
                FROM mdm.' + @HierarchyRelationshipTable + N' hr  
                INNER JOIN mdm.' + @HierarchyParentTable + N' hp  
                ON      hr.Child_HP_ID = hp.ID  
                    AND hr.Version_ID = @Version_ID  
                    AND hr.LevelNumber = -1  
                INNER JOIN [stg].' + @StagingConsolidatedTable + N' stgp  
                ON      hp.Code = stgp.Code  
                    AND hp.Version_ID = @Version_ID  
                    AND stgp.ImportStatus_ID = @StatusProcessing  
                    AND stgp.Batch_ID = @Batch_ID  
                    AND stgp.ImportType = @IT_Purge;  
            END  
            ELSE  
            BEGIN  
                DELETE hr' +  
                    CASE @TransactionLogType  
                        WHEN @TransactionLogType_Member THEN @HRHistoryOutputQuery  
                        ELSE N''  
                    END + N'  
                FROM mdm.' + @HierarchyRelationshipTable + N' hr  
                INNER JOIN mdm.' + @HierarchyParentTable + N' hp  
                ON      hr.Child_HP_ID = hp.ID  
                    AND hr.Version_ID = @Version_ID  
                    AND hr.LevelNumber = -1  
                INNER JOIN [stg].' + @StagingConsolidatedTable + N' stgp  
                ON      hp.Code = stgp.Code  
                    AND hp.Version_ID = @Version_ID  
                    AND stgp.ImportStatus_ID = @StatusProcessing  
                    AND stgp.Batch_ID = @Batch_ID  
                    AND stgp.ImportType = @IT_Purge;  
            END  
  
            -- Soft delete members when the import type is delete.  
            SET @Now = GETUTCDATE();  
            IF @LogFlag != 1  
            BEGIN  
                UPDATE hp  
                SET Status_ID = ' + @MemberStatus_Deactivated + N'  
                   ,LastChgDTM = GETUTCDATE()  
                   ,LastChgUserID = @User_ID  
                   ,LastChgVersionID = @Version_ID  
                FROM mdm.' + @HierarchyParentTable + N' hp  
                INNER JOIN [stg].' + @StagingConsolidatedTable + N' stgp  
                ON      hp.Code = stgp.Code  
                    AND hp.Status_ID = ' + @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/ + N' -- Active  
                    AND hp.Version_ID = @Version_ID  
                    AND stgp.ImportStatus_ID = @StatusProcessing  
                    AND stgp.Batch_ID = @Batch_ID  
                    AND stgp.ImportType = @IT_Delete;  
            END  
            ELSE  
            BEGIN  
                UPDATE hp  
                SET Status_ID = ' + @MemberStatus_Deactivated + N'  
                   ,LastChgDTM = GETUTCDATE()  
                   ,LastChgUserID = @User_ID  
                   ,LastChgVersionID = @Version_ID' +  
                    CASE @TransactionLogType  
                        WHEN @TransactionLogType_Member THEN @HPHistoryOutputQuery  
                        ELSE N''  
                    END + N'  
                FROM mdm.' + @HierarchyParentTable + N' hp  
                INNER JOIN [stg].' + @StagingConsolidatedTable + N' stgp  
                ON      hp.Code = stgp.Code  
                    AND hp.Status_ID = ' + @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/ + N' -- Active  
                    AND hp.Version_ID = @Version_ID  
                    AND stgp.ImportStatus_ID = @StatusProcessing  
                    AND stgp.Batch_ID = @Batch_ID  
                    AND stgp.ImportType = @IT_Delete;  
            END;'  
  
IF @TransactionLogType = @TransactionLogType_Attribute  
BEGIN  
    SET @SQL += @TruncationGuard + N'  
            IF @LogFlag = 1  
            BEGIN  
                --Log delete and purge of members.  
                --Because there is no transaction status for hard delete, record hard delete as de-activation.  
                INSERT INTO [mdm].' + QUOTENAME(@TransactionTableName) + N'  
                (  
                    Version_ID,  
                    TransactionType_ID,  
                    OriginalTransaction_ID,  
                    Hierarchy_ID,  
                    Entity_ID,  
                    Member_ID,  
                Member_MUID,  
                    MemberType_ID,  
                    MemberCode,  
                    OldValue,  
                    OldCode,  
                    NewValue,  
                    NewCode,  
                    Batch_ID,  
                    EnterDTM,  
                    EnterUserID,  
                    LastChgDTM,  
                    LastChgUserID  
                )  
                SELECT  
                    @Version_ID, --Version_ID  
                    @MemberStatusSetTransaction, --TransactionType_ID  
                    0, --OriginalTransaction_ID  
                    NULL, --Hierarchy_ID  
                    @Entity_ID, --Entity_ID  
                    hp.ID, --Member_ID  
                hp.MUID, --Member_MUID  
                    @ConsolidatedMemberTypeID, --MemberType_ID  
                    stgp.Code,  
                    N''1'', --OldValue  
                    N''Active'', --OldCode  
                    N''2'', --NewValue  
                    N''De-Activated'', --NewCode  
                    @Batch_ID,  
                    GETUTCDATE(),  
                    @User_ID,  
                    GETUTCDATE(),  
                    @User_ID  
            FROM mdm.' + @HierarchyParentTable + N' hp  
            INNER JOIN [stg].' + @StagingConsolidatedTable + N' stgp  
            ON      hp.Code = stgp.Code  
                AND hp.Status_ID = ' + @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/ + N' -- Active  
                AND hp.Version_ID = @Version_ID  
                AND stgp.ImportStatus_ID = @StatusProcessing  
                AND stgp.Batch_ID = @Batch_ID  
                    AND stgp.ImportType IN (@IT_Delete, @IT_Purge);  
            END;';  
END;  
  
SET @SQL += @TruncationGuard + N'  
            -- Delete member security  
            DELETE sra  
            FROM mdm.tblSecurityRoleAccessMember sra  
            INNER JOIN mdm.' + @HierarchyParentTable + N' hp  
            ON      sra.Member_ID = hp.ID  
                AND sra.Version_ID = @Version_ID  
                AND sra.Entity_ID = @Entity_ID  
                AND sra.HierarchyType_ID IN (0, 1) -- Derived and Explicit Hierarchy  
                AND sra.MemberType_ID = @ConsolidatedMemberTypeID  
            INNER JOIN [stg].' + @StagingConsolidatedTable + N' stgp  
            ON      hp.Code = stgp.Code  
                AND ((hp.Status_ID = ' + @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/ + N' -- Active  
                        AND stgp.ImportType = @IT_Delete)  
                        OR stgp.ImportType = @IT_Purge)  
                AND hp.Version_ID = @Version_ID  
                AND stgp.ImportStatus_ID = @StatusProcessing  
                AND stgp.Batch_ID = @Batch_ID  
                AND stgp.ImportType IN (@IT_Delete, @IT_Purge);  
  
            -- Hard delete members when the import type is Purge.  
  
            -- Get the IDs of any rows in tblFile that are about to be orphaned  
            CREATE TABLE #FileIDsToDelete  
            (  
                ID  INT  
            );  
            DECLARE @GetFileIdsSQL NVARCHAR(MAX) = mdm.udfFileIDReferencesGetSQL(@Entity_ID, 2/*Consolidated*/, NULL, 1/*Soft-deleted members only*/)  
            IF LEN(@GetFileIdsSQL) > 0  
            BEGIN  
                SET @GetFileIdsSQL = CONCAT(N''INSERT INTO #FileIDsToDelete(ID)  
'', @GetFileIdsSQL);  
                EXEC sp_executesql @GetFileIdsSQL;  
            END  
  
            SET @Now = GETUTCDATE();  
            IF @LogFlag != 1  
            BEGIN  
                DELETE hp  
                FROM mdm.' + @HierarchyParentTable + N' hp  
                INNER JOIN [stg].' + @StagingConsolidatedTable + N' stgp  
                ON      hp.Code = stgp.Code  
                    AND hp.Version_ID = @Version_ID  
                    AND stgp.ImportStatus_ID = @StatusProcessing  
                    AND stgp.Batch_ID = @Batch_ID  
                    AND stgp.ImportType = @IT_Purge;  
            END  
            ELSE  
            BEGIN  
                DELETE hp' +  
                    CASE @TransactionLogType  
                        WHEN @TransactionLogType_Member THEN @HPHistoryOutputQuery  
                        ELSE N''  
                    END + N'  
                FROM mdm.' + @HierarchyParentTable + N' hp  
                INNER JOIN [stg].' + @StagingConsolidatedTable + N' stgp  
                ON      hp.Code = stgp.Code  
                    AND hp.Version_ID = @Version_ID  
                    AND stgp.ImportStatus_ID = @StatusProcessing  
                    AND stgp.Batch_ID = @Batch_ID  
                    AND stgp.ImportType = @IT_Purge;  
            END  
  
            -- Delete orphaned files.  
            IF EXISTS(SELECT 1 FROM #FileIDsToDelete)  
            BEGIN  
                DECLARE @File_ID mdm.IdList;  
                INSERT INTO @File_ID  
                SELECT ID   
                FROM #FileIDsToDelete;  
  
                EXEC mdm.udpFilesDelete @File_ID = @File_ID  
            END  
  
            EXEC mdm.udpSecurityMemberProcessRebuildModelVersion @Version_ID, 1;  
  
        END; --IF  
  
        --Update the status after the delete  
        UPDATE [stg].' + @StagingConsolidatedTable + N'  
            SET ImportStatus_ID = @StatusOK  
            WHERE ImportType IN (@IT_Delete, @IT_Purge) AND ImportStatus_ID = @StatusProcessing AND Batch_ID = @Batch_ID;  
  
        --Get the number of errors for the batch ID  
        SELECT @ErrorCount = COUNT(ID) FROM [stg].' + @StagingConsolidatedTable + N'  
            WHERE Batch_ID = @Batch_ID AND ImportStatus_ID = @StatusError;  
  
        -- Set the status of the batch as Not Running (Completed).  
        -- Set the error member count.  
        UPDATE mdm.tblStgBatch  
            SET Status_ID = @Completed,  
                LastRunEndDTM = GETUTCDATE(),  
                LastRunEndUserID = @User_ID ,  
                ErrorMemberCount = @ErrorCount  
            WHERE ID = @Batch_ID  
  
        IF @TranCounter = 0 COMMIT TRANSACTION; --Commit only if we are not nested  
  
        RETURN 0;  
  
    END TRY  
    BEGIN CATCH  
        SET NOCOUNT OFF;  
  
        -- Get error info  
        DECLARE  
            @ErrorMessage NVARCHAR(4000),  
            @ErrorSeverity INT,  
            @ErrorState INT,  
            @ErrorNumber INT,  
            @ErrorLine INT,  
            @ErrorProcedure NVARCHAR(126);  
        EXEC mdm.udpGetErrorInfo  
            @ErrorMessage = @ErrorMessage OUTPUT,  
            @ErrorSeverity = @ErrorSeverity OUTPUT,  
            @ErrorState = @ErrorState OUTPUT,  
            @ErrorNumber = @ErrorNumber OUTPUT,  
            @ErrorLine = @ErrorLine OUTPUT,  
            @ErrorProcedure = @ErrorProcedure OUTPUT  
  
        SET @ErrorMessage = CONCAT(@ErrorMessage, N'', @ErrorNumber = '', @ErrorNumber, N'', @ErrorProcedure = "'', @ErrorProcedure, N''", line '', @ErrorLine);  
  
        IF @TranCounter = 0 ROLLBACK TRANSACTION;  
        ELSE IF XACT_STATE() <> -1 ROLLBACK TRANSACTION TX;  
  
        RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);  
        RETURN @OtherRuntimeError;  
  
    END CATCH  
        SET NOCOUNT OFF;  
    END;'  
  
    --SELECT @SQL AS [processing-instruction(x)] FOR XML PATH('');  
    EXEC sp_executesql @SQL;  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpEntityStagingCreateConsolidatedTable]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
Helper sproc that creates the Consolidated staging table of the given name.   
*/  
CREATE PROCEDURE [mdm].[udpEntityStagingCreateConsolidatedTable]  
(  
    @StagingTableName   sysname, -- The name of the consolidated staging table to create  
    @TableOptions           NVARCHAR(MAX) = N'', -- Optional compress string used in creating the table.  
    @IndexOptions           NVARCHAR(MAX) = N'', -- Optional compress string used in creating the table indexes.  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
AS BEGIN  
    SET NOCOUNT ON;  
  
    SET @TableOptions = COALESCE(@TableOptions, N'');  
    SET @IndexOptions = COALESCE(@IndexOptions, N'');  
  
    -- This pseudo-constant is for use in string concatenation operations to prevent string truncation. When concatenating two or more strings,  
    -- if none of the strings is an NVARCHAR(MAX) or an NVARCHAR constant that is longer than 4,000 characters, then the resulting string   
    -- will be silently truncated to 4,000 characters. Concatenating with this empty NVARCHAR(MAX), is sufficient to prevent truncation.  
    -- See http://connect.microsoft.com/SQLServer/feedback/details/283368/nvarchar-max-concatenation-yields-silent-truncation.  
    DECLARE @TruncationGuard NVARCHAR(MAX) = N'';  
  
    DECLARE @SQL NVARCHAR(MAX) = @TruncationGuard + N'  
        CREATE TABLE [stg].' + QUOTENAME(@StagingTableName) + N'     
        (     
            --Identity    
            ID                  INT IDENTITY (1, 1) NOT NULL,  
                          
            --Import Specific  
            ImportType          TINYINT NOT NULL,  
  
            --Status    
            ImportStatus_ID     TINYINT NOT NULL CONSTRAINT ' + QUOTENAME(N'df_' + @StagingTableName  + N'_ImportStatus_ID') + N' DEFAULT 0,   
                            
            --Info    
            Batch_ID            INT NULL,  
            BatchTag            NVARCHAR(50) NOT NULL,  
  
            --Error Code  
            ErrorCode           INT NOT NULL CONSTRAINT ' + QUOTENAME(N'df_' + @StagingTableName  + N'_ErrorCode') + N' DEFAULT 0,   
            HierarchyName       NVARCHAR(250) NULL,     
            Code                NVARCHAR(250) NOT NULL,      
            [Name]              NVARCHAR(250) NULL,  
            NewCode             NVARCHAR(250) NULL,                         
                                                                                          
            --Create PRIMARY KEY constraint    
            CONSTRAINT ' + QUOTENAME(N'pk_' + @StagingTableName) + N'     
                PRIMARY KEY CLUSTERED (ID),    
                        
            --Create CHECK constraints    
            CONSTRAINT ' + QUOTENAME(N'ck_' + @StagingTableName + N'_ImportType') + N'     
                CHECK (ImportType BETWEEN 0 AND 4),    
                              
            CONSTRAINT ' + QUOTENAME(N'ck_' + @StagingTableName + N'_ImportStatus_ID') + N'     
                CHECK (ImportStatus_ID BETWEEN 0 and 3)                            
        )    
        ' + @TableOptions + N';    
                      
        --Index [Batch_ID] for performance  
        CREATE NONCLUSTERED INDEX ' + QUOTENAME(N'ix_' + @StagingTableName + N'_Batch_ID') + N'   
            ON [stg].' + QUOTENAME(@StagingTableName) + N'(Batch_ID)  
            ' + @IndexOptions + N';  
        --Index [BatchTag] for performance  
        CREATE NONCLUSTERED INDEX ' + QUOTENAME(N'ix_' + @StagingTableName + N'_BatchTag') + N'   
            ON [stg].' + QUOTENAME(@StagingTableName) + N'(BatchTag)  
            ' + @IndexOptions + N';  
  
        --Index [BatchTag], [ImportStatus_ID] for performance  
        CREATE NONCLUSTERED INDEX ' + QUOTENAME(N'ix_' + @StagingTableName + N'_BatchTag_ImportStatus_ID') + N'   
            ON [stg].' + QUOTENAME(@StagingTableName) + N'(BatchTag, ImportStatus_ID)  
            ' + @IndexOptions + N';  
  
        --Index [Code] for performance  
        CREATE NONCLUSTERED INDEX ' + QUOTENAME(N'ix_' + @StagingTableName + N'_Code') + N'   
            ON [stg].' + QUOTENAME(@StagingTableName) + N'(Code)  
            ' + @IndexOptions + N';  
        ';    
       
    --Execute the dynamic SQL    
    --PRINT(@SQL);    
    EXEC sp_executesql @SQL;    
  
    SET NOCOUNT OFF;  
END;
GO
/****** Object:  StoredProcedure [mdm].[udpEntityStagingCreateErrorDetailViews]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    Creates all the needed entity staging views to view error detail information  
    EXEC mdm.udpEntityStagingCreateErrorDetailViews 21  
*/  
CREATE PROCEDURE [mdm].[udpEntityStagingCreateErrorDetailViews]  
    @Entity_ID       INT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
AS  
BEGIN  
    DECLARE  
        @StagingBase            NVARCHAR(MAX),  
        @IsHierarchyEnabled     BIT,  
        @SQL                    NVARCHAR(MAX),  
        @SQLMemberView          NVARCHAR(MAX),  
        @SQLRelationView        NVARCHAR(MAX),  
        @MemberErrorViewName    NVARCHAR(MAX),  
        @RelationErrorViewName  NVARCHAR(MAX);  
  
    SELECT @StagingBase = StagingBase,  
           @IsHierarchyEnabled = CASE WHEN HierarchyTable IS NULL THEN 0 ELSE 1 END  
    FROM mdm.tblEntity  
    WHERE ID = @Entity_ID;  
           
    -- In case when the entity is a system entity (@StagingBase is not specified) simply don't create the error view (don't raise an error).   
    IF COALESCE(@StagingBase, N'') = N''   
    BEGIN   
        RETURN;  
    END;  
    
    SET @MemberErrorViewName = N'stg.' + QUOTENAME(N'viw_' + @StagingBase + N'_MemberErrorDetails');  
    SET @RelationErrorViewName = N'stg.' + QUOTENAME(N'viw_' + @StagingBase + N'_RelationshipErrorDetails');  
  
    -- Drop existing view if it already exists.  
    SET @SQL = N'  
        IF  EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N''' + REPLACE(@MemberErrorViewName, N'''', N'''''') + N'''))  
            DROP VIEW ' + @MemberErrorViewName + N'  
        IF  EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N''' + REPLACE(@RelationErrorViewName, N'''', N'''''') + N'''))  
            DROP VIEW ' + @RelationErrorViewName;  
  
    EXEC(@SQL);  
  
    SET @SQLMemberView = N'  
      CREATE VIEW ' + @MemberErrorViewName + N'  
      AS  
  
        WITH Members  
        AS  
        (  
            SELECT  
                    ID,  
                    ImportType,  
                    ImportStatus_ID,  
                    Batch_ID,  
                    BatchTag,  
                    ErrorCode,  
                    Code,  
                    Name,  
                    NewCode,  
                    1 AS MemberType -- Leaf member  
                FROM stg.' + QUOTENAME(@StagingBase + N'_Leaf') + N'  
                WHERE ImportStatus_ID = 2';  
  
    IF (@IsHierarchyEnabled = 1)  
    BEGIN  
        SET @SQLMemberView = @SQLMemberView + N'  
  
            UNION ALL  
  
            SELECT  
                    ID,  
                    ImportType,  
                    ImportStatus_ID,  
                    Batch_ID,  
                    BatchTag,  
                    ErrorCode,  
                    Code,  
                    Name,  
                    NewCode,  
                    2 AS MemberType -- Consolidated membery  
                FROM stg.' + QUOTENAME(@StagingBase + N'_Consolidated') + N'  
                WHERE ImportStatus_ID = 2';  
  
        SET @SQLRelationView = N'  
        CREATE VIEW '+ @RelationErrorViewName + N'  
        AS  
            SELECT   
                r.ID,  
                r.RelationshipType,   
                r.ImportStatus_ID,  
                r.Batch_ID,  
                r.BatchTag,  
                r.HierarchyName,  
                r.ParentCode,  
                r.ChildCode,  
                ecm.UniqueErrorCode,  
                dbe.Text AS ErrorDescription  
            FROM stg.' + QUOTENAME(@StagingBase + N'_Relationship') + N' r  
                LEFT OUTER JOIN mdm.tblErrorCodesMapping ecm ON (ecm.Bitmask & r.ErrorCode) <> 0  
                LEFT OUTER JOIN mdm.tblDBErrors dbe ON dbe.ID = ecm.UniqueErrorCode  
                LEFT OUTER JOIN sys.syslanguages sl ON sl.langid = @@LANGID AND sl.lcid = dbe.Language_ID  
            WHERE r.ImportStatus_ID = 2;';  
  
        EXEC(@SQLRelationView);  
    END -- IF  
  
    SET @SQLMemberView = @SQLMemberView + N'  
        )  
        SELECT  
                m.ID,  
                m.ImportType,  
                m.ImportStatus_ID,  
                m.Batch_ID,  
                m.BatchTag,  
                m.Code,  
                m.Name,  
                m.NewCode,  
                m.MemberType,  
                ecm.UniqueErrorCode,  
                dbe.Text AS ErrorDescription,  
                sed.AttributeName,  
                sed.AttributeValue  
            FROM  
                Members m  
                LEFT OUTER JOIN mdm.tblErrorCodesMapping ecm ON (ecm.Bitmask & m.ErrorCode) <> 0  
                LEFT OUTER JOIN mdm.tblStgErrorDetail sed ON sed.Batch_ID = m.Batch_ID AND sed.Code = m.Code AND ecm.UniqueErrorCode = sed.UniqueErrorCode  
                LEFT OUTER JOIN mdm.tblDBErrors dbe ON dbe.ID = ecm.UniqueErrorCode  
                LEFT OUTER JOIN sys.syslanguages sl ON sl.langid = @@LANGID AND sl.lcid = dbe.Language_ID;';  
  
    EXEC(@SQLMemberView);  
  
END; -- PROC
GO
/****** Object:  StoredProcedure [mdm].[udpEntityStagingCreateLeafStoredProcedure]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpEntityStagingCreateLeafStoredProcedure]  
(  
    @Entity_ID    INT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE @SQL                        NVARCHAR(MAX) = N'',  
            @SQLNonDBAColumns           NVARCHAR(MAX) = N'',  
            @SQLDBAColumns              NVARCHAR(MAX) = N'',  
            @SQLNonDBA                  NVARCHAR(MAX) = N'',  
            @SQLDBA                     NVARCHAR(MAX) = N'',  
            @SQLDBAJoin                 NVARCHAR(MAX) = N'',  
            @SQLDBACheck                NVARCHAR(MAX) = N'',  
            @SQLSelfReferencingDBACheck_Initial     NVARCHAR(MAX) = N'',  
            @SQLSelfReferencingDBACheck_Propagate   NVARCHAR(MAX) = N'',  
            @SQLSelfReferencingDBAUpdate            NVARCHAR(MAX) = N'',  
            @EntityTable                SYSNAME = N'',  
            @EntityView                 SYSNAME = N'',  
            @CollectionTable            SYSNAME = N'',  
            @HierarchyParentTable       SYSNAME = N'',  
            @HierarchyRelationshipTable SYSNAME = N'',  
            @AttributeFilterCheckSQL    NVARCHAR(MAX) = N'',  
            @SQLMergeOptimisticNonDBA   NVARCHAR(MAX) = N'',  
            @SQLMergeOptimisticDBA      NVARCHAR(MAX) = N'',  
            @SQLMergeOverwriteNonDBA    NVARCHAR(MAX) = N'',  
            @SQLMergeOverwriteDBA       NVARCHAR(MAX) = N'',  
            @SQLInsertTemp              NVARCHAR(MAX) = N'',  
            @SQLAttributeTypeErrorCheck NVARCHAR(MAX) = N'',  
            @StagingBase                NVARCHAR(60),  
            @StagingLeafTable           SYSNAME,  
            @StagingLeafTableWithEscapedQuotes      SYSNAME,  -- Contains same value as @StagingLeafTable, but with the single quotes escaped out. This should be used when using the staging name inside of a dynamic SQL statement that is nested inside another dynamic SQL statement.  
            @IsCollectionEnabled        BIT,  
            @IsHierarchyEnabled         BIT,  
            @SQLAttributeValueSetMergeOverwrite     NVARCHAR(MAX) = N'',  
            @SQLAttributeValueSetMergeOptimistic    NVARCHAR(MAX) = N'',  
  
            --Entity member status  
            @MemberStatus_Active        TINYINT = 1,  
            @MemberStatus_Deactivated   TINYINT = 2,  
  
            -- staging data status constants  
            @StatusDefault              TINYINT = 0,  
            @StatusOK                   TINYINT = 1,  
            @StatusError                TINYINT = 2,  
            @StatusProcessing           TINYINT = 3,  
  
            -- This pseudo-constant is for use in string concatenation operations to prevent string truncation. When concatenating two or more strings,  
            -- if none of the strings is an NVARCHAR(MAX) or an NVARCHAR constant that is longer than 4,000 characters, then the resulting string  
            -- will be silently truncated to 4,000 characters. Concatenating with this empty NVARCHAR(MAX), is sufficient to prevent truncation.  
            -- See http://connect.microsoft.com/SQLServer/feedback/details/283368/nvarchar-max-concatenation-yields-silent-truncation.  
            @TruncationGuard            NVARCHAR(MAX) = N'',  
  
            -- attribute type constant  
            @AttributeType_File         INT = 4,  
  
            @Model_ID                   INT,  
            @TranOldColumn              NVARCHAR(MAX) = N'',  
            @TranNewColumn              NVARCHAR(MAX) = N'',  
            @TranDeletedColumn          NVARCHAR(MAX) = N'',  
            @TranBlankColumn            NVARCHAR(MAX) = N'',  
            @TranInsertedColumn         NVARCHAR(MAX) = N'',  
  
            --Transaction and annotation table names  
            @TransactionTableName       SYSNAME,  
            @OutputDeletionToTransactionTableQuery  NVARCHAR(MAX) = N'',  
            @ENHistoryOutputQuery       NVARCHAR(MAX) = N'',  
            @HRHistoryOutputQuery       NVARCHAR(MAX) = N'',  
  
            @MemberType_Leaf            TINYINT = 1,  
            @MemberType_Hierarchy       TINYINT = 4,  
              
            --Import Type Constants  
            @IT_MergeOptimistic         NVARCHAR(30) = N'0/*MergeOptimistic*/', -- specified null values are left unchanged.  
            @IT_Insert                  NVARCHAR(30) = N'1/*Insert*/',  
            @IT_MergeOverwrite          NVARCHAR(30) = N'2/*MergeOverwrite*/', -- all values are overwritten with specified values (including null)  
            @IT_Delete                  NVARCHAR(30) = N'3/*Delete*/',  
            @IT_Purge                   NVARCHAR(30) = N'4/*Purge*/',  
            @IT_DeleteSetNullToRef      NVARCHAR(30) = N'5/*DeleteSetNullToRef*/',  
            @IT_PurgeSetNullToRef       NVARCHAR(30) = N'6/*PurgeSetNullToRef*/',  
            @IT_Max                     NVARCHAR(30) = N'6/*max*/',  
  
  
            -- transaction log type constants  
            @TransactionLogType            TINYINT,  
            @TransactionLogType_Attribute  TINYINT = 1,  
            @TransactionLogType_Member     TINYINT = 2,  
            @TransactionLogType_None       TINYINT = 3;  
  
    --Initialize the variables  
  
    SELECT  @EntityTable = QUOTENAME(EntityTable),  
            @EntityView = mdm.udfViewNameGet(Model_ID, ID, @MemberType_Leaf, 0, 0),  
            @CollectionTable = QUOTENAME(CollectionTable),  
            @HierarchyParentTable = QUOTENAME(HierarchyParentTable),  
            @HierarchyRelationshipTable = QUOTENAME(HierarchyTable),  
  
            @Model_ID = Model_ID,  
            @StagingBase = StagingBase,  
            @StagingLeafTable = QUOTENAME(StagingLeafTable),  
            @IsCollectionEnabled = CASE WHEN CollectionTable IS NULL THEN 0 ELSE 1 END,  
            @IsHierarchyEnabled  = CASE WHEN HierarchyTable  IS NULL THEN 0 ELSE 1 END,  
            @TransactionLogType = TransactionLogType  
    FROM mdm.viw_SYSTEM_SCHEMA_ENTITY  
    WHERE ID = @Entity_ID;  
  
    -- Escape out the single quotes in the staging table name and put it into another var that will be used for referencing the table name from nested dynamic SQL.  
    SET @StagingLeafTableWithEscapedQuotes = QUOTENAME(@StagingLeafTable, N'''');  
    -- Remove the leading and trailing single quotes that the above QUOTENAME added (we only want the escaped quotes within the table name)  
    SET @StagingLeafTableWithEscapedQuotes = SUBSTRING(@StagingLeafTableWithEscapedQuotes, 2, LEN(@StagingLeafTableWithEscapedQuotes) - 2);  
  
    IF @TransactionLogType = @TransactionLogType_Member  
    BEGIN  
        SET @ENHistoryOutputQuery = mdm.udfGetHistoryOutputQuery(@Entity_ID, @MemberType_Leaf, N'@User_ID', N'@Now');  
        SET @HRHistoryOutputQuery = mdm.udfGetHistoryOutputQuery(@Entity_ID, @MemberType_Hierarchy, N'@User_ID', N'@Now');  
    END  
    ELSE  
    BEGIN  
        --Load the transaction and annotation table names  
        SET @TransactionTableName = mdm.udfGetTransactionTableName(@Model_ID);  
  
        IF @TransactionLogType = @TransactionLogType_Attribute  
        BEGIN  
            SET @OutputDeletionToTransactionTableQuery = CONCAT(N'  
        OUTPUT  
            CASE DELETED.Status_ID WHEN ', @MemberStatus_Active, N'/*Active*/ THEN DELETED.ID END, -- leave ID null for members that are already soft-deleted. They will not be logged.  
            DELETED.MUID,  
            DELETED.Code  
        INTO #TRANLOG  
        (  
            MemberID,  
            MemberMUID,  
            Code  
        )')  
        END  
    END  
  
    -- In case when the entity is a system entity (StagingBase is not specified)  
    -- simply don't create the staging SProc (don't raise an error).  
    IF COALESCE(@StagingBase, N'') = N''  
    BEGIN  
        RETURN;  
    END;  
  
    --If the leaf staging SProc exists drop it.  
    EXEC mdm.udpEntityStagingDeleteStoredProcedures @Entity_ID, 1/*Leaf proc*/  
  
    DECLARE @AttributeTable TABLE  
    (  
        ViewColumn              NVARCHAR(100) COLLATE DATABASE_DEFAULT,  
        TableColumn             NVARCHAR(128) COLLATE DATABASE_DEFAULT NOT NULL,  
        AttributeType_ID        TINYINT NOT NULL,  
        DataType_ID             TINYINT NOT NULL,  
        DomainEntity_ID         INT NULL,  
        DomainTable             NVARCHAR(128) COLLATE DATABASE_DEFAULT NULL,  
        FilterParentAttributeName               NVARCHAR(100) COLLATE DATABASE_DEFAULT NULL,  
        FilterHierarchyEntityViewName           SYSNAME NULL,  
        FilterHierarchyParentAttributeName      NVARCHAR(100) COLLATE DATABASE_DEFAULT NULL,  
        FilterHierarchyM2MChildAttributeName    NVARCHAR(100) COLLATE DATABASE_DEFAULT NULL,  
        SortOrder               INT  
    );  
  
    INSERT INTO @AttributeTable  
    SELECT   
         a.Name AS ViewColumn  
        ,a.TableColumn  
        ,a.AttributeType_ID  
        ,a.DataType_ID  
        ,a.DomainEntity_ID  
        ,e.EntityTable AS DomainTable  
        ,parentAttribute.Name AS FilterParentAttributeName  
        ,mdm.udfViewNameGet(@Model_ID, levelEntity.ID, @MemberType_Leaf, 0, 0) AS FilterHierarchyEntityViewName  
        ,levelParentAttribute.Name AS FilterHierarchyParentAttributeName  
        ,m2mChildAttribute.Name AS FilterHierarchyM2MChildAttributeName  
        ,a.SortOrder  
    FROM mdm.tblAttribute a   
    LEFT JOIN mdm.tblEntity e   
    ON a.DomainEntity_ID = e.ID  
  
    LEFT JOIN mdm.tblAttribute parentAttribute  
    ON a.FilterParentAttribute_ID = parentAttribute.ID  
  
    LEFT JOIN mdm.tblDerivedHierarchyDetail filterLevel  
    ON a.FilterHierarchyDetail_ID = filterLevel.ID  
    LEFT JOIN mdm.tblAttribute levelParentAttribute  
    ON filterLevel.Foreign_ID = levelParentAttribute.ID  
    LEFT JOIN mdm.tblEntity levelEntity  
    ON levelParentAttribute.Entity_ID = levelEntity.ID  
    LEFT JOIN mdm.tblAttribute m2mChildAttribute  
    ON filterLevel.ManyToManyChildAttribute_ID = m2mChildAttribute.ID  
  
    WHERE   a.Entity_ID = @Entity_ID  
        AND a.MemberType_ID = 1--Leaf  
        AND a.IsSystem = 0   
        AND a.IsReadOnly = 0  
  
    DECLARE  
        @CurrentViewColumn          NVARCHAR(120) = N'', --specifically made to be less than 128 for truncation reasons  
        @CurrentTableColumn         SYSNAME = N'',  
        @CurrentTableColumnNoQuote  SYSNAME = N'',  
        @CurrentAttributeType_ID    TINYINT,  
        @CurrentDataType_ID         TINYINT,  
        @CurrentDomainEntity_ID     INT,  
        @CurrentDomainTable         SYSNAME = N'',  
        @CurrentFilterParentAttributeName       NVARCHAR(100),  
        @CurrentFilterHierarchyEntityViewName   SYSNAME,  
        @CurrentFilterHierarchyParentAttributeName NVARCHAR(100),  
        @CurrentFilterHierarchyM2MChildAttributeName NVARCHAR(100)  
  
  
    WHILE EXISTS(SELECT 1 FROM @AttributeTable)   
    BEGIN  
        SELECT TOP 1  
            @CurrentViewColumn = QUOTENAME(ViewColumn),  
            @CurrentTableColumn = QUOTENAME(TableColumn),  
            @CurrentTableColumnNoQuote = TableColumn,  
            @CurrentAttributeType_ID = AttributeType_ID,  
            @CurrentDataType_ID =  DataType_ID,  
            @CurrentDomainEntity_ID = DomainEntity_ID,  
            @CurrentDomainTable = DomainTable,  
            @CurrentFilterParentAttributeName = QUOTENAME(FilterParentAttributeName),  
            @CurrentFilterHierarchyEntityViewName = FilterHierarchyEntityViewName,  
            @CurrentFilterHierarchyParentAttributeName = QUOTENAME(FilterHierarchyParentAttributeName),  
            @CurrentFilterHierarchyM2MChildAttributeName = QUOTENAME(FilterHierarchyM2MChildAttributeName)  
        FROM @AttributeTable  
        ORDER BY SortOrder;  
  
        SET @TranOldColumn += CONCAT(N'  
        ,', @CurrentTableColumnNoQuote, N' NVARCHAR(MAX)  COLLATE DATABASE_DEFAULT NULL ');  
        SET @TranDeletedColumn += CONCAT(N', CONVERT(NVARCHAR(MAX), deleted.', @CurrentTableColumn, N') ');  
        SET @TranBlankColumn += N', NULL ';  
        SET @TranNewColumn += CONCAT(N'  
        ,New_', @CurrentTableColumnNoQuote, N' NVARCHAR(MAX) COLLATE DATABASE_DEFAULT NULL ');  
        SET @TranInsertedColumn += CONCAT(N', CONVERT(NVARCHAR(MAX), inserted.', @CurrentTableColumn, N') ');  
  
        IF @CurrentDomainEntity_ID IS NULL   
        BEGIN -- Non DBA  
            SET @SQLNonDBAColumns += N'  
                ,' + @CurrentTableColumn + N' --' + @CurrentViewColumn;  
  
            -- When the data type is text and the value is @NULLText (~NULL~) set NULL.  
            -- When the data type is number and the value is @NULLNumber (-98765432101234567890) set NULL.  
            -- When the data type is DateTime and the value is @NULLDateTime (5555-11-22T12:34:56) set NULL.  
  
            SET @SQLAttributeValueSetMergeOverwrite = CASE  
                                    WHEN @CurrentDataType_ID IN (1 /*Text*/, 6 /*Link*/) THEN  
                                        N'NULLIF(stgl.' + @CurrentViewColumn + N',@NULLText)'  
                                    WHEN @CurrentDataType_ID = 2 THEN -- Data type is Number  
                                        N'NULLIF(stgl.' + @CurrentViewColumn + N',@NULLNumber)'  
                                    WHEN @CurrentDataType_ID = 3 THEN -- Data type is DateTime  
                                        N'NULLIF(stgl.' + @CurrentViewColumn + N',@NULLDateTime)'  
                                    ELSE  
                                        N'stgl.' + @CurrentViewColumn  
                                    END;  
  
            IF LEN(COALESCE(@SQLNonDBA, N'')) > 0  
            BEGIN -- Not at the beginning.  
                SET @SQLNonDBA += N',  
';  
            END;  
            SET @SQLNonDBA += @SQLAttributeValueSetMergeOverwrite;  
  
            -- Even in case of merge optimistic set NULL when the value is @NULLText, @NULLNumber, or @NULLDateTime depending on the data type.  
            SET @SQLAttributeValueSetMergeOptimistic = CASE  
                                    WHEN @CurrentDataType_ID IN (1 /*Text*/, 6 /*Link*/) THEN  
                                        N'CASE WHEN stgl.' + @CurrentViewColumn + N' = @NULLText THEN NULL  
                                               WHEN stgl.' + @CurrentViewColumn + N' IS NULL THEN en.'  + @CurrentTableColumn + N'  
                                               ELSE stgl.' + @CurrentViewColumn + N'  
                                          END '  
                                    WHEN @CurrentDataType_ID = 2 THEN -- Data type is Number  
                                        N'CASE WHEN stgl.' + @CurrentViewColumn + N' = @NULLNumber THEN NULL  
                                               WHEN stgl.' + @CurrentViewColumn + N' IS NULL THEN en.'  + @CurrentTableColumn + N'  
                                               ELSE stgl.' + @CurrentViewColumn + N'  
                                          END '  
                                    WHEN @CurrentDataType_ID = 3 THEN -- Data type is DateTime  
                                        N'CASE WHEN stgl.' + @CurrentViewColumn + N' = @NULLDateTime THEN NULL  
                                               WHEN stgl.' + @CurrentViewColumn + N' IS NULL THEN en.'  + @CurrentTableColumn + N'  
                                               ELSE stgl.' + @CurrentViewColumn + N'  
                                          END '  
                                    ELSE  
                                        N'stgl.' + @CurrentViewColumn  
                                    END;  
  
            SET @SQLMergeOptimisticNonDBA += N',' + @CurrentTableColumn + N' = ' + @SQLAttributeValueSetMergeOptimistic;  
            SET @SQLMergeOverwriteNonDBA += N',' + @CurrentTableColumn + N' = ' + @SQLAttributeValueSetMergeOverwrite;  
        END  
        ELSE BEGIN -- DBA  
  
            SET @SQLDBAColumns += N'  
                ,' + @CurrentTableColumn + N' --' + @CurrentViewColumn;  
  
            IF NULLIF(@SQLDBA, N'') IS NOT NULL  
            BEGIN -- Not at the beginning.  
                SET @SQLDBA += N',  
'  
            END;  
            SET @SQLDBA += N'CASE WHEN stgl.' + @CurrentViewColumn + N' = @NULLText THEN NULL ELSE ' + @CurrentViewColumn + N'.ID END';  
  
            -- Even in case of merge optimistic set NULL when the value is @NULLText.  
            SET @SQLMergeOptimisticDBA += N',' + @CurrentTableColumn + N' = CASE WHEN stgl.' + @CurrentViewColumn + N' = @NULLText THEN NULL  
            ELSE ISNULL(' + @CurrentViewColumn + N'.ID, en.' + @CurrentTableColumn + N') END  
            ';  
  
            SET @SQLMergeOverwriteDBA += N',' + @CurrentTableColumn + N' = CASE WHEN stgl.' + @CurrentViewColumn + N' = @NULLText THEN NULL  
            ELSE ' + @CurrentViewColumn + N'.ID END  
            ';  
  
            -- In case when there are multiple DBAs using the same entity table use @CurrentViewColumn as  
            -- an alias to each entity table to avoid SQL error.  
            SET @SQLDBAJoin += CONCAT(N'  
LEFT JOIN mdm.', @CurrentDomainTable, N' ', @CurrentViewColumn, N'  
ON      stgl.', @CurrentViewColumn, N' = ', @CurrentViewColumn, N'.Code  
    AND ', @CurrentViewColumn, N'.Version_ID = @Version_ID  
    AND ', @CurrentViewColumn, N'.Status_ID = ', @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/, N' -- Active')  
            IF @CurrentDomainEntity_ID = @Entity_ID  
            BEGIN  
                -- Update the SQL fragment used to find members whose self-referencing DBA(s) reference invalid members.  
                SET @SQLSelfReferencingDBACheck_Initial += @TruncationGuard +  
                    CASE WHEN LEN(@SQLSelfReferencingDBACheck_Initial) > 0 THEN N'  
UNION -- not UNION ALL because deduplication is needed  
'                       ELSE N'' END + CONCAT(N'  
SELECT stgl.ID, stgl.Code, N', QUOTENAME(@CurrentViewColumn, N''''), N', stgl.', @CurrentViewColumn, N'  
FROM [stg].', @StagingLeafTable, N' stgl  
WHERE EXISTS(  
SELECT 1 FROM mdm.', @EntityTable, N' dm -- First see if the member already exists  
WHERE stgl.', @CurrentViewColumn, N' = dm.Code  
AND dm.Status_ID = ', @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/, N' -- Active  
AND dm.Version_ID = @Version_ID)  
AND EXISTS(  
SELECT 1 FROM stg.', @StagingLeafTable, N' dm2 -- Self-referencing DBA. See if the domain member is being created in the same batch.  
WHERE stgl.', @CurrentViewColumn, N' = dm2.Code  
AND stgl.Batch_ID = dm2.Batch_ID  
AND dm2.ErrorCode = 0  
AND stgl.ImportType NOT IN (', @IT_Delete, N', ', @IT_Purge, N', ', @IT_DeleteSetNullToRef, N', ', @IT_PurgeSetNullToRef, N')  
AND LEN(ISNULL(NULLIF(stgl.', @CurrentViewColumn, N', @NULLText), N'''')) > 0  
AND stgl.Batch_ID = @Batch_ID AND stgl.ImportStatus_ID = ', @StatusDefault, N' -- Default  
AND dm2.Code IS NULL)');  
  
                -- Update the SQL fragment used to propagate errors down to descendants.  
                SET @SQLSelfReferencingDBACheck_Propagate += @TruncationGuard +  
                    CASE WHEN LEN(@SQLSelfReferencingDBACheck_Propagate) > 0 THEN N'  
    UNION -- not UNION ALL because deduplication is needed  
'                       ELSE N'' END + CONCAT(N'  
    SELECT  
         child.ID  
        ,child.Code  
        , N', QUOTENAME(@CurrentViewColumn, N''''), N'  
        ,child.', @CurrentViewColumn, N'  
    FROM @PreviousIterationOrphans parent  
    INNER JOIN stg.', @StagingLeafTable, N' child  
    ON parent.Code = child.', @CurrentViewColumn, N'  
    AND child.Batch_ID = @Batch_ID  
    AND child.ErrorCode = 0  
    LEFT JOIN @Orphans o  
    ON child.ID = o.ID  
    WHERE o.ID IS NULL -- exclude known orphans (protects against redundant lookups that would cause an infinite loop)');  
  
                -- Update the SQL fragment used for updating the self-referencing DBA value after new members have been added to the table.  
                SET @SQLSelfReferencingDBAUpdate += CONCAT(N'  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Update the self-referencing DBA value after new members have been added to the table.'')  
    UPDATE en  
    SET ', @CurrentTableColumn, N' = parent.MemberID  
    FROM mdm.', @EntityTable, N' en  
    INNER JOIN stg.', @StagingLeafTable, N' stgl  
    ON      en.Code = stgl.Code  
        AND en.Status_ID = ', @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/, N' -- Active  
        AND en.Version_ID = @Version_ID  
    INNER JOIN #TRANLOG parent  
    ON stgl.', @CurrentViewColumn, N' = parent.Code  
    WHERE   stgl.ImportStatus_ID = ', @StatusProcessing, N' -- Processing  
        AND stgl.Batch_ID = @Batch_ID;  
');  
            END ELSE -- IF self-referencing DBA  
            BEGIN  
                -- The DBA is not self-referencing, so validate by ensuring that the referenced domain member exists and is active.  
                SET @SQLDBACheck += CONCAT(@TruncationGuard, N'  
IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' (', REPLACE(@CurrentViewColumn, N'''', N''''''),') Check for Error 210003- The attribute value references a member that does not exist or is inactive'')  
-- Error 210003 The attribute value references a member that does not exist or is inactive. Binary Location 2^2:  
UPDATE stgl  
SET ErrorCode = ErrorCode | 4  
    OUTPUT inserted.Batch_ID, inserted.Code, N', QUOTENAME(@CurrentViewColumn, N''''), N', inserted.', @CurrentViewColumn, N', 210003  
    INTO [mdm].[tblStgErrorDetail] (Batch_ID, Code, AttributeName, AttributeValue, UniqueErrorCode)  
FROM [stg].', @StagingLeafTable, N' stgl  
LEFT JOIN mdm.', @CurrentDomainTable, N' dm  
ON      stgl.', @CurrentViewColumn, N' = dm.Code  
    AND dm.Status_ID = ', @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/, N' -- Active  
    AND dm.Version_ID = @Version_ID  
WHERE   stgl.ImportType NOT IN (', @IT_Delete, N', ', @IT_Purge, N', ', @IT_DeleteSetNullToRef, N', ', @IT_PurgeSetNullToRef, N')  
    AND LEN(ISNULL(NULLIF(stgl.', @CurrentViewColumn, N',  @NULLText), N'''')) > 0  
    AND stgl.Batch_ID = @Batch_ID   
    AND stgl.ImportStatus_ID = ', @StatusDefault, N' -- Default  
    AND dm.Code IS NULL  
',  
                -- The attribute has a filter. Check for incompatible values.  
                CASE WHEN @CurrentFilterParentAttributeName IS NOT NULL THEN CONCAT(@TruncationGuard, N'  
IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' (', REPLACE(@CurrentViewColumn, N'''', N''''''),', Insert and MergeOverwrite) Check for 310055- The attribute value is not compatible with the attribute filter'')  
-- Error 310055 The attribute value is not compatible with the attribute filter. Binary Location 2^20:  
-- Insert and MergeOverwrite is the simple case because the staging row is complete (what you see is what you get)  
UPDATE stgl  
SET ErrorCode = ErrorCode | 1048576  
    OUTPUT inserted.Batch_ID, inserted.Code, N', QUOTENAME(@CurrentViewColumn, N''''), N', inserted.', @CurrentViewColumn, N', 310055  
    INTO mdm.tblStgErrorDetail (Batch_ID, Code, AttributeName, AttributeValue, UniqueErrorCode)  
FROM stg.', @StagingLeafTable, N' stgl  
LEFT JOIN mdm.', @CurrentFilterHierarchyEntityViewName, N' filter -- Note: the %_CHILDATTRIBUTES view excludes inactive members  
ON      @Version_ID = filter.Version_ID  
    AND stgl.', @CurrentViewColumn, N' = filter.', COALESCE(@CurrentFilterHierarchyM2MChildAttributeName, N'Code'), N'  
    AND ISNULL(NULLIF(stgl.', @CurrentFilterParentAttributeName, N', @NULLText),N'''') = ISNULL(filter.', @CurrentFilterHierarchyParentAttributeName, N', N'''')  
WHERE   stgl.ImportType IN (', @IT_Insert, N', ', @IT_MergeOverwrite, N')  
    AND stgl.Batch_ID = @Batch_ID   
    AND stgl.ImportStatus_ID = ', @StatusDefault, N' -- Default  
    AND NULLIF(NULLIF(stgl.', @CurrentViewColumn, N',  @NULLText), N'''') IS NOT NULL -- null child values are always valid  
    AND filter.ID IS NULL -- could not find a match',   
CASE WHEN @CurrentFilterHierarchyM2MChildAttributeName IS NOT NULL THEN CONCAT(@TruncationGuard, N'  
    AND (stgl.', @CurrentFilterParentAttributeName, N' IS NOT NULL -- M2M level: not finding a filter row match is okay if the parent is null  
         OR EXISTS( SELECT 1                                       -- and the child is not under another parent  
                    FROM mdm.', @CurrentFilterHierarchyEntityViewName, N' filter  
                    WHERE   @Version_ID = filter.Version_ID    
                        AND stgl.', @CurrentViewColumn, N' = filter.', COALESCE(@CurrentFilterHierarchyM2MChildAttributeName, N'Code'), N'  
                        AND filter.', @CurrentFilterHierarchyParentAttributeName, N' IS NOT NULL))')   
    END, N'  
  
IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' (', REPLACE(@CurrentViewColumn, N'''', N''''''),', MergeOptimistic) Check for 310055- The attribute value is not compatible with the attribute filter'')  
-- Error 310055 The attribute value is not compatible with an attribute filter. Binary Location 2^20:  
-- For MergeOptimistic, the staging row is combined with the already-existing row in the EN table to get the complete picture, because the staging row may not contain values for attributes that are not changing.   
UPDATE stgl  
SET ErrorCode = ErrorCode | 1048576  
    OUTPUT inserted.Batch_ID, inserted.Code, N', QUOTENAME(@CurrentViewColumn, N''''), N', inserted.', @CurrentViewColumn, N', 310055  
    INTO mdm.tblStgErrorDetail (Batch_ID, Code, AttributeName, AttributeValue, UniqueErrorCode)  
FROM stg.', @StagingLeafTable, N' stgl  
LEFT JOIN mdm.', @EntityView , N' viw -- join to get current values  
ON      @Version_ID = viw.Version_ID  
    AND stgl.Code = viw.Code  
LEFT JOIN mdm.', @CurrentFilterHierarchyEntityViewName, N' filter -- Note: the %_CHILDATTRIBUTES view excludes inactive members  
ON      @Version_ID = filter.Version_ID  
    AND ISNULL(stgl.', @CurrentViewColumn, N', viw.', @CurrentViewColumn, N') = filter.', COALESCE(@CurrentFilterHierarchyM2MChildAttributeName, N'Code'), N'  
    AND ISNULL(NULLIF(ISNULL(stgl.', @CurrentFilterParentAttributeName, N',viw.', @CurrentFilterParentAttributeName, N'), @NULLText),'''') = ISNULL(filter.', @CurrentFilterHierarchyParentAttributeName, N',N'''')  
WHERE   stgl.ImportType = ', @IT_MergeOptimistic, N'  
    AND stgl.Batch_ID = @Batch_ID   
    AND stgl.ImportStatus_ID = ', @StatusDefault, N' -- Default  
    AND NULLIF(ISNULL(stgl.', @CurrentViewColumn, N', viw.', @CurrentViewColumn, N'), @NULLText) IS NOT NULL -- null child values are always valid  
    AND filter.ID IS NULL -- could not find a match',   
CASE WHEN @CurrentFilterHierarchyM2MChildAttributeName IS NOT NULL THEN CONCAT(@TruncationGuard, N'  
    AND (NULLIF(ISNULL(stgl.', @CurrentFilterParentAttributeName, N', viw.', @CurrentViewColumn, N'), @NULLText) IS NOT NULL -- M2M level: not finding a filter row match is okay if the parent is null  
         OR EXISTS( SELECT 1                                                -- and the child is not under another parent  
                    FROM mdm.', @CurrentFilterHierarchyEntityViewName, N' filter  
                    WHERE   @Version_ID = filter.Version_ID    
                        AND ISNULL(stgl.', @CurrentViewColumn, N', viw.', @CurrentViewColumn, N') = filter.', COALESCE(@CurrentFilterHierarchyM2MChildAttributeName, N'Code'), N'  
                        AND filter.', @CurrentFilterHierarchyParentAttributeName, N' IS NOT NULL))  
      
    ') END,  
N'  
')              END)  
            END -- IF non-self-referencing DBA  
  
        END; -- IF DBA  
  
        IF @CurrentAttributeType_ID = @AttributeType_File  
        BEGIN  
            SET @SQLAttributeTypeErrorCheck += CONCAT(@TruncationGuard, N'  
IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Check for Error 200066- Binary Location 2^18: The file attribute cannot be saved'')  
--Error 200066 Binary Location 2^18: The file attribute cannot be saved  
--If the user tries to set any value in a file attribute when the Import type is  
--Merge Optimistic, Merge Overwrite or Insert, set the error code.  
UPDATE [stg].', @StagingLeafTable, N'  
SET ErrorCode = ErrorCode | 262144  
WHERE ImportStatus_ID = ', @StatusDefault, N' -- Default   
AND Batch_ID = @Batch_ID  
AND ImportType IN (', @IT_MergeOptimistic, N', ', @IT_MergeOverwrite, N', ', @IT_Insert, N')  
AND ', @CurrentViewColumn, N' IS NOT NULL  
');  
        END; -- IF  
        DELETE FROM @AttributeTable WHERE QUOTENAME(ViewColumn) = @CurrentViewColumn;  
  
    END; --WHILE  
  
    SET @SQL = CONCAT(@TruncationGuard, CONCAT(@TruncationGuard, -- using nested CONCAT since CONCAT can't have more than 254 args  
N'CREATE PROCEDURE [stg].', QUOTENAME(N'udp_' + @StagingBase + N'_Leaf'), N'  
@VersionName NVARCHAR(50), @LogFlag INT=0, @BatchTag NVARCHAR(50)=N'''', @Batch_ID INT=NULL, @UserName NVARCHAR(100) = NULL, @User_ID INT = 0, @Debug BIT = 0  
WITH EXECUTE AS ''mds_schema_user''  
AS  
BEGIN  
  
IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' [stg].', REPLACE(QUOTENAME(N'udp_' + @StagingBase + N'_Leaf'), N'''', N''''''),'  start'')  
  
SET NOCOUNT ON;  
DECLARE @Model_ID           INT,  
@Version_ID                 INT,  
@VersionStatus_ID           INT,  
@VersionStatus_Committed    INT = 3,  
@Entity_ID                  INT,  
@MemberCount                INT = 0,  
@ErrorCount                 INT = 0,  
@NewBatch_ID                INT = 0,  
@GetNewBatch_ID             INT = 0,  
@CurrentHierarchy_ID        INT,  
@Now                        DATETIME2,  
  
-- member type constant  
@LeafMemberTypeID           INT = 1,  
  
-- attribute type constants  
@FreeformTypeId             INT = 1,  
@DomainTypeId               INT = 2,  
@SystemTypeId               INT = 3,  
  
-- transaction type constants  
@StatusChangedId            INT = 2,  
@AttributeChangedId         INT = 3,  
  
-- error return code constants  
@UserIDError                INT = 1,  
@VersionNameError           INT = 3,  
@UserPermissionError        INT = 4,  
@VersionStatusError         INT = 5,  
@NoRecordToProcessError     INT = 6,  
@BatchIDAndBatchTagSpecifiedError   INT = 7,  
@BatchStatusError           INT = 8,  
@OtherRuntimeError          INT = 9,  
  
-- batch status constants  
@QueuedToRun                INT = 1,  
@NotRunning                 INT = 2,  
@Running                    INT = 3,  
@QueueToClear               INT = 4,  
@Cleared                    INT = 5,  
@AllExceptCleared           INT = 6,  
@Completed                  INT = 7,  
  
-- GetNewBatch_ID constants  
@BatchIDFound               INT = 0,  
@BatchIDNotFound            INT = 1,  
@BatchIDForBatchTagNotFound INT = 2,  
  
--Special attribute values that are used as aliases for NULL, to allow Merge Optimistic mode to change values to NULL..  
--When changing these values, also change them in the GetPostfixItemSql() method of \Core\BusinessLogic\BusinessRules\SqlGeneration\SqlGenerator.cs  
@NULLNumber                 DECIMAL(38,0) = -98765432101234567890,  
@NULLText                   NVARCHAR(10) = N''~NULL~'',  
@NULLDateTime               NVARCHAR(30) = N''5555-11-22T12:34:56'',  
  
--Validation status  
@NewAwaitingValidation      INT = 0,  
@AwaitingRevalidation       INT = 4,  
@AwaitingDependentMemberRevalidation  INT = 5,  
  
@DependentValidationStatus      INT,  
@DependentEntityTable           SYSNAME,  
@DependentAttributeColumnName   SYSNAME,  
  
--Code generation  
@AllowCodeGen               BIT = 0,  
@StartCode                  BIGINT,  
@EndCode                    BIGINT,  
@NumberOfCodes              INT,  
  
--Change Tracking Group  
@ChangedAttributeID         INT,  
@ChangedAttributeName       NVARCHAR(100),  
@ChagendAttributeColumnName NVARCHAR(50),  
@ChangeTrackingGroup        INT,  
@SQLCTG                     NVARCHAR(MAX),  
@ChangedAttributeType_ID    TINYINT,  
@ChangedAttributeDomainEntityTableName SYSNAME,  
@AttributeType_Domain       TINYINT = 2,  
  
--Transaction Log Types  
@MemberCreateTransaction        INT = 1,  
@MemberStatusSetTransaction     INT = 2,  
@MemberAttributeSetTransaction  INT = 3,  
@HierarchyParentSetTransaction  INT = 4,  
  
--XACT_STATE() constants  
@UncommittableTransaction   INT = -1;  
  
DECLARE @MandatoryHierarchy TABLE  
(  
    Hierarchy_ID INT  
);  
  
SET @Model_ID = ', @Model_ID, N'  
SET @Entity_ID = ', @Entity_ID, N'  
  
-- @UserName overwrites @User_ID  
IF @UserName IS NOT NULL  
BEGIN  
    SET @User_ID = mdm.udfUserIDGetByUserName(@UserName)  
    IF @User_ID IS NULL  
    BEGIN  
        RAISERROR(''MDSERR500041|The UserName is unknown.'', 16, 1);  
        RETURN @UserIDError;  
    END  
END  
  
-- Check for invalid Version Name.  
IF @VersionName IS NULL RETURN @VersionNameError;  
  
-- Set @AllowCodeGen (1: Code generation is allowed for the entity. 0: Code generation is not allowed for the entity)  
EXEC @AllowCodeGen = mdm.udpIsCodeGenEnabled @Entity_ID;  
  
IF LEN(@BatchTag) > 0 AND @Batch_ID IS NOT NULL BEGIN  
    RAISERROR(''MDSERR310043|The Batch Tag and the Batch ID cannot be specified at the same time.'', 16, 1);  
    RETURN @BatchIDAndBatchTagSpecifiedError;  
END; --IF  
  
SELECT @Version_ID = ID, @VersionStatus_ID = Status_ID FROM mdm.tblModelVersion WHERE Model_ID = @Model_ID AND [Name] = @VersionName;  
  
IF @Version_ID IS NULL BEGIN  
    RAISERROR(''MDSERR100036|The version name is not valid.'', 16, 1);  
    RETURN @VersionNameError;  
END; --IF  
  
--Ensure that Version is not committed  
IF (@VersionStatus_ID = @VersionStatus_Committed) BEGIN  
    RAISERROR(''MDSERR310040|Data cannot be loaded into a committed version.'', 16, 1);  
    RETURN @VersionStatusError;  
END;  
  
-- Verify the entity is not a sync target.  
IF EXISTS(  
    SELECT 1 FROM mdm.tblSyncRelationship   
    WHERE   TargetEntity_ID = @Entity_ID  
        AND TargetVersion_ID = @Version_ID)  
BEGIN  
    RAISERROR(''MDSERR200220|The entity member(s) cannot be saved. The entity version is the target of a sync relationship.'', 16, 1);  
    RETURN;  
END  
  
  
IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Check if there is any record to process.'')  
  
--Check if there is any record to process.  
IF LEN(@BatchTag) > 0 BEGIN  
    SELECT @MemberCount = COUNT(ID) FROM [stg].', @StagingLeafTable, N'  
        WHERE BatchTag = @BatchTag AND ImportStatus_ID = ', @StatusDefault, N' -- Default  
    IF @MemberCount = 0 BEGIN  
        RETURN @NoRecordToProcessError;  
    END; -- IF  
END; -- IF  
ELSE IF @Batch_ID IS NOT NULL BEGIN  
    SELECT @MemberCount = COUNT(ID) FROM [stg].', @StagingLeafTable, N'  
        WHERE Batch_ID = @Batch_ID AND ImportStatus_ID = ', @StatusDefault, N' -- Default  
    IF @MemberCount = 0 BEGIN  
        RETURN @NoRecordToProcessError;  
    END; -- IF  
END; -- IF  
  
IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' If neither @BatchTag nor @Batch_ID is specified assume that a blank @BatchTag is specified.'')  
-- If neither @BatchTag nor @Batch_ID is specified assume that a blank @BatchTag is specified.  
  
IF @Batch_ID IS NULL AND LEN(@BatchTag) = 0 BEGIN  
    SELECT @MemberCount = COUNT(ID) FROM [stg].', @StagingLeafTable, N'  
        WHERE (BatchTag IS NULL OR BatchTag = N'''') AND ImportStatus_ID = ', @StatusDefault, N' -- Default  
    IF @MemberCount = 0 BEGIN  
        RETURN @NoRecordToProcessError;  
    END; -- IF  
END; -- IF  
  
IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Check if there is any record with an invalid status.'')  
--Check if there is any record with an invalid status.  
IF LEN(@BatchTag) > 0 BEGIN  
    -- Determine if there is a running batch with the given batch tag.  
    DECLARE @IsBatchTagRunning BIT =  
        CASE WHEN EXISTS (SELECT 1  
                          FROM mdm.tblStgBatch  
                          WHERE  
                                LTRIM(RTRIM(BatchTag)) = @BatchTag  
                            AND Status_ID = @Running)  
        THEN 1 ELSE 0 END;  
  
    IF      @IsBatchTagRunning = 1  
        AND EXISTS (SELECT 1  
               FROM [stg].', @StagingLeafTable, N'  
               WHERE  
                     BatchTag = @BatchTag  
                 AND ImportStatus_ID = ', @StatusDefault, N' -- Default  
                 )  
    BEGIN  
        RAISERROR(''MDSERR310029|The status of the specified batch is not valid.'', 16, 1);  
        RETURN @BatchStatusError;  
    END; -- IF  
END; -- IF  
  
IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' IF @Batch_ID IS NOT NULL (check batch status).'')  
IF @Batch_ID IS NOT NULL BEGIN  
    DECLARE @BatchStatus_ID INT = (SELECT Status_ID FROM mdm.tblStgBatch WHERE ID = @Batch_ID);  
    IF @BatchStatus_ID IN (@Running, @QueueToClear, @Cleared)  
        AND EXISTS (  
            SELECT ID  
            FROM [stg].', @StagingLeafTable, N'  
            WHERE  
                    Batch_ID = @Batch_ID  
                AND ImportStatus_ID = ', @StatusDefault, N' -- Default  
                )  
    BEGIN  
        RAISERROR(''MDSERR310029|The status of the specified batch is not valid.'', 16, 1);  
        RETURN @BatchStatusError;  
    END; -- IF  
END; -- IF  
  
IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' IF @Batch_ID IS NOT NULL.'')  
IF @Batch_ID IS NOT NULL  BEGIN  
    IF NOT EXISTS (SELECT ID FROM mdm.tblStgBatch WHERE ID = @Batch_ID AND Status_ID NOT IN (@Running, @QueueToClear, @Cleared)  
                   AND Version_ID = @Version_ID AND Entity_ID = @Entity_ID AND MemberType_ID = 1) BEGIN  
        SET @GetNewBatch_ID = @BatchIDNotFound  
    END; --IF  
END; --IF  
ELSE BEGIN  
    -- Check if udpEntityStagingFlagForProcessing already assigned a new batch ID (in this case the status is QueuedToRun).  
    SELECT TOP 1 @Batch_ID = ID FROM mdm.tblStgBatch  
        WHERE BatchTag = @BatchTag AND Status_ID = @QueuedToRun  
        AND Version_ID = @Version_ID AND Entity_ID = @Entity_ID AND MemberType_ID = @LeafMemberTypeID ORDER BY ID DESC  
  
    IF @Batch_ID IS NULL BEGIN  
        SET @GetNewBatch_ID = @BatchIDForBatchTagNotFound  
    END; --IF  
    ELSE BEGIN  
        -- Set the member count  
        UPDATE mdm.tblStgBatch  
        SET TotalMemberCount = @MemberCount  
        WHERE BatchTag = @BatchTag AND Status_ID = @QueuedToRun  
            AND Version_ID = @Version_ID AND Entity_ID = @Entity_ID AND MemberType_ID = @LeafMemberTypeID  
    END; --IF  
END; --IF  
  
IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' IF @GetNewBatch_ID IN (@BatchIDNotFound, @BatchIDForBatchTagNotFound)'')  
IF @GetNewBatch_ID IN (@BatchIDNotFound, @BatchIDForBatchTagNotFound) BEGIN  
-- Create a new batch ID.  
    INSERT INTO mdm.tblStgBatch  
    (MUID  
    ,Version_ID  
    ,Status_ID  
    ,BatchTag  
    ,Entity_ID  
    ,MemberType_ID  
    ,TotalMemberCount  
    ,ErrorMemberCount  
    ,TotalMemberAttributeCount  
    ,ErrorMemberAttributeCount  
    ,TotalMemberRelationshipCount  
    ,ErrorMemberRelationshipCount  
    ,LastRunStartDTM  
    ,LastRunStartUserID  
    ,LastRunEndDTM  
    ,LastRunEndUserID  
    ,LastClearedDTM  
    ,LastClearedUserID  
    ,EnterDTM  
    ,EnterUserID)  
    SELECT  
        NEWID(),  
        @Version_ID,  
        @Running,  
        @BatchTag,  
        @Entity_ID,  
        1,  
        @MemberCount,  
        NULL,  
        NULL,  
        NULL,  
        NULL,  
        NULL,  
        GETUTCDATE(),  
        @User_ID,  
        NULL,  
        NULL,  
        NULL,  
        NULL,  
        GETUTCDATE(),  
        @User_ID  
  
    SELECT @NewBatch_ID = SCOPE_IDENTITY();  
  
    -- Update batch ID.  
    IF @GetNewBatch_ID = @BatchIDNotFound BEGIN  
        IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' @GetNewBatch_ID = @BatchIDNotFound'')  
        UPDATE [stg].', @StagingLeafTable, N'  
        SET Batch_ID = @NewBatch_ID  
        WHERE Batch_ID = @Batch_ID AND ImportStatus_ID = ', @StatusDefault, N' -- Default  
    END; --IF  
    ELSE BEGIN  
        IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' @GetNewBatch_ID <> @BatchIDNotFound'')  
        UPDATE [stg].', @StagingLeafTable, N'  
        SET Batch_ID = @NewBatch_ID  
        WHERE BatchTag = @BatchTag AND ImportStatus_ID = ', @StatusDefault, N' -- Default  
    END; --IF  
  
    SET @Batch_ID = @NewBatch_ID;  
END --IF  
ELSE BEGIN  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' The user specified a valid batch ID.'')  
    -- The user specified a valid batch ID.  
    -- Set the status of the batch as Running and set the total member count.  
    UPDATE mdm.tblStgBatch  
    SET Status_ID = @Running,  
        TotalMemberCount = @MemberCount,  
        LastRunStartDTM = GETUTCDATE(),  
        LastRunStartUserID = @User_ID  
    WHERE ID = @Batch_ID  
END; --IF  
  
IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Populate @UsedImportTypes'')  
DECLARE @UsedImportTypes TABLE  
(  
    ImportType TINYINT PRIMARY KEY  
)  
INSERT INTO @UsedImportTypes  
SELECT DISTINCT ImportType  
FROM [stg].', @StagingLeafTable, N'  
WHERE ImportStatus_ID = ', @StatusDefault, N' -- Default  
    AND Batch_ID = @Batch_ID;  
  
IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Check for Error 210001- Multiple Records for the same member record'')  
--Error Check all staged members  
--Error 210001 Binary Location 2^1: Multiple Records for the same member record  
UPDATE stgl  
SET ErrorCode = stgl.ErrorCode | 2  
FROM [stg].', @StagingLeafTable, N' stgl  
INNER JOIN [stg].', @StagingLeafTable, N' stgl2  
ON      stgl.Code = stgl2.Code  
    AND stgl.ID <> stgl2.ID  
    AND stgl.Batch_ID = stgl2.Batch_ID  
WHERE stgl.ImportStatus_ID = ', @StatusDefault, N' -- Default  
    AND stgl.Batch_ID = @Batch_ID;  
      
-- skip DBA and auto-gen Code check for Delete/Purge  
IF EXISTS(SELECT 1 FROM @UsedImportTypes WHERE ImportType IN (', @IT_Insert,N', ', @IT_MergeOverwrite, N', ', @IT_MergeOptimistic, N'))  
BEGIN  
  
',  
  
  
@SQLDBACheck, N'  
  
    IF (@AllowCodeGen = 0)  
    BEGIN  
        IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Check for Error 210035- Code generation is not allowed for the entity, Code is Mandatory'')  
        --Error 210035 Binary Location 2^5: Code generation is not allowed for the entity, Code is Mandatory  
        UPDATE [stg].', @StagingLeafTable, N'  
        SET ErrorCode = ErrorCode | 32  
        WHERE ISNULL(Code, N'''') = N'''' AND ImportStatus_ID = ', @StatusDefault, N' -- Default  
            AND Batch_ID = @Batch_ID;  
    END  
    ELSE  
    BEGIN  
        IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Check for Error 210035- Code generation is allowed for the entity and the Code is an empty string (NULL is allowed)'')  
        --Error 210035 Binary Location 2^5: Code generation is allowed for the entity and the Code is an empty string (NULL is allowed).  
        UPDATE [stg].', @StagingLeafTable, N'  
        SET ErrorCode = ErrorCode | 32  
        WHERE Code = N'''' AND ImportStatus_ID = ', @StatusDefault, N' -- Default  
            AND Batch_ID = @Batch_ID;  
  
    END; --IF  
END -- IF Insert/Merge  
  
  
IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Check for Error 210041- ROOT is not a valid MemberCode'')  
--Error 210041 Binary Location 2^6: ROOT is not a valid MemberCode  
UPDATE [stg].', @StagingLeafTable, N'  
SET ErrorCode = ErrorCode | 64  
WHERE UPPER(Code) = N''ROOT'' AND ImportStatus_ID = ', @StatusDefault, N' -- Default  
    AND Batch_ID = @Batch_ID;  
  
IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Check for Error 210042- MDMUnused is not a valid MemberCode'')  
--Error 210042 Binary Location 2^7: MDMUnused is not a valid MemberCode  
UPDATE [stg].', @StagingLeafTable, N'  
SET ErrorCode = ErrorCode | 128  
WHERE UPPER(Code) = N''MDMUNUSED'' AND ImportStatus_ID = ', @StatusDefault, N' -- Default  
    AND Batch_ID = @Batch_ID;',  
  @SQLAttributeTypeErrorCheck, N'  
  
IF EXISTS(SELECT 1 FROM @UsedImportTypes WHERE ImportType IN (', @IT_Delete, N', ', @IT_Purge, N', ', @IT_DeleteSetNullToRef, N', ', @IT_PurgeSetNullToRef, N'))  
BEGIN  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Populate a temp table of MemberCodes to be removed (soft-deleted or purged).'')  
    -- Populate a temp table of MemberCodes to be removed (soft-deleted or purged).  
    CREATE TABLE #MembersToRemove  
    (  
         Member_ID  INT  
        ,Staging_ID INT NOT NULL  
        ,MemberCode NVARCHAR(250) COLLATE DATABASE_DEFAULT  
        ,IsPurge    BIT NOT NULL -- 0 Delete, 1 Purge  
        ,SetToNull  BIT NOT NULL  
        ,IsActive   BIT NOT NULL  
    );  
    CREATE UNIQUE CLUSTERED INDEX #ix_MembersToRemove_IsPurge_Member_ID_IsActive ON #MembersToRemove(IsPurge, Member_ID, IsActive);  
    CREATE UNIQUE INDEX #ix_MembersToRemove_SetToNull_Member_ID ON #MembersToRemove(SetToNull, Member_ID);  
  
    INSERT INTO #MembersToRemove(Member_ID, Staging_ID, MemberCode, IsPurge, SetToNull, IsActive)  
    SELECT en.ID  
        , stgl.ID  
        , stgl.Code  
        , CASE WHEN stgl.ImportType IN (', @IT_Purge, N', ', @IT_PurgeSetNullToRef, N') THEN 1 ELSE 0 END -- IsPurge  
        , CASE WHEN stgl.ImportType IN (', @IT_DeleteSetNullToRef, N', ', @IT_PurgeSetNullToRef, N') THEN 1 ELSE 0 END -- SetToNull  
        , CASE WHEN en.Status_ID = ', @MemberStatus_Active, N'/*Active*/ THEN 1 ELSE 0 END -- IsActive  
    FROM [stg].', @StagingLeafTable, N' stgl  
    LEFT JOIN mdm.', @EntityTable, N' en  
    ON      en.Version_ID = @Version_ID  
        AND stgl.Code = en.Code  
    WHERE   stgl.ImportType IN (', @IT_Delete, N', ', @IT_Purge, N', ', @IT_DeleteSetNullToRef, N', ', @IT_PurgeSetNullToRef, N')  
        AND stgl.ImportStatus_ID = ', @StatusDefault, N'-- Default  
        AND stgl.Batch_ID = @Batch_ID;  
  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Populate @BadMemberCodes TABLE.'')  
    DECLARE @BadMemberCodes TABLE  
    (  
        Staging_ID INT PRIMARY KEY  
    )  
    DELETE #MembersToRemove  
    OUTPUT deleted.Staging_ID  
    INTO @BadMemberCodes  
    WHERE   Member_ID IS NULL  
        OR (    IsPurge = 0  -- Cannot delete an already deleted member  
            AND IsActive = 0)  
  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Check for Error 300002- The member code is not valid'')  
    --Error 300002 Binary Location 2^8: The member code is not valid  
    UPDATE stgl  
    SET ErrorCode = ErrorCode | 256  
    FROM [stg].', @StagingLeafTable, N' stgl  
    INNER JOIN @BadMemberCodes bmc  
    ON stgl.ID = bmc.Staging_ID  
END -- IF Delete or Purge  
  
IF EXISTS(SELECT 1 FROM @UsedImportTypes WHERE ImportType = ', @IT_Insert, N')  
BEGIN  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Check for Error 300003 (Insert)- The Member code already exists'')  
    --Error 300003 Binary Location 2^9: The Member code already exists  
    --Verify uniqueness of Code against the entity table  
    UPDATE sc  
    SET ErrorCode = ErrorCode | 512  
    FROM [stg].', @StagingLeafTable, N' sc  
    INNER JOIN mdm.', @EntityTable, N' AS tSource  
    ON sc.Code = tSource.Code  
    WHERE   tSource.Status_ID = ', @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/, N' -- Active  
        AND tSource.Version_ID = @Version_ID  
        AND sc.ImportType = ', @IT_Insert, N'  
        AND sc.ImportStatus_ID = ', @StatusDefault, N' -- Default  
        AND sc.Batch_ID = @Batch_ID;  
END -- IF Insert  
  
IF EXISTS(SELECT 1 FROM @UsedImportTypes WHERE ImportType IN (', @IT_MergeOptimistic, N', ', @IT_MergeOverwrite, N'))  
BEGIN  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Check for Error 300003 (MergeOptimistic, MergeOverwrite)- The Member code already exists'')  
    --Error 300003 Binary Location 2^9: The Member code already exists  
    --Verify uniqueness of the new code against the entity table  
    UPDATE sc  
    SET ErrorCode = ErrorCode | 512  
    FROM [stg].', @StagingLeafTable, N' sc  
    INNER JOIN mdm.', @EntityTable, N' AS tSource  
    ON sc.NewCode = tSource.Code  
    WHERE   tSource.Status_ID = ', @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/, N' -- Active  
        AND tSource.Version_ID = @Version_ID  
        AND sc.ImportType IN (', @IT_MergeOptimistic, N', ', @IT_MergeOverwrite, N')  
        AND sc.ImportStatus_ID = ', @StatusDefault, N' -- Default  
        AND sc.Batch_ID = @Batch_ID;  
END -- IF Merge  
  
IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Check for Error 210058- Invalid ImportType'')  
--Error 210058 Binary Location 2^10: Invalid ImportType  
UPDATE [stg].', @StagingLeafTable, N'  
SET ErrorCode = ErrorCode | 1024  
WHERE ImportType > ', @IT_Max, N' AND ImportStatus_ID = ', @StatusDefault, N' -- Default  
    AND Batch_ID = @Batch_ID;'  
  
) -- end nested CONCAT  
,  
  
CASE WHEN LEN(COALESCE(@HierarchyParentTable, N'')) > 0 THEN CONCAT(N'  
IF EXISTS(SELECT 1 FROM @UsedImportTypes WHERE ImportType IN (', @IT_Insert, N', ', @IT_MergeOptimistic, N', ', @IT_MergeOverwrite, N'))  
BEGIN  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Check for Error 300003 (HP table, Code)- The Member code already exists'')  
    --Error 300003 Binary Location 2^9: The Member code already exists  
    --Verify uniqueness of code against the parent table  
    UPDATE sc  
    SET ErrorCode = ErrorCode | 512  
    FROM [stg].', @StagingLeafTable, N' sc  
    INNER JOIN mdm.', @HierarchyParentTable, N' AS tSource  
    ON sc.Code = tSource.Code  
    WHERE   tSource.Status_ID = ', @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/, N' -- Active  
        AND tSource.Version_ID = @Version_ID  
        AND sc.ImportType IN (', @IT_Insert, N', ', @IT_MergeOptimistic, N', ', @IT_MergeOverwrite, N')  
        AND sc.ImportStatus_ID = ', @StatusDefault, N' -- Default  
        AND sc.Batch_ID = @Batch_ID;  
END -- IF Insert or Merge  
  
IF EXISTS(SELECT 1 FROM @UsedImportTypes WHERE ImportType IN (', @IT_MergeOptimistic, N', ', @IT_MergeOverwrite, N'))  
BEGIN  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Check for Error 300003 (HP table, NewCode)- The Member code already exists'')  
    --Error 300003 Binary Location 2^9: The Member code already exists  
    --Verify uniqueness of the new code against the parent table  
    UPDATE sc  
    SET ErrorCode = ErrorCode | 512  
    FROM [stg].', @StagingLeafTable, N' sc  
    INNER JOIN mdm.', @HierarchyParentTable, N' AS tSource  
    ON sc.NewCode = tSource.Code  
    WHERE   tSource.Status_ID = ', @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/, N' -- Active  
        AND tSource.Version_ID = @Version_ID  
        AND sc.ImportType IN (', @IT_MergeOptimistic, N', ', @IT_MergeOverwrite, N')  
        AND sc.ImportStatus_ID = ', @StatusDefault, N' -- Default  
        AND sc.Batch_ID = @Batch_ID;  
END -- IF Merge  
') END,  
  
CASE WHEN @IsCollectionEnabled = 1 THEN CONCAT(N'  
IF EXISTS(SELECT 1 FROM @UsedImportTypes WHERE ImportType IN (', @IT_Insert, N', ', @IT_MergeOptimistic, N', ', @IT_MergeOverwrite, N'))  
BEGIN  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Check for Error 300003 (CN table, Code)- The Member code already exists'')  
    --Error 300003 Binary Location 2^9: The Member code already exists  
    --Verify uniqueness of code against the collection table  
    UPDATE sc  
    SET ErrorCode = ErrorCode | 512  
    FROM [stg].', @StagingLeafTable, N' sc  
    INNER JOIN mdm.' + @CollectionTable + N' AS tSource  
    ON sc.Code = tSource.Code  
    WHERE   tSource.Status_ID = ', @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/, N' -- Active  
        AND tSource.Version_ID = @Version_ID  
        AND sc.ImportType IN (', @IT_Insert, N', ', @IT_MergeOptimistic, N', ', @IT_MergeOverwrite, N')  
        AND sc.ImportStatus_ID = ', @StatusDefault, N' -- Default  
        AND sc.Batch_ID = @Batch_ID;  
  
END -- IF Insert or Merge  
  
IF EXISTS(SELECT 1 FROM @UsedImportTypes WHERE ImportType IN (', @IT_MergeOptimistic, N', ', @IT_MergeOverwrite, N'))  
BEGIN  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Check for Error 300003 (CN table, NewCode)- The Member code already exists'')  
    --Error 300003 Binary Location 2^9: The Member code already exists  
    --Verify uniqueness of the new code against the collection table  
    UPDATE sc  
    SET ErrorCode = ErrorCode | 512  
    FROM [stg].', @StagingLeafTable, N' sc  
    INNER JOIN mdm.' + @CollectionTable + N' AS tSource  
    ON sc.NewCode = tSource.Code  
    WHERE   tSource.Status_ID = ', @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/, N' -- Active  
        AND tSource.Version_ID = @Version_ID  
        AND sc.ImportType IN (', @IT_MergeOptimistic, N', ', @IT_MergeOverwrite, N')  
        AND sc.ImportStatus_ID = ', @StatusDefault, N' -- Default  
        AND sc.Batch_ID = @Batch_ID;  
END -- IF Merge  
') END,  
  
-- Add errors for invalid self-referencing DBA values  
CASE WHEN LEN(@SQLSelfReferencingDBACheck_Initial) > 0 THEN CONCAT(N'  
  
IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Get a list of members with whose self-referencing DBA(s) reference invalid parent members.'')  
-- Get a list of members with whose self-referencing DBA(s) reference invalid parent members.  
DECLARE @Orphans TABLE  
(  
     ID INT PRIMARY KEY  
    ,ColumnName SYSNAME  
    ,ColumnValue NVARCHAR(250) COLLATE DATABASE_DEFAULT  
);  
DECLARE @PreviousIterationOrphans TABLE  
(  
    Code NVARCHAR(250) COLLATE DATABASE_DEFAULT PRIMARY KEY  
);  
DECLARE @NewOrphans TABLE  
(  
     ID INT PRIMARY KEY  
    ,Code NVARCHAR(250) COLLATE DATABASE_DEFAULT  
    ,ColumnName SYSNAME  
    ,ColumnValue NVARCHAR(250) COLLATE DATABASE_DEFAULT  
);  
INSERT INTO @NewOrphans(ID, Code, ColumnName, ColumnValue)  
', @SQLSelfReferencingDBACheck_Initial, N'  
  
-- Propagate the errors down to the orphans'' descendants  
WHILE EXISTS (SELECT 1 FROM @NewOrphans)  
BEGIN  
    INSERT INTO @Orphans(ID, ColumnName, ColumnValue)  
    SELECT ID, ColumnName, ColumnValue  
    FROM @NewOrphans;  
  
    DELETE FROM @PreviousIterationOrphans;  
    INSERT INTO @PreviousIterationOrphans(Code)  
    SELECT Code  
    FROM @NewOrphans;  
  
    DELETE FROM @NewOrphans;  
    INSERT INTO @NewOrphans  
', @SQLSelfReferencingDBACheck_Propagate, N'  
END;  
  
IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Check for Error 210003- The attribute value references a member that does not exist or is inactive.'')  
-- Error 210003 The attribute value references a member that does not exist or is inactive. Binary Location 2^2:  
MERGE stg.', @StagingLeafTable, N' stgl  
USING  
(  
    SELECT  
        ID  
       ,ColumnName  
       ,ColumnValue  
    FROM @Orphans  
) o  
ON o.ID = stgl.ID  
WHEN MATCHED THEN  
UPDATE  
    SET ErrorCode = COALESCE(ErrorCode, 0) | 4  
        OUTPUT inserted.Batch_ID, inserted.Code, o.ColumnName, o.ColumnValue, 210003  
        INTO mdm.tblStgErrorDetail (Batch_ID, Code, AttributeName, AttributeValue, UniqueErrorCode)  
;  
') END,   
  
    --Get the Attributes for the Entity (Leaf Attributes).  
CONCAT(@TruncationGuard, N'  
  
IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Set ImportStatus on all records with at least one error'')  
--Set ImportStatus on all records with at least one error  
UPDATE [stg].', @StagingLeafTable, N'  
SET ImportStatus_ID = ', @StatusError, N' -- Error  
WHERE ErrorCode > 0 AND ImportStatus_ID = ', @StatusDefault, N' -- Default  
    AND Batch_ID = @Batch_ID;  
  
IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Start transaction'')  
--Start transaction, being careful to check if we are nested  
DECLARE @TranCounter INT;  
SET @TranCounter = @@TRANCOUNT;  
IF @TranCounter > 0 SAVE TRANSACTION TX;  
ELSE BEGIN TRANSACTION;  
  
BEGIN TRY  
IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Get all the non-system attributes plus name and code attribute info for current entity'')  
-- get all the non-system attributes plus name and code attribute info for current entity  
-- We need track entity attribute change for 3 scenarios  
-- 0x1. The attribute has a tracking group  
-- 0x10. The attribute is self referencing DBA  
-- 0x100. The entity is a DBA, The attribute is used in BR changeValue by dependent entity  
DECLARE @TrackingAttributeInfo TABLE  
(  
    AttributeID         INT NOT NULL PRIMARY KEY,  
    AttributeName       NVARCHAR(100) COLLATE DATABASE_DEFAULT NOT NULL,  
    AttributeColumnName SYSNAME,  
    AttributeTypeID     TINYINT,  
    ChangeTrackingGroupID    INT,  
    TrackingType        TINYINT NOT NULL,  
    DomainEntityID      INT,  
    DomainEntityTableName SYSNAME NULL  
);  
  
INSERT INTO @TrackingAttributeInfo (  
    AttributeID,  
    AttributeName,  
    AttributeColumnName,  
    AttributeTypeID,  
    ChangeTrackingGroupID,  
    TrackingType,  
    DomainEntityID,  
    DomainEntityTableName  
)  
SELECT DISTINCT  
    attr.ID,  
    attr.Name,  
    attr.TableColumn,  
    attr.AttributeType_ID,  
    attr.ChangeTrackingGroup,  
    CASE WHEN attr.ChangeTrackingGroup <> 0 THEN 1 ELSE 0 END, --1. The attribute has a tracking group  
    attr.DomainEntity_ID,  
    ent.EntityTable  
FROM mdm.tblAttribute attr  
LEFT JOIN mdm.tblEntity ent ON ent.ID = attr.DomainEntity_ID  
WHERE  
    attr.Entity_ID = @Entity_ID AND  
    attr.MemberType_ID = @LeafMemberTypeID AND  
    (attr.IsSystem = 0 OR attr.IsCode = 1 OR attr.IsName = 1); -- Exclude system attributes other than Code and Name.  
  
--2. The attribute is self referencing DBA  
UPDATE a  
SET TrackingType = TrackingType | 2  
FROM @TrackingAttributeInfo a  
INNER JOIN mdm.tblDerivedHierarchyDetail d  
    ON a.DomainEntityID = @Entity_ID  
       AND a.AttributeID = d.Foreign_ID  
       AND d.ForeignParent_ID = @Entity_ID  
  
--3. The entity is a DBA, The attribute is used in BR changeValue by dependent entity  
UPDATE a  
SET TrackingType = TrackingType | 4  
FROM @TrackingAttributeInfo a  
INNER JOIN mdm.viw_SYSTEM_BUSINESSRULES_ATTRIBUTE_INHERITANCE_HIERARCHY i  
    ON i.ParentAttributeName = a.AttributeName AND i.ParentEntityID = @Entity_ID  
  
DELETE @TrackingAttributeInfo  
WHERE TrackingType = 0  
  
IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Store the changed attribute name and Member_ID for the changed row.'')  
--store the changed attribute name and Member_ID for the changed row  
--This must be temp tables vs. table variables because we need to reference it in dynamic SQL.  
CREATE TABLE #MemberAttributeWorkingSet (  
    MemberID                INT NOT NULL,  
    AttributeID             INT  NOT NULL  
);  
  
CREATE INDEX #ix_MemberAttributeWorkingSet_MemberID_AttributeID ON #MemberAttributeWorkingSet(MemberID, AttributeID);  
  
IF @AllowCodeGen = 1  
BEGIN  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Gather up the valid user provided codes.'')  
    --Gather up the valid user provided codes.  
    DECLARE @CodesToProcess mdm.MemberCodes;  
  
    INSERT @CodesToProcess (MemberCode)  
    SELECT Code FROM [stg].', @StagingLeafTable, N'  
    WHERE ErrorCode = 0 AND ImportStatus_ID = ', @StatusDefault, N' -- Default  
        AND Batch_ID = @Batch_ID AND Code IS NOT NULL;  
  
    INSERT @CodesToProcess (MemberCode)  
    SELECT NewCode FROM [stg].', @StagingLeafTable, N'  
    WHERE ErrorCode = 0 AND ImportStatus_ID = ', @StatusDefault, N' -- Default  
        AND Batch_ID = @Batch_ID AND NewCode IS NOT NULL;  
  
    --Process the user-provided codes to update the code gen info table with the largest one.  
    EXEC mdm.udpProcessCodes @Entity_ID, @CodesToProcess;  
  
    --If code generation is allowed populate new codes into the staging table.  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Generate the codes.'')  
    --Generate the codes.  
    SELECT @NumberOfCodes = COUNT(*) FROM [stg].', @StagingLeafTable, N'  
    WHERE ImportStatus_ID = ', @StatusDefault, N' -- Default  
        AND Batch_ID = @Batch_ID AND Code IS NULL;  
  
    EXEC mdm.udpGenerateCodeRange @Entity_ID = @Entity_ID, @NumberOfCodesToGenerate = @NumberOfCodes, @CodeRangeStart = @StartCode OUTPUT, @CodeRangeEnd = @EndCode OUTPUT;  
  
    DECLARE @CodeCounter BIGINT = @StartCode - 1;  
  
    --Set generated codes into the staging table.  
    UPDATE [stg].', @StagingLeafTable, N'  
    SET @CodeCounter += 1,  
        Code = CONVERT(NVARCHAR(25), @CodeCounter)  
    WHERE ImportStatus_ID = ', @StatusDefault, N' -- Default  
        AND Batch_ID = @Batch_ID AND Code IS NULL;  
  
END; -- IF  
  
IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Table for transaction log.'')  
--Table for transaction log  
CREATE TABLE #TRANLOG  
(  
     MemberID    INT  
    ,MemberMUID  UNIQUEIDENTIFIER  
    ,Code       NVARCHAR(250) COLLATE DATABASE_DEFAULT  
    ,New_Code    NVARCHAR(250) COLLATE DATABASE_DEFAULT  
    ,Name       NVARCHAR(250) COLLATE DATABASE_DEFAULT NULL  
    ,New_Name    NVARCHAR(250) COLLATE DATABASE_DEFAULT NULL  
', @TranOldColumn, @TranNewColumn, N'  
);', CASE WHEN LEN(@SQLSelfReferencingDBACheck_Initial) > 0 THEN N'  
-- The entity has at least one self-referencing DBA, so add an index on the Code column to speed up looking up new member DBA values.  
CREATE INDEX #ix_TRANLOG_Code ON #TRANLOG(Code)  
' END, N'  
  
IF EXISTS(SELECT 1 FROM @UsedImportTypes WHERE ImportType IN (', @IT_MergeOptimistic, N', ', @IT_Insert, N', ', @IT_MergeOverwrite, N'))  
BEGIN  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Set ImportStatus_ID to Processing for new members.'')  
    --Process Insert all new error free records into MDS internal table.  
    UPDATE stgl  
    SET ImportStatus_ID = ', @StatusProcessing, N' -- Processing  
    FROM [stg].', @StagingLeafTable, N' stgl  
    LEFT JOIN  mdm.', @EntityTable, N' en  
    ON      stgl.Code = en.Code  
        AND en.Status_ID = ', @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/, N' -- Active  
        AND en.Version_ID = @Version_ID  
    WHERE stgl.Batch_ID = @Batch_ID  
        AND stgl.ImportType IN (', @IT_MergeOptimistic, N', ', @IT_Insert, N', ', @IT_MergeOverwrite, N')  
        AND stgl.ImportStatus_ID = ', @StatusDefault, N' -- Default  
        AND en.Code IS NULL;  
  
    IF @LogFlag != 1  
    BEGIN  
        IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Insert into EN table (@LogFlag != 1).'')  
  
        INSERT INTO mdm.', @EntityTable, N'  
        (  
            Version_ID,  
            Status_ID,  
            ValidationStatus_ID,  
            Name,  
            Code,  
            EnterDTM,  
            EnterUserID,  
            EnterVersionID,  
            LastChgDTM,  
            LastChgUserID,  
            LastChgVersionID', @SQLNonDBAColumns, @SQLDBAColumns, N'  
        ) ', CASE WHEN LEN(@SQLSelfReferencingDBACheck_Initial) > 0 THEN N'  
            -- Need to capture new member IDs for updating self-referencing DBAs  
            OUTPUT inserted.ID, inserted.Code  
                INTO #TRANLOG(MemberID, Code)  
        ' END, N'  
        SELECT  
            @Version_ID,  
            1,  
            @NewAwaitingValidation,  
            stgl.Name,  
            stgl.Code,  
            GETUTCDATE(),  
            @User_ID,  
            @Version_ID,  
            GETUTCDATE(),  
            @User_ID,  
            @Version_ID',  
                CASE  
                    WHEN LEN(COALESCE(@SQLNonDBA, N'') + COALESCE(@SQLDBA, N'')) = 0 THEN N''  
                    WHEN LEN(COALESCE(@SQLNonDBA, N'')) > 0 AND LEN(COALESCE(@SQLDBA, N'')) > 0 THEN CONCAT(N',', @SQLNonDBA, N',',@SQLDBA)  
                    ELSE CONCAT(N',',@SQLNonDBA, @SQLDBA)  
                END, N'  
        FROM [stg].', @StagingLeafTable, N' stgl ', @SQLDBAJoin, N'  
        WHERE stgl.ImportStatus_ID = ', @StatusProcessing, N' -- Processing   
            AND stgl.Batch_ID = @Batch_ID;  
        ', CASE WHEN LEN(@SQLSelfReferencingDBACheck_Initial) > 0 THEN CONCAT(N'  
        -- Update the values of self-referencing DBA(s) with the IDs of newly created members  
        ', @SQLSelfReferencingDBAUpdate) END, N'  
        END  
    ELSE  
    BEGIN  
        IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Insert into EN table (@LogFlag = 1).'')  
        INSERT INTO mdm.', @EntityTable, N'  
        (  
            Version_ID,  
            Status_ID,  
            ValidationStatus_ID,  
            Name,  
            Code,  
            EnterDTM,  
            EnterUserID,  
            EnterVersionID,  
            LastChgDTM,  
            LastChgUserID,  
            LastChgVersionID', @SQLNonDBAColumns, @SQLDBAColumns, N'  
        )  
        ', CASE @TransactionLogType  
                WHEN @TransactionLogType_Attribute THEN CONCAT(N'  
        OUTPUT inserted.ID, inserted.MUID, inserted.Code, inserted.Code, inserted.Name, inserted.Name ', @TranBlankColumn, @TranInsertedColumn, N'  
            INTO #TRANLOG')  
                ELSE N'  
        -- Need to capture new member IDs for updating self-referencing DBAs  
        OUTPUT inserted.ID, inserted.Code  
            INTO #TRANLOG(MemberID, Code)'  
            END, N'  
        SELECT  
            @Version_ID,  
            1,  
            @NewAwaitingValidation,  
            stgl.Name,  
            stgl.Code,  
            GETUTCDATE(),  
            @User_ID,  
            @Version_ID,  
            GETUTCDATE(),  
            @User_ID,  
            @Version_ID',  
                CASE  
                    WHEN LEN(COALESCE(@SQLNonDBA, N'') + COALESCE(@SQLDBA, N'')) = 0 THEN N''  
                    WHEN LEN(COALESCE(@SQLNonDBA, N'')) > 0 AND LEN(COALESCE(@SQLDBA, N'')) > 0 THEN CONCAT(N',',@SQLNonDBA, N',', @SQLDBA)  
                    ELSE CONCAT(N',', @SQLNonDBA, @SQLDBA)  
                END, N'  
        FROM [stg].', @StagingLeafTable, N' stgl ', @SQLDBAJoin, N'  
        WHERE stgl.ImportStatus_ID = ', @StatusProcessing, N' -- Processing   
            AND stgl.Batch_ID = @Batch_ID;  
    ', CASE WHEN LEN(@SQLSelfReferencingDBACheck_Initial) > 0 THEN CONCAT(N'  
        -- Update the values of self-referencing DBA(s) with the IDs of newly created members  
    ', @SQLSelfReferencingDBAUpdate) END, N'  
    END; --IF  
'  
)-- end nested CONCAT  
,  
  
CASE WHEN @IsHierarchyEnabled = 1 THEN CONCAT(@TruncationGuard, N'  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Add HR records for each mandatory hierarchy.'')  
    -- After the insertion add HR records for each mandatory hierarchies  
  
    INSERT INTO @MandatoryHierarchy  
    SELECT DISTINCT ID AS Hierarchy_ID FROM mdm.tblHierarchy WHERE Entity_ID = ', @Entity_ID, N' AND IsMandatory = 1  
  
    WHILE EXISTS(SELECT 1 FROM @MandatoryHierarchy) BEGIN  
  
        SELECT TOP 1  
            @CurrentHierarchy_ID = Hierarchy_ID  
        FROM @MandatoryHierarchy;  
  
        -- Add the member to the root of the hierarchy.  
        INSERT INTO mdm.', @HierarchyRelationshipTable, N'  
        (  
            [Version_ID]  
            ,[Status_ID]  
            ,[ValidationStatus_ID]  
            ,[Hierarchy_ID]  
            ,[Parent_HP_ID]  
            ,[ChildType_ID]  
            ,[Child_EN_ID]  
            ,[Child_HP_ID]  
            ,[SortOrder]  
            ,[LevelNumber]  
            ,[EnterDTM]  
            ,[EnterUserID]  
            ,[EnterVersionID]  
            ,[LastChgDTM]  
            ,[LastChgUserID]  
            ,[LastChgVersionID]  
        )  
        SELECT  
        @Version_ID,  
        1,  
        @NewAwaitingValidation,  
        @CurrentHierarchy_ID,  
        NULL,  
        1,  
        en.ID,  
        NULL,  
        0,  
        0,  
        GETUTCDATE(),  
        @User_ID,  
        @Version_ID,  
        GETUTCDATE(),  
        @User_ID,  
        @Version_ID  
        FROM [stg].', @StagingLeafTable, N' stgl  
        INNER JOIN mdm.', @EntityTable, N' en  
        ON      stgl.Code = en.Code  
            AND en.Status_ID = ', @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/, N' -- Active  
            AND en.Version_ID = @Version_ID  
        WHERE stgl.ImportStatus_ID = ', @StatusProcessing, N' -- Processing   
            AND stgl.Batch_ID = @Batch_ID;  
',  
    CASE WHEN @TransactionLogType = @TransactionLogType_Attribute THEN CONCAT(@TruncationGuard, N'  
        IF @LogFlag = 1  
        BEGIN  
            -- Record addition of the members to the ROOT node of the hierarchy.  
            -- OldCode and NewCode are set to ROOT (this is the same as the existing transaction log).  
            INSERT INTO [mdm].', QUOTENAME(@TransactionTableName), N'  
            (  
                Version_ID,  
                TransactionType_ID,  
                OriginalTransaction_ID,  
                Hierarchy_ID,  
                Entity_ID,  
                Member_ID,  
                Member_MUID,  
                MemberType_ID,  
                MemberCode,  
                OldValue,  
                OldCode,  
                NewValue,  
                NewCode,  
                Batch_ID,  
                EnterDTM,  
                EnterUserID,  
                LastChgDTM,  
                LastChgUserID  
            )  
            SELECT  
                @Version_ID, --Version_ID  
                @HierarchyParentSetTransaction, --TransactionType_ID  
                0, --OriginalTransaction_ID  
                @CurrentHierarchy_ID, --Hierarchy_ID  
                @Entity_ID, --Entity_ID  
                en.ID, --Member_ID  
                en.MUID, --Member_MUID  
                @LeafMemberTypeID, --MemberType_ID  
                stgl.Code,  
                N''0'', --OldValue  
                N''ROOT'', --OldCode  
                N''0'', --NewValue  
                N''ROOT'', --NewCode  
                @Batch_ID,  
                GETUTCDATE(),  
                @User_ID,  
                GETUTCDATE(),  
                @User_ID  
            FROM mdm.', @EntityTable, N' en  
            INNER JOIN [stg].', @StagingLeafTable, N' stgl  
            ON      en.Code = stgl.Code  
                AND en.Status_ID = ', @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/, N' -- Active  
                AND en.Version_ID = @Version_ID  
                AND stgl.ImportStatus_ID = ', @StatusProcessing, N' -- Processing  
                AND stgl.Batch_ID = @Batch_ID  
        END;') END,   
  
N'  
        DELETE FROM @MandatoryHierarchy WHERE Hierarchy_ID = @CurrentHierarchy_ID  
    END; -- WHILE  
') END,   
  
N'  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' SELECT TOP 1 @ChangedAttributeID = AttributeID.'')  
    SELECT TOP 1 @ChangedAttributeID = AttributeID, @ChangedAttributeName = AttributeName  
    FROM @TrackingAttributeInfo  
    ORDER BY AttributeID  
  
    WHILE @@ROWCOUNT > 0  
    BEGIN  
        -- All new insert entity will be in tracking working set  
        SET @SQLCTG = N''  
        INSERT INTO #MemberAttributeWorkingSet  
        SELECT DISTINCT en.ID, '' + CAST (@ChangedAttributeID AS NVARCHAR(10)) + N''  
        FROM [stg].', @StagingLeafTableWithEscapedQuotes, -- This is being used in a nested dynamic SQL statement, so any single quotes within the table name must be escaped out  
                                                                N' stgl  
        INNER JOIN [mdm].', @EntityTable, N' en  
        ON      en.Code = stgl.Code  
            AND en.Status_ID = ', @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/, N' -- Active  
            AND en.Version_ID = @Version_ID  
        WHERE stgl.ImportStatus_ID = ', @StatusProcessing, N'-- Processing  
            AND stgl.Batch_ID = @Batch_ID  
            AND stgl.'' + QUOTENAME(@ChangedAttributeName) + N'' IS NOT NULL; '';  
  
        EXEC sp_executesql @SQLCTG, N''@Batch_ID INT, @Version_ID INT'', @Batch_ID, @Version_ID;  
  
      SELECT TOP 1 @ChangedAttributeID = AttributeID, @ChangedAttributeName = AttributeName  
      FROM @TrackingAttributeInfo  
      WHERE AttributeID > @ChangedAttributeID  
      ORDER BY AttributeID  
    END  
',  
  
CASE WHEN @TransactionLogType = @TransactionLogType_Attribute THEN CONCAT(@TruncationGuard, N'  
    IF @LogFlag = 1  
    BEGIN  
        IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Insert into TransactionTble (@LogFlag = 1)'')  
        --Log member creation transactions.  
        --In this case OldValue, OldCode, NewValue, and NewCode are blank.  
        INSERT INTO [mdm].', QUOTENAME(@TransactionTableName), N'  
        (  
            Version_ID,  
            TransactionType_ID,  
            OriginalTransaction_ID,  
            Hierarchy_ID,  
            Entity_ID,  
            Member_ID,  
            Member_MUID,  
            MemberType_ID,  
            MemberCode,  
            OldValue,  
            OldCode,  
            NewValue,  
            NewCode,  
            Batch_ID,  
            EnterDTM,  
            EnterUserID,  
            LastChgDTM,  
            LastChgUserID  
        )  
        SELECT  
            @Version_ID, --Version_ID  
            @MemberCreateTransaction, --TransactionType_ID  
            0, --OriginalTransaction_ID  
            NULL, --Hierarchy_ID  
            @Entity_ID, --Entity_ID  
            en.ID, --Member_ID  
            en.MUID, --Member_MUID  
            @LeafMemberTypeID, --MemberType_ID  
            stgl.Code,  
            N'''', --OldValue  
            N'''', --OldCode  
            N'''', --NewValue  
            N'''', --NewCode  
            @Batch_ID,  
            GETUTCDATE(),  
            @User_ID,  
            GETUTCDATE(),  
            @User_ID  
        FROM mdm.', @EntityTable, N' en  
        INNER JOIN [stg].', @StagingLeafTable, N' stgl  
        ON      en.Code = stgl.Code  
            AND en.Status_ID = ', @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/, N' -- Active  
            AND en.Version_ID = @Version_ID  
            AND stgl.ImportStatus_ID = ', @StatusProcessing, N' -- Processing  
            AND stgl.Batch_ID = @Batch_ID  
    END;') END,   
  
N'  
    -- Inserting records is done. Updated the status.  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Inserting records is done. Updated the status'')  
  
    UPDATE [stg].', @StagingLeafTable, N'  
    SET ImportStatus_ID = ', @StatusOK, N' -- OK  
    WHERE ImportStatus_ID = ', @StatusProcessing, N' -- Processing   
        AND Batch_ID = @Batch_ID;  
END; -- Insert or Merge  
  
IF EXISTS(SELECT 1 FROM @UsedImportTypes WHERE ImportType IN (', @IT_MergeOptimistic, N', ', @IT_MergeOverwrite, N'))  
BEGIN  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Set status to process updates.'')  
    -- Set status to process updates.  
    UPDATE stgl  
    SET ImportStatus_ID = ', @StatusProcessing, N' -- Processing  
    FROM [stg].', @StagingLeafTable, N' stgl  
    INNER JOIN mdm.', @EntityTable, N' en  
    ON      stgl.Code = en.Code  
        AND en.Status_ID = ', @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/, N' -- Active  
        AND en.Version_ID = @Version_ID  
    WHERE   stgl.ImportType in (', @IT_MergeOptimistic, N', ', @IT_MergeOverwrite, N')  
        AND stgl.ImportStatus_ID = ', @StatusDefault, N' -- Default  
        AND stgl.Batch_ID = @Batch_ID;  
  
    --Process Updates  
  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Tracking updates.'')  
    -- Tracking updates  
    SELECT TOP 1 @ChangedAttributeID = AttributeID, @ChangedAttributeName = AttributeName, @ChagendAttributeColumnName = AttributeColumnName,  
                 @ChangedAttributeType_ID = AttributeTypeID, @ChangedAttributeDomainEntityTableName = DomainEntityTableName  
    FROM @TrackingAttributeInfo  
    ORDER BY AttributeID  
  
    WHILE @@ROWCOUNT > 0  
    BEGIN  
        IF @ChangedAttributeType_ID = @AttributeType_Domain  
        BEGIN  
            -- Update change tracking mask for merge optimistic.  
            SET @SQLCTG = N''  
            INSERT INTO #MemberAttributeWorkingSet  
            SELECT DISTINCT  
                en.ID,  
                '' + CAST (@ChangedAttributeID AS NVARCHAR(10)) + N''  
            FROM mdm.', @EntityTable, N' en  
            INNER JOIN [stg].', @StagingLeafTableWithEscapedQuotes, -- This is being used in a nested dynamic SQL statement, so any single quotes within the table name must be escaped out  
                                                                        N' stgl  
            ON      en.Code = stgl.Code  
                AND en.Status_ID = ', @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/, N' -- Active  
                AND en.Version_ID = @Version_ID  
                AND stgl.ImportStatus_ID = ', @StatusProcessing, N'-- Processing  
                AND stgl.Batch_ID = @Batch_ID  
                AND stgl.ImportType = ', @IT_MergeOptimistic, N'  
                AND stgl.'' + QUOTENAME(@ChangedAttributeName) + N'' IS NOT NULL  
            LEFT JOIN [mdm].'' + QUOTENAME(@ChangedAttributeDomainEntityTableName) + N'' domain ON domain.Code = stgl.'' + QUOTENAME(@ChangedAttributeName) + N''  
                AND domain.Status_ID = ', @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/, N' -- Active  
                AND domain.Version_ID = @Version_ID  
            WHERE  
                ISNULL(NULLIF(domain.ID, en.'' + QUOTENAME(@ChagendAttributeColumnName) + N''), NULLIF(en.'' + QUOTENAME(@ChagendAttributeColumnName) + N'', domain.ID)) IS NOT NULL;  
                '';  
  
            EXEC sp_executesql @SQLCTG, N''@Version_ID INT, @Batch_ID INT'', @Version_ID, @Batch_ID;  
  
            -- Update change tracking mask for merge overwrite.  
            SET @SQLCTG = N''  
            INSERT INTO #MemberAttributeWorkingSet  
            SELECT DISTINCT  
                en.ID,  
                '' + CAST (@ChangedAttributeID AS NVARCHAR(10)) + N''  
            FROM mdm.', @EntityTable, N' en  
            INNER JOIN [stg].', @StagingLeafTableWithEscapedQuotes, -- This is being used in a nested dynamic SQL statement, so any single quotes within the table name must be escaped out  
                                                                        N' stgl  
            ON      en.Code = stgl.Code  
                AND en.Status_ID = ', @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/, N' -- Active  
                AND en.Version_ID = @Version_ID  
                AND stgl.ImportStatus_ID = ', @StatusProcessing, N'-- Processing  
                AND stgl.Batch_ID = @Batch_ID  
                AND stgl.ImportType = ', @IT_MergeOverwrite, N'  
            LEFT JOIN [mdm].'' + QUOTENAME(@ChangedAttributeDomainEntityTableName) + N'' domain ON domain.Code = stgl.'' + QUOTENAME(@ChangedAttributeName) + N''  
                AND domain.Status_ID = ', @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/, N' -- Active  
                AND domain.Version_ID = @Version_ID  
            WHERE  
                ISNULL(NULLIF(domain.ID, en.'' + QUOTENAME(@ChagendAttributeColumnName) + N''), NULLIF(en.'' + QUOTENAME(@ChagendAttributeColumnName) + N'', domain.ID)) IS NOT NULL;  
                    '';  
  
            EXEC sp_executesql @SQLCTG, N''@Version_ID INT, @Batch_ID INT'', @Version_ID, @Batch_ID;  
        END  
        ELSE  
        BEGIN  
            -- Update change tracking mask for merge optimistic.  
            SET @SQLCTG = N''  
            INSERT INTO #MemberAttributeWorkingSet  
            SELECT DISTINCT  
                en.ID,  
                '' + CAST (@ChangedAttributeID AS NVARCHAR(10)) + N''  
            FROM mdm.', @EntityTable, N' en  
            INNER JOIN [stg].', @StagingLeafTableWithEscapedQuotes, -- This is being used in a nested dynamic SQL statement, so any single quotes within the table name must be escaped out  
                                                                        N' stgl  
            ON      en.Code = stgl.Code  
                AND en.Status_ID = ', @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/, N' -- Active  
                AND en.Version_ID = @Version_ID  
                AND stgl.ImportStatus_ID = ', @StatusProcessing, N'-- Processing  
                AND stgl.Batch_ID = @Batch_ID  
                AND stgl.ImportType = ', @IT_MergeOptimistic, N'  
                AND stgl.'' + QUOTENAME(@ChangedAttributeName) + N'' IS NOT NULL  
                AND ISNULL(NULLIF(stgl.'' + QUOTENAME(@ChangedAttributeName) + N'', en.'' + QUOTENAME(@ChagendAttributeColumnName) + N''), NULLIF(en.'' + QUOTENAME(@ChagendAttributeColumnName) + N'', stgl.'' + QUOTENAME(@ChangedAttributeName) + N'')) IS NOT NULL;  
                '';  
  
            EXEC sp_executesql @SQLCTG, N''@Version_ID INT, @Batch_ID INT'', @Version_ID, @Batch_ID;  
  
            -- Update change tracking mask for merge overwrite.  
            SET @SQLCTG = N''  
            INSERT INTO #MemberAttributeWorkingSet  
            SELECT DISTINCT  
                en.ID,  
                '' + CAST (@ChangedAttributeID AS NVARCHAR(10)) + N''  
            FROM mdm.', @EntityTable, N' en  
            INNER JOIN [stg].', @StagingLeafTableWithEscapedQuotes, -- This is being used in a nested dynamic SQL statement, so any single quotes within the table name must be escaped out  
                                                                        N' stgl  
            ON      en.Code = stgl.Code  
                AND en.Status_ID = ', @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/, N' -- Active  
                AND en.Version_ID = @Version_ID  
                AND stgl.ImportStatus_ID = ', @StatusProcessing, N'-- Processing  
                AND stgl.Batch_ID = @Batch_ID  
                AND stgl.ImportType = ', @IT_MergeOverwrite, N'  
                AND ISNULL(NULLIF(stgl.'' + QUOTENAME(@ChangedAttributeName) + N'', en.'' + QUOTENAME(@ChagendAttributeColumnName) + N''), NULLIF(en.'' + QUOTENAME(@ChagendAttributeColumnName) + N'', stgl.'' + QUOTENAME(@ChangedAttributeName) + N'')) IS NOT NULL;  
                '';  
  
            EXEC sp_executesql @SQLCTG, N''@Version_ID INT, @Batch_ID INT'', @Version_ID, @Batch_ID;  
        END  
  
        SELECT TOP 1 @ChangedAttributeID = AttributeID, @ChangedAttributeName = AttributeName, @ChagendAttributeColumnName = AttributeColumnName,  
                     @ChangedAttributeType_ID = AttributeTypeID, @ChangedAttributeDomainEntityTableName = DomainEntityTableName  
        FROM @TrackingAttributeInfo  
        WHERE AttributeID > @ChangedAttributeID  
        ORDER BY AttributeID  
    END; -- WHILE  
  
    IF EXISTS(SELECT 1 FROM @UsedImportTypes WHERE ImportType = ', @IT_MergeOptimistic, N')  
    BEGIN  
        --Process update (Merge Optimistic)  
        SET @Now = GETUTCDATE();  
        IF @LogFlag != 1  
        BEGIN  
        IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Process update (Merge Optimistic, @LogFlag != 1).'')  
            UPDATE en  
            SET Code = CASE WHEN stgl.[NewCode] IS NULL THEN en.[Code] ELSE stgl.[NewCode] END  
                ,ValidationStatus_ID = @AwaitingRevalidation  
                ,LastChgDTM = @Now  
                ,LastChgUserID = @User_ID  
                ,LastChgVersionID = @Version_ID  
                ,[Name] = CASE  
                            WHEN stgl.[Name] = @NULLText THEN NULL  
                            WHEN stgl.[Name] IS NULL THEN en.[Name]  
                            ELSE stgl.[Name]   
                          END  
                ', @SQLMergeOptimisticDBA, N'  
                ', @SQLMergeOptimisticNonDBA, N'  
            FROM mdm.', @EntityTable, N' en  
            INNER JOIN [stg].', @StagingLeafTable, N' stgl  
            ON      en.Code = stgl.Code  
                AND en.Status_ID = ', @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/, N' -- Active  
                AND en.Version_ID = @Version_ID  
            ', @SQLDBAJoin, N'  
            WHERE stgl.ImportType = ', @IT_MergeOptimistic, N'  
                AND stgl.ImportStatus_ID = ', @StatusProcessing, N'-- Processing  
                AND stgl.Batch_ID = @Batch_ID;  
        END  
        ELSE  
        BEGIN  
        IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Insert update information into _HS table (@LogFlag = 1).'')  
            -- Insert update information into _HS table.  
            UPDATE en  
            SET Code = CASE WHEN stgl.[NewCode] IS NULL THEN en.[Code] ELSE stgl.[NewCode] END  
                ,ValidationStatus_ID = @AwaitingRevalidation  
                ,LastChgDTM = @Now  
                ,LastChgUserID = @User_ID  
                ,LastChgVersionID = @Version_ID  
                ,[Name] = CASE  
                            WHEN stgl.[Name] = @NULLText THEN NULL  
                            WHEN stgl.[Name] IS NULL THEN en.[Name]  
                            ELSE stgl.[Name]   
                          END  
                ', @SQLMergeOptimisticDBA, N'  
                ', @SQLMergeOptimisticNonDBA,   
                CASE @TransactionLogType  
                    WHEN @TransactionLogType_Member THEN @ENHistoryOutputQuery  
                    WHEN @TransactionLogType_Attribute THEN CONCAT(N'  
                OUTPUT inserted.ID, inserted.MUID, deleted.Code, inserted.Code, deleted.Name, inserted.Name ', @TranDeletedColumn, @TranInsertedColumn, N'  
                INTO #TRANLOG')  
                    ELSE N''  
                END, N'  
            FROM mdm.', @EntityTable, N' en  
            INNER JOIN [stg].', @StagingLeafTable, N' stgl  
            ON      en.Code = stgl.Code  
                AND en.Status_ID = ', @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/, N' -- Active  
                AND en.Version_ID = @Version_ID  
            ', @SQLDBAJoin, N'  
            WHERE stgl.ImportType = ', @IT_MergeOptimistic, N'  
                AND stgl.ImportStatus_ID = ', @StatusProcessing, N'-- Processing  
                AND stgl.Batch_ID = @Batch_ID;  
        END; --IF  
    END; -- IF MergeOptimistic  
  
    IF EXISTS(SELECT 1 FROM @UsedImportTypes WHERE ImportType = ', @IT_MergeOverwrite, N')  
    BEGIN  
         --Process update (Merge Overwrite)  
        SET @Now = GETUTCDATE();  
        IF @LogFlag != 1  
        BEGIN  
            IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Process update (Merge Overwrite, @LogFlag != 1).'')  
            UPDATE en  
            SET Code = CASE WHEN stgl.[NewCode] IS NULL THEN en.[Code] ELSE stgl.[NewCode] END  
                ,ValidationStatus_ID = @AwaitingRevalidation  
                ,LastChgDTM = @Now  
                ,LastChgUserID = @User_ID  
                ,LastChgVersionID = @Version_ID  
                ,Name = NULLIF(stgl.[Name], @NULLText)  
                ', @SQLMergeOverwriteDBA, N'  
                ', @SQLMergeOverwriteNonDBA, N'  
            FROM mdm.', @EntityTable, N' en  
            INNER JOIN [stg].', @StagingLeafTable, N' stgl  
            ON      en.Code = stgl.Code  
                AND en.Status_ID = ', @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/, N' -- Active  
                AND en.Version_ID = @Version_ID  
            ', @SQLDBAJoin, N'  
            WHERE stgl.ImportType = ', @IT_MergeOverwrite, N'  
                AND stgl.ImportStatus_ID = ', @StatusProcessing, N'-- Processing  
                AND stgl.Batch_ID = @Batch_ID;  
        END  
        ELSE  
        BEGIN  
            IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Insert update information into _HS table (@LogFlag = 1).'')  
            -- Insert update information into _HS table.  
            UPDATE en  
            SET Code = CASE WHEN stgl.[NewCode] IS NULL THEN en.[Code] ELSE stgl.[NewCode] END  
                ,ValidationStatus_ID = @AwaitingRevalidation  
                ,LastChgDTM = @Now  
                ,LastChgUserID = @User_ID  
                ,LastChgVersionID = @Version_ID  
                ,Name = NULLIF(stgl.[Name], @NULLText)  
                ', @SQLMergeOverwriteDBA, N'  
                ', @SQLMergeOverwriteNonDBA,   
                CASE @TransactionLogType  
                    WHEN @TransactionLogType_Member THEN @ENHistoryOutputQuery  
                    WHEN @TransactionLogType_Attribute THEN CONCAT(N'  
                OUTPUT inserted.ID, inserted.MUID, deleted.Code, inserted.Code, deleted.Name, inserted.Name ', @TranDeletedColumn, @TranInsertedColumn, N'  
                INTO #TRANLOG')  
                END, N'  
            FROM mdm.', @EntityTable, N' en  
            INNER JOIN [stg].', @StagingLeafTable, N' stgl  
            ON      en.Code = stgl.Code  
                AND en.Status_ID = ', @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/, N' -- Active  
                AND en.Version_ID = @Version_ID  
            ', @SQLDBAJoin, N'  
            WHERE stgl.ImportType = ', @IT_MergeOverwrite, N'  
                AND stgl.ImportStatus_ID = ', @StatusProcessing, N'-- Processing  
                AND stgl.Batch_ID = @Batch_ID;  
        END;  
    END; -- IF MergeOverwrite  
  
    ----------------------------------------------------------------------------------------  
    --Check for Inheritance Business Rules and update dependent members validation status.  
    ----------------------------------------------------------------------------------------  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Check for Inheritance Business Rules and update dependent members validation status.'')  
  
    IF EXISTS(SELECT 1 FROM @TrackingAttributeInfo WHERE TrackingType & 4 <> 0)  
    BEGIN  
        --check DBA Inheritance  
        DECLARE @BRInherit AS TABLE (  
             RowNumber INT IDENTITY(1,1) NOT NULL PRIMARY KEY  
            ,DependentAttributeColumnName SYSNAME NOT NULL  
            ,DependentEntityTable SYSNAME NULL  
            ,AttributeID int null  
                    );  
  
        DECLARE @Counter       INT = 0,  
                @MaxCounter    INT = 0;  
  
        --DBA Inheritance  
        INSERT INTO @BRInherit (DependentEntityTable, DependentAttributeColumnName, AttributeID)  
        SELECT DISTINCT  
             depEnt.EntityTable  
            ,i.ChildAttributeColumnName  
            ,a.AttributeID  
        FROM mdm.viw_SYSTEM_BUSINESSRULES_ATTRIBUTE_INHERITANCE_HIERARCHY i  
        INNER JOIN @TrackingAttributeInfo a  
            ON a.AttributeName = i.ParentAttributeName  AND i.ParentEntityID = @Entity_ID AND a.TrackingType & 4 <> 0  
        INNER JOIN mdm.tblEntity AS depEnt  
            ON i.ChildEntityID = depEnt.ID;  
  
        IF EXISTS(SELECT 1 FROM @BRInherit) BEGIN  
            SELECT  
                 @DependentValidationStatus = @AwaitingDependentMemberRevalidation  
                ,@Counter = 1  
                ,@MaxCounter = MAX(RowNumber)  
            FROM @BRInherit;  
  
            --Loop through each DBA Entity updating the dependent members validation status.  
            WHILE @Counter <= @MaxCounter  
            BEGIN  
                SELECT  
                    @DependentEntityTable = DependentEntityTable,  
                    @DependentAttributeColumnName = DependentAttributeColumnName,  
                    @ChangedAttributeID = AttributeID  
                FROM @BRInherit WHERE [RowNumber] = @Counter;  
  
                --Update immediate dependent member table validation status.  
                SELECT @SQLCTG = N''  
                UPDATE   dep  
                SET dep.ValidationStatus_ID = @DependentValidationStatus  
                FROM  mdm.'' + @DependentEntityTable + N'' AS dep  
                INNER JOIN #MemberAttributeWorkingSet AS ws  
                ON dep.'' + @DependentAttributeColumnName + N'' = ws.MemberID  
                    AND ws.AttributeID = @ChangedAttributeID  
                    AND dep.Version_ID = @Version_ID  
                    AND dep.ValidationStatus_ID <> @DependentValidationStatus;  
                    '';  
  
                --PRINT @SQLCTG;  
                EXEC sp_executesql @SQLCTG, N''@Version_ID INT, @DependentValidationStatus INT, @ChangedAttributeID INT'', @Version_ID, @DependentValidationStatus, @ChangedAttributeID;  
  
                SET @Counter += 1;  
  
            END; -- WHILE  
        END; -- IF @BRInherit  
    END; -- IF @TrackingAttributeInfo  
END; -- IF Merge  
',  
CASE WHEN @TransactionLogType = @TransactionLogType_Attribute THEN CONCAT(@TruncationGuard, N'  
  
IF @LogFlag = 1  
BEGIN  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Update Attribute Transaction table (@LogFlag = 1).'')  
    DECLARE @TempTable TABLE(  
        ID              INT,  
        TableColumn     NVARCHAR(128) COLLATE DATABASE_DEFAULT NOT NULL,  
        DomainEntity_ID INT NULL,  
        SortOrder       INT,  
        DomainTable     SYSNAME NULL);  
  
    DECLARE     @CurrentID              INT,  
                @CurrentTableColumn     NVARCHAR(128),  
                @CurrentDomainEntity_ID INT,  
                @CurrentSortOrder       INT,  
                @CurrentDomainTable     SYSNAME,  
                @TranSQL                NVARCHAR(MAX) = N'''';  
  
    INSERT INTO @TempTable  
    SELECT  
        A.ID,  
        A.TableColumn,  
        A.DomainEntity_ID,  
        A.SortOrder,  
        E.EntityTable AS DomainTable  
    FROM  
    mdm.tblAttribute A  
    LEFT OUTER JOIN mdm.tblEntity E  
    ON A.DomainEntity_ID = E.ID  
    WHERE A.Entity_ID = @Entity_ID AND A.MemberType_ID = @LeafMemberTypeID  
    AND (A.IsSystem = 0 OR A.IsCode = 1 OR A.IsName = 1) -- Exclude system attributes other than Code and Name.  
    ORDER BY  
        SortOrder ASC;  
  
    -- For each attribute, set the attribute update information to the Transaction table.  
    WHILE EXISTS(SELECT 1 FROM @TempTable) BEGIN  
        SELECT TOP 1  
            @CurrentID = ID,  
            @CurrentTableColumn = TableColumn,  
            @CurrentDomainEntity_ID = DomainEntity_ID,  
            @CurrentSortOrder = SortOrder,  
            @CurrentDomainTable = DomainTable  
        FROM @TempTable  
        ORDER BY SortOrder;  
        -- Get Old and New values from #TRANLOG table and insert into the transaction table.  
  
        IF @CurrentDomainEntity_ID IS NULL -- Handle non DBA  
        BEGIN  
  
            SET @TranSQL = N''  
    INSERT INTO [mdm].', QUOTENAME(@TransactionTableName), N'  
    (  
        Version_ID,  
        TransactionType_ID,  
        OriginalTransaction_ID,  
        Hierarchy_ID,  
        Entity_ID,  
        Attribute_ID,  
        Member_ID,  
        Member_MUID,  
        MemberType_ID,  
        MemberCode,  
        OldValue,  
        OldCode,  
        NewValue,  
        NewCode,  
        Batch_ID,  
        EnterDTM,  
        EnterUserID,  
        LastChgDTM,  
        LastChgUserID  
    )  
    SELECT  
        @Version_ID, --Version_ID  
        3, --TransactionType_ID (Member attribute set)  
        0, --OriginalTransaction_ID  
        NULL, --Hierarchy_ID  
        @Entity_ID, --Entity_ID  
        @Attribute_ID, -- Attribute_ID  
        MemberID, --Member_ID  
        MemberMUID, --Member_MUID  
        1, -- Leaf Member Type ID  
        CASE WHEN ISNULL(Code, N'''''''') = N'''''''' THEN New_Code ELSE Code END,  
        '' + @CurrentTableColumn + N'',  
        '' + @CurrentTableColumn + N'',  
        New_'' + @CurrentTableColumn + N'',  
        New_'' + @CurrentTableColumn + N'',  
        @Batch_ID,  
        GETUTCDATE(),  
        @User_ID,  
        GETUTCDATE(),  
        @User_ID  
    FROM #TRANLOG  
    WHERE ISNULL(NULLIF('' + @CurrentTableColumn + N'', New_'' + @CurrentTableColumn + N''), NULLIF(New_'' + @CurrentTableColumn + N'', '' + @CurrentTableColumn + N'')) IS NOT NULL  
        '';  
  
            EXEC sp_executesql @TranSQL, N''@Version_ID INT, @Attribute_ID INT, @Entity_ID INT, @Batch_ID INT, @User_ID INT '', @Version_ID, @CurrentID, @Entity_ID, @Batch_ID, @User_ID;  
        END  
        ELSE  
        BEGIN  
            -- Handle DBA  
            -- Get the old code value and the new code value by table join.  
            SET @TranSQL = N''  
    INSERT INTO [mdm].', QUOTENAME(@TransactionTableName), N'  
    (  
        Version_ID,  
        TransactionType_ID,  
        OriginalTransaction_ID,  
        Hierarchy_ID,  
        Entity_ID,  
        Attribute_ID,  
        Member_ID,  
        Member_MUID,  
        MemberType_ID,  
        MemberCode,  
        OldValue,  
        OldCode,  
        NewValue,  
        NewCode,  
        Batch_ID,  
        EnterDTM,  
        EnterUserID,  
        LastChgDTM,  
        LastChgUserID  
    )  
    SELECT  
        @Version_ID, --Version_ID  
        3, --TransactionType_ID (Member attribute set)  
        0, --OriginalTransaction_ID  
        NULL, --Hierarchy_ID  
        @Entity_ID, --Entity_ID  
        @Attribute_ID, -- Attribute_ID  
        T.MemberID, --Member_ID  
        T.MemberMUID, --Member_MUID  
        1, -- Leaf Member Type ID  
        CASE WHEN ISNULL(T.Code, N'''''''') = N'''''''' THEN T.New_Code ELSE T.Code END,  
        T.'' + @CurrentTableColumn + N'',  
        DO.Code,  
        New_'' + @CurrentTableColumn + N'',  
        DN.Code,  
        @Batch_ID,  
        GETUTCDATE(),  
        @User_ID,  
        GETUTCDATE(),  
        @User_ID  
    FROM #TRANLOG T  
    LEFT OUTER JOIN mdm.'' + QUOTENAME(@CurrentDomainTable) + N'' DN  
    ON T.New_'' + @CurrentTableColumn + N'' = DN.ID  
    LEFT OUTER JOIN mdm.'' + QUOTENAME(@CurrentDomainTable) + N'' DO  
    ON T.'' + @CurrentTableColumn + N'' = DO.ID  
    WHERE ISNULL(NULLIF(T.'' + @CurrentTableColumn + N'', T.New_'' + @CurrentTableColumn + N''), NULLIF(T.New_'' + @CurrentTableColumn + N'', T.'' + @CurrentTableColumn + N'')) IS NOT NULL  
        '';  
  
            EXEC sp_executesql @TranSQL, N''@Version_ID INT, @Attribute_ID INT, @Entity_ID INT, @Batch_ID INT, @User_ID INT '', @Version_ID, @CurrentID, @Entity_ID, @Batch_ID, @User_ID;  
  
        END; --IF  
  
        DELETE FROM @TempTable WHERE ID = @CurrentID;  
  
    END; --WHILE  
  
    TRUNCATE TABLE #TRANLOG;  
  
END; --IF')   
END, N'  
IF EXISTS(SELECT 1 FROM @UsedImportTypes WHERE ImportType IN (', @IT_MergeOptimistic, N', ', @IT_MergeOverwrite, N'))  
BEGIN  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Updating is done. Update the status.'')  
    -- Updating is done. Update the status.  
    UPDATE sc  
    SET ImportStatus_ID = ', @StatusOK, N' -- OK  
    FROM [stg].', @StagingLeafTable, N' sc  
    WHERE sc.ImportStatus_ID = ', @StatusProcessing, N'-- Processing   
        AND sc.Batch_ID = @Batch_ID;  
END -- IF Merge  
  
-- Update Tracking group  
IF EXISTS (SELECT 1 FROM @TrackingAttributeInfo WHERE TrackingType & 1 <> 0) BEGIN  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Update Tracking group.'')  
    UPDATE en  
    SET en.ChangeTrackingMask = ISNULL(en.ChangeTrackingMask, 0) | trackingMask.ChangeTrackingMask  
    FROM mdm.', @EntityTable, N' en  
    INNER JOIN     (  
        SELECT MemberID, SUM(Distinct(ISNULL(POWER(2, a.ChangeTrackingGroupID - 1), 0))) as ChangeTrackingMask  
        FROM #MemberAttributeWorkingSet ws  
        INNER JOIN @TrackingAttributeInfo a  
            ON a.AttributeID = ws.AttributeID AND a.TrackingType & 1 <> 0  
        GROUP BY MemberID) as trackingMask  
        ON en.ID = trackingMask.MemberID  and en.Version_ID = @Version_ID  
END  
  
----------------------------------------------------------------------------------------  
--Check circular reference  
----------------------------------------------------------------------------------------  
IF EXISTS (SELECT 1 FROM @TrackingAttributeInfo WHERE TrackingType & 2 <> 0) BEGIN  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Check circular reference.'')  
    -- Check circular references only when there is a DBA to check.  
    DECLARE @RecursiveHierarchy_ID              INT = 0,  
            @RecursiveHierarchyAttribute_ID     INT = 0,  
            @CircularReferenceErrors            INT = 0,  
            @CRMembers           mdm.MemberAttributes;  
  
    -- Determine if a recursive derived hierarchy is in play.  There may be multiple but just grab the first one.  
    SELECT TOP 1  
         @RecursiveHierarchy_ID  = d.DerivedHierarchy_ID  
        ,@RecursiveHierarchyAttribute_ID = att.Attribute_ID  
    FROM mdm.tblDerivedHierarchyDetail d  
    INNER JOIN [mdm].[viw_SYSTEM_SCHEMA_ATTRIBUTES] att  
        ON att.Attribute_DBAEntity_ID = @Entity_ID  
        AND att.Attribute_ID = d.Foreign_ID  
        AND d.ForeignParent_ID = att.Attribute_DBAEntity_ID  
  
    IF @RecursiveHierarchy_ID > 0 BEGIN  
        INSERT INTO @CRMembers (MemberCode)  
        SELECT en.Code  
        FROM #MemberAttributeWorkingSet ws  
        INNER JOIN mdm.', @EntityTable, N' en  
        ON en.ID = ws.MemberID AND en.Version_ID = @Version_ID  
        WHERE AttributeID = @RecursiveHierarchyAttribute_ID  
    END  
  
    IF EXISTS(SELECT 1 FROM @CRMembers) BEGIN  
  
        --There is a recursive derived hierarchy in play therefore we need to check the DBA values for circular references.  
        DECLARE @CircularReferenceCodeList TABLE  
        (  
            MemberCode            NVARCHAR(MAX) COLLATE DATABASE_DEFAULT NULL  
        );  
  
        --Call [udpCircularReferenceMemberCodesGet] and get the number of circular reference errors and the member codes  
        --that participate in the circular reference  
        INSERT INTO @CircularReferenceCodeList EXEC    @CircularReferenceErrors = [mdm].[udpCircularReferenceMemberCodesGet]  
                                                    @Model_ID = @Model_ID,  
                                                    @RecursiveHierarchy_ID = @RecursiveHierarchy_ID,  
                                                    @MemberAttributes = @CRMembers;  
  
        --If we found circular references, rollback the transaction and set the error code.  
        IF @CircularReferenceErrors > 0  
        BEGIN  
            IF @TranCounter = 0 ROLLBACK TRANSACTION;  
            ELSE IF XACT_STATE() <> -1 ROLLBACK TRANSACTION TX;  
  
            -- Set error 210016 (Binary Location: 2^13) for record(s) that caused the issue.  
            UPDATE stgl  
            SET ErrorCode = stgl.ErrorCode | 8192,  
                ImportStatus_ID = ', @StatusError, N' -- Error  
            FROM [stg].', @StagingLeafTable, N' stgl  
            INNER JOIN @CircularReferenceCodeList cref  
            ON stgl.Code = cref.MemberCode  
            WHERE stgl.ImportType IN (', @IT_MergeOptimistic, N', ', @IT_Insert, N', ', @IT_MergeOverwrite, N')  
                AND stgl.Batch_ID = @Batch_ID;  
  
            -- If there is any circular reference the entire batch process fails.  
            -- Since the records without an error status in the batch process rolled back as well,  
            -- Set their status as not processed.  
  
            UPDATE [stg].', @StagingLeafTable, N'  
            SET ImportStatus_ID = ', @StatusDefault, N' -- Default  
            WHERE Batch_ID = @Batch_ID AND ImportStatus_ID <> ', @StatusError, N' -- Error  
  
            --Get the number of errors for the batch ID  
            SELECT @ErrorCount = COUNT(ID) FROM [stg].', @StagingLeafTable, N'  
            WHERE Batch_ID = @Batch_ID AND ImportStatus_ID = ', @StatusError, N' -- Error  
  
            -- Set the status of the batch as Not Running (Completed).  
            -- Set the error member count.  
            UPDATE mdm.tblStgBatch  
            SET Status_ID = @Completed,  
                LastRunEndDTM = GETUTCDATE(),  
                LastRunEndUserID = @User_ID,  
                ErrorMemberCount = @ErrorCount  
            WHERE ID = @Batch_ID;  
  
            RETURN @OtherRuntimeError;  
  
        END; --IF  
    END;--IF  
END;--IF  
  
IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Determine if any purge or delete records exist.'')  
  
--Determine if any purge or delete records exist  
IF EXISTS(SELECT 1 FROM @UsedImportTypes WHERE ImportType IN (', @IT_Delete, N', ', @IT_Purge, N', ', @IT_DeleteSetNullToRef, N', ', @IT_PurgeSetNullToRef, N'))  
BEGIN  
  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Populate a temp table of FK Relationships.'')  
    --Populate a temp table of FK Relationships  
    DECLARE @TABLEFK TABLE  
    (  
         ID                 INT IDENTITY (1, 1) NOT NULL PRIMARY KEY  
        ,Entity_ID          INT  
        ,TableName          SYSNAME COLLATE DATABASE_DEFAULT NULL  
        ,AttributeName      NVARCHAR(100) COLLATE DATABASE_DEFAULT NULL  
        ,TableColumn        SYSNAME COLLATE DATABASE_DEFAULT NOT NULL  
        ,MemberType_ID      INT  
    );  
  
    INSERT INTO @TABLEFK (Entity_ID, TableName, AttributeName, TableColumn, MemberType_ID)  
    SELECT   
        Entity_ID,  
        mdm.udfTableNameGetByID(Entity_ID, MemberType_ID),  
        Name,  
        TableColumn,  
        MemberType_ID  
    FROM mdm.tblAttribute  
    WHERE DomainEntity_ID = @Entity_ID;  
  
    DECLARE @FkTotalCount INT = 0;  
  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' SELECT @FkTotalCount = COUNT(ID) FROM @TABLEFK;'')  
    SELECT @FkTotalCount = COUNT(ID) FROM @TABLEFK;  
  
    IF @FkTotalCount > 0  
    BEGIN  
        DECLARE   
            @Row_ID         INT,  
            @TableName      SYSNAME,  
            @TableColumn    SYSNAME,  
            @FKSQL          NVARCHAR(MAX) = N''''  
  
        -- When not setting references to null, add errors for any existing references. This must be done for all FK before setting any refs to null.  
        IF EXISTS(SELECT 1 FROM #MembersToRemove WHERE SetToNull = 0)  
        BEGIN  
            IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' CREATE TABLE #ErrorRows'')  
            CREATE TABLE #ErrorRows  
            (  
                Staging_ID      INT,  
                Member_ID       INT,  
                MemberCode      NVARCHAR(250) COLLATE DATABASE_DEFAULT,  
                TableColumn     SYSNAME COLLATE DATABASE_DEFAULT,   
            )  
            CREATE CLUSTERED INDEX #ErrorRows_Staging_ID ON #ErrorRows(Staging_ID);  
  
            -- Loop through FK references, to check for errors  
            SET @Row_ID = 0;  
            WHILE @FkTotalCount > @Row_ID  
            BEGIN  
                SELECT TOP 1  
                    @TableName = TableName,  
                    @TableColumn = TableColumn,  
                    @Row_ID = ID  
                FROM @TABLEFK  
                WHERE ID > @Row_ID  
                ORDER BY ID;  
  
                SET @FKSQL = CONCAT(N''  
                    DELETE mtr  
                    OUTPUT deleted.Staging_ID, deleted.Member_ID, deleted.MemberCode, '', QUOTENAME(@TableColumn, N''''''''), N''  
                    INTO #ErrorRows (Staging_ID, Member_ID, MemberCode, TableColumn)  
                    FROM #MembersToRemove mtr  
                    INNER JOIN mdm.'', QUOTENAME(@TableName), N'' en  
                    ON      en.Version_ID = @Version_ID  
                        AND mtr.Member_ID = en.'', QUOTENAME(@TableColumn), N''  
                    WHERE mtr.SetToNull = 0'');  
  
                EXEC sp_executesql @FKSQL, N''@Version_ID INT'', @Version_ID;  
            END -- loop through FKs, error check  
  
            IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Check for Error 210052- The member cannot be deleted or purged when it is referenced as a domain-based attribute value.'')  
            --In case of @IT_Delete and @IT_Purge when the entity is referenced via foreign key, set as an error.  
            --Error 210052 Binary Location 2^19: The member cannot be deleted or purged when it is referenced as a domain-based attribute value.  
            UPDATE stg  
            SET ErrorCode = ErrorCode | 524288,  
                ImportStatus_ID = ', @StatusError, N' -- Error  
            FROM [stg].', @StagingLeafTable, N' stg  
            INNER JOIN #ErrorRows er  
            ON stg.ID = er.Staging_ID  
  
            IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Insert the error detail information.'')  
            -- Insert the error detail information.  
            INSERT INTO [mdm].[tblStgErrorDetail]  
                (Batch_ID, Code, AttributeName, AttributeValue, UniqueErrorCode)  
            SELECT  
                @Batch_ID, MemberCode, TableColumn, Member_ID, 210052  
            FROM #ErrorRows  
        END -- If exists SetToNull = 0  
  
        IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Set references to null'')  
        -- Set references to null. This must be done after the above error checks.  
        IF EXISTS(SELECT 1 FROM #MembersToRemove WHERE SetToNull = 1)  
        BEGIN  
            -- Loop through FK references, setting referencing DBAs to null  
            SET @Row_ID = 0;  
            WHILE @FkTotalCount > @Row_ID  
            BEGIN  
                SELECT TOP 1  
                    @TableName = TableName,  
                    @TableColumn = TableColumn,  
                    @Row_ID = ID  
                FROM @TABLEFK  
                WHERE ID > @Row_ID  
                ORDER BY ID;  
  
                SET @FKSQL = CONCAT(N''  
                    UPDATE en  
                    SET '', QUOTENAME(@TableColumn), N'' = NULL  
                    FROM #MembersToRemove mtr  
                    INNER JOIN mdm.'', QUOTENAME(@TableName), N'' en  
                    ON      en.Version_ID = @Version_ID  
                        AND mtr.Member_ID = en.'', QUOTENAME(@TableColumn), N''  
                        AND mtr.SetToNull = 1'');  
  
                 EXEC sp_executesql @FKSQL, N''@Version_ID INT'', @Version_ID;  
            END -- loop through FKs, set DBAs to null  
        END  
    END -- IF FK  
    ',  
CASE WHEN @IsHierarchyEnabled = 1 THEN CONCAT(@TruncationGuard, N'  
    -- Deactivate (soft delete) the member in Hierarchy Relationship table.  
    SET @Now = GETUTCDATE();  
    IF @LogFlag != 1  
    BEGIN  
        IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Deactivate (soft delete) the member in Hierarchy Relationship table (@LogFlag != 1).'')  
        UPDATE hr  
        SET Status_ID = ', @MemberStatus_Deactivated, N' -- Deactivated  
           ,LastChgDTM = @Now  
           ,LastChgUserID = @User_ID  
           ,LastChgVersionID = @Version_ID  
        FROM mdm.', @HierarchyRelationshipTable, N' hr  
        INNER JOIN #MembersToRemove mtr  
        ON      hr.Version_ID = @Version_ID  
            AND hr.Child_EN_ID = mtr.Member_ID  
            AND mtr.IsPurge = 0;  
    END  
    ELSE  
    BEGIN  
        IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Deactivate (soft delete) the member in Hierarchy Relationship table (@LogFlag = 1).'')  
        UPDATE hr  
        SET Status_ID = ', @MemberStatus_Deactivated, N' -- Deactivated  
           ,LastChgDTM = @Now  
           ,LastChgUserID = @User_ID  
           ,LastChgVersionID = @Version_ID',  
        CASE @TransactionLogType  
            WHEN @TransactionLogType_Member THEN @HRHistoryOutputQuery  
        END, N'  
        FROM mdm.', @HierarchyRelationshipTable, N' hr  
        INNER JOIN #MembersToRemove mtr  
        ON      hr.Version_ID = @Version_ID  
            AND hr.Child_EN_ID = mtr.Member_ID  
            AND mtr.IsPurge = 0;  
    END;  
    ')  
END, N'  
    -- Deactivate (soft delete) the member in Entity table.  
    SET @Now = GETUTCDATE();  
    IF @LogFlag != 1  
    BEGIN  
        IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Deactivate (soft delete) the member in Entity table. (@LogFlag != 1).'')  
        UPDATE en  
        SET Status_ID = ', @MemberStatus_Deactivated, N' -- Deactivated  
           ,LastChgDTM = @Now  
           ,LastChgUserID = @User_ID  
           ,LastChgVersionID = @Version_ID  
        FROM mdm.', @EntityTable, N' en  
        INNER JOIN #MembersToRemove mtr  
        ON      en.Version_ID = @Version_ID  
            AND en.ID = mtr.Member_ID  
            AND mtr.IsPurge = 0;  
    END  
    ELSE  
    BEGIN  
        IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Deactivate (soft delete) the member in Entity table. (@LogFlag = 1).'')  
        UPDATE en  
        SET Status_ID = ', @MemberStatus_Deactivated, N' -- Deactivated  
           ,LastChgDTM = @Now  
           ,LastChgUserID = @User_ID  
           ,LastChgVersionID = @Version_ID',  
        CASE @TransactionLogType  
            WHEN @TransactionLogType_Member THEN @ENHistoryOutputQuery  
            WHEN @TransactionLogType_Attribute THEN @OutputDeletionToTransactionTableQuery  
        END, N'  
        FROM mdm.', @EntityTable, N' en  
        INNER JOIN #MembersToRemove mtr  
        ON      en.Version_ID = @Version_ID  
            AND en.ID = mtr.Member_ID  
            AND mtr.IsPurge = 0;  
    END',  
  
    CASE WHEN @IsHierarchyEnabled = 1 THEN CONCAT(@TruncationGuard, N'  
    -- ImportType is Purge.  
    -- Hard delete the member FROM Hierarchy Relationship table.  
    SET @Now = GETUTCDATE();  
    IF @LogFlag != 1  
    BEGIN  
        IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Hard delete the member FROM Hierarchy Relationship table (@LogFlag != 1).'')  
        DELETE hr  
        FROM mdm.', @HierarchyRelationshipTable, N' hr  
        INNER JOIN #MembersToRemove mtr  
        ON      hr.Version_ID = @Version_ID  
            AND hr.Child_EN_ID = mtr.Member_ID  
            AND mtr.IsPurge = 1;  
    END  
    ELSE  
    BEGIN  
        IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Hard delete the member FROM Hierarchy Relationship table (@LogFlag = 1).'')  
        DELETE hr',  
        CASE @TransactionLogType  
            WHEN @TransactionLogType_Member THEN @HRHistoryOutputQuery  
        END, N'  
        FROM mdm.', @HierarchyRelationshipTable, N' hr  
        INNER JOIN #MembersToRemove mtr  
        ON      hr.Version_ID = @Version_ID  
            AND hr.Child_EN_ID = mtr.Member_ID  
            AND mtr.IsPurge = 1;  
    END  
    ') END, N'  
  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Delete member security.'')  
    -- Delete member security  
    DELETE sra  
    FROM mdm.tblSecurityRoleAccessMember sra  
    INNER JOIN #MembersToRemove mtr  
    ON      sra.Version_ID = @Version_ID  
        AND sra.Member_ID = mtr.Member_ID  
        AND sra.Entity_ID = @Entity_ID  
        AND sra.HierarchyType_ID IN (0, 1) -- Derived and Explicit Hierarchy  
        AND sra.MemberType_ID = ', @MemberType_Leaf, N'-- Leaf  
        AND mtr.IsPurge = 1;  
  
    -- Hard delete the member from Entity table.  
  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Get the IDs of any rows in tblFile that are about to be orphaned.'')  
    -- Get the IDs of any rows in tblFile that are about to be orphaned  
    CREATE TABLE #FileIDsToDelete  
    (  
        ID  INT  
    );  
    DECLARE @GetFileIdsSQL NVARCHAR(MAX) = mdm.udfFileIDReferencesGetSQL(@Entity_ID, 1/*Leaf*/, NULL, 1/*Soft-deleted members only*/)  
    IF LEN(@GetFileIdsSQL) > 0  
    BEGIN  
        SET @GetFileIdsSQL = CONCAT(N''INSERT INTO #FileIDsToDelete(ID)  
'', @GetFileIdsSQL);  
        EXEC sp_executesql @GetFileIdsSQL;  
    END  
  
    SET @Now = GETUTCDATE();  
    IF @LogFlag != 1  
    BEGIN  
        IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Hard delete the member from Entity table (@LogFlag != 1).'')  
        DELETE en  
        FROM mdm.', @EntityTable, N' en  
        INNER JOIN #MembersToRemove mtr  
        ON      en.Version_ID = @Version_ID  
            AND en.ID = mtr.Member_ID  
            AND mtr.IsPurge = 1;  
    END  
    ELSE  
    BEGIN  
        IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Hard delete the member from Entity table (@LogFlag = 1).'')  
        DELETE en',  
        CASE @TransactionLogType  
            WHEN @TransactionLogType_Member THEN @ENHistoryOutputQuery  
            WHEN @TransactionLogType_Attribute THEN @OutputDeletionToTransactionTableQuery  
        END, N'  
        FROM mdm.', @EntityTable, N' en  
        INNER JOIN #MembersToRemove mtr  
        ON      en.Version_ID = @Version_ID  
            AND en.ID = mtr.Member_ID  
            AND mtr.IsPurge = 1;',  
  
CASE WHEN @TransactionLogType = @TransactionLogType_Attribute THEN CONCAT(@TruncationGuard, N'  
  
        IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Log delete and purge of members (Attribute log type).'')  
        --Log delete and purge of members.  
        --Because there is no transaction status for hard delete, record hard delete as deactivation.  
        INSERT INTO [mdm].', QUOTENAME(@TransactionTableName), N'  
        (  
            Version_ID,  
            TransactionType_ID,  
            OriginalTransaction_ID,  
            Hierarchy_ID,  
            Entity_ID,  
            Member_ID,  
            Member_MUID,  
            MemberType_ID,  
            MemberCode,  
            OldValue,  
            OldCode,  
            NewValue,  
            NewCode,  
            Batch_ID,  
            EnterDTM,  
            EnterUserID,  
            LastChgDTM,  
            LastChgUserID  
        )  
        SELECT  
            @Version_ID, --Version_ID  
            @MemberStatusSetTransaction, --TransactionType_ID  
            0, --OriginalTransaction_ID  
            NULL, --Hierarchy_ID  
            @Entity_ID, --Entity_ID  
            MemberID, --Member_ID  
            MemberMUID, --Member_MUID  
            @LeafMemberTypeID, --MemberType_ID  
            Code,  
            N''1'', --OldValue  
            N''Active'', --OldCode  
            N''2'', --NewValue  
            N''De-Activated'', --NewCode  
            @Batch_ID,  
            GETUTCDATE(),  
            @User_ID,  
            GETUTCDATE(),  
            @User_ID  
        FROM #TRANLOG  
        WHERE MemberID IS NOT NULL -- exclude members that were already soft-deleted')  
    END, N'  
    END  
  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Delete orphaned files.'')  
    -- Delete orphaned files.  
    IF EXISTS(SELECT 1 FROM #FileIDsToDelete)  
    BEGIN  
        DECLARE @File_ID mdm.IdList;  
        INSERT INTO @File_ID  
        SELECT ID   
        FROM #FileIDsToDelete;  
  
        EXEC mdm.udpFilesDelete @File_ID = @File_ID  
    END  
  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' EXEC mdm.udpSecurityMemberProcessRebuildModelVersion @Version_ID, 1'')  
    EXEC mdm.udpSecurityMemberProcessRebuildModelVersion @Version_ID, 1;  
  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Update the status after the delete (soft delete) and the purge (hard delete)'')  
    --Update the status after the delete (soft delete) and the purge (hard delete)  
    UPDATE [stg].', @StagingLeafTable, N'  
    SET ImportStatus_ID = ', @StatusOK, N' -- OK  
    WHERE ImportType IN (', @IT_Delete, N', ', @IT_Purge, N', ', @IT_DeleteSetNullToRef, N', ', @IT_PurgeSetNullToRef, N')  
        AND ErrorCode = 0  
        AND Batch_ID = @Batch_ID;  
END -- IF Delete/Purge  
  
  
IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Get the number of errors for the batch ID'')  
--Get the number of errors for the batch ID  
SELECT @ErrorCount = COUNT(ID) FROM [stg].', @StagingLeafTable, N'  
    WHERE Batch_ID = @Batch_ID AND ErrorCode != 0  
  
IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Set the status of the batch as Not Running (Completed).'')  
-- Set the status of the batch as Not Running (Completed).  
-- Set the error member count.  
UPDATE mdm.tblStgBatch  
SET Status_ID = @Completed,  
    LastRunEndDTM = GETUTCDATE(),  
    LastRunEndUserID = @User_ID,  
    ErrorMemberCount = @ErrorCount  
WHERE ID = @Batch_ID  
  
IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' Commit only if not nested'')  
IF @TranCounter = 0 COMMIT TRANSACTION; --Commit only if we are not nested  
  
IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' [stg].', REPLACE(QUOTENAME(N'udp_' + @StagingBase + N'_Leaf'), N'''', N''''''),'  end'')  
RETURN 0;  
  
END TRY  
BEGIN CATCH  
    SET NOCOUNT OFF;  
  
    -- Get error info  
    DECLARE  
        @ErrorMessage NVARCHAR(4000),  
        @ErrorSeverity INT,  
        @ErrorState INT,  
        @ErrorNumber INT,  
        @ErrorLine INT,  
        @ErrorProcedure NVARCHAR(126);  
    EXEC mdm.udpGetErrorInfo  
        @ErrorMessage = @ErrorMessage OUTPUT,  
        @ErrorSeverity = @ErrorSeverity OUTPUT,  
        @ErrorState = @ErrorState OUTPUT,  
        @ErrorNumber = @ErrorNumber OUTPUT,  
        @ErrorLine = @ErrorLine OUTPUT,  
        @ErrorProcedure = @ErrorProcedure OUTPUT  
  
    SET @ErrorMessage = CONCAT(@ErrorMessage, N'', @ErrorNumber = '', @ErrorNumber, N'', @ErrorProcedure = "'', @ErrorProcedure, N''", line '', @ErrorLine);  
  
    IF @TranCounter = 0 ROLLBACK TRANSACTION;  
    ELSE IF XACT_STATE() <> -1 ROLLBACK TRANSACTION TX;  
  
    RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), '' [stg].', REPLACE(QUOTENAME(N'udp_' + @StagingBase + N'_Leaf'), N'''', N''''''),'  end'')  
    RETURN @OtherRuntimeError;  
END CATCH  
SET NOCOUNT OFF;  
END;')  
    --SELECT @SQL AS [processing-instruction(x)] FOR XML PATH('');  
    EXEC sp_executesql @SQL;  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpEntityStagingCreateLeafTable]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
Helper sproc that creates the Leaf staging table of the given name.   
*/  
CREATE PROCEDURE [mdm].[udpEntityStagingCreateLeafTable]  
(  
    @StagingTableName   sysname, -- The name of the leaf staging table to create  
    @TableOptions           NVARCHAR(MAX) = N'', -- Optional compress string used in creating the table.  
    @IndexOptions           NVARCHAR(MAX) = N'', -- Optional compress string used in creating the table indexes.  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
AS BEGIN  
    SET NOCOUNT ON;  
  
    SET @TableOptions = COALESCE(@TableOptions, N'');  
    SET @IndexOptions = COALESCE(@IndexOptions, N'');  
  
    -- This pseudo-constant is for use in string concatenation operations to prevent string truncation. When concatenating two or more strings,  
    -- if none of the strings is an NVARCHAR(MAX) or an NVARCHAR constant that is longer than 4,000 characters, then the resulting string   
    -- will be silently truncated to 4,000 characters. Concatenating with this empty NVARCHAR(MAX), is sufficient to prevent truncation.  
    -- See http://connect.microsoft.com/SQLServer/feedback/details/283368/nvarchar-max-concatenation-yields-silent-truncation.  
    DECLARE @TruncationGuard NVARCHAR(MAX) = N'';  
  
    DECLARE @SQL NVARCHAR(MAX) = @TruncationGuard + N'  
        CREATE TABLE [stg].' + QUOTENAME(@StagingTableName) + N'    
        (    
            --Identity    
            ID                  INT IDENTITY (1, 1) NOT NULL,  
                          
            --Import Specific  
            ImportType          TINYINT NOT NULL,  
  
            --Status    
            ImportStatus_ID     TINYINT NOT NULL CONSTRAINT ' + QUOTENAME(N'df_' + @StagingTableName  + N'_ImportStatus_ID') + N' DEFAULT 0,   
        
            --Info  
            Batch_ID            INT NULL,  
            BatchTag            NVARCHAR(50) NOT NULL,  
  
            --Error Code  
            ErrorCode           INT NOT NULL CONSTRAINT ' + QUOTENAME(N'df_' + @StagingTableName  + N'_ErrorCode') + N' DEFAULT 0,   
            Code                NVARCHAR(250) NULL,  
            [Name]              NVARCHAR(250) NULL,    
            NewCode             NVARCHAR(250) NULL,      
                                                                                                            
            --Create PRIMARY KEY constraint    
            CONSTRAINT ' + QUOTENAME(N'pk_' + @StagingTableName) + N'     
                PRIMARY KEY CLUSTERED (ID),    
                        
            --Create CHECK constraints    
            CONSTRAINT ' + QUOTENAME(N'ck_' + @StagingTableName + N'_ImportType') + N'     
                CHECK (ImportType BETWEEN 0 AND 6),    
                              
            CONSTRAINT ' + QUOTENAME(N'ck_' + @StagingTableName + N'_ImportStatus_ID') + N'     
                CHECK (ImportStatus_ID BETWEEN 0 and 3)     
        )    
        ' + @TableOptions + N';  
                      
        --Index [Batch_ID] for performance  
        CREATE NONCLUSTERED INDEX ' + QUOTENAME(N'ix_' + @StagingTableName + N'_Batch_ID') + N'   
            ON [stg].' + QUOTENAME(@StagingTableName) + N'(Batch_ID)  
            ' + @IndexOptions + N';  
                      
        --Index [BatchTag], [ImportStatus_ID] for performance  
        CREATE NONCLUSTERED INDEX ' + QUOTENAME(N'ix_' + @StagingTableName + N'_BatchTag_ImportStatus_ID') + N'   
            ON [stg].' + QUOTENAME(@StagingTableName) + N'(BatchTag, ImportStatus_ID)  
            ' + @IndexOptions + N';  
  
        --Index [Code] for performance  
        CREATE NONCLUSTERED INDEX ' + QUOTENAME(N'ix_' + @StagingTableName + N'_Code') + N'   
            ON [stg].' + QUOTENAME(@StagingTableName) + N'(Code)  
            ' + @IndexOptions + N';  
        ';    
       
    --Execute the dynamic SQL    
    --PRINT(@SQL);    
    EXEC sp_executesql @SQL;    
  
    SET NOCOUNT OFF;  
END;
GO
/****** Object:  StoredProcedure [mdm].[udpEntityStagingCreateRelationshipStoredProcedure]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpEntityStagingCreateRelationshipStoredProcedure]  
(  
    @Entity_ID      INT,  
    @CorrelationID  UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE @MainSQL                        NVARCHAR(MAX) = N'',  
            @EntityTable                    SYSNAME = N'',  
            @HierarchyRelationshipTable     SYSNAME = N'',  
            @HRHistoryOutputQuery           NVARCHAR(MAX) = N'',  
            @HierarchyParentTable           SYSNAME = N'',  
            @SQLInsertTemp                  NVARCHAR(MAX) = N'',  
            @Model_ID                       INT,  
            @EntityName                     NVARCHAR(50) = N'',  
            @StagingBase                    NVARCHAR(60),  
  
            @StagingRelationshipTable       SYSNAME,  
  
            --Entity member status  
            @MemberStatus_Active            NVARCHAR(1) = N'1',  
            @MemberStatus_Deactivated       NVARCHAR(1) = N'2',  
  
            @MemberType_Hierarchy           TINYINT = 4,  
  
            -- Transaction log type constants  
            @TransactionLogType            TINYINT,  
            @TransactionLogType_Attribute  TINYINT = 1,  
            @TransactionLogType_Member     TINYINT = 2,  
            @TransactionLogType_None       TINYINT = 3,  
  
            --Transaction and annotation table names  
            @TransactionTableName          SYSNAME;  
  
    --Initialize the variables  
  
    SELECT  @EntityTable = QUOTENAME(EntityTable),  
            @HierarchyRelationshipTable = QUOTENAME(HierarchyTable),  
            @HierarchyParentTable = QUOTENAME(HierarchyParentTable),  
            @Model_ID = Model_ID,  
            @EntityName = Name,  
            @StagingBase = StagingBase,  
            @StagingRelationshipTable = QUOTENAME(IsNULL(StagingRelationshipTable, N'')),  
            @TransactionLogType = TransactionLogType  
    FROM mdm.viw_SYSTEM_SCHEMA_ENTITY  
    WHERE ID = @Entity_ID;  
  
    IF @TransactionLogType = @TransactionLogType_Member  
    BEGIN  
        SET @HRHistoryOutputQuery = mdm.udfGetHistoryOutputQuery(@Entity_ID, @MemberType_Hierarchy, N'@User_ID', N'@Now');  
    END  
    ELSE IF @TransactionLogType = @TransactionLogType_Attribute  
    BEGIN  
         --Load the transaction and annotation table names  
        SET @TransactionTableName = mdm.udfGetTransactionTableName(@Model_ID);  
    END  
  
    -- In case when the entity is a system entity (StagingBase is not specified)  
    -- simply don't create the staging SProc (don't raise an error).  
    IF COALESCE(@StagingBase, N'') = N''  
    BEGIN  
        RETURN;  
    END;  
  
    --If the Relationship staging SProc exists drop it.  
    EXEC mdm.udpEntityStagingDeleteStoredProcedures @Entity_ID, 4  
  
    SET @MainSQL = N'CREATE PROCEDURE [stg].' + QUOTENAME(N'udp_' + @StagingBase + N'_Relationship') + N'  
@VersionName NVARCHAR(50), @LogFlag INT=0, @BatchTag NVARCHAR(50)=N'''', @Batch_ID INT=NULL, @UserName NVARCHAR(100) = NULL, @User_ID INT = 0  
WITH EXECUTE AS ''mds_schema_user''  
AS  
BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE @Model_ID                   INT,  
            @Entity_ID                  INT,  
            @Hierarchy_ID               INT,  
            @TargetType_ID              INT,  
            @Meta_ID                    INT,  
            @Hierarchy_IsMandatory      INT,  
            @MaxSortOrderRelationship   INT,  
            @MaxSortOrderStaging        INT,  
            @Version_ID                 INT,  
            @HierarchyParent_ID         INT,  
            @IsMandatory                BIT,  
            @VersionStatus_ID           INT,  
            @VersionStatus_Committed    INT = 3,  
            @Now                        DATETIME2,  
  
            @MemberCount                INT = 0,  
            @ErrorCount                 INT = 0,  
            @NewBatch_ID                INT = 0,  
            @GetNewBatch_ID             INT = 0,  
  
            -- member type constants  
            @LeafMemberTypeID           INT = 1,  
            @ConsolidatedMemberTypeID   INT = 2,  
            @HierarchyMemberTypeID      INT = 4,  
  
            -- staging datastatus constants  
            @StatusDefault              INT = 0,  
            @StatusOK                   INT = 1,  
            @StatusError                INT = 2,  
            @StatusProcessing           INT = 3,  
  
            -- error return code constants  
            @UserIDError                INT = 1,  
            @VersionNameError           INT = 3,  
            @UserPermissionError        INT = 4,  
            @VersionStatusError         INT = 5,  
            @NoRecordToProcessError     INT = 6,  
            @BatchIDAndBatchTagSpecifiedError   INT = 7,  
            @BatchStatusError           INT = 8,  
            @OtherRuntimeError          INT = 9,  
            '  
    SET @MainSQL = @MainSQL + N'  
            -- bacth status constants  
            @QueuedToRun                INT = 1,  
            @NotRunning                 INT = 2,  
            @Running                    INT = 3,  
            @QueueToClear               INT = 4,  
            @Cleared                    INT = 5,  
            @AllExceptCleared           INT = 6,  
            @Completed                  INT = 7,  
  
            -- GetNewBatch_ID constants  
            @BatchIDFound               INT = 0,  
            @BatchIDNotFound            INT = 1,  
            @BatchIDForBatchTagNotFound INT = 2,  
  
            --Import Type Constans  
            @IT_MergeOptimistic         INT = 0,  
            @IT_Insert                  INT = 1,  
            @IT_MergeOverwrite          INT = 2,  
            @IT_Delete                  INT = 3,  
            @IT_Purge                   INT = 4,  
            @IT_Max                     INT = 4,  
  
            --Validation status  
            @NewAwaitingValidation      INT = 0,  
            @AwaitingRevalidation       INT = 4,  
  
            --XACT_STATE() constancts  
            @UncommittableTransaction   INT = -1,  
            @MemberStatus_Deactivated   INT = 2  
            ;  
  
            DECLARE @tblMeta TABLE  
            (  
                ID                      INT IDENTITY (1, 1) NOT NULL,  
                Hierarchy_ID            INT,  
                Hierarchy_IsMandatory   BIT,  
                TargetType_ID           INT  
            );  
  
            DECLARE @tblHierarchy TABLE  
            (  
                Hierarchy_ID            INT  
            );  
  
            DECLARE @tblDuplicatedCodeInHierarchy TABLE  
            (  
                ChildCode               NVARCHAR(250) COLLATE DATABASE_DEFAULT,  
                HierarchyName           NVARCHAR(250) COLLATE DATABASE_DEFAULT  
            );  
  
    SET @Model_ID = ' + CONVERT(NVARCHAR(25),@Model_ID) + N'  
    SET @Entity_ID = ' + CONVERT(NVARCHAR(25),@Entity_ID);  
  
    SET @MainSQL = @MainSQL + N'  
  
    -- @UserName overwrites @User_ID  
    IF @UserName IS NOT NULL  
    BEGIN  
        SET @User_ID = mdm.udfUserIDGetByUserName(@UserName)  
        IF @User_ID IS NULL  
        BEGIN  
            RAISERROR(''MDSERR500041|The UserName is unknown.'', 16, 1);  
            RETURN @UserIDError;  
        END  
    END  
  
    -- Check for invalid Version Name.  
    IF @VersionName IS NULL RETURN @VersionNameError;  
  
    IF LEN(@BatchTag) > 0 AND @Batch_ID IS NOT NULL BEGIN  
        RAISERROR(''MDSERR310043|The Batch Tag and the Batch ID cannot be specified at the same time.'', 16, 1);  
        RETURN @BatchIDAndBatchTagSpecifiedError;  
    END; --IF  
  
    SELECT @Version_ID = ID, @VersionStatus_ID = Status_ID FROM mdm.tblModelVersion WHERE Model_ID = @Model_ID AND [Name] = @VersionName;  
  
    IF @Version_ID IS NULL BEGIN  
        RAISERROR(''MDSERR100036|The version name is not valid.'', 16, 1);  
        RETURN @VersionNameError;  
    END; --IF  
  
     --Ensure that Version is not committed  
    IF (@VersionStatus_ID = @VersionStatus_Committed) BEGIN  
        RAISERROR(''MDSERR310040|Data cannot be loaded into a committed version.'', 16, 1);  
        RETURN @VersionStatusError;  
    END;  
  
    --Check if there is any record to process.  
    IF LEN(@BatchTag) > 0 BEGIN  
        SELECT @MemberCount = COUNT(ID) FROM [stg].' + @StagingRelationshipTable + N'  
            WHERE BatchTag = @BatchTag AND ImportStatus_ID = @StatusDefault;  
        IF @MemberCount = 0 BEGIN  
            RETURN @NoRecordToProcessError;  
        END; -- IF  
    END; -- IF  
    ELSE BEGIN  
        IF @Batch_ID IS NOT NULL BEGIN  
            SELECT @MemberCount = COUNT(ID) FROM [stg].' + @StagingRelationshipTable + N'  
                WHERE Batch_ID = @Batch_ID AND ImportStatus_ID = @StatusDefault;  
            IF @MemberCount = 0 BEGIN  
                RETURN @NoRecordToProcessError;  
            END; -- IF  
        END; -- IF  
    END; -- IF  
  
    -- If neither @BatchTag nor @Batch_ID is specified assume that a blank @BatchTag is specified.  
  
    IF @Batch_ID IS NULL AND LEN(@BatchTag) = 0 BEGIN  
        SELECT @MemberCount = COUNT(ID) FROM [stg].' + @StagingRelationshipTable + N'  
            WHERE (BatchTag IS NULL OR BatchTag = N'''') AND ImportStatus_ID = @StatusDefault;  
        IF @MemberCount = 0 BEGIN  
            RETURN @NoRecordToProcessError;  
        END; -- IF  
    END; -- IF  
  
    --Check if there is any record with an invalid status.  
    IF LEN(@BatchTag) > 0 BEGIN  
        IF EXISTS (SELECT stgr.ID FROM [stg].' + @StagingRelationshipTable + N' stgr  
            INNER JOIN mdm.tblStgBatch stgb  
            ON stgr.BatchTag = stgb.BatchTag AND stgb.Status_ID = @Running  
            WHERE stgr.BatchTag = @BatchTag AND stgr.ImportStatus_ID = @StatusDefault) BEGIN  
  
            RAISERROR(''MDSERR310029|The status of the specified batch is not valid.'', 16, 1);  
            RETURN @BatchStatusError;  
        END; -- IF  
    END; -- IF  
  
    IF @Batch_ID IS NOT NULL  BEGIN  
        IF EXISTS (SELECT stgr.ID FROM [stg].' + @StagingRelationshipTable + N' stgr  
            INNER JOIN mdm.tblStgBatch stgb  
            ON stgr.Batch_ID = stgb.ID AND stgb.Status_ID IN (@Running, @QueueToClear, @Cleared)  
            WHERE stgr.Batch_ID = @Batch_ID AND stgr.ImportStatus_ID = @StatusDefault) BEGIN  
  
            RAISERROR(''MDSERR310029|The status of the specified batch is not valid.'', 16, 1);  
            RETURN @BatchStatusError;  
        END; -- IF  
    END; -- IF  
  
    --Start transaction, being careful to check if we are nested  
    DECLARE @TranCounter INT;  
    SET @TranCounter = @@TRANCOUNT;  
    IF @TranCounter > 0 SAVE TRANSACTION TX;  
    ELSE BEGIN TRANSACTION;  
  
    BEGIN TRY  
  
        --Create relationship staging temporary table  
        CREATE TABLE #tblStage  
        (  
            ID                    BIGINT IDENTITY (1, 1) NOT NULL,  
            Stage_ID            INT NOT NULL,  
            Relationship_ID        INT NOT NULL DEFAULT -1,    --ID from the hierarchy relationship table  
            Member_ID            INT NOT NULL,  
            Member_MUID          UNIQUEIDENTIFIER NULL,  
            Member_Code            NVARCHAR(250) COLLATE database_default NOT NULL,  
            ChildType_ID        INT NOT NULL DEFAULT 0,        --Source member type: 1=EN and 2=HP  
            MemberStatus_ID        TINYINT NOT NULL DEFAULT 1,    --Defaults to active  
            TargetType_ID        INT NOT NULL,                --Type of relationship: 1=parent; 2=sibling (move behind sibling)  
            Target_ID            INT NULL,  
            Target_Code            NVARCHAR(250) COLLATE database_default NULL,  
            TargetMemberType_ID    INT NOT NULL DEFAULT 0,        --Target member type: 1=leaf member, 2=consolidated member, 3=collection (derived)  
            TargetStatus_ID        TINYINT NOT NULL DEFAULT 1,    --Defaults to active  
            SortOrder            INT NOT NULL DEFAULT 0,  
            PrevTarget_ID        INT NULL,                    --For transaction logging  
            PrevTarget_Code        NVARCHAR(250) COLLATE database_default, --For transaction logging  
            Status_ID            INT NOT NULL DEFAULT 1,  
            Status_ErrorCode    NVARCHAR(10) COLLATE database_default NOT NULL DEFAULT N''210000''  
        );  
  
        --Create relationship temporary table - contains the list of new relationships  
        CREATE TABLE #tblRelation  
        (  
            ID                BIGINT IDENTITY (1, 1) NOT NULL,  
            Version_ID        INT NOT NULL,  
            Status_ID        INT NOT NULL DEFAULT 1,  
            Hierarchy_ID    INT NULL,  
            Parent_ID        INT NULL DEFAULT -2,  
            Child_ID        INT NOT NULL DEFAULT -2,  
            ChildType_ID    INT NOT NULL DEFAULT 0,  
            SortOrder        INT NOT NULL DEFAULT 0,  
            LevelNumber        SMALLINT NOT NULL DEFAULT (-1)  
        );  
  
        IF @Batch_ID IS NOT NULL  BEGIN  
            IF NOT EXISTS (SELECT ID FROM mdm.tblStgBatch WHERE ID = @Batch_ID AND Status_ID NOT IN (@Running, @QueueToClear, @Cleared)  
                AND Version_ID = @Version_ID AND Entity_ID = @Entity_ID AND MemberType_ID = @HierarchyMemberTypeID) BEGIN  
                SET @GetNewBatch_ID = @BatchIDNotFound  
            END; --IF  
        END; --IF  
        ELSE BEGIN  
        -- Check if udpEntityStagingFlagForProcessing already assigned a new batch ID (in this case the status is QueuedToRun).  
            SELECT TOP 1 @Batch_ID = ID FROM mdm.tblStgBatch  
                WHERE BatchTag = @BatchTag AND Status_ID = @QueuedToRun  
                AND Version_ID = @Version_ID AND Entity_ID = @Entity_ID AND MemberType_ID = @HierarchyMemberTypeID ORDER BY ID DESC  
  
            IF @Batch_ID IS NULL BEGIN  
                SET @GetNewBatch_ID = @BatchIDForBatchTagNotFound  
            END; --IF  
            ELSE BEGIN  
            -- Set the member count  
                UPDATE mdm.tblStgBatch  
                SET TotalMemberCount = @MemberCount  
                WHERE BatchTag = @BatchTag AND Status_ID = @QueuedToRun  
                            AND Version_ID = @Version_ID AND Entity_ID = @Entity_ID AND MemberType_ID = @HierarchyMemberTypeID  
            END; --IF  
        END; --IF  
  
  
        IF @GetNewBatch_ID IN (@BatchIDNotFound, @BatchIDForBatchTagNotFound) BEGIN  
        -- Create a new batch ID.  
            INSERT INTO mdm.tblStgBatch  
            (MUID  
            ,Version_ID  
            ,Status_ID  
            ,BatchTag  
            ,Entity_ID  
            ,MemberType_ID  
            ,TotalMemberCount  
            ,ErrorMemberCount  
            ,TotalMemberAttributeCount  
            ,ErrorMemberAttributeCount  
            ,TotalMemberRelationshipCount  
            ,ErrorMemberRelationshipCount  
            ,LastRunStartDTM  
            ,LastRunStartUserID  
            ,LastRunEndDTM  
            ,LastRunEndUserID  
            ,LastClearedDTM  
            ,LastClearedUserID  
            ,EnterDTM  
            ,EnterUserID)  
            SELECT  
                NEWID(),  
                @Version_ID,  
                @Running,  
                @BatchTag,  
                @Entity_ID,  
                @HierarchyMemberTypeID,  
                @MemberCount,  
                NULL,  
                NULL,  
                NULL,  
                NULL,  
                NULL,  
                GETUTCDATE(),  
                @User_ID,  
                NULL,  
                NULL,  
                NULL,  
                NULL,  
                GETUTCDATE(),  
                @User_ID  
  
            SELECT @NewBatch_ID = SCOPE_IDENTITY();  
  
            -- Update batch ID.  
  
            IF @GetNewBatch_ID = @BatchIDNotFound BEGIN  
                UPDATE [stg].' + @StagingRelationshipTable + N'  
                SET Batch_ID = @NewBatch_ID  
                WHERE Batch_ID = @Batch_ID AND ImportStatus_ID = @StatusDefault  
            END; --IF  
            ELSE BEGIN  
                UPDATE [stg].' + @StagingRelationshipTable + N'  
                SET Batch_ID = @NewBatch_ID  
                WHERE BatchTag = @BatchTag AND ImportStatus_ID = @StatusDefault  
            END; --IF  
  
            SET @Batch_ID = @NewBatch_ID;  
        END; --IF  
        ELSE BEGIN  
            -- Set the status of the batch as Running.  
            UPDATE mdm.tblStgBatch  
                SET Status_ID = @Running,  
                    TotalMemberCount = @MemberCount,  
                    LastRunStartDTM = GETUTCDATE(),  
                    LastRunStartUserID = @User_ID  
                WHERE ID = @Batch_ID  
        END; --  
    '  
  
    SET @MainSQL = @MainSQL + N'  
        --Error Check all staged members  
  
        --Error 300002 Binary Location 2^8: Child Code does not exist in Entity Table nor Parent Table.  
        UPDATE [stg].' + @StagingRelationshipTable + N'  
            SET ErrorCode = ErrorCode | 256  
            WHERE ChildCode NOT IN  
                (SELECT DISTINCT stgr.ChildCode FROM [stg].' + @StagingRelationshipTable + N' stgr  
                INNER JOIN mdm.' + @EntityTable + N' en ON stgr.ChildCode = en.Code AND en.Status_ID = ' + @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/ + N' /*Active*/  
                WHERE en.Version_ID = @Version_ID)  
                AND ChildCode NOT IN  
                (SELECT DISTINCT stgr.ChildCode FROM [stg].' + @StagingRelationshipTable + N' stgr  
                 INNER JOIN mdm.' + @HierarchyParentTable + N' hp  
                    ON      stgr.ChildCode = hp.Code  
                        AND hp.Status_ID = ' + @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/ + N' -- Active  
                 INNER JOIN mdm.tblHierarchy h -- join with the hierarchy table to validate the hierarchy name  
                    ON      stgr.HierarchyName = h.Name  
                        AND hp.Hierarchy_ID = h.ID  
                 WHERE  
                        hp.Version_ID = @Version_ID  
                    AND h.Entity_ID = @Entity_ID  
                )  
                AND ImportStatus_ID = @StatusDefault AND Batch_ID = @Batch_ID;  
  
        --Error 300002 Binary Location 2^8: Parent Code does not exist in Parent Table when RelationshipType is 1 (parent).  
        UPDATE [stg].' + @StagingRelationshipTable + N'  
            SET ErrorCode = ErrorCode | 256  
            WHERE ParentCode <> N''ROOT'' AND ParentCode NOT IN  
                (SELECT DISTINCT stgr.ParentCode FROM [stg].' + @StagingRelationshipTable + N' stgr  
                 INNER JOIN mdm.' + @HierarchyParentTable + N' hp  
                    ON      stgr.ParentCode = hp.Code  
                        AND hp.Status_ID = ' + @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/ + N' -- Active  
                 INNER JOIN mdm.tblHierarchy h -- join with the hierarchy table to validate the hierarchy name  
                    ON      stgr.HierarchyName = h.Name  
                        AND hp.Hierarchy_ID = h.ID  
                 WHERE  
                        hp.Version_ID = @Version_ID  
                    AND h.Entity_ID = @Entity_ID  
                )  
                AND ImportStatus_ID = @StatusDefault AND Batch_ID = @Batch_ID AND RelationshipType = 1;  
  
        --Error 210011 Binary Location 2^11: When RelationshipType is 1 (parent) the ParentCode cannot be a leaf member.  
        UPDATE [stg].' + @StagingRelationshipTable + N'  
            SET ErrorCode = ErrorCode | 2048  
            WHERE ParentCode IN  
                (SELECT DISTINCT stgr.ParentCode FROM [stg].' + @StagingRelationshipTable + N' stgr  
                INNER JOIN mdm.' + @EntityTable + N' en ON stgr.ParentCode = en.Code AND en.Status_ID = ' + @MemberStatus_Active/*DO NOT replace this hardcoded value with a var. It would be bad for perf*/ + N'/*Active*/  
                WHERE en.Version_ID = @Version_ID)  
                AND ImportStatus_ID = @StatusDefault AND Batch_ID = @Batch_ID AND RelationshipType = 1;  
  
        --Error 210015 Binary Location 2^12: The MemberCode exists multiple times in the staging table for a hierarchy and a batch.  
        INSERT INTO @tblDuplicatedCodeInHierarchy (ChildCode, HierarchyName)  
        SELECT ChildCode, HierarchyName  
            FROM [stg].' + @StagingRelationshipTable + N'  
            WHERE ImportStatus_ID = @StatusDefault AND Batch_ID = @Batch_ID  
            GROUP BY ChildCode, HierarchyName having COUNT(*) > 1;  
  
        UPDATE stgr  
            SET ErrorCode = ErrorCode | 4096  
            FROM [stg].' + @StagingRelationshipTable + N' stgr  
            INNER JOIN @tblDuplicatedCodeInHierarchy dup  
            ON stgr.ChildCode = dup.ChildCode  
            AND stgr.HierarchyName = dup.HierarchyName  
            WHERE stgr.ImportStatus_ID = @StatusDefault AND stgr.Batch_ID = @Batch_ID;  
  
        --Error 210032 Binary Location 2^4: The HierarchyName is missing or invalid.  
        UPDATE [stg].' + @StagingRelationshipTable + N'  
            SET ErrorCode = ErrorCode | 16  
            Where LEN(COALESCE(HierarchyName, N'''')) = 0  
                AND ImportStatus_ID = @StatusDefault AND Batch_ID = @Batch_ID;  
  
        UPDATE [stg].' + @StagingRelationshipTable + N'  
            SET ErrorCode = ErrorCode | 16  
            WHERE LEN(COALESCE(HierarchyName, N'''')) > 0 AND HierarchyName NOT IN  
                (SELECT DISTINCT [Name] FROM mdm.tblHierarchy  
                WHERE Entity_ID = @Entity_ID)  
                AND ImportStatus_ID = @StatusDefault AND Batch_ID = @Batch_ID;  
  
        --Error 210035 Binary Location 2^5: Child Code is required.  
        UPDATE [stg].' + @StagingRelationshipTable + N'  
            SET ErrorCode = ErrorCode | 32  
            WHERE LEN(COALESCE(ChildCode, N'''')) = 0  
                AND ImportStatus_ID = @StatusDefault AND Batch_ID = @Batch_ID;  
  
        --Error 210041 Binary Location 2^6: ROOT is not a valid Child Code  
        UPDATE [stg].' + @StagingRelationshipTable + N'  
            SET ErrorCode = ErrorCode | 64  
            WHERE ChildCode = N''ROOT'' AND ImportStatus_ID = @StatusDefault AND Batch_ID = @Batch_ID;  
  
        --Error 210042 Binary Location 2^7: MDMUnused is not a valid Child Code  
        UPDATE [stg].' + @StagingRelationshipTable + N'  
            SET ErrorCode = ErrorCode | 128  
            WHERE ChildCode = ''MDMUnused'' AND ImportStatus_ID = @StatusDefault AND Batch_ID = @Batch_ID;  
  
        --Error 210043 Binary Location 2^14: The RelationshipType must be 1 (parent) or 2 (sibling)  
        UPDATE [stg].' + @StagingRelationshipTable + N'  
            SET ErrorCode = ErrorCode | 16384  
            WHERE RelationshipType <> 1 AND RelationshipType <> 2 AND ImportStatus_ID = @StatusDefault AND Batch_ID = @Batch_ID;  
  
        --Error 210035 Binary Location 2^5: Parent Code is required.  
        UPDATE [stg].' + @StagingRelationshipTable + N'  
            SET ErrorCode = ErrorCode | 32  
            WHERE LEN(COALESCE(ParentCode, N'''')) = 0 AND ImportStatus_ID = @StatusDefault AND Batch_ID = @Batch_ID;  
  
        --Error 210046 Binary Location 2^15: The member cannot be a sibling of ROOT.  
        UPDATE [stg].' + @StagingRelationshipTable + N'  
            SET ErrorCode = ErrorCode | 32768  
            WHERE ParentCode = N''ROOT'' AND RelationshipType = 2 AND ImportStatus_ID = @StatusDefault AND Batch_ID = @Batch_ID;  
  
        --Error 210047 Binary Location 2^16: The member cannot be a sibling of Unused.  
        UPDATE [stg].' + @StagingRelationshipTable + N'  
            SET ErrorCode = ErrorCode | 65536  
            WHERE ParentCode = ''MDMUnused'' AND RelationshipType = 2 AND ImportStatus_ID = @StatusDefault AND Batch_ID = @Batch_ID;  
  
        --Error 210048 Binary Location 2^17: Parent Code and Child Code cannot be the same.  
        UPDATE [stg].' + @StagingRelationshipTable + N'  
            SET ErrorCode = ErrorCode | 131072  
            WHERE Upper(ParentCode) = Upper(ChildCode) AND ImportStatus_ID = @StatusDefault AND Batch_ID = @Batch_ID;'  
  
    SET @MainSQL = @MainSQL + N'  
        --Set ImportStatus on all records with at least one error  
        UPDATE [stg].' + @StagingRelationshipTable + N'  
            SET ImportStatus_ID = @StatusError  
            WHERE ErrorCode > 0 AND ImportStatus_ID = @StatusDefault AND Batch_ID = @Batch_ID;  
  
        --Process Insert all new error free records into MDS internal table  
        UPDATE [stg].' + @StagingRelationshipTable + N'  
            SET ImportStatus_ID = @StatusProcessing  
            WHERE ImportStatus_ID = @StatusDefault AND Batch_ID = @Batch_ID;  
  
  
        --Identify entities and hierarchies (for recalculating level numbers and sort orders)  
        INSERT INTO @tblHierarchy  
        SELECT DISTINCT hr.ID  
        FROM [stg].' + @StagingRelationshipTable + N' stgr  
        LEFT OUTER JOIN mdm.tblHierarchy hr ON stgr.HierarchyName = hr.Name AND hr.Entity_ID = @Entity_ID  
        WHERE hr.ID IS NOT NULL AND hr.ID > 0  
        AND stgr.ImportStatus_ID = @StatusProcessing AND stgr.Batch_ID = @Batch_ID;  
  
        --Identify entities and hierarchies  
        INSERT INTO @tblMeta  
        (  
            Hierarchy_ID, Hierarchy_IsMandatory, TargetType_ID  
        )  
        SELECT DISTINCT  
            hr.ID,  
            hr.IsMandatory,  
            stgr.RelationshipType  
        FROM [stg].' + @StagingRelationshipTable + N' stgr  
        INNER JOIN mdm.tblHierarchy hr  
        ON stgr.HierarchyName = hr.Name AND hr.Entity_ID = @Entity_ID  
        WHERE hr.ID IS NOT NULL AND hr.ID > 0  
        AND stgr.ImportStatus_ID = @StatusProcessing AND stgr.Batch_ID = @Batch_ID;  
  
        --Iterate through the meta table  
        WHILE EXISTS(SELECT 1 FROM @tblMeta) BEGIN  
  
            SELECT TOP 1  
                @Meta_ID = ID,  
                @Hierarchy_ID = Hierarchy_ID,  
                @Hierarchy_IsMandatory = Hierarchy_IsMandatory,  
                @TargetType_ID = TargetType_ID  
            FROM @tblMeta;  
    '  
    SET @MainSQL = @MainSQL + N'  
            --Populate temporary staging table  
            INSERT INTO #tblStage  
            (  
                Stage_ID, Member_ID, Member_Code, TargetType_ID, Target_ID, Target_Code, SortOrder  
            )  
            SELECT  
                stgr.ID,  
                -2,  
                stgr.ChildCode,  
                stgr.RelationshipType,  
                CASE  
                    WHEN stgr.ParentCode = N''ROOT'' THEN 0  
                    WHEN stgr.ParentCode = N''MDMUNUSED'' AND hr.IsMandatory = 0 THEN -1  
                    ELSE -2  
                END,  
                stgr.ParentCode,  
                CASE  
                    WHEN stgr.SortOrder IS NULL THEN 0  
                    ELSE stgr.SortOrder  
                END  
            FROM [stg].' + @StagingRelationshipTable + N' stgr  
            INNER JOIN mdm.tblHierarchy hr  
            ON stgr.HierarchyName = hr.Name AND hr.Entity_ID = @Entity_ID  
            WHERE  
                hr.ID = @Hierarchy_ID  
                AND stgr.RelationshipType = @TargetType_ID  
                AND stgr.ImportStatus_ID = @StatusProcessing  
                AND stgr.Batch_ID = @Batch_ID  
            ORDER BY  
                stgr.ID DESC; --To accommodate multiple moves for the same member load the most recent data first.  
            /*  
            ------------------------  
            FETCH SOURCE MEMBER DATA  
            ------------------------  
            */  
  
            --Update temporary table with Member_ID, Member_MUID, MemberStatus_ID, and ChildType_ID = 1 (EN)  
            UPDATE tStage SET  
                Member_ID = tSource.ID,  
                Member_MUID = tSource.MUID,  
                MemberStatus_ID = tSource.Status_ID,  
                ChildType_ID = 1 -- Leaf  
            FROM #tblStage AS tStage  
            INNER JOIN mdm.' + @EntityTable + N' AS tSource  
                ON tStage.Member_Code = tSource.Code  
            WHERE tSource.Version_ID = @Version_ID;  
  
            --Update temporary table with Member_ID, Member_MUID, MemberStatus_ID, and ChildType_ID = 2 (HP)  
            UPDATE tStage SET  
                Member_ID = tSource.ID,  
                Member_MUID = tSource.MUID,  
                MemberStatus_ID = tSource.Status_ID,  
                ChildType_ID = 2 -- Parent  
            FROM #tblStage AS tStage  
            INNER JOIN mdm.' + @HierarchyParentTable + N' AS tSource  
                ON tStage.Member_Code = tSource.Code  
            WHERE tSource.Version_ID = @Version_ID  
            AND tSource.Hierarchy_ID = @Hierarchy_ID;  
  
            --Delete soft-deleted records for children that need to be staged  
            --We would rather insert new records than ressurect existing ones to  
            --avoid issues with SortOrder  
            --Leaf members  
            DELETE FROM mdm.' + @HierarchyRelationshipTable + N'  
            WHERE Hierarchy_ID = @Hierarchy_ID AND  
                  Version_ID = @Version_ID AND  
                  Status_ID = @MemberStatus_Deactivated AND  
                  Child_EN_ID IN (SELECT Member_ID FROM #tblStage WHERE ChildType_ID = @LeafMemberTypeID);  
  
            --Consolidated members  
            DELETE FROM mdm.' + @HierarchyRelationshipTable + N'  
            WHERE Hierarchy_ID = @Hierarchy_ID AND  
                  Version_ID = @Version_ID AND  
                  Status_ID = @MemberStatus_Deactivated AND  
                  Child_EN_ID IN (SELECT Member_ID FROM #tblStage WHERE ChildType_ID = @ConsolidatedMemberTypeID);  
    '  
    SET @MainSQL = @MainSQL + N'  
            /*  
            ------------------------  
            FETCH TARGET MEMBER DATA  
            ------------------------  
            */  
  
            --Process hierarchy; target may be a leaf (if a sibling) or a consolidation  
  
            --Update temporary table with Target_ID, TargetStatus_ID, and TargetMemberType_ID = 1 (leaf)  
            UPDATE tStage SET  
                Target_ID = tSource.ID,  
                TargetStatus_ID = tSource.Status_ID,  
                TargetMemberType_ID = 1  
            FROM #tblStage AS tStage  
            INNER JOIN mdm.' + @EntityTable + N' AS tSource  
                ON tStage.Target_Code = tSource.Code  
            WHERE tSource.Version_ID = @Version_ID;  
  
            --Update temporary table with Target_ID, TargetStatus_ID, and TargetMemberType_ID = 2 (consolidated)  
            UPDATE tStage SET  
                Target_ID = tSource.ID,  
                TargetStatus_ID = tSource.Status_ID,  
                TargetMemberType_ID = 2  
            FROM #tblStage AS tStage  
            INNER JOIN mdm.' + @HierarchyParentTable + N' AS tSource  
                ON tStage.Target_Code = tSource.Code  
            WHERE tSource.Version_ID = @Version_ID  
                AND tSource.Hierarchy_ID = @Hierarchy_ID;  
  
            --If the target is a sibling (@TargetType_ID is 2) then reassign the target ID (fetch the parent ID of the target) and assign the sort order of the sibling  
            IF @TargetType_ID = 2 BEGIN  
  
                UPDATE tStage SET  
                     Target_ID = tRel.Parent_HP_ID  
                    ,SortOrder = tRel.SortOrder  
                FROM #tblStage AS tStage  
                INNER JOIN mdm.' + @HierarchyRelationshipTable + N' AS tRel  
                    ON tStage.TargetMemberType_ID = tRel.ChildType_ID  
                    AND tStage.Target_ID = CASE tStage.TargetMemberType_ID  
                        WHEN 1 THEN tRel.Child_EN_ID -- Leaf  
                        WHEN 2 THEN tRel.Child_HP_ID -- Consolidated  
                    END --case  
                WHERE tRel.Version_ID = @Version_ID  
                    AND tRel.Hierarchy_ID = @Hierarchy_ID;  
  
            END; --if  
    '  
    SET @MainSQL = @MainSQL + N'  
            --EN  
            UPDATE tStage SET  
                Relationship_ID = tSource.ID  
            FROM #tblStage AS tStage  
            INNER JOIN mdm.' + @HierarchyRelationshipTable + N' AS tSource  
                ON tStage.ChildType_ID = tSource.ChildType_ID  
                AND tStage.Member_ID = tSource.Child_EN_ID  
            WHERE tSource.Version_ID = @Version_ID  
                AND tStage.ChildType_ID = 1 -- Leaf  
                AND tSource.Hierarchy_ID = @Hierarchy_ID;  
  
            --HP  
            UPDATE tStage SET  
                Relationship_ID = tSource.ID  
            FROM #tblStage AS tStage  
            INNER JOIN mdm.' + @HierarchyRelationshipTable + N' AS tSource  
                ON tStage.ChildType_ID = tSource.ChildType_ID  
                AND tStage.Member_ID = tSource.Child_HP_ID  
            WHERE tSource.Version_ID = @Version_ID  
                AND tStage.ChildType_ID = 2 -- Consolidated  
                AND tSource.Hierarchy_ID = @Hierarchy_ID;  
  
            IF @TargetType_ID = 1 BEGIN  
                --EN  
                --Warning - redundant assignment; transaction will not be logged  
                UPDATE tStage SET  
                    Status_ID = 3  
                FROM #tblStage AS tStage  
                INNER JOIN mdm.' + @HierarchyRelationshipTable + N' AS tSource  
                    ON tStage.ChildType_ID = tSource.ChildType_ID  
                    AND tStage.Member_ID = tSource.Child_EN_ID  
                    AND tStage.Target_ID = tSource.Parent_HP_ID  
                WHERE tSource.Version_ID = @Version_ID  
                    AND tStage.ChildType_ID = 1 -- Leaf  
                    AND tStage.Status_ID = 1  
                    AND tSource.Hierarchy_ID = @Hierarchy_ID;  
                --HP  
                --Warning - redundant assignment; transaction will not be logged  
                UPDATE tStage SET  
                    Status_ID = 3  
                FROM #tblStage AS tStage  
                INNER JOIN mdm.' + @HierarchyRelationshipTable + N' AS tSource  
                    ON tStage.ChildType_ID = tSource.ChildType_ID  
                    AND tStage.Member_ID = tSource.Child_HP_ID  
                    AND tStage.Target_ID = tSource.Parent_HP_ID  
                WHERE tSource.Version_ID = @Version_ID  
                    AND tStage.ChildType_ID = 2 --- Consolidated  
                    AND tStage.Status_ID = 1  
                    AND tSource.Hierarchy_ID = @Hierarchy_ID;  
  
            END; --if  
  
            --Mark new records  
            UPDATE #tblStage SET  
                Status_ID = 4  
            WHERE Status_ID = 1 AND Relationship_ID = -1;  
  
            --Mark records to be removed (moving to Unused for non-mandatory hierarchies)  
            UPDATE #tblStage SET  
                Status_ID = 5  
            WHERE Target_ID = -1 AND Status_ID = 1;  
  
    '  
    IF @TransactionLogType = @TransactionLogType_Attribute  
    BEGIN  
        SET @MainSQL = @MainSQL + N'  
  
            /*  
            --------------------------------------------  
            FETCH PRIOR VALUES (FOR TRANSACTION LOGGING)  
            --------------------------------------------  
            If logging is requested then insert into the transaction log  
            */  
  
            IF @LogFlag = 1 BEGIN  
  
                --Fetch previous target ID from relationship table  
                UPDATE tStage SET  
                    PrevTarget_ID = tSource.Parent_HP_ID  
                FROM #tblStage AS tStage  
                INNER JOIN mdm.' + @HierarchyRelationshipTable + N' AS tSource  
                    ON tStage.Relationship_ID = tSource.ID  
                WHERE tSource.Version_ID = @Version_ID  
                    AND tStage.Status_ID = 1  
                    AND tSource.Hierarchy_ID = @Hierarchy_ID;  
  
                --Fetch previous target code from hierarchy parent table  
                UPDATE tStage SET  
                    PrevTarget_Code = tSource.Code  
                FROM #tblStage AS tStage  
                INNER JOIN mdm.' + @HierarchyParentTable + N' AS tSource  
                    ON tStage.PrevTarget_ID = tSource.ID  
                WHERE tSource.Version_ID = @Version_ID  
                    AND tStage.Status_ID = 1;  
  
            END; --if'  
    END  
  
    SET @MainSQL = @MainSQL + N'  
            SET @Now = GETUTCDATE();  
  
            /*  
              ---------------------------  
              UPDATE RELATIONSHIP RECORDS  
              ---------------------------  
              Update mdm.tblHR with the new relationship records.  
              Assign the SortOrder = Stage_ID for parent assignments (to force ordering of relationships by data entry).  
              Assign the SortOrder = sibling sort order for sibling assignments.  
              This step is only pertinent for hierarchies; collection relationships support redundancy (i.e., more than one of the same member).  
            */'  
  
    IF @TransactionLogType != @TransactionLogType_Member  
    BEGIN  
        SET @MainSQL = @MainSQL + N'  
            --EN  
            UPDATE tSource SET  
                 Parent_HP_ID = NULLIF(tStage.Target_ID, 0)  
                ,ValidationStatus_ID = @AwaitingRevalidation  
                ,LastChgDTM = @Now  
                ,LevelNumber = -1  
                ,LastChgUserID = @User_ID  
                ,LastChgVersionID = @Version_ID  
            FROM #tblStage AS tStage  
            INNER JOIN mdm.' + @HierarchyRelationshipTable + N' AS tSource  
                ON tStage.ChildType_ID = tSource.ChildType_ID  
                AND tStage.Member_ID = tSource.Child_EN_ID  
            WHERE tSource.Version_ID = @Version_ID  
                AND tStage.ChildType_ID = 1 -- Leaf  
                AND tStage.Status_ID = 1  
                AND tSource.Hierarchy_ID = @Hierarchy_ID;  
  
            --HP  
            UPDATE tSource SET  
                 Parent_HP_ID = NULLIF(tStage.Target_ID, 0)  
                ,ValidationStatus_ID = @AwaitingRevalidation  
                ,LastChgDTM = @Now  
                ,LevelNumber = -1  
                ,LastChgUserID = @User_ID  
                ,LastChgVersionID = @Version_ID  
            FROM #tblStage AS tStage  
            INNER JOIN mdm.' + @HierarchyRelationshipTable + N' AS tSource  
                ON tStage.ChildType_ID = tSource.ChildType_ID  
                AND tStage.Member_ID = tSource.Child_HP_ID  
            WHERE tSource.Version_ID = @Version_ID  
                AND tStage.ChildType_ID = 2 --Parent  
                AND tStage.Status_ID = 1  
                AND tSource.Hierarchy_ID = @Hierarchy_ID;';  
    END  
    ELSE  
    BEGIN  
        SET @MainSQL = @MainSQL + N'  
            IF @LogFlag != 1  
            BEGIN  
                --EN  
                UPDATE tSource SET  
                     Parent_HP_ID = NULLIF(tStage.Target_ID, 0)  
                    ,ValidationStatus_ID = @AwaitingRevalidation  
                    ,LastChgDTM = @Now  
                    ,LevelNumber = -1  
                    ,LastChgUserID = @User_ID  
                    ,LastChgVersionID = @Version_ID  
                FROM #tblStage AS tStage  
                INNER JOIN mdm.' + @HierarchyRelationshipTable + N' AS tSource  
                    ON tStage.ChildType_ID = tSource.ChildType_ID  
                    AND tStage.Member_ID = tSource.Child_EN_ID  
                WHERE tSource.Version_ID = @Version_ID  
                    AND tStage.ChildType_ID = 1 -- Leaf  
                    AND tStage.Status_ID = 1  
                    AND tSource.Hierarchy_ID = @Hierarchy_ID;  
  
                --HP  
                UPDATE tSource SET  
                     Parent_HP_ID = NULLIF(tStage.Target_ID, 0)  
                    ,ValidationStatus_ID = @AwaitingRevalidation  
                    ,LastChgDTM = @Now  
                    ,LevelNumber = -1  
                    ,LastChgUserID = @User_ID  
                    ,LastChgVersionID = @Version_ID  
                FROM #tblStage AS tStage  
                INNER JOIN mdm.' + @HierarchyRelationshipTable + N' AS tSource  
                    ON tStage.ChildType_ID = tSource.ChildType_ID  
                    AND tStage.Member_ID = tSource.Child_HP_ID  
                WHERE tSource.Version_ID = @Version_ID  
                    AND tStage.ChildType_ID = 2 --Parent  
                    AND tStage.Status_ID = 1  
                    AND tSource.Hierarchy_ID = @Hierarchy_ID;  
            END  
            ELSE  
            BEGIN  
                --EN  
                UPDATE tSource SET  
                        Parent_HP_ID = NULLIF(tStage.Target_ID, 0)  
                    ,ValidationStatus_ID = @AwaitingRevalidation  
                    ,LastChgDTM = @Now  
                    ,LevelNumber = -1  
                    ,LastChgUserID = @User_ID  
                    ,LastChgVersionID = @Version_ID ' + @HRHistoryOutputQuery + N'  
                FROM #tblStage AS tStage  
                INNER JOIN mdm.' + @HierarchyRelationshipTable + N' AS tSource  
                    ON tStage.ChildType_ID = tSource.ChildType_ID  
                    AND tStage.Member_ID = tSource.Child_EN_ID  
                WHERE tSource.Version_ID = @Version_ID  
                    AND tStage.ChildType_ID = 1 -- Leaf  
                    AND tStage.Status_ID = 1  
                    AND tSource.Hierarchy_ID = @Hierarchy_ID;  
  
                --HP  
                UPDATE tSource SET  
                        Parent_HP_ID = NULLIF(tStage.Target_ID, 0)  
                    ,ValidationStatus_ID = @AwaitingRevalidation  
                    ,LastChgDTM = @Now  
                    ,LevelNumber = -1  
                    ,LastChgUserID = @User_ID  
                    ,LastChgVersionID = @Version_ID ' + @HRHistoryOutputQuery + N'  
                FROM #tblStage AS tStage  
                INNER JOIN mdm.' + @HierarchyRelationshipTable + N' AS tSource  
                    ON tStage.ChildType_ID = tSource.ChildType_ID  
                    AND tStage.Member_ID = tSource.Child_HP_ID  
                WHERE tSource.Version_ID = @Version_ID  
                    AND tStage.ChildType_ID = 2 --Parent  
                    AND tStage.Status_ID = 1  
                    AND tSource.Hierarchy_ID = @Hierarchy_ID;  
            END';  
    END  
    SET @MainSQL = @MainSQL + N'  
            /*  
            ---------------------------  
            DELETE RELATIONSHIP RECORDS  
            ---------------------------  
            Update mdm.tblHR - remove records where the target is unused  
            */'  
      
    IF @TransactionLogType != @TransactionLogType_Member  
    BEGIN  
        SET @MainSQL = @MainSQL + N'  
            UPDATE mdm.' + @HierarchyRelationshipTable + N'  
            SET Status_ID = @MemberStatus_Deactivated  
               ,LastChgDTM = @Now  
               ,LastChgUserID = @User_ID  
               ,LastChgVersionID = @Version_ID  
            WHERE ID IN (SELECT Relationship_ID FROM #tblStage WHERE Status_ID = 5)  
                AND Version_ID = @Version_ID;'  
    END  
    ELSE  
    BEGIN  
        SET @MainSQL = @MainSQL + N'  
            IF @LogFlag != 1  
            BEGIN  
                UPDATE mdm.' + @HierarchyRelationshipTable + N'  
                SET Status_ID = @MemberStatus_Deactivated  
                   ,LastChgDTM = @Now  
                   ,LastChgUserID = @User_ID  
                   ,LastChgVersionID = @Version_ID  
                WHERE ID IN (SELECT Relationship_ID FROM #tblStage WHERE Status_ID = 5)  
                    AND Version_ID = @Version_ID;  
            END  
            ELSE  
            BEGIN  
                UPDATE mdm.' + @HierarchyRelationshipTable + N'  
                SET Status_ID = @MemberStatus_Deactivated  
                   ,LastChgDTM = @Now  
                   ,LastChgUserID = @User_ID  
                   ,LastChgVersionID = @Version_ID ' + @HRHistoryOutputQuery + N'  
                WHERE ID IN (SELECT Relationship_ID FROM #tblStage WHERE Status_ID = 5)  
                    AND Version_ID = @Version_ID;  
            END'  
    END  
    SET @MainSQL = @MainSQL + N'  
            /*  
            ----------------------------------------------------------  
            UPDATE SortOrder previously inserted from udpStgMemberSave  
            ----------------------------------------------------------  
            */  
            SET @MaxSortOrderRelationship = 0;  
            SET @MaxSortOrderStaging = 0;  
  
            -- Get the maximum Sort Order for the existing records in the HR table  
            SELECT @MaxSortOrderRelationship = MAX(tSource.SortOrder)  
                    FROM mdm.' + @HierarchyRelationshipTable + N' AS tSource  
                        INNER JOIN #tblStage tStage1  
                        ON tStage1.ChildType_ID = tSource.ChildType_ID  
                    WHERE NOT EXISTS (SELECT tStage.Member_ID  
                        FROM #tblStage AS tStage  
                            WHERE tStage.Member_ID = tSource.Child_EN_ID  )  
                            AND tSource.Hierarchy_ID = @Hierarchy_ID  
                            AND tSource.Status_ID = 1;  
  
            -- Get the maximum Sort Order for the records to be inserted in the staging table  
            SELECT @MaxSortOrderStaging = MAX(tStage.SortOrder)  
                     FROM #tblStage AS tStage  
                        INNER JOIN mdm.' + @HierarchyRelationshipTable + N' AS tSource  
                        ON tStage.Relationship_ID = tSource.ID  
                    WHERE tSource.Hierarchy_ID = @Hierarchy_ID;'  
  
    IF @TransactionLogType != @TransactionLogType_Member  
    BEGIN  
        SET @MainSQL = @MainSQL + N'  
            UPDATE tSource  
            SET tSource.SortOrder =  
                CASE WHEN @MaxSortOrderStaging <= @MaxSortOrderRelationship THEN tStage.SortOrder + @MaxSortOrderRelationship  
                ELSE tStage.SortOrder  
                END,  
                ValidationStatus_ID = @AwaitingRevalidation  
            FROM mdm.' + @HierarchyRelationshipTable + N' AS tSource  
                INNER JOIN #tblStage AS tStage ON  
                tStage.Relationship_ID = tSource.ID;'  
    END  
    ELSE  
    BEGIN  
        SET @MainSQL = @MainSQL + N'  
            IF @LogFlag != 1  
            BEGIN  
                UPDATE tSource  
                SET tSource.SortOrder =  
                    CASE WHEN @MaxSortOrderStaging <= @MaxSortOrderRelationship THEN tStage.SortOrder + @MaxSortOrderRelationship  
                    ELSE tStage.SortOrder  
                    END,  
                    ValidationStatus_ID = @AwaitingRevalidation  
                FROM mdm.' + @HierarchyRelationshipTable + N' AS tSource  
                    INNER JOIN #tblStage AS tStage ON  
                    tStage.Relationship_ID = tSource.ID;  
            END  
            ELSE  
            BEGIN  
                UPDATE tSource  
                SET tSource.SortOrder =  
                    CASE WHEN @MaxSortOrderStaging <= @MaxSortOrderRelationship THEN tStage.SortOrder + @MaxSortOrderRelationship  
                    ELSE tStage.SortOrder  
                    END,  
                    ValidationStatus_ID = @AwaitingRevalidation ' + @HRHistoryOutputQuery + N'  
                FROM mdm.' + @HierarchyRelationshipTable + N' AS tSource  
                    INNER JOIN #tblStage AS tStage ON  
                    tStage.Relationship_ID = tSource.ID;  
            END'  
    END  
    SET @MainSQL = @MainSQL + N'  
  
            /*  
            -------------------------------  
            INSERT NEW RELATIONSHIP RECORDS  
            -------------------------------  
            */  
  
            --Insert into the hierarchy temporary table (necessary to generate key values)  
            --Added a DISTINCT to eliminate potential duplicate records for collections  
  
            INSERT INTO #tblRelation  
            (  
                Version_ID,  
                Hierarchy_ID,  
                Parent_ID,  
                Child_ID,  
                ChildType_ID,  
                SortOrder  
            ) SELECT DISTINCT  
                @Version_ID,  
                @Hierarchy_ID,  
                Target_ID, --Parent_ID  
                Member_ID,  
                ChildType_ID,  
                SortOrder  
            FROM #tblStage  
            WHERE Status_ID = 4;  
  
            --Insert into hierarchy relationship table  
  
            INSERT INTO mdm.' + @HierarchyRelationshipTable + N'  
            (  
                Version_ID,  
                Status_ID,  
                ValidationStatus_ID,  
                Parent_HP_ID,  
                Child_EN_ID,  
                Child_HP_ID,  
                ChildType_ID,  
                SortOrder,  
                EnterDTM,  
                EnterUserID,  
                EnterVersionID,  
                LastChgDTM,  
                LastChgUserID,  
                LastChgVersionID,  
                Hierarchy_ID,  
                LevelNumber)  
    '  
    SET @MainSQL = @MainSQL + N'  
            --Assign the SortOrder = SortOrder from the staging table  
            SELECT  
                Version_ID,  
                Status_ID,  
                @NewAwaitingValidation,  
                NULLIF(Parent_ID, 0), --Parent_HP_ID / Parent_CN_ID  
                CASE WHEN ChildType_ID = 1 THEN Child_ID ELSE NULL END, --EN  
                CASE WHEN ChildType_ID = 2 THEN Child_ID ELSE NULL END, --HP  
                ChildType_ID,  
                SortOrder,  
                @Now,  
                @User_ID ,  
                @Version_ID,  
                @Now,  
                @User_ID ,  
                @Version_ID,  
                Hierarchy_ID,  
                LevelNumber  
            FROM #tblRelation;  
  
            /*  
            --------------------------------------------------------------------------------------------  
            VERIFY THAT RECURSIVE ASSINGMENTS HAVE NOT BEEN ENTERED  
            This can be accomplished by calculating the level number.  
            Any levels that can not be calculated are deemed recursive and will be moved to the Root.  
            --------------------------------------------------------------------------------------------  
            */  
  
            --Calculate level numbers for the current hierarchy  
            EXEC mdm.udpHierarchyMemberLevelSave @Version_ID, @Hierarchy_ID, 0, 2;  
  
            --For those relationships where the LevelNumber = -1 (i.e., can not be calculated) move to Root  
            UPDATE tStage SET  
                Target_ID = PrevTarget_ID,  
                Target_Code = PrevTarget_Code,  
                Status_ID = 6  
            FROM #tblStage AS tStage  
            INNER JOIN mdm.' + @HierarchyRelationshipTable + N' AS tSource  
                ON tStage.Relationship_ID = tSource.ID  
            WHERE tSource.LevelNumber = -1  
                AND tSource.Version_ID = @Version_ID  
                AND tSource.Hierarchy_ID = @Hierarchy_ID  AND tStage.Status_ID = 1;  
  
            -- Set the error code when circular reference is detected.  
            --Error 210016 Binary Location 2^13:  
            UPDATE stgr SET  
                ErrorCode = ErrorCode | 8192,  
                ImportStatus_ID = @StatusError  
            FROM [stg].' + @StagingRelationshipTable + N' AS stgr  
            INNER JOIN #tblStage AS tStage  
                ON stgr.ID = tStage.Stage_ID  
            WHERE tStage.Status_ID = 6;'  
  
    IF @TransactionLogType != @TransactionLogType_Member  
    BEGIN  
        SET @MainSQL = @MainSQL + N'  
            --Reset the source table  
            --EN  
            UPDATE tSource SET  
                 Parent_HP_ID = NULLIF(tStage.PrevTarget_ID, 0),  
                 ValidationStatus_ID = @AwaitingRevalidation  
            FROM #tblStage AS tStage  
            INNER JOIN mdm.' + @HierarchyRelationshipTable + N' AS tSource  
                ON tStage.ChildType_ID = tSource.ChildType_ID  
                AND tStage.Member_ID = tSource.Child_EN_ID  
            WHERE tSource.LevelNumber = -1  
                AND tStage.ChildType_ID = 1  
                AND tSource.Version_ID = @Version_ID  
                AND tSource.Hierarchy_ID = @Hierarchy_ID;  
  
             --Reset the source table  
             --HP  
            UPDATE tSource SET  
                    Parent_HP_ID = NULLIF(tStage.PrevTarget_ID, 0),  
                    ValidationStatus_ID = @AwaitingRevalidation  
            FROM #tblStage AS tStage  
            INNER JOIN mdm.' + @HierarchyRelationshipTable + N' AS tSource  
                ON tStage.ChildType_ID = tSource.ChildType_ID  
                AND tStage.Member_ID = tSource.Child_HP_ID  
            WHERE tSource.LevelNumber = -1  
                AND tStage.ChildType_ID = 2 -- Parent  
                AND tSource.Version_ID = @Version_ID  
                AND tSource.Hierarchy_ID = @Hierarchy_ID;';  
    END  
    ELSE  
    BEGIN  
        SET @MainSQL = @MainSQL + N'  
            IF @LogFlag != 1  
            BEGIN  
                --Reset the source table  
                --EN  
                UPDATE tSource SET  
                     Parent_HP_ID = NULLIF(tStage.PrevTarget_ID, 0),  
                     ValidationStatus_ID = @AwaitingRevalidation  
                FROM #tblStage AS tStage  
                INNER JOIN mdm.' + @HierarchyRelationshipTable + N' AS tSource  
                    ON tStage.ChildType_ID = tSource.ChildType_ID  
                    AND tStage.Member_ID = tSource.Child_EN_ID  
                WHERE tSource.LevelNumber = -1  
                    AND tStage.ChildType_ID = 1  
                    AND tSource.Version_ID = @Version_ID  
                    AND tSource.Hierarchy_ID = @Hierarchy_ID;  
  
                 --Reset the source table  
                 --HP  
                UPDATE tSource SET  
                        Parent_HP_ID = NULLIF(tStage.PrevTarget_ID, 0),  
                        ValidationStatus_ID = @AwaitingRevalidation  
                FROM #tblStage AS tStage  
                INNER JOIN mdm.' + @HierarchyRelationshipTable + N' AS tSource  
                    ON tStage.ChildType_ID = tSource.ChildType_ID  
                    AND tStage.Member_ID = tSource.Child_HP_ID  
                WHERE tSource.LevelNumber = -1  
                    AND tStage.ChildType_ID = 2 -- Parent  
                    AND tSource.Version_ID = @Version_ID  
                    AND tSource.Hierarchy_ID = @Hierarchy_ID;  
            END  
            ELSE  
            BEGIN  
                --Reset the source table  
                --EN  
                UPDATE tSource SET  
                     Parent_HP_ID = NULLIF(tStage.PrevTarget_ID, 0),  
                     ValidationStatus_ID = @AwaitingRevalidation' + @HRHistoryOutputQuery + N'  
                FROM #tblStage AS tStage  
                INNER JOIN mdm.' + @HierarchyRelationshipTable + N' AS tSource  
                    ON tStage.ChildType_ID = tSource.ChildType_ID  
                    AND tStage.Member_ID = tSource.Child_EN_ID  
                WHERE tSource.LevelNumber = -1  
                    AND tStage.ChildType_ID = 1  
                    AND tSource.Version_ID = @Version_ID  
                    AND tSource.Hierarchy_ID = @Hierarchy_ID;  
  
                 --Reset the source table  
                 --HP  
                UPDATE tSource SET  
                        Parent_HP_ID = NULLIF(tStage.PrevTarget_ID, 0),  
                        ValidationStatus_ID = @AwaitingRevalidation' + @HRHistoryOutputQuery + N'  
                FROM #tblStage AS tStage  
                INNER JOIN mdm.' + @HierarchyRelationshipTable + N' AS tSource  
                    ON tStage.ChildType_ID = tSource.ChildType_ID  
                    AND tStage.Member_ID = tSource.Child_HP_ID  
                WHERE tSource.LevelNumber = -1  
                    AND tStage.ChildType_ID = 2 -- Parent  
                    AND tSource.Version_ID = @Version_ID  
                    AND tSource.Hierarchy_ID = @Hierarchy_ID;   
            END'  
    END  
  
    IF @TransactionLogType = @TransactionLogType_Attribute  
    BEGIN  
        SET @MainSQL = @MainSQL + N'  
            /*  
            ---------------------------  
            PROCESS TRANSACTION LOGGING  
            ---------------------------  
            If logging is requested then insert into the transaction log  
            */  
  
            IF @LogFlag = 1 BEGIN  
                --Log relationship transactions  
                INSERT INTO [mdm].' + QUOTENAME(@TransactionTableName) + N'  
                (  
                    Version_ID,  
                    TransactionType_ID,  
                    OriginalTransaction_ID,  
                    Hierarchy_ID,  
                    Entity_ID,  
                    Member_ID,  
                    Member_MUID,  
                    MemberType_ID,  
                    MemberCode,  
                    OldValue,  
                    OldCode,  
                    NewValue,  
                    NewCode,  
                    Batch_ID,  
                    EnterDTM,  
                    EnterUserID,  
                    LastChgDTM,  
                    LastChgUserID  
                )  
                SELECT  
                    @Version_ID,  
                    CASE TargetType_ID WHEN 1 THEN 4 WHEN 2 THEN 5 ELSE 0 END,  
                    0,  
                    @Hierarchy_ID,  
                    @Entity_ID,  
                    Member_ID,  
                    Member_MUID,  
                    ChildType_ID,  
                    Member_Code,  
                    CASE PrevTarget_ID WHEN NULL THEN -1 ELSE PrevTarget_ID END,  
                    CASE PrevTarget_ID WHEN NULL THEN N''MDMUNUSED'' WHEN -1 THEN N''MDMUNUSED'' WHEN 0 THEN N''ROOT'' ELSE PrevTarget_Code END,  
                    Target_ID,  
                    Target_Code,  
                    @Batch_ID,  
                    GETUTCDATE(),  
                    @User_ID ,  
                    GETUTCDATE(),  
                    @User_ID  
                FROM #tblStage  
                WHERE Status_ID IN (1, 4, 5);  
  
            END; --if  
    '  
    END  
    SET @MainSQL = @MainSQL + N'  
  
            TRUNCATE TABLE #tblStage;  
            TRUNCATE TABLE #tblRelation;  
  
            DELETE FROM @tblMeta WHERE ID = @Meta_ID;  
  
        END; --while  
  
        DROP TABLE #tblStage;  
        DROP TABLE #tblRelation;  
  
        /*  
        ---------------------------------------  
        RECALCULATE HIERARCHY SYSTEM ATTRIBUTES  
        ---------------------------------------  
        */  
        --Iterate through the meta table  
        WHILE EXISTS(SELECT 1 FROM @tblHierarchy) BEGIN  
  
           SELECT TOP 1 @Hierarchy_ID = Hierarchy_ID FROM @tblHierarchy;  
  
           --Recalculate system hierarchy attributes (level number, sort order, and index code)  
           EXEC mdm.udpHierarchySystemAttributesSave @Version_ID, @Hierarchy_ID;  
           DELETE FROM @tblHierarchy WHERE Hierarchy_ID = @Hierarchy_ID;  
  
        END; --while  
  
    '  
        SET @MainSQL = @MainSQL + N'  
        UPDATE [stg].' + @StagingRelationshipTable + '  
        SET ImportStatus_ID = @StatusOK  
        FROM [stg].' + @StagingRelationshipTable + '  
        WHERE ImportStatus_ID = @StatusProcessing;  
  
        --Get the number of errors for the batch ID  
        SELECT @ErrorCount = COUNT(ID) FROM [stg].' + @StagingRelationshipTable + N'  
            WHERE Batch_ID = @Batch_ID AND ImportStatus_ID = @StatusError;  
  
        -- Set the status of the batch as Completed.  
        UPDATE mdm.tblStgBatch  
            SET Status_ID = @Completed,  
                LastRunEndDTM = GETUTCDATE(),  
                LastRunEndUserID = @User_ID,  
                ErrorMemberCount = @ErrorCount  
            WHERE ID = @Batch_ID  
  
        IF @TranCounter = 0 COMMIT TRANSACTION; --Commit only if we are not nested  
  
        RETURN 0;  
  
    END TRY  
    BEGIN CATCH  
        SET NOCOUNT OFF;  
  
        -- Get error info  
        DECLARE  
            @ErrorMessage NVARCHAR(4000),  
            @ErrorSeverity INT,  
            @ErrorState INT,  
            @ErrorNumber INT,  
            @ErrorLine INT,  
            @ErrorProcedure NVARCHAR(126);  
        EXEC mdm.udpGetErrorInfo  
            @ErrorMessage = @ErrorMessage OUTPUT,  
            @ErrorSeverity = @ErrorSeverity OUTPUT,  
            @ErrorState = @ErrorState OUTPUT,  
            @ErrorNumber = @ErrorNumber OUTPUT,  
            @ErrorLine = @ErrorLine OUTPUT,  
            @ErrorProcedure = @ErrorProcedure OUTPUT  
  
        SET @ErrorMessage = CONCAT(@ErrorMessage, N'', @ErrorNumber = '', @ErrorNumber, N'', @ErrorProcedure = "'', @ErrorProcedure, N''", line '', @ErrorLine);  
  
        IF @TranCounter = 0 ROLLBACK TRANSACTION;  
        ELSE IF XACT_STATE() <> -1 ROLLBACK TRANSACTION TX;  
  
        RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);  
        RETURN @OtherRuntimeError;  
  
    END CATCH  
        SET NOCOUNT OFF;  
    END;'  
  
    --SELECT @MainSQL AS [processing-instruction(x)] FOR XML PATH('');  
    EXEC sp_executesql @MainSQL;  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpEntityStagingDeleteErrorDetailViews]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    Drops all the entity staging views to view an error  
    EXEC mdm.udpDeleteEntityStagingErrorDetailViews 21  
*/  
CREATE PROCEDURE [mdm].[udpEntityStagingDeleteErrorDetailViews]  
    @Entity_ID  INT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
AS  
BEGIN  
    DECLARE  
        @StagingBase            sysname,  
        @SQLDropView            NVARCHAR(MAX),  
        @MemberErrorViewName    NVARCHAR(MAX),  
        @RelationErrorViewName  NVARCHAR(MAX);  
  
    SELECT  
        @StagingBase = StagingBase  
        FROM  
            mdm.tblEntity  
        WHERE  
            ID = @Entity_ID;  
      
    SET @MemberErrorViewName = N'stg.' + QUOTENAME('viw_' + @StagingBase + '_MemberErrorDetails');  
    SET @RelationErrorViewName = N'stg.' + QUOTENAME('viw_' + @StagingBase + '_RelationshipErrorDetails');  
  
    SET @SQLDropView = N'  
        IF  EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(' + QUOTENAME(@MemberErrorViewName, N'''') + N'))  
          DROP VIEW ' + @MemberErrorViewName + N'  
        IF  EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(' + QUOTENAME(@RelationErrorViewName, N'''') + N'))  
          DROP VIEW ' + @RelationErrorViewName;  
  
    EXEC(@SQLDropView);  
  
  
END;
GO
/****** Object:  StoredProcedure [mdm].[udpEntityStagingDeleteStoredProcedures]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpEntityStagingDeleteStoredProcedures]  
(    
    @Entity_ID INT,  
    @ProcedureType INT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    --Start transaction, being careful to check if we are nested    
    DECLARE @TranCounter INT;     
    SET @TranCounter = @@TRANCOUNT;    
    IF @TranCounter > 0 SAVE TRANSACTION TX;    
    ELSE BEGIN TRANSACTION;    
    
    BEGIN TRY    
    
        DECLARE @SQL                            NVARCHAR(MAX),  
                @IsHierarchyEnabled             BIT,  
                @LeafSproc                      sysname,  
                @ConsolidatedSproc              sysname,  
                @RelationshipSproc              sysname,  
                -- Types of staging procedures to delete.      
                @AllTypes                       INT = 0,    
                @Leaf                           INT = 1,      
                @Consolidated                   INT = 2,  
                @ConsolidatedAndRelationship    INT = 3,      
                @Relationship                   INT = 4,  
                @StagingBase					NVARCHAR(max) = NULL;  
  
        --Set variables.    
        SET @SQL = N'';  
          
        SELECT  
            @IsHierarchyEnabled  = CASE WHEN HierarchyTable  IS NULL THEN 0 ELSE 1 END,  
            @StagingBase = StagingBase,  
            @LeafSproc = N'udp_' + StagingBase + N'_Leaf',  
            @ConsolidatedSproc = N'udp_' + StagingBase + N'_Consolidated',  
            @RelationshipSproc = N'udp_' + StagingBase + N'_Relationship'  
        FROM  
            mdm.tblEntity WHERE ID = @Entity_ID;  
                      
        IF      (@ProcedureType = @Leaf OR @ProcedureType = @AllTypes)   
            AND EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_TYPE = N'PROCEDURE' AND ROUTINE_SCHEMA = N'stg' AND ROUTINE_NAME = @LeafSproc)  
        BEGIN  
            SET @SQL += N'  
                DROP PROCEDURE stg.' + QUOTENAME(@LeafSproc) + ';';  
        END; -- IF  
          
          
        --Drop Consolidated Entity Based Staging Procedure if the entity supports hierarchies  
        IF @IsHierarchyEnabled = 1   
        BEGIN  
            IF      @ProcedureType IN (@AllTypes, @Consolidated, @ConsolidatedAndRelationship)   
                AND EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_TYPE = N'PROCEDURE' AND ROUTINE_SCHEMA = N'stg' AND ROUTINE_NAME = @ConsolidatedSproc)  
            BEGIN   
                --Drop Consolidated Staging Procedure.  
                SET @SQL += N'  
                    DROP PROCEDURE stg.' + QUOTENAME(@ConsolidatedSproc) + ';';  
            END; --IF  
           
            IF  @ProcedureType IN (@AllTypes, @ConsolidatedAndRelationship, @Relationship)  
                AND EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_TYPE = N'PROCEDURE' AND ROUTINE_SCHEMA = N'stg' AND ROUTINE_NAME = @RelationshipSproc)  
            BEGIN  
                -- Drop Relationship Staging Procedure.  
                SET @SQL += N'  
                    DROP PROCEDURE stg.' + QUOTENAME(@RelationshipSproc) + ';';  
            END; --IF  
        END --IF   
  
        EXEC sp_executesql @SQL;    
    
        --Commit only if we are not nested    
        IF @TranCounter = 0 COMMIT TRANSACTION;    
        RETURN(0);    
            
    END TRY    
    --Compensate as necessary    
    BEGIN CATCH  
        -- Get error info.  
        DECLARE  
            @ErrorMessage NVARCHAR(4000),  
            @ErrorSeverity INT,  
            @ErrorState INT,  
            @ErrorNumber INT,  
            @ErrorLine INT,  
            @ErrorProcedure NVARCHAR(126);  
        EXEC mdm.udpGetErrorInfo  
            @ErrorMessage = @ErrorMessage OUTPUT,  
            @ErrorSeverity = @ErrorSeverity OUTPUT,  
            @ErrorState = @ErrorState OUTPUT,  
            @ErrorNumber = @ErrorNumber OUTPUT,  
            @ErrorLine = @ErrorLine OUTPUT,  
            @ErrorProcedure = @ErrorProcedure OUTPUT  
  
        SET @ErrorMessage = CONCAT(@ErrorMessage, N', @ErrorNumber = ', @ErrorNumber, N', @ErrorProcedure = "', @ErrorProcedure, N'", line ', @ErrorLine);  
  
    
        IF @TranCounter = 0 ROLLBACK TRANSACTION;    
        ELSE IF XACT_STATE() <> -1 ROLLBACK TRANSACTION TX;    
    
        RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);    
    
        RETURN(1);    
    
    END CATCH;      
      
    SET NOCOUNT OFF;    
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpEntityStagingFlagForClearing]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpEntityStagingFlagForClearing]  
	@Batch_ID       INT,  
    @UserID         INT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
WITH EXECUTE AS 'mds_schema_user'  
AS  
BEGIN  
    DECLARE  
		@QueuedToRun				TINYINT = 1,  
 		@Running					TINYINT = 3,  
  		@QueueToClear				TINYINT = 4,  
 		@Cleared					TINYINT = 5,  
        @IsInvalidState             BIT = 1  
  
    SELECT   
        @IsInvalidState =  
        CASE  
            WHEN (Status_ID IN (@Running, @QueuedToRun, @Cleared)) THEN     1  
            ELSE                                                            0  
        END  
    FROM  
        mdm.tblStgBatch  
    WHERE  
        ID = @Batch_ID  
  
    -- No need to update batch information if it is currently queued to run or running or already cleared  
    IF (@IsInvalidState = 1)  
    BEGIN  
        RAISERROR('MDSERR310029|The status of the specified batch is not valid.', 16, 1);  
        RETURN;    			  
    END -- IF  
  
  
    EXEC	[mdm].[udpStagingBatchSave]  
		        @UserID = @UserID,  
		        @StatusID = @QueueToClear,  
                @BatchID = @Batch_ID  
  
END;
GO
/****** Object:  StoredProcedure [mdm].[udpEntityStagingFlagForProcessing]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
-- Creates a new entry in the tblStgBatch table with "QueueToRun" and returns a unique  
-- ID for this batch  
*/  
CREATE PROCEDURE [mdm].[udpEntityStagingFlagForProcessing]  
    @BatchTag           NVARCHAR(50),  
    @UserID             INT,  
    @Entity_ID          INT,  
    @Version_ID         INT,  
    @MemberTypeID       TINYINT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
WITH EXECUTE AS 'mds_schema_user'  
AS  
BEGIN  
  
   DECLARE  
        @ReturnID           INT,  
        @StagingTable       SYSNAME,  
        @SQL                NVARCHAR(MAX),  
        @QueuedToRun        TINYINT = 1,  
        @Running            TINYINT = 3,  
        @IsInvalidState     BIT = 0 -- Default to valid. If the batchtag doesn't exist, it is a perfectly good condition to start one.  
  
    SELECT   
        @IsInvalidState =  
        CASE  
            WHEN (Status_ID IN (@Running, @QueuedToRun)) THEN   1  
            ELSE                                                0  
        END  
    FROM  
        mdm.tblStgBatch  
    WHERE  
        (BatchTag = @BatchTag) AND  
        (Entity_ID = @Entity_ID) AND  
        (Version_ID = @Version_ID) AND  
        (MemberType_ID = @MemberTypeID)  
  
    -- No need to update batch information if it is currently queued to run or running  
    IF (@IsInvalidState = 1)  
    BEGIN  
        RAISERROR('MDSERR310029|The status of the specified batch is not valid.', 16, 1);  
        RETURN;                  
    END -- IF  
  
    EXEC    [mdm].[udpStagingBatchSave]  
                @UserID = @UserID,  
                @VersionID = @Version_ID,  
                @StatusID = @QueuedToRun,  
                @BatchTag = @BatchTag,  
                @EntityID = @Entity_ID,  
                @MemberTypeID = @MemberTypeID,  
                @ReturnID = @ReturnID OUTPUT;  
                  
    -- Update the new batchID in the staging table.  
    SELECT    
        @StagingTable =   
            CASE   
                WHEN @MemberTypeID = 1 THEN -- Leaf member   
                    N'[stg].' + QUOTENAME(StagingBase + N'_Leaf')  
                WHEN @MemberTypeID = 2 THEN -- Consolidated member   
                    N'[stg].' + QUOTENAME(StagingBase + N'_Consolidated')  
                WHEN @MemberTypeID = 4 THEN -- Relationship member   
                    N'[stg].' + QUOTENAME(StagingBase + N'_Relationship')      
            END  
    FROM       
        mdm.tblEntity WHERE ID = @Entity_ID;  
                      
    SET @SQL = N'UPDATE ' + @StagingTable + N'  
                SET Batch_ID = @Batch_ID  
                WHERE IsNULL(BatchTag, N'''') = @BatchTag AND ImportStatus_ID = 0';  
                              
    EXEC sp_executesql @SQL, N'@Batch_ID INT, @BatchTag NVARCHAR(50)', @ReturnID, @BatchTag;  
              
    SELECT    @ReturnID  
END -- Proc
GO
/****** Object:  StoredProcedure [mdm].[udpEntityStagingGetTableColumnDefinitions]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
Returns two result sets:  
    1) Returns the entity EntityStagingTable name.  
    2) Returns an empty resultset that is used to create an empty DataTable for bulk copy operations, using SqlBulkCopy class, for the leaf or consolidated table.  
    3) Returns an empty resultset that is used to create an empty DataTable for bulk copy operations, using SqlBulkCopy class, for the relationship table.  
  
    EXEC mdm.udpEntityStagingGetTableColumnDefinitions 31, 1;  
    EXEC mdm.udpEntityStagingGetTableColumnDefinitions 31, 2;  
*/  
  
CREATE PROCEDURE [mdm].[udpEntityStagingGetTableColumnDefinitions]  
(  
    @Entity_ID                INT,   
    @MemberType_ID            INT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;    
    
    DECLARE   
        @SQL                        NVARCHAR(MAX) = N'',  
        @StagingTableName           sysname,   
        @StagingLeafTable           sysname,  
        @StagingConsolidatedTable   sysname,  
        @StagingRelationshipTable   sysname,  
        @StagingBase                NVARCHAR(MAX),  
        @IsHierarchyEnabled         BIT,  
        @MemberType_Leaf            TINYINT = 1,  
        @MemberType_Consolidated    TINYINT = 2;  
                         
    --Invalid @MemberType_ID    
    IF @MemberType_ID NOT IN (1, 2) --Invalid MemberType    
    BEGIN    
        RAISERROR('MDSERR310044|Error while getting staging table column definitions.  Invalid Member Type.', 16, 1);  
        RETURN;    
    END; --if    
    
    --Invalid @MemberType_ID for THIS entity    
    IF      @MemberType_ID = @MemberType_Consolidated  
        AND NOT EXISTS(SELECT 1 FROM mdm.tblEntity WHERE ID = @Entity_ID AND HierarchyTable IS NOT NULL)--Invalid MemberType    
    BEGIN    
        RAISERROR('MDSERR310045|Error while getting staging table column definitions. Invalid Member Type for this entity.', 16, 1);  
        RETURN;    
    END; --if    
    
   
    -- Validate @Entity_ID    
    ;    
    DECLARE @result INT;  
    EXECUTE @result = mdm.udpIDParameterCheck @Entity_ID, 5, NULL, NULL, 1;    
    DECLARE @IsValidParam BIT = CONVERT(BIT, @result)  
    IF (@IsValidParam = 0)    
    BEGIN    
        RAISERROR('MDSERR310046|Error while getting staging table column definitions. Invalid Entity ID.', 16, 1);  
        RETURN;    
    END; --if  
      
    BEGIN TRY  
        --Get the appropriate Staging table name       
        SELECT  
            @StagingLeafTable = StagingLeafName,  
            @StagingConsolidatedTable = StagingConsolidatedName,  
            @StagingRelationshipTable = StagingRelationshipName,   
            @StagingBase = StagingBase,  
            @IsHierarchyEnabled  = CASE WHEN HierarchyTable IS NULL THEN 0 ELSE 1 END  
        FROM mdm.tblEntity  
        WHERE ID = @Entity_ID;  
  
        IF @MemberType_ID = 1  
            SET @StagingTableName = @StagingLeafTable  
        ELSE  
            SET @StagingTableName = @StagingConsolidatedTable  
              
        -- Check if staging table exists when StagingBase is specified (when the entity is not a system entity).  
        DECLARE @StagingTableObjectID INT = OBJECT_ID(N'stg.' + quotename(@StagingTableName));  
        IF  COALESCE(@StagingBase, N'') <> N'' AND EXISTS (SELECT * FROM sys.objects WHERE object_id = @StagingTableObjectID AND type in (N'U')) BEGIN  
            SELECT  
                @SQL = @SQL + N', ' + quotename(att.Attribute_Name)   
            FROM  
                mdm.viw_SYSTEM_SCHEMA_ATTRIBUTES att  
            WHERE  
                att.Entity_ID = @Entity_ID AND  
                att.Attribute_MemberType_ID = @MemberType_ID AND  
                (att.Attribute_IsSystem = 0 OR   
                 att.Attribute_IsCode = 1 OR   
                 att.Attribute_IsName = 1)  
  
            SELECT   
                 N'stg.' + quotename(@StagingTableName) AS EntityStagingTableName  
                ,N'stg.' + quotename(@StagingRelationshipTable) AS EntityStagingRelationshipTableName  
  
            IF @MemberType_ID = @MemberType_Consolidated  
            BEGIN  
                SET @SQL += N', HierarchyName'  
            END  
  
            SELECT @SQL = N'SELECT ImportType, Batch_ID, BatchTag ' + @SQL + N' FROM stg.' + quotename(@StagingTableName) + N' WHERE 1 = 0';  
            --PRINT @SQL;  
            EXEC sp_executesql @SQL;  
            SET @SQL = N'';  
              
            --Relationship staging is only applicable to entities that support hierarchies  
            IF @IsHierarchyEnabled = 1  
            BEGIN  
                SELECT @SQL = N'SELECT RelationshipType, Batch_ID, BatchTag, HierarchyName, ParentCode, ChildCode, SortOrder FROM stg.' + quotename(@StagingRelationshipTable) + N' WHERE 1 = 0';  
                EXEC sp_executesql @SQL;  
                SET @SQL = N'';  
            END  
  
        END  
        ELSE BEGIN  
            RAISERROR('MDSERR310047|Error while getting staging table column definitions. Entity staging table does not exist.', 16, 1);  
            RETURN;    
        END  
  
    END TRY    
    --Compensate as necessary    
    BEGIN CATCH    
    
        -- Get error info.  
        DECLARE  
            @ErrorMessage NVARCHAR(4000),  
            @ErrorSeverity INT,  
            @ErrorState INT,  
            @ErrorNumber INT,  
            @ErrorLine INT,  
            @ErrorProcedure NVARCHAR(126);  
        EXEC mdm.udpGetErrorInfo  
            @ErrorMessage = @ErrorMessage OUTPUT,  
            @ErrorSeverity = @ErrorSeverity OUTPUT,  
            @ErrorState = @ErrorState OUTPUT,  
            @ErrorNumber = @ErrorNumber OUTPUT,  
            @ErrorLine = @ErrorLine OUTPUT,  
            @ErrorProcedure = @ErrorProcedure OUTPUT  
  
        SET @ErrorMessage = CONCAT(@ErrorMessage, N', @ErrorNumber = ', @ErrorNumber, N', @ErrorProcedure = "', @ErrorProcedure, N'", line ', @ErrorLine);  
  
        --Throw the error again so the calling procedure can use it    
        RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);    
            
        RETURN(1);    
    
    END CATCH;    
  
    SET NOCOUNT OFF;    
END;
GO
/****** Object:  StoredProcedure [mdm].[udpEntityStagingRunBatch]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
This SPROC runs a staging batch synchronously and optionally clears the batch after it is run.  
  
EXEC mdm.udpEntityStagingRunBatch 31, 20, 4, 1  
*/  
CREATE PROCEDURE [mdm].[udpEntityStagingRunBatch]  
(  
   @User_ID             INT,  
   @Version_ID          INT,  
   @Entity_ID           INT,  
   @MemberType_ID       INT,     
   @Batch_ID            INT,  
   @ClearBatchAfterRun  BIT = 0,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON  
  
    DECLARE @EntityStagingTableName     SYSNAME,  
            @LogFlag                    INT = NULL,  
            @VersionName                NVARCHAR(50),  
            @RunStagingSql              NVARCHAR(MAX),  
            @SecurityLevel              TINYINT = 0,  
            @PermissionType_Admin       TINYINT = 5,  
            @MemberType_Leaf            TINYINT = 1,  
            @MemberType_Consolidated    TINYINT = 2,  
            @Entity_Permission          TINYINT;  
  
  
    SELECT @Entity_Permission = Privilege_ID  
    FROM mdm.viw_SYSTEM_SECURITY_USER_ENTITY  
    WHERE [User_ID] = @User_ID  
        AND ID = @Entity_ID;  
  
    IF @Entity_Permission = @PermissionType_Admin  
    BEGIN  
        RAISERROR('MDSERR120002|The user does not have permission to perform this operation.', 16, 1);  
        RETURN;  
    END  
  
    SELECT @EntityStagingTableName = (CASE @MemberType_ID   
                                        WHEN @MemberType_Leaf THEN StagingLeafName  
                                        WHEN @MemberType_Consolidated THEN StagingConsolidatedName  
                                        ELSE NULL  
                                      END)  
    FROM mdm.tblEntity  
    WHERE ID = @Entity_ID;  
  
    -- @LogFlag is OnOff list box which value is On 1, Off 2.  
    SELECT @LogFlag = CONVERT(INT, SettingValue) FROM mdm.tblSystemSetting WHERE SettingName = 'StagingTransactionLogging';      
    SELECT @LogFlag = CASE @LogFlag WHEN 1 THEN 1 ELSE 0 END;  
  
    SELECT @VersionName = Name FROM mdm.tblModelVersion WHERE ID = @Version_ID;  
  
    SET @RunStagingSql = N'  
    EXECUTE stg.udp_' + @EntityStagingTableName + N'@VersionName=@VersionName, @LogFlag=@LogFlag, @Batch_ID=@Batch_ID, @User_ID=@User_ID;  
    ';  
  
    IF @ClearBatchAfterRun = 1  
    BEGIN  
        SET @RunStagingSql += N'  
        EXECUTE mdm.udpEntityStagingFlagForClearing @Batch_ID, @User_ID;  
        EXECUTE mdm.udpStagingProcessAllReadyToRun;  
        ';  
    END  
  
    EXEC sp_executesql   
                        @RunStagingSql,   
                        N'@Batch_ID INT, @VersionName NVARCHAR(50), @LogFlag INT, @User_ID INT',  
                          @Batch_ID,     @VersionName,              @LogFlag,     @User_ID;  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpEntityStagingUnprocessedBatchesGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
-- Returns information about batches found in the staging tables of all entities  
-- in the given model  
CREATE PROCEDURE [mdm].[udpEntityStagingUnprocessedBatchesGet]  
(  
    @Model_ID                    INT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
  
    DECLARE @BatchStatusQueuedToRun INT = 1,  
            @BatchStatusNotRunning  INT = 2,  
            @BatchStatusRunning     INT = 3,  
            @StatusDefault          INT = 0,  
            @LeafMemberType         INT = 1,  
            @ConsolidatedMemberType INT = 2,  
            @HierarchyMemberType    INT = 4;  
              
    DECLARE @entities TABLE  
    (  
        RowNumber               INT IDENTITY(1,1)   NOT NULL,  
        Entity_MUID             UNIQUEIDENTIFIER    NOT NULL,  
        StagingLeafTable        NVARCHAR(128),  
        StagingConsolidatedTable    NVARCHAR(128),  
        StagingRelationshipTable    NVARCHAR(128)  
    )  
  
    CREATE TABLE #batchTagResults  
    (  
        BatchTag                NVARCHAR(50)        COLLATE DATABASE_DEFAULT NOT NULL,  
        [Status]                TINYINT             NOT NULL,  
        MemberTypeID            INT                 NOT NULL,  
        Entity_MUID             UNIQUEIDENTIFIER    NOT NULL,  
        MemberCount             INT                 NOT NULL  
    )  
      
    -- Get a list of all entities that belong to the model  
    INSERT INTO @entities (Entity_MUID, StagingLeafTable, StagingConsolidatedTable, StagingRelationshipTable)  
    SELECT  
        MUID                    AS Entity_MUID,  
        StagingLeafTable,  
        StagingConsolidatedTable,  
        StagingRelationshipTable  
    FROM  
        mdm.viw_SYSTEM_SCHEMA_ENTITY  
    WHERE  
        Model_ID = @Model_ID  
  
    DECLARE     
        @Entity_MUID            UNIQUEIDENTIFIER,  
        @StagingLeafTable       SYSNAME,  
        @StagingConsolidatedTable   SYSNAME,  
        @StagingRelationshipTable    SYSNAME,    
        @SQLPrefix              NVARCHAR(MAX),  
        @SQLSuffix              NVARCHAR(MAX),  
        @SQL                    NVARCHAR(MAX)  
      
    -- Query that for a given staging table returns all the distinct batch tags found. In case the same batch  
    -- tag has multiple statuses return the MAX of them, as we don't care about the exact status, just to know  
    -- if it is in progress or not.  
        SET @SQLPrefix = N'  
        INSERT INTO #batchTagResults  
        SELECT  
            DISTINCT(BatchTag)      AS BatchTag,  
            MAX(ImportStatus_ID)    AS Status,  
            @MemberTypeID           AS MemberTypeID,  
            @Entity_MUID            AS Entity_MUID,  
            COUNT(BatchTag)         AS MemberCount  
        FROM  
        ';  
    SET @SQLSuffix = N'  
        WHERE      
            BatchTag IS NOT NULL AND  
            Batch_ID IS NULL  
        GROUP BY  
            BatchTag  
        ';  
  
    -- Loop through all the entities that belong to this model and store in the temp table all the  
    -- batch tags found in the staging tables (both leaf and consolidated)  
    DECLARE @Counter    INT     = 1,    
            @MaxCounter INT     = (SELECT MAX(RowNumber) FROM @entities);    
      
    WHILE @Counter <= @MaxCounter    
        BEGIN    
            SELECT TOP 1    
                @Entity_MUID            = Entity_MUID,  
                @StagingLeafTable       = StagingLeafTable,  
                @StagingConsolidatedTable = StagingConsolidatedTable,  
                @StagingRelationshipTable = StagingRelationshipTable    
            FROM @entities    
            WHERE RowNumber = @Counter;    
          
            -- Get batches from the leaf table (always exists)  
            SET @SQL = @SQLPrefix + N'stg.' + QUOTENAME(@StagingLeafTable) + @SQLSuffix  
            EXEC sp_executesql @SQL, N'@Entity_MUID UNIQUEIDENTIFIER, @MemberTypeID INT', @Entity_MUID, @LeafMemberType  
  
            -- If the consolidated table exists (i.e. a consolidated member), get the batch tags in it  
            IF @StagingConsolidatedTable IS NOT NULL  
            BEGIN  
                SET @SQL = @SQLPrefix + N'stg.' + QUOTENAME(@StagingConsolidatedTable) + @SQLSuffix  
                EXEC sp_executesql @SQL, N'@Entity_MUID UNIQUEIDENTIFIER, @MemberTypeID INT', @Entity_MUID, @ConsolidatedMemberType  
            END -- IF  
              
            -- If the relationship table exists (a hierarchy member), get the batch tags in it    
            IF @StagingRelationshipTable IS NOT NULL    
            BEGIN    
                SET @SQL = @SQLPrefix + N'stg.' + QUOTENAME(@StagingRelationshipTable) + @SQLSuffix    
                EXEC sp_executesql @SQL, N'@Entity_MUID UNIQUEIDENTIFIER, @MemberTypeID INT', @Entity_MUID, @HierarchyMemberType    
            END -- IF  
              
            SET @Counter += 1;    
        END  -- WHILE  
    
  -- Use "group by" clause to return the distinct batch tags for each member type and entity ID.  
  -- To avoid showing duplicated lines for the same batch process, don't include batch processes   
  -- if the status in tblStgBatch is QueuedToRun or Running and import status is 0.  
    
    SELECT   
        BatchTag                AS BatchTag,  
        @BatchStatusNotRunning  AS [Status],  
        MemberTypeID            AS MemberTypeID,  
        Entity_MUID             AS Entity_MUID,  
        MemberCount             AS MemberCount  
    FROM   
        #batchTagResults   
    WHERE   
        NOT (BatchTag IN (SELECT BatchTag FROM mdm.tblStgBatch WHERE Status_ID IN (@BatchStatusQueuedToRun, @BatchStatusRunning))   
        AND [Status] = @StatusDefault)  
    GROUP BY  
        BatchTag,  
        [Status],  
        MemberTypeID,  
        Entity_MUID,  
        MemberCount  
          
    -- Remove the temporary table  
    DROP TABLE #batchTagResults;    
END; -- PROC
GO
/****** Object:  StoredProcedure [mdm].[udpExplicitHierarchyGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpExplicitHierarchyGet]  
(  
     @User_ID       INT  
  
    ,@Model_MUID    UNIQUEIDENTIFIER = NULL  
    ,@Model_Name    NVARCHAR(50) = NULL  
    ,@Model_ID      INT = NULL -- set internally only  
  
    ,@Entity_MUID   UNIQUEIDENTIFIER = NULL  
    ,@Entity_Name   NVARCHAR(50) = NULL  
    ,@Entity_ID     INT = NULL -- set internally only  
  
    ,@HierarchyTable mdm.Identifier READONLY  
  
    ,@IncludeParentIdentifiers  BIT = 1 -- Return results sets for parent Model and Entity identifiers. Set to 0 when getting explicit hierarchies as part of a parent object (because the parent identifiers will already have been looked up).  
    ,@Debug                     BIT = 0  
    ,@CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
  
    SET NOCOUNT ON  
  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), ': begin udpExplicitHierarchyGet')  
  
    -- Get model ID  
    IF @Model_ID IS NULL -- If the ID was already provided, don't bother looking it up again  
        AND (@Model_Name IS NOT NULL OR @Model_MUID IS NOT NULL)  
    BEGIN  
        SELECT   
             @Model_ID = ID  
            ,@Model_MUID = MUID  
            ,@Model_Name = Name  
        FROM mdm.tblModel  
        WHERE   MUID = ISNULL(@Model_MUID, MUID)  
            AND Name = ISNULL(@Model_Name, Name)  
  
        SET @Model_ID = COALESCE(@Model_ID, 0)  
    END  
  
    -- Get entity ID  
    IF @Entity_ID IS NULL -- If the ID was already provided, don't bother looking it up again  
        AND (@Entity_Name IS NOT NULL OR @Entity_MUID IS NOT NULL)  
    BEGIN  
        SELECT  
             @Model_ID = Model_ID  
            ,@Entity_ID = ID  
            ,@Entity_MUID = MUID  
            ,@Entity_Name = Name  
        FROM mdm.tblEntity  
        WHERE   MUID = ISNULL(@Entity_MUID, MUID)  
            AND Name = ISNULL(@Entity_Name, Name)  
            AND Model_ID = ISNULL(@Model_ID, Model_ID) -- If a model filter is specified, use it  
  
        SET @Entity_ID = COALESCE(@Entity_ID, 0)  
    END  
  
    DECLARE @SelectedHierarchy TABLE   
    (  
         ID                 INT PRIMARY KEY  
        ,Entity_ID          INT  
        ,Model_ID           INT  
        ,Privilege_ID       TINYINT  
        ,AccessPermission   TINYINT  
    )  
  
    IF EXISTS(SELECT 1 FROM @HierarchyTable)  
    BEGIN  
        INSERT INTO @SelectedHierarchy  
        SELECT  
             h.Hierarchy_ID AS ID  
            ,h.Entity_ID  
            ,h.Model_ID  
            ,acl.Privilege_ID  
            ,acl.AccessPermission  
        FROM mdm.viw_SYSTEM_SCHEMA_HIERARCHY_EXPLICIT h  
        INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_HIERARCHY acl  
        ON h.Hierarchy_ID = acl.ID  
        INNER JOIN @HierarchyTable ht  
        ON      h.Hierarchy_MUID = ISNULL(ht.MUID, h.Hierarchy_MUID)  
            AND h.Hierarchy_Name = ISNULL(ht.Name, h.Hierarchy_Name)  
        WHERE   acl.User_ID = @User_ID  
            AND h.Model_ID = ISNULL(@Model_ID, h.Model_ID)  
            AND h.Entity_ID = ISNULL(@Entity_ID, h.Entity_ID)  
            AND (ht.MUID IS NOT NULL OR ht.Name IS NOT NULL)  
    END ELSE  
    BEGIN  
        INSERT INTO @SelectedHierarchy  
        SELECT  
             h.Hierarchy_ID AS ID  
            ,h.Entity_ID  
            ,h.Model_ID  
            ,acl.Privilege_ID  
            ,acl.AccessPermission  
        FROM mdm.viw_SYSTEM_SCHEMA_HIERARCHY_EXPLICIT h  
        INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_HIERARCHY acl  
        ON h.Hierarchy_ID = acl.ID  
        WHERE   acl.User_ID = @User_ID  
            AND h.Model_ID = ISNULL(@Model_ID, h.Model_ID)  
            AND h.Entity_ID = ISNULL(@Entity_ID, h.Entity_ID)  
    END  
  
    IF @IncludeParentIdentifiers = 1  
    BEGIN  
        -- Return model Identifier(s)  
        IF @Model_ID IS NOT NULL  
        BEGIN  
            IF @Model_Name IS NULL OR @Model_MUID IS NULL  
            BEGIN  
                SELECT   
                     @Model_MUID = MUID  
                    ,@Model_Name = Name  
                FROM mdm.tblModel  
                WHERE ID = @Model_ID  
            END  
  
            -- A single model was specified, and its info has already been looked up, so simply return it  
            SELECT   
                 @Model_MUID    AS Model_MUID  
                ,@Model_Name    AS Model_Name  
                ,@Model_ID      AS Model_ID  
        END ELSE  
        BEGIN  
            SELECT DISTINCT  
                 m.MUID AS Model_MUID  
                ,m.Name AS Model_Name  
                ,m.ID   AS Model_ID  
            FROM @SelectedHierarchy h  
            INNER JOIN mdm.tblEntity e  
            ON h.Entity_ID = e.ID  
            INNER JOIN mdm.tblModel m  
            ON e.Model_ID = m.ID  
        END  
  
        -- Return entity Identifier(s)  
        IF @Entity_ID IS NOT NULL  
        BEGIN  
            -- A single entity was specified, and its info has already been looked up, so simply return it  
            SELECT   
                 @Model_ID      AS Model_ID  
                ,@Entity_MUID   AS Entity_MUID  
                ,@Entity_Name   AS Entity_Name  
                ,@Entity_ID     AS Entity_ID  
        END ELSE  
        BEGIN  
            SELECT DISTINCT  
                 e.Model_ID AS Model_ID  
                ,e.MUID AS Entity_MUID  
                ,e.Name AS Entity_Name  
                ,e.ID   AS Entity_ID  
            FROM @SelectedHierarchy h  
            INNER JOIN mdm.tblEntity e  
            ON h.Entity_ID = e.ID  
        END  
    END  
  
    SELECT  
         h.Hierarchy_MUID   AS ExplicitHierarchy_MUID  
        ,h.Hierarchy_Name   AS ExplicitHierarchy_Name  
        ,h.Hierarchy_ID     AS ExplicitHierarchy_ID  
        ,sh.Privilege_ID  
        ,sh.AccessPermission  
  
        ,h.Entity_ID  
        ,h.Hierarchy_IsMandatory AS IsMandatory  
  
        ,h.EnteredUser_DTM  
        ,h.EnteredUser_MUID  
        ,h.EnteredUser_UserName  
        ,h.EnteredUser_ID  
        ,h.LastChgUser_DTM  
        ,h.LastChgUser_MUID  
        ,h.LastChgUser_UserName  
        ,h.LastChgUser_ID  
    FROM @SelectedHierarchy sh  
    INNER JOIN mdm.viw_SYSTEM_SCHEMA_HIERARCHY_EXPLICIT h  
    ON sh.ID = h.Hierarchy_ID  
    ORDER BY sh.Model_ID, sh.Entity_ID, h.Hierarchy_Name  
  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), ': end udpExplicitHierarchyGet')  
  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpExternalActionsGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
This sproc allows a third party application like WorkFlow to wait for notifications from MDS. The external actions are triggerred as defined by business rules.  
  
*/  
CREATE PROCEDURE [mdm].[udpExternalActionsGet]  
(  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE			  
         @message_type_name	sysname  
        ,@handle			UNIQUEIDENTIFIER  
        ,@body				XML;  
      
    --Initialize variables  
    SELECT @handle = NULL;   
      
    BEGIN TRANSACTION   
  
    WAITFOR (  
        RECEIVE TOP(1)  
            @handle = [conversation_handle],  
            @message_type_name = message_type_name,  
            @body = CONVERT(XML,message_body)  
        FROM mdm.[microsoft/mdm/queue/externalaction]		  
    ), TIMEOUT 5000; --Always wait a constant time for any new messages  
              
    --Got a TIMER message  
    IF (@message_type_name = N'microsoft/mdm/message/externalaction') BEGIN  
  
        COMMIT TRANSACTION;  
        PRINT 'ExternalActionQueue received message';	  
        SELECT @body  
  
    --Got an END DIALOG message  
    END ELSE IF (@message_type_name = N'http://schemas.microsoft.com/SQL/ServiceBroker/EndDialog') BEGIN  
  
        PRINT 'ExternalActionQueue EndDialog'  
  
    --Got ERROR message  
    END ELSE IF (@message_type_name = N'http://schemas.microsoft.com/SQL/ServiceBroker/Error') BEGIN  
  
        PRINT 'ExternalActionQueue Error'  
  
    --Timeout or unexpected message  
    END ELSE BEGIN   
          
        COMMIT TRANSACTION;  
          
    END; --if  
      
    SET NOCOUNT OFF;  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpFileGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
udpFileGet 1  
  
select * from mdm.tblFile  
*/  
CREATE PROCEDURE [mdm].[udpFileGet]  
(  
    @ID             INT,  
    @CorrelationID  UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON  
  
  
    SELECT  
         ID  
        ,FileName  
        ,FileContentType  
        ,FileContent  
        ,EnterDTM  
        ,EnterUserID  
        ,LastChgDTM  
        ,LastChgUserID  
    FROM  
        mdm.tblFile  
    WHERE  
        ID = @ID  
  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpFileSave]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
udpFileSave 1,'test.zip','application/x-zip-compressed','<Binary data>'  
  
select * from mdm.tblFile  
*/  
CREATE PROCEDURE [mdm].[udpFileSave]  
(  
    @User_ID            INT,  
    @FileName           NVARCHAR(250),  
    @FileContentType    NVARCHAR(200),  
    @FileContent        VARBINARY(max),  
    @Return_ID          INT = NULL OUTPUT,  
    @CorrelationID      UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON  
  
    --Insert the Data  
    INSERT INTO [mdm].[tblFile]  
    (  
        [FileName],  
        [FileContentType],  
        [FileContent],  
        [EnterDTM],  
        [EnterUserID],  
        [LastChgDTM],  
        [LastChgUserID]  
    )  
    VALUES  
    (  
        @FileName,  
        @FileContentType,  
        @FileContent,  
        GETUTCDATE(),  
        @User_ID,  
        GETUTCDATE(),  
        @User_ID  
    )  
  
    SELECT @Return_ID = SCOPE_IDENTITY()  
  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpFilesDelete]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
Deletes the files with the given IDs  
*/  
CREATE PROCEDURE [mdm].[udpFilesDelete]  
(  
    @File_ID        mdm.IdList READONLY,  
    @CorrelationID  UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON  
  
    -- Orphan any sync target files that reference the files being deleted  
    UPDATE f  
    SET   
         Source_ID = NULL  
        ,Source_LastChgTS = NULL  
    FROM mdm.tblFile f  
    INNER JOIN @File_ID d  
    ON f.Source_ID = d.ID;  
PRINT CONCAT(SYSDATETIME(), N': ', @@ROWCOUNT, N' row(s) had Source_ID set to null in tblFile.');  
  
    -- Delete the files  
    DELETE f  
    FROM mdm.tblFile f  
    INNER JOIN @File_ID d  
    ON f.ID = d.ID  
PRINT CONCAT(SYSDATETIME(), N': ', @@ROWCOUNT, N' row(s) deleted from tblFile.');  
  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpGenerateCodeRange]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
Call the udpGenerateCodeRange to allocate a range of codes for a code gen enabled entity. The SPROC has two output parameters CodeRangeStart  
and CodeRangeEnd which defines an inclusive range of usable code values. This means that if CodeRangeStart comes out 5 and CodeRangeEnd comes  
out 14 the ten codes 5,6,7,8,9,10,11,12,13,14 have been allocated  
  
Example  
    DECLARE @Start BIGINT, @End BIGINT;  
    EXEC mdm.udpGenerateCodeRange @Entity_ID = 31, @NumberOfCodesToGenerate = 3, @CodeRangeStart = @Start OUTPUT, @CodeRangeEnd = @End OUTPUT;  
  
This is an example of how calling SPROC might call this SPROC and use its output to populate codes:  
  
declare @Codes Table (Code nvarchar(250));  
insert into @Codes Values(null);  
insert into @Codes Values('text');  
insert into @Codes Values(null);  
insert into @Codes Values('arun');  
insert into @Codes Values(null);  
insert into @Codes Values(null);  
insert into @Codes Values(null);  
insert into @Codes Values('blah');  
insert into @Codes Values(null);  
  
declare @numberofcodes int;  
set @numberofcodes = (select COUNT(*) FROM @Codes WHERE Code is null);  
  
DECLARE @Start BIGINT, @End BIGINT;  
EXEC mdm.udpGenerateCodeRange @Entity_ID = 31, @NumberOfCodesToGenerate = @numberofcodes, @CodeRangeStart = @Start OUTPUT, @CodeRangeEnd = @End OUTPUT;  
  
DECLARE @Counter BIGINT = @Start - 1;  
  
UPDATE @Codes  
SET @Counter = @Counter + 1,  
	Code = CONVERT(NVARCHAR(250), @Counter)  
WHERE Code IS NULL;  
*/  
CREATE PROCEDURE [mdm].[udpGenerateCodeRange]  
(  
    @Entity_ID		            INT,  
    @NumberOfCodesToGenerate    INT,  
    @CodeRangeStart BIGINT OUTPUT,  
    @CodeRangeEnd BIGINT OUTPUT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
AS BEGIN  
  
    SET NOCOUNT ON;  
  
    IF NOT EXISTS(SELECT * FROM mdm.tblCodeGenInfo WHERE EntityId = @Entity_ID)  
        BEGIN  
            RAISERROR('MDSERR310054|This entity does not support automatic code generation', 16, 1);  
            RETURN;  
        END  
  
    --We use this complicated update statement to ensure that while we are doing the calculations  
    --to generate the codes we have an exclusive lock on this row  
    --First, calculate the current largest value. If the LargestCodeValue is null or smaller than the  
    --Seed the current largest value is the seed. If the LargestCodeValue is greater than or equal to  
    --the Seed then the current largest is LargestCodeValue  
    UPDATE mdm.tblCodeGenInfo  
    SET @CodeRangeStart = CASE WHEN LargestCodeValue IS NULL OR LargestCodeValue < Seed THEN Seed ELSE LargestCodeValue + 1 END,  
        @CodeRangeEnd = LargestCodeValue = @CodeRangeStart + (@NumberOfCodesToGenerate - 1)  
    WHERE EntityId = @Entity_ID;  
  
END; --proc mdm.udpGenerateCodeRange
GO
/****** Object:  StoredProcedure [mdm].[udpGenerateNextCode]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
Call the udpGenerateNextCode generate the next code for a code gen enabled entity  
  
Example  
    DECLARE @Code NVARCHAR(250);  
    EXEC @Code = mdm.udpGenerateNextCode @Entity_ID = 20;  
*/  
CREATE PROCEDURE [mdm].[udpGenerateNextCode]  
(  
    @Entity_ID		INT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
AS BEGIN  
  
    SET NOCOUNT ON;  
  
    DECLARE @GeneratedCode          NVARCHAR(250) = NULL;  
    DECLARE @Start BIGINT, @End BIGINT;  
  
    --Generate one code. Start and End should come out equal  
    EXEC mdm.udpGenerateCodeRange   @Entity_ID = @Entity_ID,   
                                    @NumberOfCodesToGenerate = 1,   
                                    @CodeRangeStart = @Start OUTPUT,   
                                    @CodeRangeEnd = @End OUTPUT;  
  
    --Convert the generated code to an nvarchar  
    SET @GeneratedCode = CONVERT(NVARCHAR(250), @Start);  
  
    RETURN @GeneratedCode;  
  
END; --proc mdm.udpGenerateNextCode
GO
/****** Object:  StoredProcedure [mdm].[udpGetErrorInfo]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
When called from within a CATCH block, gets info about the error that can be   
then used to re-raise the error from within the CATCH block. If the original error   
number is a system error (not a custom MDS error) then the system error  
number will be added to the beginning of the error message with a "SYSERR" prefix  
to distinguish it from the "MDSERR" prefix used for custom errors. Otherwise, the  
original error number would be lost because when the error message is re-raised,  
error number 50000 is used.  
  
Example:  
    BEGIN TRY  
        DECLARE @temp INT = 1/0; -- Causes divide by zero error  
    END TRY  
    BEGIN CATCH  
        DECLARE  
            @ErrorMessage NVARCHAR(4000),  
            @ErrorSeverity INT,  
            @ErrorState INT;  
  
        EXEC mdm.udpGetErrorInfo  
            @ErrorMessage = @ErrorMessage OUTPUT,  
            @ErrorSeverity = @ErrorSeverity OUTPUT,  
            @ErrorState = @ErrorState OUTPUT;  
        
        RAISERROR (@ErrorMessage,  @ErrorSeverity, @ErrorState); -- Re-raise the error, with the original error number at the beginning of the error message.  
        -- Yields:  
        --      "Msg 50000, Level 16, State 1, Line 15  
        --      SYSERR8134|Divide by zero error encountered."  
    END CATCH  
*/  
CREATE PROCEDURE [mdm].[udpGetErrorInfo]  
(  
    @ErrorMessage NVARCHAR(4000) = NULL OUTPUT,  
    @ErrorSeverity INT = NULL OUTPUT,  
    @ErrorState INT = NULL OUTPUT,  
    @ErrorNumber INT = NULL OUTPUT,  
    @ErrorLine INT = NULL OUTPUT,  
    @ErrorProcedure NVARCHAR(126) = NULL OUTPUT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
AS  
BEGIN  
    SELECT  
        @ErrorMessage = ERROR_MESSAGE(),  
        @ErrorSeverity = ERROR_SEVERITY(),  
        @ErrorState = ERROR_STATE(),  
        @ErrorNumber = ERROR_NUMBER(), -- Note that @@Error will not work here as a replacement for ERROR_NUMBER().  
        @ErrorLine = ERROR_LINE(),  
        @ErrorProcedure = ERROR_PROCEDURE();  
          
    -- If a system error occurred, preserve the original error number by adding it to the front of the error message.  
    IF @ErrorNumber < 50000  
    BEGIN  
        SET @ErrorMessage = N'SYSERR' + COALESCE(CONVERT(NVARCHAR, @ErrorNumber), N'') + N'|' + COALESCE(@ErrorMessage, N'');  
    END;  
END;
GO
/****** Object:  StoredProcedure [mdm].[udpGetFirstEntityUsingMember]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
/*  
Determine if the specified Member_ID is in use by another Entity's DBA for the specified version.  
*/  
CREATE PROCEDURE [mdm].[udpGetFirstEntityUsingMember]  
(    
    @Entity_ID INT,   
    @Member_ID INT,  
    @Version_ID INT,   
    @ReferencingEntityName NVARCHAR(50) = NULL OUTPUT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON  
    DECLARE  
        @MemberInUse BIT,  
        @SQL NVARCHAR(MAX)  
          
    --Store the list of entities that have a DBA referencing the Entity containing the specified Member_ID.  
    DECLARE @ReferencingEntities TABLE        
    (    
        Entity_Name NVARCHAR(50) NOT NULL,  
        MemberTable sysname NOT NULL,  
        MemberColumn sysname NOT NULL  
    )  
       
    INSERT INTO @ReferencingEntities  
    SELECT de.Name, mdm.udfTableNameGetByID(a.Entity_ID, 1), a.TableColumn  
    FROM mdm.tblEntity e  
        INNER JOIN mdm.tblAttribute a ON a.DomainEntity_ID = e.ID  
        INNER JOIN mdm.tblEntity de ON de.ID = a.Entity_ID  
    WHERE e.ID = @Entity_ID		  
      
    DECLARE   
        @ReferencingMemberTable sysname,  
        @ReferencingMemberColumn sysname  
          
    --Iterate through the referencing entities until one of them is found to reference the specified Member_ID  
    WHILE EXISTS(SELECT 1 FROM @ReferencingEntities) BEGIN    
            
        SELECT TOP 1    
            @ReferencingEntityName = Entity_Name,     
            @ReferencingMemberTable = MemberTable,    
            @ReferencingMemberColumn = MemberColumn    
        FROM @ReferencingEntities;    
  
        --Determine if the member is in use.  
        SET @SQL = N'  
            SET @MemberInUse = 0; ' + N'  
            IF EXISTS( ' + N'  
                SELECT TOP 1 ID ' + N'  
                FROM mdm.' + quotename(@ReferencingMemberTable) + N' e ' + N'  
                WHERE ' + quotename(@ReferencingMemberColumn) + N' = ' + CAST(@Member_ID AS NVARCHAR(250)) + N'    
                    AND e.Version_ID = @Version_ID  
            ) SET @MemberInUse = 1;';			  
              
        EXEC sp_executesql @SQL, N'@Version_ID INT, @MemberInUse BIT OUTPUT', @Version_ID, @MemberInUse OUTPUT;  
  
        --Return the name of the entity that references the member.  
        IF @MemberInUse = 1  
        BEGIN  
            RETURN(1);  
        END  
          
        DELETE   
        FROM @ReferencingEntities   
        WHERE Entity_Name = @ReferencingEntityName  
            AND MemberTable = @ReferencingMemberTable  
            AND MemberColumn = @ReferencingMemberColumn;	  
                        
    END; --while    
    
   --The member is not used  
   SET @ReferencingEntityName = NULL;  
   RETURN(0);  
     
SET NOCOUNT OFF;    
END;
GO
/****** Object:  StoredProcedure [mdm].[udpGetIndexNameBySystemName]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
/*  
--Returns the index name and ID based on the SystemName of the index.  
*/  
CREATE PROCEDURE [mdm].[udpGetIndexNameBySystemName]    
(    
    @SystemName             sysname,        
    @CorrelationID          UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability    
)    
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
  
    SELECT TOP 1 idx.Name as UserDefinedName, idx.MUID as IndexMUID  
        FROM mdm.tblIndex AS idx  
        INNER JOIN sys.indexes as sysIdx ON sysIdx.name = @SystemName   
        AND idx.SysIndex_ID = sysIdx.index_id  
  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpGetMaxCodeValue]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
/*  
    Call the udpGetMaxCodeValue SPROC to determine the largest numeric Code value for an entity.  
  
    Example: EXEC	[mdm].[udpGetMaxCodeValue]  @Entity_ID = 31  
*/  
CREATE PROCEDURE [mdm].[udpGetMaxCodeValue]  
(  
    @Entity_ID      INT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
AS  
BEGIN  
      
    DECLARE  
        @IsCollectionEnabled    BIT,  
        @IsHierarchyEnabled     BIT,  
        @EntityTable            NVARCHAR(258),  
        @HierarchyParentTable   NVARCHAR(258) = NULL,  
        @CollectionTable        NVARCHAR(258) = NULL,  
        @MemberStatus_Active    TINYINT = 1;  
  
    DECLARE @maxvalue BIGINT = NULL;  
    DECLARE @SQL NVARCHAR(MAX);  
    DECLARE @WhereClause NVARCHAR(MAX) = N'  
        WHERE Status_ID = ' + CONVERT(NVARCHAR, @MemberStatus_Active); -- Do not replace this hardcoded value with a var. It would be bad for perf.  
    DECLARE @SqlAzureEngineEdition INT = 5;  
    DECLARE @IsAzure BIT =  CASE SERVERPROPERTY(N'EngineEdition') WHEN @SqlAzureEngineEdition THEN 1 ELSE 0 END;  
    IF (@IsAzure = 0)  
    BEGIN  
        -- Since SQL CLR is enabled, use the mdq.IsNumber function to filter out non numeric Codes. Otherwise, the filtering will be   
        -- done after all unique Codes are loaded into the temp table.  
        SET @WhereClause += N'  
            AND COALESCE(mdq.IsNumber(Code), 0) = 1';  
    END;  
  
    SELECT   
        @EntityTable = EntityTable,  
        @HierarchyParentTable = HierarchyParentTable,  
        @CollectionTable = CollectionTable,  
        @IsCollectionEnabled = CASE WHEN CollectionTable IS NULL THEN 0 ELSE 1 END,  
        @IsHierarchyEnabled  = CASE WHEN HierarchyTable  IS NULL THEN 0 ELSE 1 END  
    FROM mdm.tblEntity  
    WHERE ID = @Entity_ID;  
  
    CREATE TABLE #NumericCodes   
    (  
         ID INT IDENTITY(1,1) PRIMARY KEY CLUSTERED  
        ,Code NVARCHAR(250) COLLATE DATABASE_DEFAULT  
    );  
  
    -- Get leaf member codes.  
    SET @SQL = N'  
        INSERT INTO #NumericCodes  
        SELECT Code  
        FROM mdm.' + QUOTENAME(@EntityTable) +   
        @WhereClause;  
  
    --If the entity supports collecitons, then also get collection member codes.  
    IF @IsCollectionEnabled = 1  
    BEGIN   
        SET @SQL += N'  
        UNION ALL  
        SELECT Code  
        FROM mdm.' + QUOTENAME(@CollectionTable) +  
        @WhereClause;  
    END  
  
    --If the entity supports hierachies, then also get consolidated member codes.  
    IF @IsHierarchyEnabled = 1  
    BEGIN     
        SET @SQL += N'  
        UNION ALL  
        SELECT Code  
        FROM mdm.' + QUOTENAME(@HierarchyParentTable) +  
        @WhereClause;  
    END  
      
    --PRINT @SQL;  
    EXEC sp_executesql @SQL;  
  
    IF (@IsAzure = 1)  
    BEGIN  
        -- SQL CLR is not supported, so loop through the #NumericCodes rows and remove non-numeric codes.  
        -- TODO: Consider removing this IF block when SQL Azure adds support for SQL CLR  
        DECLARE   
             @Code NVARCHAR(250)  
            ,@Row_ID INT = 0  
            ,@MaxRow_ID INT = COALESCE((SELECT MAX(ID) FROM #NumericCodes), 0)  
            ,@IsNumeric BIT;  
        WHILE @Row_ID < @MaxRow_ID  
        BEGIN  
            -- Get the next row  
            SELECT TOP 1  
                 @Row_ID = ID  
                ,@Code = Code  
            FROM #NumericCodes  
            WHERE ID > @Row_ID  
  
            SET @IsNumeric = 0;  
            EXEC mdq.udpIsNumber @Code, @IsNumeric OUTPUT  
            IF COALESCE(@IsNumeric, 0) = 0  
            BEGIN  
                -- The Code isn't numeric, so delete it from the temp table.  
                DELETE FROM #NumericCodes WHERE ID = @Row_ID  
            END;  
        END;-- WHILE  
    END;   
  
    -- Find the biggest numeric Code value  
    SELECT  
        @maxvalue = MAX(CAST(Code AS BIGINT))  
    FROM #NumericCodes  
  
    -- Return the result of the SPROC  
    RETURN @maxvalue  
END; --[udpGetMaxCodeValue]
GO
/****** Object:  StoredProcedure [mdm].[udpHierarchyAncestorsGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
Procedure  : mdm.udpHierarchyAncestorsGet  
Component  : Hierarchy Explorer  
Description: mdm.udpHierarchyAncestorsGet returns a list of ascendants associated with a specific member  
Parameters : Version ID, Hierarchy ID, Member ID, Member type ID  
Return     : Table: Member ID (INT), MemberType_ID (INT), LevelNumber (TINYINT)  
Example 1  : EXEC mdm.udpHierarchyAncestorsGet 4, 6, 38, 1, 0  
Example 1  : EXEC mdm.udpHierarchyAncestorsGet 4, 6, 38, 1, 1  
  
*/  
CREATE PROCEDURE [mdm].[udpHierarchyAncestorsGet]  
(  
   @User_ID			INT,  
   @Version_ID		INT,  
   @Hierarchy_ID	INT,  
   @Member_ID		INT,  
   @MemberType_ID	TINYINT,  
   @ReturnTree		BIT = 0,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON  
  
    DECLARE @SQL			NVARCHAR(max)  
    DECLARE @Entity_ID		INT  
    DECLARE @Hierarchy_Muid	UNIQUEIDENTIFIER  
    DECLARE @Entity_Muid	UNIQUEIDENTIFIER  
    DECLARE @viwHR			sysname  
    DECLARE @Level			INT --Counter variable  
  
    SELECT @Entity_ID = Entity_ID,@Hierarchy_Muid=MUID FROM mdm.tblHierarchy WHERE ID = @Hierarchy_ID  
    SELECT @Entity_Muid = MUID FROM mdm.tblEntity WHERE ID=@Entity_ID  
    SELECT @viwHR = mdm.udfViewNameGetByID(@Entity_ID,4,0, 0);   
      
    --Temporary table to store list of ascendants (ancestors)  
    CREATE TABLE #tblAncestor (ParentID INT, MemberType_ID TINYINT, LevelNumber SMALLINT,ParentCode NVARCHAR(250),ParentName NVarchar(250),Code NVarchar(250),[Name] NVarchar(250),Privilege_ID INT,AccessPermission TINYINT)  
  
    --Create first level (if it exists)  
    SET @Level = 1  
    SET @SQL = N'  
        INSERT INTO #tblAncestor   
        SELECT Parent_ID, 2, 1,Parent_Code,Parent_Name,Child_Code,Child_Name,-1,0   
        FROM mdm.' + quotename(@viwHR) + N'  
        WHERE Version_ID = @Version_ID  
            AND Hierarchy_ID = @Hierarchy_ID  
            AND ChildType_ID = @MemberType_ID   
            AND ' + CASE @MemberType_ID WHEN 1 THEN N'Child_EN_ID' WHEN 2 THEN N'Child_HP_ID' END + N' = @Member_ID;';  
    EXEC sp_executesql @SQL,   
        N'@Version_ID INT, @Hierarchy_ID INT, @Member_ID INT, @MemberType_ID TINYINT',   
        @Version_ID, @Hierarchy_ID, @Member_ID, @MemberType_ID  
  
    --Collect ascendants (ancestors) of target member  
    WHILE EXISTS (SELECT 1 FROM #tblAncestor WHERE LevelNumber = @Level) AND @Level < 22 BEGIN  
        SET @SQL = N'  
            INSERT INTO #tblAncestor   
            SELECT DISTINCT Parent_ID, ChildType_ID,@Level+1, Parent_Code,Parent_Name,Child_Code,Child_Name,-1,0  
            FROM mdm.' + quotename(@viwHR) + N'  
            WHERE Version_ID = @Version_ID AND Hierarchy_ID = @Hierarchy_ID   
                AND ChildType_ID = 2 AND Child_HP_ID IN (SELECT ParentID FROM #tblAncestor WHERE LevelNumber = @Level);';  
            
          EXEC sp_executesql @SQL,   
            N'@Version_ID INT, @Hierarchy_ID INT, @Level INT OUTPUT',   
            @Version_ID, @Hierarchy_ID, @Level OUTPUT;  
          SET @Level = @Level + 1;  
    END; --while  
      
    --Loop thru the temp table and look up the privilege  
    DECLARE @TempMember_ID INT  
    DECLARE @TempMemberType_ID TINYINT  
    DECLARE @TempPrivilege_ID TINYINT=0;  
    DECLARE @TempAccessPermission TINYINT=0;  
    WHILE EXISTS (SELECT 1 FROM #tblAncestor WHERE Privilege_ID = -1)  
    BEGIN		  
        SET @TempMember_ID = COALESCE((SELECT TOP 1 ParentID from #tblAncestor WHERE Privilege_ID = -1), 0);		  
        SET @TempMemberType_ID = (SELECT TOP 1 MemberType_ID from #tblAncestor WHERE Privilege_ID = -1);	  
        EXEC mdm.udpSecurityMemberResolverGet @User_ID=@User_ID,@Version_ID=@Version_ID,@Hierarchy_ID=@Hierarchy_ID,@HierarchyType_ID=0,@Entity_ID=@Entity_ID,@Member_ID=@TempMember_ID,@MemberType_ID=@TempMemberType_ID,@Privilege_ID=@TempPrivilege_ID OUTPUT,@AccessPermission=@TempAccessPermission OUTPUT;  
          
        IF @TempPrivilege_ID = 1 BREAK; --Once you have hit a denied member then exit as nothing else above can be visible  
          
        UPDATE #tblAncestor SET Privilege_ID = @TempPrivilege_ID, AccessPermission = @TempAccessPermission  
        WHERE   
        MemberType_ID = @TempMemberType_ID  
        AND ISNULL(ParentID,0) = @TempMember_ID  
    END  
      
    IF @ReturnTree = 1  
    BEGIN  
        SELECT 			   
            @Member_ID MemberID,  
            @MemberType_ID MemberTypeID,  
            ParentID AncestorID,   
            2 AncestorMemberTypeID,  
            ABS(LevelNumber-@Level)-2 LevelNumber  
        FROM   
            #tblAncestor  
        ORDER BY   
            LevelNumber  
    END  
    ELSE  
    BEGIN  
        SELECT   
            ParentID as ID,   
            MemberType_ID,   
            Object_ID = CASE MemberType_ID WHEN 1 THEN 8 WHEN 2 THEN 9 WHEN 3 THEN 10 ELSE 0 END,  
            ABS(LevelNumber-@Level)-2 LevelNumber,  
            --New Columns For API - The ones above can be removed after the webui is converted to use API  
            ParentCode,  
            ParentName,  
            2 AS ParentType_ID,  
            @Entity_Muid as ParentEntity_MUID,		   
            Code,  
            [Name],  
            MemberType_ID AS ChildType_ID,  
            @Entity_Muid AS ChildEntity_MUID,  
            @Hierarchy_Muid AS RelationShipId,  
            2 AS RelationShipTypeId, --2 is Hierarchy  
            Privilege_ID AS Privilege_ID,		   
            AccessPermission AS AccessPermission  
        FROM   
            #tblAncestor  
        WHERE  
            Privilege_ID > 0  
        ORDER BY   
            LevelNumber  
    END  
      
      
  
    DROP TABLE #tblAncestor  
  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpHierarchyCreate]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    EXEC mdm.udpHierarchyCreate 1, 15, 8, 0, 50, 2;  
*/  
CREATE PROCEDURE [mdm].[udpHierarchyCreate]  
(  
   @User_ID       INT,  
   @Version_ID    INT,  
   @Entity_ID     INT,  
   @Hierarchy_ID  INT,  
   @Parent_ID     INT,  
   @Child_ID      INT,  
   @ChildType_ID  INT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE   
        @HierarchyTable		sysname,  
        @SQL				NVARCHAR(MAX),  
        @Member_ID			INT;  
  
    --Invalid @ChildType_ID  
    IF @ChildType_ID NOT IN (1, 2) BEGIN --1=EN, 2=HP  
        --On error, return NULL results  
        SELECT @Member_ID = NULL;  
        RAISERROR('MDSERR100010|The Parameters are not valid.', 16, 1);  
        RETURN(1);  
    END; --if  
      
    --Get the Entity Hierarchy Table Name  
    SET @HierarchyTable = mdm.udfTableNameGetByID(@Entity_ID, 4);  
  
    --Insert into the Correct Hierarchy Relationship table  
    SELECT @SQL = N'  
        DECLARE @SortOrder INT;   
        SELECT @SortOrder = MAX(ID) FROM mdm.' + quotename(@HierarchyTable) + N'  
        WHERE Version_ID = @Version_ID;  
          
        INSERT INTO mdm.' + quotename(@HierarchyTable) + N'  
        (  
            Version_ID,  
            Status_ID,  
            Hierarchy_ID,  
            Parent_HP_ID,  
            ChildType_ID,			  
            Child_EN_ID,  
            Child_HP_ID,  
            SortOrder,  
            LevelNumber,  
            EnterDTM,   
            EnterUserID,  
            EnterVersionID,  
            LastChgDTM,  
            LastChgUserID,  
            LastChgVersionID  
        )   
        VALUES  
        (  
             @Version_ID  
            ,1  
            ,@Hierarchy_ID  
            ,NULLIF(@Parent_ID, 0) --Parent_HP_ID  
            ,@ChildType_ID --ChildType_ID  
            ,CASE @ChildType_ID WHEN 1 THEN @Child_ID ELSE NULL END --Child_EN_ID  
            ,CASE @ChildType_ID WHEN 2 THEN @Child_ID ELSE NULL END --Child_HP_ID  
            ,ISNULL(@SortOrder, 0) + 1  
            ,-1  
            ,GETUTCDATE()  
            ,@User_ID  
            ,@Version_ID  
            ,GETUTCDATE()  
            ,@User_ID  
            ,@Version_ID		  
        );  
          
        SET @Member_ID = SCOPE_IDENTITY();';  
  
    --PRINT(@SQL);  
    EXEC sp_executesql @SQL,   
        N'@User_ID INT, @Version_ID INT, @Hierarchy_ID INT, @Parent_ID INT, @Child_ID INT, @ChildType_ID INT, @Member_ID INT OUTPUT',   
        @User_ID, @Version_ID, @Hierarchy_ID, @Parent_ID, @Child_ID, @ChildType_ID, @Member_ID OUTPUT;  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpHierarchyDerivedAncestorsGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
Procedure  : mdm.udpHierarchyDerivedAncestorsGet  
Component  : Hierarchy Explorer  
Description: mdm.udpHierarchyDerivedAncestorsGet returns a list of ascendants associated with a specific member in a Derived Hierarchy  
Parameters : Version ID, Hierarchy ID, Member ID, Item_ID  
               Member ID represents the entity member ID or attribute member ID.  It is the "starting point" [of the hierarchy] to use when fetching the ancestors.  
               Item ID represents the entity ID or attribute ID corresponding to the Member_ID (-1 simulates leaf).  
               Item type ID represents the type of item: 0=Entity; 1=DBA; 2=Hierarchy; 3=Consolidated DBA (Common.HierarchyItemType)  
Return     : Table: Member ID (INT), Item_ID (INT), Object ID, Level number (TINYINT)  
               Object_ID references the values in mdm.tblSecurityObject and corresponds to the object type within the hierarchy: 3=Entity; 4=Attribute; 6=EXplicit Hierarchy.  
Example 1  : EXEC mdm.udpHierarchyDerivedAncestorsGet 20,  9, 265, 1, 32, 0  
SELECT * FROM mdm.viw_SYSTEM_7_9_PARENTCHILD_DERIVED  
*/  
  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpHierarchyDerivedAncestorsGet]  
(  
    @User_ID		INT,  
    @Version_ID		INT,  
    @Hierarchy_ID	INT,  
    @Member_ID		INT,  
    @MemberType_ID	TINYINT,  
    @Item_ID		INT,  
    @ItemType_ID	INT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
      
    DECLARE @ParamList  NVARCHAR(MAX);  
    SET @ParamList = N'@Version_ID      INT  
                      ,@Member_ID		INT  
                      ,@MemberType_ID	TINYINT  
                      ,@Item_ID			INT  
                      ,@ItemType_ID		INT';      
          
    DECLARE @SQL			NVARCHAR(MAX)  
    DECLARE @Model_ID	    INT  
    DECLARE @Entity_ID	    INT  
    DECLARE @viwHR			sysname  
    DECLARE @Level			SMALLINT    --Tracking variable  
  
    SELECT @Model_ID = Model_ID FROM mdm.tblModelVersion WHERE ID = @Version_ID  
  
    SET @viwHR  = CONCAT(N'viw_SYSTEM_', @Model_ID, N'_', @Hierarchy_ID, N'_PARENTCHILD_DERIVED')  
    SET @Level  = 0  
  
    --Temporary table to store list of ascendants (ancestors)  
    CREATE TABLE #tblAncestor   
    (  
         Parent_ID          INT  
        ,ParentType_ID      TINYINT  
        ,Child_ID           INT  
        ,ChildType_ID       TINYINT  
        ,Item_ID            INT  
        ,ItemType_ID        TINYINT  
        ,ParentItem_ID      INT  
        ,ParentItemType_ID  TINYINT  
        ,ChildEntity_MUID   UNIQUEIDENTIFIER  
        ,ParentEntity_MUID  UNIQUEIDENTIFIER  
        ,LevelNumber        SMALLINT IDENTITY (0, 1)          
        ,ParentCode         NVARCHAR(250)  
        ,ParentName         NVARCHAR(250)  
        ,Code               NVARCHAR(250)  
        ,[Name]             NVARCHAR(250)  
        ,Item_MUID          UNIQUEIDENTIFIER  
        ,Privilege_ID       TINYINT  
        ,AccessPermission   TINYINT  
    )  
  
    --Top 1 is used because of Recursive Derived Hierarchies  
    --Insert base record  
    SET @SQL = N'  
        INSERT INTO #tblAncestor  
        SELECT TOP 1  
             Parent_ID  
            ,ParentType_ID  
            ,Child_ID  
            ,ChildType_ID  
            ,Item_ID  
            ,ItemType_ID  
            ,ParentItem_ID  
            ,ParentItemType_ID  
            ,Entity_MUID  
            ,ParentEntity_MUID  
            ,ParentCode  
            ,ParentName  
            ,ChildCode  
            ,ChildName  
            ,Item_MUID  
            ,NULL  
            ,0  
        FROM mdm.' + quotename(@viwHR) + N'  
        WHERE   Version_ID = @Version_ID  
            AND Child_ID = @Member_ID  
            AND ChildType_ID = @MemberType_ID  
            AND Item_ID = @Item_ID  
            AND ItemType_ID = @ItemType_ID  
        ORDER BY Child_ID;';  
    --PRINT @SQL;  
    EXEC sp_executesql @SQL, @ParamList, @Version_ID, @Member_ID, @MemberType_ID, @Item_ID, @ItemType_ID;  
  
    --Collect ascendants (ancestors) of target member  
    WHILE EXISTS (SELECT 1 FROM #tblAncestor WHERE LevelNumber = @Level) AND @Level < 22 BEGIN  
        SELECT   
             @Member_ID = Parent_ID  
            ,@MemberType_ID = ParentType_ID  
            ,@Item_ID = ParentItem_ID  
            ,@ItemType_ID = ParentItemType_ID   
        FROM #tblAncestor   
        WHERE LevelNumber = @Level;  
              
        IF @Member_ID=0 BREAK  
        SET @SQL = N'  
            INSERT INTO #tblAncestor   
            SELECT TOP 1   
                 Parent_ID  
                ,ParentType_ID  
                ,Child_ID  
                ,ChildType_ID  
                ,Item_ID  
                ,ItemType_ID  
                ,ParentItem_ID  
                ,ParentItemType_ID  
                ,Entity_MUID  
                ,ParentEntity_MUID  
                ,ParentCode  
                ,ParentName  
                ,ChildCode  
                ,ChildName  
                ,Item_MUID  
                ,NULL  
                ,0  
            FROM mdm.' + quotename(@viwHR) + N'   
            WHERE   Version_ID = @Version_ID   
                AND Child_ID = @Member_ID   
                AND ChildType_ID = @MemberType_ID   
                AND Item_ID = @Item_ID   
                AND ItemType_ID = @ItemType_ID  
             ORDER BY Child_ID;';  
        EXEC sp_executesql @SQL, @ParamList, @Version_ID, @Member_ID, @MemberType_ID, @Item_ID, @ItemType_ID;  
        SET @Level = @Level + 1;  
    END; --while  
  
    --Loop through the temp table and look up the privilege  
    DECLARE @TempMember_ID INT  
    DECLARE @TempMemberType_ID TINYINT  
    DECLARE @TempPrivilege_ID TINYINT=0;  
    DECLARE @TempAccessPermission TINYINT=0;  
    DECLARE @TempEntity_MUID UNIQUEIDENTIFIER  
    DECLARE @TempEntity_ID INT;  
    WHILE EXISTS (SELECT 1 FROM #tblAncestor WHERE Privilege_ID IS NULL)  
    BEGIN  
        SELECT TOP 1  
             @TempMember_ID = Parent_ID  
            ,@TempMemberType_ID = ParentType_ID  
            ,@TempEntity_MUID = COALESCE(ParentEntity_MUID, 0x0)  
        FROM #tblAncestor  
        WHERE Privilege_ID IS NULL  
        ORDER BY LevelNumber, ParentCode;  
  
        SET @TempEntity_ID = (SELECT ID FROM mdm.tblEntity WHERE MUID = @TempEntity_MUID);  
        EXEC mdm.udpSecurityMemberResolverGet @User_ID=@User_ID,@Version_ID=@Version_ID,@Hierarchy_ID=@Hierarchy_ID,@HierarchyType_ID=1,@Entity_ID=@TempEntity_ID,@Member_ID=@TempMember_ID,@MemberType_ID=@TempMemberType_ID,@Privilege_ID=@TempPrivilege_ID OUTPUT, @AccessPermission = @TempAccessPermission OUTPUT;  
          
        IF @TempPrivilege_ID = 1 BREAK; --Once you have hit a denied member then exit as nothing else above can be visible  
  
        UPDATE #tblAncestor   
        SET Privilege_ID = COALESCE(@TempPrivilege_ID, 0),  
            AccessPermission = @TempAccessPermission  
        WHERE   COALESCE(ParentEntity_MUID, 0x0) = @TempEntity_MUID --Logical Root has a null ParentMuid  
            AND ParentType_ID = @TempMemberType_ID  
            AND Parent_ID = @TempMember_ID  
    END  
  
    SELECT  
         ParentEntity_MUID  
        ,ParentCode  
        ,ParentName  
        ,ParentType_ID  
        ,ChildEntity_MUID  
        ,ChildType_ID  
        ,Code  
        ,[Name]  
        ,Item_MUID AS RelationshipId  
        ,ItemType_ID AS RelationshipTypeId  
        ,Privilege_ID AS Privilege_ID  
        ,AccessPermission AS AccessPermission  
    FROM #tblAncestor  
    WHERE Privilege_ID > 0  
    ORDER  BY LevelNumber DESC; -- Order from top to bottom  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpHierarchyGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    THIS SPROC (IN THEORY) SHOULD ONLY BE CALLED BY udpHierarchyMembersGet.  
    The reason nothing should call this sproc directly is that the wrapper(udpHierarchyMembersGet) was written  
    to do the lookups necesary to provide the parameters for this sproc.  
  
    --Examples  
    EXEC mdm.udpHierarchyGet @User_ID=1,@Version_ID=4,@Hierarchy_ID=1,@HierarchyType_ID=0,@Item_ID=6,@ItemType_ID=0,@ParentItem_ID=0,@ParentItemType_ID=0,@Parent_ID=0,@RowLimit=N'51'  
*/  
  
CREATE PROCEDURE [mdm].[udpHierarchyGet]  
(  
    @User_ID                INT,  
    @Version_ID             INT,  
    @Hierarchy_ID           INT,  
    @HierarchyType_ID       TINYINT,  
    @Item_ID                INT = NULL,  
    @ItemType_ID            INT = NULL,  
    @ParentItem_ID          INT = NULL,  
    @ParentItemType_ID      INT = NULL,  
    @Parent_ID              INT,  
    @RowLimit               INT = NULL,  
    @IncludeDeny            BIT = 0,  
    @AnchorNullRecursions   BIT = 0,  
    @ReturnXML              BIT = 0,  
    @EntityMemberTypeID     TINYINT = 0,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE @EntityTable                    SYSNAME,  
            @HierarchyParentTable           SYSNAME,  
            @HierarchyTable                 SYSNAME,  
            @HierarchyView                  SYSNAME,  
            @CollectionMemberTable          SYSNAME,  
            @CollectionTable                SYSNAME,  
            @ViewName                       SYSNAME,  
            @SQL                            NVARCHAR(MAX),  
            @Model_ID                       INT,  
            @ModelPrivilege_ID              INT,  
            @ModelAccessPermission          TINYINT,  
            @ModelLeafPrivilege_ID          INT,  
            @ModelLeafAccessPermission      TINYINT,  
            @ModelConsolidatedPrivilege_ID  INT,  
            @ModelConsolidatedAccessPermission  TINYINT,  
            @HRPrivilege_ID                 INT,  
            @HRAccessPermission             TINYINT,  
            @MemberType_ID                  TINYINT,  
            @Object_ID                      INT, --Security object  
            @SecItem_ID                     INT, --Security item  
            @RootSecured                    INT,  
            @MemberPrivilege_ID             INT,  
            @MemberAccessPermission         TINYINT,  
            @Entity_ID                      INT,  
            @UseMemberSecurity              INT, --0=No,1=Yes,2 LeafOnly  
  
            @MemberType_Leaf                TINYINT = 1,  
            @MemberType_Consolidated        TINYINT = 2,  
  
            @EntityMUID                     UNIQUEIDENTIFIER,  
            @HierarchyMUID                  UNIQUEIDENTIFIER,  
            @strEntityName                  NVARCHAR(MAX),  
            @ParamList                      NVARCHAR(MAX),  
            @RowLimitText                   NVARCHAR(11),  
            @MemberSecurityCTE              NVARCHAR(MAX),  
            @EntitySecurityTable            SYSNAME,  
            @HierarchyParentSecurityTable   SYSNAME;  
  
    DECLARE @ProcID SYSNAME; SET @ProcID = OBJECT_NAME(@@PROCID);  
  
    DECLARE @ExplicitHierarchyType_ID TINYINT = 0;  
    DECLARE @DerivedHierarchyType_ID TINYINT = 1;  
    DECLARE @CollectionType_ID TINYINT = 2;  
  
    IF @HierarchyType_ID < 0 OR @HierarchyType_ID > 2 -- Hierarchy type should be 0, 1, 2  
        OR (@HierarchyType_ID <> 0 AND (@Item_ID IS NULL OR @ItemType_ID IS NULL OR @ItemType_ID < 0 OR @ItemType_ID > 3)) -- Item type and ID can not be NULL, item type should be 0-3  
    BEGIN  
        RAISERROR('MDSERR100010|The Parameters are not valid.', 16, 1);  
        RETURN(1);  
    END  
  
    SET @MemberPrivilege_ID = 4;  
    SET @MemberAccessPermission = 7;  
  
    SELECT @Model_ID = Model_ID FROM mdm.tblModelVersion WHERE ID = @Version_ID  
  
    SET @RootSecured=0  
  
    --Get Entity_ID  
    IF @HierarchyType_ID = @ExplicitHierarchyType_ID --Explicit  
        BEGIN  
            SET @Entity_ID = @Item_ID  
        END  
    ELSE --Derived  
        BEGIN  
            SET @Entity_ID =  
            CASE  
                WHEN @ItemType_ID = 0 THEN @Item_ID  
                WHEN @ItemType_ID = 1 THEN (SELECT DomainEntity_ID FROM mdm.tblAttribute WHERE ID = @Item_ID)  
                WHEN @ItemType_ID = 2 THEN (SELECT Entity_ID FROM mdm.tblHierarchy WHERE ID = @Item_ID)  
                WHEN @ItemType_ID = 3 THEN @Item_ID  
            END  
        END  
  
  
    --Assign the Object ID  
    --This used be different based on the Parent_ID. See TFS 142134  
    SET @Object_ID = CASE @HierarchyType_ID  
        WHEN @ExplicitHierarchyType_ID THEN 6  
        WHEN @CollectionType_ID THEN 11  
        ELSE  
        CASE @ItemType_ID  
            WHEN 0 THEN 3  
            WHEN 1 THEN 4  
            WHEN 2 THEN 6  
            WHEN 3 THEN 3  
            ELSE 0 END  
        END  
  
    /*  
    Assign the member type:  
    ----------------------  
    2: Default value  
    1: Start ID = -1 indicates Unused (non-mandatory hierarchy)  
    1: Hierarchy ID = 1 indicates a Derived Hierarchy  
    3: Hierarchy ID = 2 indicates a Collection  
    */  
    SELECT @MemberType_ID = CASE WHEN @Parent_ID = -1 THEN 1 WHEN @HierarchyType_ID = @DerivedHierarchyType_ID THEN 1 WHEN @HierarchyType_ID = @CollectionType_ID THEN 3 ELSE 2 END  
  
    --For an Explicit Hierarchy the MemberType ID represents the Item ID  
    IF @HierarchyType_ID = @ExplicitHierarchyType_ID SET @Item_ID = ISNULL(@Item_ID, (SELECT Entity_ID FROM mdm.tblHierarchy WHERE ID = @Hierarchy_ID))  
  
    --Determine the item ID to use when determining the default security permissions (Explicit Hierarchies are secured on the Hierarchy_ID).  
    --This used be different based on the Parent_ID.  See TFS 142134  
    SET @SecItem_ID = CASE @HierarchyType_ID WHEN @ExplicitHierarchyType_ID THEN @Hierarchy_ID ELSE @Item_ID END  
  
    --Fetch the default privilege for the selected member type within the current hierarchy.  
    --SELECT @ModelPrivilege_ID = mdm.udfSecurityUserMemberDefault(@User_ID, @SecItem_ID, @Object_ID, @MemberType_ID)  
    --SELECT @ModelLeafPrivilege_ID = mdm.udfSecurityUserMemberDefault(@User_ID, @SecItem_ID, @Object_ID, 1)  
    --PERF - moved these calls to a udp to decrease the execution plan compile time.  
    EXEC mdm.udpSecurityUserMemberDefault  
        @User_ID = @User_ID,  
        @Item_ID = @SecItem_ID,  
        @Object_ID = @Object_ID,  
        @MemberType_ID = @MemberType_ID,  
        @Privilege_ID = @ModelPrivilege_ID OUTPUT,  
        @AccessPermission = @ModelAccessPermission OUTPUT;  
  
    EXEC mdm.udpSecurityUserMemberDefault  
        @User_ID = @User_ID,  
        @Item_ID = @SecItem_ID,  
        @Object_ID = @Object_ID,  
        @MemberType_ID = 1,  
        @Privilege_ID = @ModelLeafPrivilege_ID OUTPUT,  
        @AccessPermission = @ModelLeafAccessPermission OUTPUT;  
  
        IF(@MemberType_ID = 3)  
        BEGIN  
            EXEC mdm.udpSecurityUserMemberDefault  
                @User_ID = @User_ID,  
                @Item_ID = @SecItem_ID,  
                @Object_ID = @Object_ID,  
                @MemberType_ID = 2,  
                @Privilege_ID = @ModelConsolidatedPrivilege_ID OUTPUT,  
                @AccessPermission = @ModelConsolidatedAccessPermission OUTPUT;  
        END  
  
    --Initialize variables  
    SET @SQL = N''  
    IF @ModelPrivilege_ID = 1 --if default privilege is Deny then do not return any rows  
        SET @RowLimitText = N'0'  
    ELSE  
        BEGIN  
            SET @RowLimitText = ISNULL(CAST(@RowLimit as NVARCHAR(11)), N'100 Percent')  
        END  
  
    --Figure out if Member security is used  
    SET @UseMemberSecurity = mdm.udfUseMemberSecurity (@User_ID, @Entity_ID, @Version_ID, @MemberType_ID);  
  
    --If UseMemberSecurity is false for Consolidated Members, check again for Leaf Members to handle the case  
    --where member security was set for a Derived Hierarchy whose leaf members fall within this Explicit Hierarchy.  
    IF @UseMemberSecurity = 0 AND @MemberType_ID = @MemberType_Consolidated  
        AND mdm.udfUseMemberSecurity(@User_ID, @Entity_ID, @Version_ID, @MemberType_Leaf) = 1  
    BEGIN  
        SET @UseMemberSecurity = 2;  
    END  
  
    --PRINT '@User_ID: ' + convert(nvarchar(100),@User_ID);  
    --PRINT '@Version_ID: ' + convert(nvarchar(100),@Version_ID);  
    --PRINT '@Hierarchy_ID: ' + convert(nvarchar(100),@Hierarchy_ID);  
    --PRINT '@HierarchyType_ID: ' + convert(nvarchar(100),@HierarchyType_ID);  
    --PRINT '@Entity_ID: ' + convert(nvarchar(100),@Entity_ID);  
    --PRINT '@Item_ID: ' + convert(nvarchar(100),@Item_ID);  
    --PRINT '@ItemType_ID: ' + convert(nvarchar(100),@ItemType_ID);  
  
    --PRINT '@UseMemberSecurity: ' + convert(nvarchar(100),@UseMemberSecurity);  
    --Check to see if Root is secured  
    IF EXISTS(  
        SELECT * FROM mdm.viw_SYSTEM_SECURITY_USER_MEMBER  
        WHERE  
            IsMapped=1 AND  
            User_ID = @User_ID AND  
            Hierarchy_ID = @Hierarchy_ID AND  
            HierarchyType_ID = @HierarchyType_ID AND  
            Member_ID=0  
        ) AND @UseMemberSecurity=1  
    SET @RootSecured=1  
    ----------------------------------------------------------------------------------------  
  
  
    SELECT @EntityMUID=MUID,@strEntityName=[Name] FROM mdm.tblEntity WHERE ID=@Entity_ID  
    IF @HierarchyType_ID = @ExplicitHierarchyType_ID SELECT @HierarchyMUID=MUID FROM mdm.tblHierarchy WHERE ID=@Hierarchy_ID  
  
  
    --BEGIN PROCESSING  
    --Criterion 1: process explicit hierarchy  
    IF @HierarchyType_ID = @ExplicitHierarchyType_ID  
        BEGIN  
            SELECT  
                @EntityTable = EntityTable,  
                @HierarchyParentTable = HierarchyParentTable,  
                @HierarchyTable = HierarchyTable,  
                @EntitySecurityTable = CAST(EntityTable + '_MS' AS SYSNAME),  
                @HierarchyParentSecurityTable = CASE WHEN HierarchyParentTable IS NOT NULL THEN CAST(HierarchyParentTable + '_MS' AS SYSNAME) ELSE NULL END  
            FROM  
                mdm.tblEntity  
            WHERE  
                ID = @Item_ID;  
  
  
            SET @MemberSecurityCTE = CONCAT(N'  
                            --Member security cte  
                            DECLARE @Ancestors TABLE(MemberID INT, MemberTypeID INT, AncestorID INT,AncestorMemberTypeID INT,LevelNumber SMALLINT);  
                            DECLARE @RAM TABLE(VersionID INT,[HierarchyID] INT,MemberID INT, MemberTypeID INT);  
                            DECLARE @TempVersionID INT;  
                            DECLARE @TempHierarchyID INT;  
                            DECLARE @TempMemberID INT;  
                            DECLARE @TempMemberTypeID INT;  
                            INSERT INTO @RAM  SELECT Version_ID,Hierarchy_ID, Member_ID,MemberType_ID FROM mdm.tblSecurityRoleAccessMember WHERE Hierarchy_ID=', @Hierarchy_ID, N' AND HierarchyType_ID = ', @HierarchyType_ID, N' ;  
                            WHILE (SELECT COUNT(*) FROM @RAM) <> 0  
                            BEGIN  
                                SELECT TOP 1  
                                    @TempVersionID=VersionID, @TempHierarchyID=HierarchyID, @TempMemberID=MemberID, @TempMemberTypeID=MemberTypeID  
                                FROM @RAM ORDER BY VersionID;  
  
                                INSERT INTO @Ancestors  
                                EXEC mdm.udpHierarchyAncestorsGet @User_ID, @TempVersionID, @TempHierarchyID, @TempMemberID, @TempMemberTypeID, 1;  
  
                                DELETE FROM @RAM WHERE VersionID=@TempVersionID AND HierarchyID=@TempHierarchyID AND MemberID=@TempMemberID AND MemberTypeID=@TempMemberTypeID;  
                            END;  
                            WITH membersresolved as  
                            (  
                                SELECT  
                                    ID AS Member_ID,  
                                    ', @MemberType_Leaf, N' AS MemberType_ID,  
                                    AccessPermission  
                                FROM  
                                    mdm.', QUOTENAME(@EntitySecurityTable), N' X  
                                WHERE X.User_ID = @User_ID  
                                    AND X.Version_ID = @Version_ID',  
                                    CASE  
                                        WHEN @HierarchyParentSecurityTable IS NOT NULL THEN CONCAT(N'  
                                UNION ALL  
                                SELECT  
                                    ID AS Member_ID,  
                                    ', @MemberType_Consolidated, N' AS MemberType_ID,  
                                    AccessPermission  
                                FROM  
                                    mdm.', QUOTENAME(@HierarchyParentSecurityTable), N' X  
                                WHERE X.User_ID = @User_ID  
                                    AND X.Version_ID = @Version_ID')  
                                        ELSE N''  
                                    END, N'  
                            ),  
                            TopMostSecuredNodes as  
                            (  
                            SELECT DISTINCT MemberID,MemberTypeID FROM @Ancestors  
                            WHERE MemberID NOT IN (select MemberID from @Ancestors WHERE AncestorID IN(SELECT MemberID FROM @Ancestors) )  
                            )');  
  
            SELECT @HierarchyView = mdm.udfViewNameGetByID(@Item_ID, 4, 0, 0)  
  
            IF @Parent_ID = -1 --Unused (non-mandatory hierarchy)  
                BEGIN  
                --Are the table variables we want to use not null?  
                    IF @HierarchyTable IS NULL  
                    BEGIN  
                        RAISERROR('MDSERR100104|A required schema object for this call is missing. Verify that the Hierarchy table exists for this entity.', 16, 1);  
                        RETURN;  
                    END  
                    IF @EntityTable IS NULL  
                    BEGIN  
                        RAISERROR('MDSERR100103|A required schema object for this call is missing. Verify that the Entity table exists for this entity.', 16, 1);  
                        RETURN;  
                    END  
  
                    --For Non-Mandatory hierarchies, we always use the member security as we  
                    --have to get the permissions of the nodes of where they reside now  
                    SET @SQL = CASE WHEN @UseMemberSecurity <> 0 THEN @MemberSecurityCTE ELSE + ' ' END + N'  
                        SELECT TOP ' + @RowLimitText + N'  
                            tEN.Code                    AS Code,  
                            ISNULL(tEN.Name, '''')        AS Name,  
                            ''MDMUNUSED''                AS ParentCode,  
                            ''''                        AS ParentName,  
                            @EntityMUID                    AS ChildEntity_MUID ,  
                            @EntityName                    AS ChildEntity_Name ,  
                            @EntityID                    AS ParentEntity_ID,  
                            @EntityMUID                    AS ParentEntity_MUID,  
                            @EntityName                    AS ParentEntity_Name,  
                            @HierarchyMUID                AS RelationshipId,  
                            2                            AS RelationshipTypeId,  
                            -1                            AS Parent_ID,  
                            0                            AS Hierarchy_ID,  
                            tEN.ID                        AS Child_ID,  
                            CONVERT(INT,1)                AS ChildType_ID,  
                            CONVERT(INT,2)                AS ParentType_ID,  
                            -1                            AS SortOrder,  
                            0                            AS NextHierarchyType_ID,  
                            @MemberPrivilegeID AS Privilege_ID,  
                            CONVERT(INTEGER,ISNULL(SR.AccessPermission, @MemberAccessPermission)) AS AccessPermission,  
                            @ModelPrivilegeID               AS ModelPrivilege_ID,  
                            @ModelAccessPermission          AS ModelAccessPermission  
                        FROM  
                            mdm.' + QUOTENAME(@EntityTable) + N' AS tEN '  
                        IF @UseMemberSecurity <> 0 SET @SQL = @SQL + N'  
                                INNER JOIN membersresolved AS SR  
                                        ON SR.Member_ID = tEN.ID  
                                        AND SR.MemberType_ID = 1 '  
                        IF @UseMemberSecurity = 0 SET @SQL = @SQL + N'  
                                LEFT JOIN membersresolved AS SR  
                                        ON SR.Member_ID = tEN.ID  
                                        AND SR.MemberType_ID = 1 '  
                         SET @SQL = @SQL + N'  
                            WHERE  
                                tEN.Status_ID = 1 AND '  
                            IF @IncludeDeny <> 1 SET @SQL = @SQL + N'SR.AccessPermission IS NOT NULL AND '  
                            SET @SQL = @SQL + N'  
                                tEN.Version_ID = @Version_ID AND  
                                NOT EXISTS  
                                (  
                                    SELECT  
                                        tHR.Child_EN_ID  
                                    FROM  
                                        mdm.' + QUOTENAME(@HierarchyTable) + N' AS tHR  
                                    WHERE  
                                        tHR.Child_EN_ID = tEN.ID AND  
                                        tHR.Version_ID = @Version_ID AND  
                                        tHR.ChildType_ID = 1 AND  
                                        tHR.Status_ID = 1 AND  
                                        tHR.Hierarchy_ID = @HierarchyID  
                                )  
                            ORDER BY  
                                tEN.Code  
                        '  
                        IF @ReturnXML=1  
                            SET @SQL = @SQL + N'  
                            FOR XML PATH(''MemberData''),ELEMENTS,ROOT(''ArrayOfMemberData'');'  
  
                        SET @ParamList = N'@MemberPrivilegeID       INT  
                                          ,@MemberAccessPermission  INT  
                                          ,@ModelPrivilegeID        INT  
                                          ,@ModelAccessPermission   INT  
                                          ,@User_ID                 INT  
                                          ,@EntityID                INT  
                                          ,@Version_ID              INT  
                                          ,@HierarchyID             INT  
                                          ,@EntityMUID              UNIQUEIDENTIFIER  
                                          ,@EntityName              NVARCHAR(MAX)  
                                          ,@HierarchyMUID           UNIQUEIDENTIFIER'  
  
                        EXEC sp_executesql @SQL, @ParamList  
                                ,@MemberPrivilege_ID  
                                ,@MemberAccessPermission  
                                ,@ModelPrivilege_ID  
                                ,@ModelAccessPermission  
                                ,@User_ID  
                                ,@Entity_ID  
                                ,@Version_ID  
                                ,@Hierarchy_ID  
                                ,@EntityMUID  
                                ,@strEntityName  
                                ,@HierarchyMUID  
  
            END ELSE BEGIN --Used (mandatory hierarchy)  
  
                IF OBJECT_ID(N'mdm.'+@HierarchyView,N'V') IS NULL BEGIN  
                        RAISERROR('MDSERR100102|A view is required.', 16, 1);  
                        RETURN;  
                END; --if  
  
                SET @SQL = CASE WHEN @UseMemberSecurity <> 0 THEN @MemberSecurityCTE ELSE + ' ' END + N'  
                    SELECT TOP ' + @RowLimitText + N'  
                        tHR.Child_Code                    AS Code,  
                        tHR.Child_Name                    AS Name,  
                        tHR.Parent_Code                    AS ParentCode,  
                        tHR.Parent_Name                    AS ParentName,  
                        @EntityID                        AS Item_ID,  
                        0                                AS ItemType_ID,  
                        @EntityID                        AS ParentItem_ID,  
                        @EntityID                        AS ChildEntity_ID,  
                        @EntityMUID                        AS ChildEntity_MUID ,  
                        @EntityName                        AS ChildEntity_Name ,  
                        @EntityID                        AS ParentEntity_ID,  
                        @EntityMUID                        AS ParentEntity_MUID,  
                        @EntityName                        AS ParentEntity_Name,  
                        @HierarchyMUID                    AS RelationshipId,  
                        2                                AS RelationshipTypeId,  
                        0                                AS ParentItemType_ID,  
                        tHR.Parent_ID,  
                        tHR.Hierarchy_ID,  
                        tHR.Child_ID                    AS Child_ID,  
                        CONVERT(INT,tHR.ChildType_ID)    AS ChildType_ID,  
                        2                                AS ParentType_ID,  
                        tHR.Child_SortOrder                AS SortOrder,  
                        @HierarchyID                    AS NextHierarchy_ID,  
                        0                                AS NextHierarchyType_ID,  
                        CASE WHEN tHR.ChildType_ID=1 THEN @ModelLeafPrivilegeID ELSE @ModelPrivilegeID END AS ModelPrivilege_ID,  
                        CASE WHEN tHR.ChildType_ID=1 THEN @ModelLeafAccessPermission ELSE @ModelAccessPermission END AS ModelAccessPermission,';  
                IF @UseMemberSecurity <> 0 SET @SQL = @SQL + N'  
                        @MemberPrivilegeID AS Privilege_ID,  
                        CONVERT(INTEGER,ISNULL(SR.AccessPermission, @MemberAccessPermission)) AS AccessPermission'  
                ELSE SET @SQL += N'  
                        CASE WHEN tHR.ChildType_ID=1 AND @ModelLeafPrivilegeID =1 THEN @ModelLeafPrivilegeID ELSE @ModelPrivilegeID END AS Privilege_ID,  
                        CASE WHEN tHR.ChildType_ID=1 AND @ModelLeafPrivilegeID =1 THEN @ModelLeafAccessPermission ELSE @ModelAccessPermission END AS AccessPermission'  
                SET @SQL = @SQL + N'  
                    FROM '  
                IF @RootSecured=0 AND ISNULL(@Parent_ID, 0) = 0 AND @UseMemberSecurity = 1 SET @SQL = @SQL + N'  
                        TopMostSecuredNodes AS SU  
                    INNER JOIN mdm.' + QUOTENAME(@HierarchyView) + N' AS tHR  
                        ON SU.MemberID = tHR.Child_HP_ID  
                        AND SU.MemberTypeID = tHR.ChildType_ID  
                        AND tHR.Hierarchy_ID = @HierarchyID  
                        '  
                IF (ISNULL(@Parent_ID, 0) = 0 AND @UseMemberSecurity <> 1) OR @RootSecured=1 OR ISNULL(@Parent_ID, 0) <> 0 SET @SQL = @SQL + N'  
                        mdm.' + QUOTENAME(@HierarchyView) + N' tHR '  
                IF @UseMemberSecurity = 1 SET @SQL = @SQL + N'  
                    LEFT JOIN membersresolved AS SR  
                        ON SR.Member_ID = tHR.Child_ID  
                        AND SR.MemberType_ID = tHR.ChildType_ID'  
                IF @UseMemberSecurity = 2 SET @SQL = @SQL + N'  
                    LEFT JOIN membersresolved AS SR  
                        ON SR.Member_ID = tHR.Child_ID  
                        AND SR.MemberType_ID = tHR.ChildType_ID  
                        AND tHR.ChildType_ID = 1'  
                SET @SQL = @SQL + N'  
                    WHERE  
                        tHR.Version_ID = @Version_ID  
                        AND tHR.Hierarchy_ID = @HierarchyID'  
                  IF ISNULL(@Parent_ID, 0) > 0 OR @RootSecured=1 OR (ISNULL(@Parent_ID, 0) = 0 AND @UseMemberSecurity <> 1) SET @SQL = @SQL + N'  
                        AND ((tHR.Parent_ID IS NULL AND NULLIF(@ParentID, 0) IS NULL) OR (tHR.Parent_ID = @ParentID))'  
                IF @IncludeDeny <> 1 AND @UseMemberSecurity <> 0 SET @SQL = @SQL + N'  
                        AND SR.AccessPermission IS NOT NULL'  
                IF @UseMemberSecurity = 2 SET @SQL = @SQL + N'  
                        AND ISNULL(SR.AccessPermission, 0) <> CASE  
                                WHEN tHR.ChildType_ID = 2 THEN -1  
                                WHEN tHR.ChildType_ID = 1 THEN 0  
                            END'  
                -- Add @EntityMemberTypeID  
                IF @EntityMemberTypeID > 0 SET @SQL += N'  
                        AND tHR.ChildType_ID = @EntityMemberTypeID'  
  
                SET @SQL = @SQL + N'  
                    ORDER BY SortOrder'  
  
                IF @ReturnXML=1  
                    SET @SQL = @SQL + N'  
                    FOR XML PATH(''MemberData''),ELEMENTS,ROOT(''ArrayOfMemberData'');'  
  
                SET @ParamList = N'  
                     @EntityID                  INT  
                    ,@EntityMemberTypeID        INT  
                    ,@EntityMUID                UNIQUEIDENTIFIER  
                    ,@EntityName                NVARCHAR(MAX)  
                    ,@HierarchyID               INT  
                    ,@ModelLeafPrivilegeID      INT  
                    ,@ModelLeafAccessPermission TINYINT  
                    ,@MemberPrivilegeID         INT  
                    ,@MemberAccessPermission    TINYINT  
                    ,@ModelPrivilegeID          INT  
                    ,@ModelAccessPermission     TINYINT  
                    ,@User_ID                   INT  
                    ,@Version_ID                INT  
                    ,@ParentID                  INT  
                    ,@HierarchyMUID             UNIQUEIDENTIFIER';  
  
                EXEC sp_executesql  
                     @SQL  
                    ,@ParamList  
                    ,@Entity_ID  
                    ,@EntityMemberTypeID  
                    ,@EntityMUID  
                    ,@strEntityName  
                    ,@Hierarchy_ID  
                    ,@ModelLeafPrivilege_ID  
                    ,@ModelLeafAccessPermission  
                    ,@MemberPrivilege_ID  
                    ,@MemberAccessPermission  
                    ,@ModelPrivilege_ID  
                    ,@ModelAccessPermission  
                    ,@User_ID  
                    ,@Version_ID  
                    ,@Parent_ID  
                    ,@HierarchyMUID;  
            END; --if  
        END; --if  
  
    --Criterion 2: process Derived Hierarchy  
    ELSE IF @HierarchyType_ID = @DerivedHierarchyType_ID  
        BEGIN  
            SET @ViewName = CONCAT(N'viw_SYSTEM_', @Model_ID, N'_', @Hierarchy_ID, N'_PARENTCHILD_DERIVED')  
            IF OBJECT_ID(N'mdm.'+@ViewName,N'V') IS NULL  
                BEGIN  
                    RAISERROR('MDSERR100102|A view is required.', 16, 1);  
                    RETURN;  
                END  
            SELECT  
                @EntitySecurityTable = CAST(EntityTable + '_MS' AS SYSNAME),  
                @HierarchyParentSecurityTable = CASE WHEN HierarchyParentTable IS NOT NULL THEN CAST(HierarchyParentTable + '_MS' AS SYSNAME) ELSE NULL END  
            FROM mdm.tblEntity WHERE ID = @Entity_ID;  
  
            SET @MemberSecurityCTE = CONCAT(N'  
                            --Member security cte  
                            WITH membersresolved as  
                            (  
                                SELECT  
                                    ID AS Member_ID,  
                                    ', @MemberType_Leaf, N' AS MemberType_ID,  
                                    AccessPermission  
                                FROM  
                                    mdm.', QUOTENAME(@EntitySecurityTable), N' X  
                                WHERE X.User_ID = @User_ID  
                                    AND X.Version_ID = @Version_ID',  
                                    CASE  
                                        WHEN @HierarchyParentSecurityTable IS NOT NULL THEN CONCAT(N'  
                                UNION ALL  
                                SELECT  
                                    ID AS Member_ID,  
                                    ', @MemberType_Consolidated, N' AS MemberType_ID,  
                                    AccessPermission  
                                FROM  
                                    mdm.', QUOTENAME(@HierarchyParentSecurityTable), N' X  
                                WHERE X.User_ID = @User_ID  
                                    AND X.Version_ID = @Version_ID')  
                                        ELSE N''  
                                    END, N'  
                            ),  
                            TopMostSecuredNodes as  
                            (  
                            SELECT Version_ID, Hierarchy_ID, Entity_ID, Member_ID, MemberType_ID, Privilege_ID, AccessPermission  
                            FROM mdm.tblSecurityRoleAccessMember X  
                            INNER JOIN [mdm].[viw_SYSTEM_SECURITY_USER_ROLE] U ON X.Role_ID = U.Role_ID  
                                    AND U.User_ID = @User_ID  
                            WHERE Hierarchy_ID= ', @Hierarchy_ID, N' AND HierarchyType_ID = ', @HierarchyType_ID, N'  
                            )');  
            SET @SQL =  CASE WHEN @UseMemberSecurity <> 0 THEN @MemberSecurityCTE ELSE + ' ' END + N'  
                SELECT TOP ' + @RowLimitText + N'  
                    tHR.Child_ID                AS Child_ID,  
                    CONVERT(INT,ChildType_ID)    AS ChildType_ID,  
                    tHR.Entity_ID,  
                    NextEntity_ID,  
                    tHR.Entity_ID as ChildEntity_ID,  
                    Entity_MUID as ChildEntity_MUID,  
                    NextEntity_ID as ParentEntity_ID,  
                    NextEntity_MUID as ParentEntity_MUID,  
                    tHR.Item_ID,  
                    tHR.Item_MUID as RelationshipId,  
                    tHR.ItemType_ID as RelationshipTypeId,  
                    tHR.ItemType_ID,  
                    tHR.NextItem_ID,  
                    tHR.NextItemType_ID,  
                    tHR.ParentItem_ID,  
                    tHR.ParentItemType_ID,  
                    tHR.DomainAttribute_ID,  
                    CASE  
                        WHEN tHR.ItemType_ID = 3 THEN tHR.NextItem_ID  
                        WHEN tHR.ItemType_ID = 2 AND tHR.NextItemType_ID = 2 THEN tHR.Item_ID  
                        ELSE ''''  
                    END Hierarchy_ID,  
                    tHR.ChildCode Code,  
                    tHR.ChildName Name,  
                    tHR.ParentCode ParentCode,  
                    tHR.ParentName ParentName,  
                    tHR.ParentType_ID,  
                    ParentVisible,  
                    @HierarchyID  NextHierarchy_ID,  
                    1 NextHierarchyType_ID,  
                    tHR.Level,'  
                    SET @SQL = @SQL + N' @ModelPrivilegeID  AS ModelPrivilege_ID, @ModelAccessPermission AS ModelAccessPermission, '  
                    IF @UseMemberSecurity <> 0 BEGIN  
                        IF  @RootSecured = 0 AND ISNULL(@Parent_ID, 0) = 0 BEGIN  
                            SET @SQL = @SQL + N'CONVERT(INTEGER,ISNULL(SU.Privilege_ID, @MemberPrivilegeID )) AS Privilege_ID, CONVERT(INTEGER,ISNULL(SU.AccessPermission, @MemberAccessPermission )) AS AccessPermission';  
                        END ELSE BEGIN  
                            SET @SQL = @SQL + N'CONVERT(INTEGER, @MemberPrivilegeID) AS Privilege_ID, CONVERT(INTEGER,ISNULL(SR.AccessPermission, @MemberAccessPermission )) AS AccessPermission';  
                        END  
                    END ELSE BEGIN  
                        SET @SQL = @SQL + ' @ModelPrivilegeID AS Privilege_ID,  @ModelAccessPermission AS AccessPermission';  
                    END  
                    SET @SQL = @SQL + N' FROM '  
                    IF @RootSecured=0 AND ISNULL(@Parent_ID, 0) = 0 AND @UseMemberSecurity <> 0  
                        SET @SQL += N' TopMostSecuredNodes AS SU  
                        INNER JOIN mdm.' + QUOTENAME(@ViewName) + N' AS tHR  
                            ON SU.Entity_ID = tHR.Entity_ID  
                            AND SU.MemberType_ID = tHR.ChildType_ID  
                            AND SU.Member_ID = tHR.Child_ID  
                            --AND tHR.NextItem_ID = @ParentItemID  
                            --AND tHR.NextItemType_ID = @ParentItemTypeID  
                            AND SU.Hierarchy_ID = @HierarchyID  
                            AND SU.Privilege_ID <> 1 -- deny access';  
                    IF (ISNULL(@Parent_ID, 0) = 0 AND @UseMemberSecurity = 0) OR ISNULL(@Parent_ID, 0) <> 0 OR @RootSecured=1  
                        SET @SQL = @SQL + N' mdm.' + QUOTENAME(@ViewName) + N' AS tHR '  
                    IF ISNULL(@Parent_ID, 0) = 0 AND @UseMemberSecurity = 1 AND @RootSecured<>1 SET @SQL = @SQL + N'  
                    LEFT JOIN membersresolved AS SR  
                            ON SR.Member_ID = tHR.Child_ID  
                            AND SR.MemberType_ID = tHR.ChildType_ID'  
                    IF (ISNULL(@Parent_ID, 0) <> 0 AND @UseMemberSecurity = 1) OR (@RootSecured=1 AND @UseMemberSecurity = 1) SET @SQL = @SQL + N'  
                    LEFT JOIN membersresolved AS SR  
                            ON SR.Member_ID = tHR.Child_ID  
                            AND SR.MemberType_ID = tHR.ChildType_ID '  
                    IF @UseMemberSecurity = 2 SET @SQL = @SQL + N'  
                    LEFT JOIN membersresolved AS SR  
                            ON SR.Member_ID = tHR.Child_ID  
                            AND SR.MemberType_ID = tHR.ChildType_ID'  
  
                DECLARE @PartialSearchTerm NVARCHAR(MAX) = N'';  
  
                IF ISNULL(@Parent_ID, 0) > 0 OR (ISNULL(@Parent_ID, 0) = 0 AND @UseMemberSecurity = 0) OR @RootSecured=1 SET @PartialSearchTerm = @PartialSearchTerm + CASE @PartialSearchTerm WHEN N'' THEN N' WHERE ' ELSE N' AND ' END + N'tHR.Item_ID = @ItemID AND  
                    tHR.ItemType_ID = @ItemTypeID  AND  
                    tHR.Parent_ID = @ParentID'  
                IF ISNULL(@Parent_ID, 0) > 0 AND @ParentItem_ID=@Item_ID AND @ItemType_ID=@ParentItemType_ID AND @ItemType_ID<>2 SET @PartialSearchTerm = @PartialSearchTerm + CASE @PartialSearchTerm WHEN N'' THEN N' WHERE ' ELSE N' AND ' END + N'  
                    tHR.ParentItem_ID = @ParentItemID  AND  
                    tHR.ParentItemType_ID = @ParentItemTypeID'  
                SET @PartialSearchTerm = @PartialSearchTerm + CASE @PartialSearchTerm WHEN N'' THEN N' WHERE ' ELSE N' AND ' END + N'tHR.Version_ID = @Version_ID '  
                IF @UseMemberSecurity = 2 SET @PartialSearchTerm = @PartialSearchTerm + CASE @PartialSearchTerm WHEN N'' THEN N' WHERE ' ELSE N' AND ' END + N'ISNULL(SR.AccessPermission, 0) <> CASE  
                                                                                                        WHEN tHR.ChildType_ID = 2 THEN -1  
                                                                                                        WHEN tHR.ChildType_ID = 1 THEN 0  
                                                                                                    END'  
  
                IF @AnchorNullRecursions = 1 SET @PartialSearchTerm = @PartialSearchTerm + CASE @PartialSearchTerm WHEN N'' THEN N' WHERE ' ELSE N' AND ' END +  
                    N'(tHR.Child_ID NOT IN (SELECT tHR2.Child_ID  
                         FROM mdm.' + QUOTENAME(@ViewName) + N' AS tHR2  
                         WHERE tHR2.Version_ID = @Version_ID AND tHR2.Parent_ID <> 0 AND tHR2.[Entity_ID] = tHR.[Entity_ID]))'  
  
                IF @IncludeDeny <> 1 AND @UseMemberSecurity <> 0 SET @PartialSearchTerm = @PartialSearchTerm + CASE @PartialSearchTerm WHEN N'' THEN N' WHERE ' ELSE N' AND ' END + N'SR.AccessPermission IS NOT NULL '  
                IF ISNULL(@Parent_ID, 0) > 0 AND @ParentItem_ID=@Item_ID AND @ItemType_ID=@ParentItemType_ID AND @ItemType_ID<>2 SET @PartialSearchTerm = @PartialSearchTerm + CASE @PartialSearchTerm WHEN N'' THEN N' WHERE ' ELSE N' AND ' END + N'tHR.Level >=  
                        (  
                        SELECT  
                            MAX(Level) FROM mdm.' + QUOTENAME(@ViewName) + N'  
                        WHERE  
                            Item_ID = @ItemID  AND  
                            ItemType_ID = @ItemTypeID  AND  
                            Parent_ID = @ParentID  AND  
                            ParentItem_ID = @ParentItemID  AND  
                            ParentItemType_ID = @ParentItemTypeID AND  
                            Version_ID = @Version_ID  
                        )'  
                SET @SQL = @SQL + @PartialSearchTerm + N' ORDER BY SortItem '  
  
                SET @ParamList = N'@HierarchyID             INT  
                                ,@ModelPrivilegeID          INT  
                                ,@ModelAccessPermission     TINYINT  
                                ,@MemberPrivilegeID         INT  
                                ,@MemberAccessPermission    TINYINT  
                                ,@User_ID                    INT  
                                ,@Version_ID                INT  
                                ,@EntityID                  INT  
                                ,@ItemID                    INT  
                                ,@ItemTypeID                INT  
                                ,@ParentID                  INT  
                                ,@ParentItemID              INT  
                                ,@ParentItemTypeID          INT'  
  
                IF @ReturnXML = 1  
                    SET @SQL = @SQL + N' FOR XML PATH(''MemberData''),ELEMENTS,ROOT(''ArrayOfMemberData'');';  
  
                --PRINT(@SQL);  
                EXEC sp_executesql  
                     @SQL  
                    ,@ParamList  
                    ,@Hierarchy_ID  
                    ,@ModelPrivilege_ID  
                    ,@ModelAccessPermission  
                    ,@MemberPrivilege_ID  
                    ,@MemberAccessPermission  
                    ,@User_ID  
                    ,@Version_ID  
                    ,@Entity_ID  
                    ,@Item_ID  
                    ,@ItemType_ID  
                    ,@Parent_ID  
                    ,@ParentItem_ID  
                    ,@ParentItemType_ID;  
  
  
        END  
  
    --Criterion 3: process Collection or Collection members  
    ELSE IF @HierarchyType_ID = @CollectionType_ID  
        BEGIN  
            SELECT  
                @EntityTable = EntityTable,  
                @HierarchyParentTable = HierarchyParentTable,  
                @CollectionMemberTable = CollectionMemberTable,  
                @CollectionTable = CollectionTable  
            FROM [mdm].tblEntity WHERE ID = @Item_ID  
  
            IF @Hierarchy_ID = 0 --List all Collections  
                BEGIN  
                    --Are the table variables we want to use not null?  
                    IF @CollectionTable IS NULL  
                    BEGIN  
                        -- No collections have been defined yet, so return.  
                        RETURN;  
                    END  
  
                    SET @SQL =  
                    N'  
                    SELECT  TOP ' + @RowLimitText + N'  
                        tCN.ID Member_ID,  
                        3 MemberType_ID,  
                        tCN.ID Hierarchy_ID,  
                        tCN.ID SortOrder,  
                        tCN.Code Code,  
                        tCN.Name Name,  
                        CONVERT(DECIMAL(18, 2), 0) Weight,  
                        tCN.ID AS Child_ID,  
                        CONVERT(INT,3) ChildType_ID,  
                        tCN.ID NextHierarchy_ID,  
                        2 NextHierarchyType_ID,  
                        @ModelPrivilegeID  ModelPrivilege_ID,  
                        @ModelAccessPermission  ModelAccessPermission,  
                        @ModelPrivilegeID  Privilege_ID  
                        @ModelAccessPermission  AccessPermission  
                    FROM  
                        mdm.' + QUOTENAME(@CollectionTable) + N' tCN  
                    WHERE  
                        tCN.Version_ID = @Version_ID  AND  
                        tCN.Status_ID = 1  
                    ORDER BY tCN.ID  
                    '  
                    SET @ParamList = N'@ModelPrivilegeID        INT  
                                      ,@ModelAccessPermission   TINYINT  
                                      ,@Version_ID              INT'  
                    --PRINT(@SQL);  
                    IF @ReturnXML=1  
                    BEGIN  
                        SET @SQL = @SQL + N' FOR XML PATH(''MemberData''),ELEMENTS,ROOT(''ArrayOfMemberData'');'  
                    END  
                    EXEC sp_executesql @SQL, @ParamList  
                                ,@ModelPrivilege_ID  
                                ,@ModelAccessPermission  
                                ,@Version_ID  
  
  
                END  
            ELSE  --List members in a Collection  
            BEGIN  
                IF @CollectionTable IS NULL  
                BEGIN  
                    -- No collections have been created yet, so return.  
                    RETURN;  
                END  
  
                -- Verify that the leaf member table is defined.  
                IF @EntityTable IS NULL  
                BEGIN  
                    RAISERROR('MDSERR100103|A required schema object for this call is missing. Verify that the Entity table exists for this entity.', 16, 1);  
                    RETURN;  
                END  
  
                SET @SQL =  
                N'  
                SELECT  TOP ' + @RowLimitText + N'  
  
                    @EntityID ChildEntity_ID,  
                    @EntityMUID ChildEntity_MUID,  
                    @EntityID ParentEntity_ID,  
                    @EntityMUID ParentEntity_MUID,  
                    N''ROOT'' ParentCode,  
                    N'''' ParentName,  
                    2 as ParentType_ID,  
                    CASE tCM.ChildType_ID  
                        WHEN 1 THEN tEN.ID' +  
                        CASE WHEN @HierarchyParentTable IS NOT NULL THEN N'  
                        WHEN 2 THEN tHP.ID' ELSE N'' END + N'  
                        WHEN 3 THEN tCN.ID  
                        END Member_ID,  
                    tCM.ChildType_ID MemberType_ID,  
                    CASE tCM.ChildType_ID  
                        WHEN 1 THEN 0' +  
                        CASE WHEN @HierarchyParentTable IS NOT NULL THEN N'  
                        WHEN 2 THEN tHP.Hierarchy_ID' ELSE N'' END + N'  
                        WHEN 3 THEN tCN.ID  
                        END Hierarchy_ID,  
                    tCM.SortOrder,  
                    CASE tCM.ChildType_ID  
                        WHEN 1 THEN tEN.Code' +  
                        CASE WHEN @HierarchyParentTable IS NOT NULL THEN N'  
                        WHEN 2 THEN tHP.Code' ELSE N'' END + N'  
                        WHEN 3 THEN tCN.Code  
                        END Code,  
                    CASE tCM.ChildType_ID  
                        WHEN 1 THEN tEN.Name' +  
                        CASE WHEN @HierarchyParentTable IS NOT NULL THEN N'  
                        WHEN 2 THEN tHP.Name' ELSE N'' END + N'  
                        WHEN 3 THEN tCN.Name  
                        END Name,  
                    CONVERT(DECIMAL(18, 2), tCM.Weight) Weight,  
                    CASE tCM.ChildType_ID  
                        WHEN 1 THEN tCM.Child_EN_ID' +  
                        CASE WHEN @HierarchyParentTable IS NOT NULL THEN N'  
                        WHEN 2 THEN tCM.Child_HP_ID' ELSE N'' END + N'  
                        WHEN 3 THEN tCM.Child_CN_ID  
                        END AS Child_ID,  
                    CASE tCM.ChildType_ID  
                        WHEN 1 THEN tEN.MUID' +  
                        CASE WHEN @HierarchyParentTable IS NOT NULL THEN N'  
                        WHEN 2 THEN tHP.MUID' ELSE N'' END + N'  
                        WHEN 3 THEN tCN.MUID  
                        END Child_MUID,  
                    CONVERT(INT,tCM.ChildType_ID) ChildType_ID,  
                    CASE tCM.ChildType_ID  
                        WHEN 1 THEN 0' +  
                        CASE WHEN @HierarchyParentTable IS NOT NULL THEN N'  
                        WHEN 2 THEN tHP.Hierarchy_ID' ELSE N'' END + N'  
                        WHEN 3 THEN tCN.ID  
                    END NextHierarchy_ID,  
                    CASE  
                        WHEN tCM.ChildType_ID = 3 THEN 2  
                        ELSE 0  
                    END NextHierarchyType_ID,  
                    @ModelPrivilegeID  ModelPrivilege_ID,  
                    @ModelAccessPermission  ModelAccessPermission,  
                    CASE WHEN tCM.ChildType_ID=1 AND @ModelLeafPrivilegeID =1 THEN @ModelLeafPrivilegeID ELSE  
                    CASE WHEN tCM.ChildType_ID=2 AND @ModelConsolidatedPrivilegeID =1  THEN @ModelConsolidatedPrivilegeID ELSE @ModelPrivilegeID END END AS Privilege_ID,  
                    CASE WHEN tCM.ChildType_ID=1 AND @ModelLeafPrivilegeID =1 THEN @ModelLeafAccessPermission ELSE  
                    CASE WHEN tCM.ChildType_ID=2 AND @ModelConsolidatedPrivilegeID =1  THEN @ModelConsolidatedAccessPermission ELSE @ModelAccessPermission END END AS AccessPermission,  
                    @EntityMUID RelationshipId,  
                    4 RelationshipTypeId  
                FROM  
                    mdm.' + QUOTENAME(@CollectionMemberTable) + N' AS tCM';  
  
                --Direct assignment of expression > 4000 nchars truncates nvarchar(max) to nvarchar(4000). Workaround is to concatenate.  
                --Details here: http://connect.microsoft.com/SQLServer/feedback/details/283368/nvarchar-max-concatenation-yields-silent-truncation  
                SET @SQL += N'  
                            LEFT JOIN mdm.' + QUOTENAME(@EntityTable) + N' AS tEN  
                            ON tCM.Child_EN_ID = tEN.ID  
                            AND tCM.Version_ID = tEN.Version_ID  
                            AND tEN.Version_ID = @Version_ID  
                            AND tCM.Parent_CN_ID = @HierarchyID  
                            AND tCM.ChildType_ID = 1  
                            AND tEN.Status_ID = 1' +  
                        CASE WHEN @HierarchyParentTable IS NOT NULL THEN N'  
                        LEFT JOIN mdm.' + QUOTENAME(@HierarchyParentTable) + N' AS tHP  
                            ON tCM.Child_HP_ID = tHP.ID  
                            AND tCM.Version_ID = tHP.Version_ID  
                            AND tHP.Version_ID = @Version_ID  
                            AND tCM.Parent_CN_ID = @HierarchyID  
                            AND tCM.ChildType_ID = 2  
                            AND tHP.Status_ID = 1' ELSE N'' END + N'  
                        LEFT JOIN mdm.' + QUOTENAME(@CollectionTable) + N' AS tCN  
                            ON tCM.Child_CN_ID = tCN.ID  
                            AND tCM.Version_ID = tCN.Version_ID  
                            AND tCN.Version_ID = @Version_ID  
                            AND tCM.Parent_CN_ID = @HierarchyID  
                            AND tCM.ChildType_ID = 3  
                            AND tCN.Status_ID = 1  
                WHERE  
                    tCM.Version_ID = @Version_ID AND  
                    tCM.Status_ID = 1 AND  
                    tCM.Parent_CN_ID = @HierarchyID AND  
                    (tEN.ID IS NOT NULL' +  
                    CASE WHEN @HierarchyParentTable IS NOT NULL THEN N' OR tHP.ID IS NOT NULL' ELSE N'' END + N' OR tCN.ID IS NOT NULL)  
                ORDER BY tCM.SortOrder';  
  
  
                SET @ParamList = N'@EntityID                    INT  
                            ,@EntityMUID                        UNIQUEIDENTIFIER  
                            ,@ModelPrivilegeID                  INT  
                            ,@ModelAccessPermission             TINYINT  
                            ,@ModelLeafPrivilegeID              INT  
                            ,@ModelLeafAccessPermission         TINYINT  
                            ,@ModelConsolidatedPrivilegeID      INT  
                            ,@ModelConsolidatedAccessPermission TINYINT  
                            ,@Version_ID                        INT  
                            ,@HierarchyID                       INT'  
  
                IF @ReturnXML=1  
                    SET @SQL = @SQL + N' FOR XML PATH(''MemberData''),ELEMENTS,ROOT(''ArrayOfMemberData'');';  
  
                --PRINT(@SQL);  
                EXEC sp_executesql @SQL, @ParamList  
                            ,@Entity_ID  
                            ,@EntityMUID  
                            ,@ModelPrivilege_ID  
                            ,@ModelAccessPermission  
                            ,@ModelLeafPrivilege_ID  
                            ,@ModelLeafAccessPermission  
                            ,@ModelConsolidatedPrivilege_ID  
                            ,@ModelAccessPermission  
                            ,@Version_ID  
                            ,@Hierarchy_ID  
  
            END; --if (list members in a collection)  
        END; --if  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpHierarchyIDGetByMemberID]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
declare @var INT  
exec mdm.udpHierarchyIDGetByMemberID 1,9,1036,2,0,@var OUTPUT  
select @var  
*/  
CREATE PROCEDURE [mdm].[udpHierarchyIDGetByMemberID]  
(  
    @Version_ID 	INT,  
    @Entity_ID	INT,  
    @Member_ID	INT,  
    @MemberType_ID	INT,  
    @Return 	INT,	  
    @Hierarchy_ID	INT = NULL OUTPUT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON  
      
    IF @MemberType_ID <> 1 and @MemberType_ID <>2  
    BEGIN	  
        RAISERROR('MDSERR100002|The Member Type is not valid.', 16, 1);  
        RETURN;    		  
    END  
  
    IF @MemberType_ID = 1   
    BEGIN  
        SELECT @Hierarchy_ID = 0  
    END   
    ELSE IF @MemberType_ID = 2   
    BEGIN  
        DECLARE @HierarchyParentTable 	sysname  
        DECLARE @SQLString 				NVARCHAR(MAX)  
        DECLARE @TempID 				INT  
          
        SELECT @HierarchyParentTable = mdm.udfTableNameGetByID(@Entity_ID,2);  
          
        SELECT @SQLString =   
            N'SELECT @TempID = Hierarchy_ID   
              FROM mdm.' + quotename(@HierarchyParentTable) + N'   
              WHERE Version_ID = @Version_ID   
                AND ID = @Member_ID'  
        EXEC sp_executesql @SQLString,   
            N'@Version_ID INT, @Member_ID INT, @TempID int output',   
            @Version_ID, @Member_ID, @TempID output  
        SELECT @Hierarchy_ID = @TempID  
    END  
  
    IF @Return = 1  
        SELECT @Hierarchy_ID  
  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpHierarchyMemberLevelSave]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
This procedure constructs a hierarchy tree for a given member.  Then it determines the level - within  
the hierarchy - associated with the member.  If requested the corresponding member is updated.  
    EXEC mdm.udpHierarchyMemberLevelSave 21, 0, 2  
*/  
  
CREATE PROCEDURE [mdm].[udpHierarchyMemberLevelSave]  
(  
    @Version_ID    INT,  
    @Hierarchy_ID  INT,  
    @Member_ID     INT,  
    @MemberType_ID TINYINT, --MemberType_ID: 1=EN, 2=HP, 3=CN  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE  
         @strSQL            NVARCHAR(MAX)   --SQL string  
        ,@Entity_ID         INT             --Entity ID  
        ,@tblRelationship   sysname         --Hierarchy relationships table  
        ,@Level             SMALLINT;       --Counter variable  
  
    --Assign local variables  
    SELECT @Entity_ID = Entity_ID FROM mdm.tblHierarchy WHERE ID = @Hierarchy_ID;  
    SELECT @tblRelationship = HierarchyTable FROM [mdm].tblEntity WHERE ID = @Entity_ID;  
  
    --Temporary table to store list of ascendants (ancestors)  
    CREATE TABLE #tblHierarchy  
    (  
        ID               INT,  
        MemberType_ID    INT,  
        [Level]          SMALLINT  
    );  
  
    --Create base record  
    INSERT INTO #tblHierarchy(ID, MemberType_ID, [Level])  
    SELECT @Member_ID, @MemberType_ID, 0; --0, 1, 0  
  
    SET @Level = 1;  
  
    --Create first level (if it exists)  
    SET @strSQL = N'  
        INSERT INTO #tblHierarchy(ID, MemberType_ID, [Level])  
        SELECT  
            Parent_HP_ID,  
            2,  
            1  
        FROM mdm.' + quotename(@tblRelationship) + N'  
        WHERE Version_ID = @Version_ID  
            AND Hierarchy_ID = @Hierarchy_ID  
            AND Status_ID = 1  
            AND ChildType_ID = @MemberType_ID  
            AND ' + CASE @MemberType_ID WHEN 1 THEN N'Child_EN_ID' WHEN 2 THEN N'Child_HP_ID' WHEN 3 THEN N'Child_CN_ID' END + N' = @Member_ID;';  
  
    EXEC sp_executesql @strSQL,  
        N'@Version_ID INT, @Hierarchy_ID INT, @Member_ID INT, @MemberType_ID INT',  
        @Version_ID, @Hierarchy_ID, @Member_ID, @MemberType_ID;  
  
    --Temporary table to collect ascendants (ancestors)  
    WHILE @Level < 22 AND EXISTS(SELECT 1 FROM #tblHierarchy WHERE [Level] = @Level) BEGIN  
  
        SET @strSQL = N'  
            INSERT INTO #tblHierarchy(ID, MemberType_ID, [Level])  
            SELECT DISTINCT  
                Parent_HP_ID,  
                ChildType_ID,  
                @Level + 1  
            FROM mdm.' + quotename(@tblRelationship) + N'  
            WHERE Version_ID = @Version_ID  
                AND Hierarchy_ID = @Hierarchy_ID  
                AND Status_ID = 1  
                AND ChildType_ID = 2  
                AND Child_HP_ID IN (SELECT ID FROM #tblHierarchy WHERE [Level] = @Level);';  
          EXEC sp_executesql @strSQL,  
            N'@Version_ID INT, @Hierarchy_ID INT, @Level INT',  
            @Version_ID, @Hierarchy_ID, @Level;  
  
          SET @Level = @Level + 1;  
  
    END; --while  
  
    SELECT @Level = MAX([Level]) - 1 FROM #tblHierarchy;  
  
    --Temporary table to collect descendants  
    TRUNCATE TABLE #tblHierarchy;  
  
    INSERT INTO #tblHierarchy(ID, MemberType_ID, [Level])  
    SELECT @Member_ID, @MemberType_ID, @Level;  
    WHILE EXISTS(SELECT 1 FROM #tblHierarchy WHERE [Level] = @Level) BEGIN  
  
        SET @strSQL = N'  
            INSERT INTO #tblHierarchy(ID, MemberType_ID, [Level])  
            SELECT DISTINCT  
                CASE ChildType_ID WHEN 1 THEN Child_EN_ID WHEN 2 THEN Child_HP_ID END AS Child_ID,  
                ChildType_ID,  
                @Level + 1  
            FROM mdm.' + quotename(@tblRelationship) + N'  
            WHERE Version_ID = @Version_ID  
                AND Hierarchy_ID = @Hierarchy_ID  
                AND Status_ID = 1  
                AND (  
                    ISNULL(Parent_HP_ID, 0) IN (SELECT ID FROM #tblHierarchy WHERE [Level] = @Level AND MemberType_ID = 2)  
                );';  
  
        EXEC sp_executesql @strSQL,  
            N'@Version_ID INT, @Hierarchy_ID INT, @Level INT',  
            @Version_ID, @Hierarchy_ID, @Level;  
  
        SET @Level = @Level + 1;  
  
    END; --while  
  
    --EN  
    SET @strSQL = N'  
        UPDATE tHR SET  
            tHR.LevelNumber = tDesc.[Level]  
        FROM mdm.' + quotename(@tblRelationship) + N' AS tHR  
        INNER JOIN #tblHierarchy AS tDesc  
            ON tDesc.MemberType_ID = tHR.ChildType_ID  
            AND tDesc.ID = tHR.Child_EN_ID  
        WHERE Version_ID = @Version_ID  
            AND Hierarchy_ID = @Hierarchy_ID  
            AND tDesc.MemberType_ID = 1  
            AND Status_ID = 1  
            AND tHR.LevelNumber <> tDesc.[Level];';  
    EXEC sp_executesql @strSQL,  
        N'@Version_ID INT, @Hierarchy_ID INT',  
        @Version_ID, @Hierarchy_ID;  
  
    --HP  
    SET @strSQL = N'  
        UPDATE tHR SET  
            tHR.LevelNumber = tDesc.[Level]  
        FROM mdm.' + quotename(@tblRelationship) + N' AS tHR  
        INNER JOIN #tblHierarchy AS tDesc  
            ON tDesc.MemberType_ID = tHR.ChildType_ID  
            AND tDesc.ID = tHR.Child_HP_ID  
        WHERE Version_ID = @Version_ID  
            AND Hierarchy_ID = @Hierarchy_ID  
            AND tDesc.MemberType_ID = 2  
            AND Status_ID = 1  
            AND tHR.LevelNumber <> tDesc.[Level];';  
    EXEC sp_executesql @strSQL,  
        N'@Version_ID INT, @Hierarchy_ID INT',  
        @Version_ID, @Hierarchy_ID;  
  
    DROP TABLE #tblHierarchy;  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpHierarchyMembersCreate]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
Description: Bulk creates hierarchy member records.  
  
    EXEC mdm.udpHierarchyMembersCreate 1, 8, 0, 50, 2;  
*/  
CREATE PROCEDURE [mdm].[udpHierarchyMembersCreate]  
(  
    @User_ID            INT,  
    @Version_ID         INT,  
    @Entity_ID          INT,  
    @HierarchyMembers   mdm.HierarchyMembers READONLY,  
    @LogFlag            INT = NULL, --1 = log the transaction; anything else = do not log  
    @CorrelationID      UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
AS BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE  
         @HierarchyTable            SYSNAME  
        ,@SQL                       NVARCHAR(MAX)  
        ,@strMemberTypeLeaf         NVARCHAR(1) = N'1'  
        ,@strMemberTypeConsolidated NVARCHAR(1) = N'2'  
        ,@strStatus_Active          NVARCHAR(1) = N'1'  
        ,@MemberType_Hierarchy      TINYINT = 4  
        ,@HRHistoryOutputQuery      NVARCHAR(MAX)  
  
        ,@TransactionLogType        TINYINT  
        ,@TransactionLogType_Member TINYINT = 2  
        ,@TransactionLogType_None   TINYINT = 3;  
  
    CREATE TABLE #NewMembers  
        (ID	INT);  
  
    --Get the Entity Hierarchy Table Name  
    SELECT @HierarchyTable = QUOTENAME(HierarchyTable)  
           ,@TransactionLogType = CASE @LogFlag WHEN 1 THEN TransactionLogType ELSE @TransactionLogType_None END  
    FROM mdm.tblEntity  
    WHERE ID = @Entity_ID;  
  
    IF @TransactionLogType = @TransactionLogType_Member  
    BEGIN  
        SET @HRHistoryOutputQuery = mdm.udfGetHistoryOutputQuery(@Entity_ID, @MemberType_Hierarchy, N'@User_ID', N'@Now');  
    END  
  
    IF @HierarchyTable IS NULL  
    BEGIN  
        RAISERROR('MDSERR310021|For consolidated members, the entity must be enabled for hierarchies and collections.', 16, 1);  
        RETURN;  
    END  
  
    --Insert into the Correct Hierarchy Relationship table  
    SELECT @SQL = N'  
        --Hard-delete any soft deleted hierarchy relationship records for any leaf children  
        --being added  
        DECLARE @Now DATETIME = GETUTCDATE();  
  
        DELETE FROM mdm.' + @HierarchyTable + CASE @TransactionLogType WHEN @TransactionLogType_Member THEN @HRHistoryOutputQuery ELSE N'' END + N'  
        FROM mdm.' + @HierarchyTable + N' hr  
        INNER JOIN @HierarchyMembers hm ON  
        hr.Hierarchy_ID = hm.Hierarchy_ID AND  
        hr.ChildType_ID = hm.ChildMemberType_ID AND  
        hr.Child_EN_ID = hm.Child_ID  
        WHERE hr.Status_ID <> ' + @strStatus_Active + N' AND hm.ChildMemberType_ID = ' + @strMemberTypeLeaf + N';  
  
        --Hard-delete any soft deleted hierarchy relationship records for any consolidated children  
        --being added  
        DELETE FROM mdm.' + @HierarchyTable + CASE @TransactionLogType WHEN @TransactionLogType_Member THEN @HRHistoryOutputQuery ELSE N'' END +  N'  
        FROM mdm.' + @HierarchyTable + N' hr  
        INNER JOIN @HierarchyMembers hm ON  
        hr.Hierarchy_ID = hm.Hierarchy_ID AND  
        hr.ChildType_ID = hm.ChildMemberType_ID AND  
        hr.Child_HP_ID = hm.Child_ID  
        WHERE hr.Status_ID <> ' + @strStatus_Active + N' AND hm.ChildMemberType_ID = ' + @strMemberTypeConsolidated + N';  
  
        INSERT INTO mdm.' + @HierarchyTable + N'  
        (  
            Version_ID,  
            Status_ID,  
            Hierarchy_ID,  
            Parent_HP_ID,  
            ChildType_ID,  
            Child_EN_ID,  
            Child_HP_ID,  
            SortOrder,  
            LevelNumber,  
            EnterDTM,  
            EnterUserID,  
            EnterVersionID,  
            LastChgDTM,  
            LastChgUserID,  
            LastChgVersionID  
        )  
        OUTPUT inserted.ID INTO #NewMembers  
        SELECT  
             @Version_ID  
            ,1  
            ,hm.Hierarchy_ID  
            ,NULLIF(hm.Parent_ID, 0) --Parent_HP_ID  
            ,hm.ChildMemberType_ID  
            ,CASE hm.ChildMemberType_ID WHEN 1 THEN hm.Child_ID ELSE NULL END --Child_EN_ID  
            ,CASE hm.ChildMemberType_ID WHEN 2 THEN hm.Child_ID ELSE NULL END --Child_HP_ID  
            ,1  
            ,-1  
            ,GETUTCDATE()  
            ,@User_ID  
            ,@Version_ID  
            ,GETUTCDATE()  
            ,@User_ID  
            ,@Version_ID  
        FROM @HierarchyMembers hm;  
  
        UPDATE mdm.' + @HierarchyTable + N'  
        SET SortOrder = nm.ID  
        FROM mdm.' + @HierarchyTable + N' hr INNER JOIN #NewMembers	nm  
            ON hr.ID = nm.ID AND Version_ID = @Version_ID;  
        ';  
  
    --PRINT(@SQL);  
    EXEC sp_executesql @SQL,  
        N'@User_ID INT, @Version_ID INT, @HierarchyMembers mdm.HierarchyMembers READONLY',  
        @User_ID, @Version_ID, @HierarchyMembers;  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpHierarchyMembersGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
--Derived Hierarchy Examples  
--Product/Category/Root/Entire Hierarchy  
exec mdm.udpHierarchyMembersGet @User_ID=1,@Version_ID=20,@Hierarchy_ID=5,@HierarchyType_ID=1,@ParentCode=NULL,@ParentEntity_ID=NULL,@RowLimit=NULL  
--Product/Category/Root/Members under Root  
exec mdm.udpHierarchyMembersGet @User_ID=1,@Version_ID=20,@Hierarchy_ID=5,@HierarchyType_ID=1,@ParentCode=NULL,@ParentEntity_ID=NULL,@RowLimit=100  
--Product/Category/2/Members under 2 (Road Bike)  
exec mdm.udpHierarchyMembersGet @User_ID=1,@Version_ID=20,@Hierarchy_ID=5,@HierarchyType_ID=1,@ParentCode='2',@ParentEntity_ID=32,@RowLimit=100  
--Product/Category/2/Ancestors - Ancestros for 1 (Mountain Bike)(consolidated)  
exec mdm.udpHierarchyMembersGet @User_ID=1,@Version_ID=20,@Hierarchy_ID=5,@HierarchyType_ID=1,@ParentCode='1',@ParentEntity_ID=33,@RowLimit=100,@Ancestors=1,@SearchTerm=null  
--Product/Category/2/Ancestors - Ancestros for HS-0296(leaf)  
exec mdm.udpHierarchyMembersGet @User_ID=1,@Version_ID=20,@Hierarchy_ID=5,@HierarchyType_ID=1,@ParentCode='HS-0296',@ParentEntity_ID=31,@RowLimit=50,@Ancestors=1,@SearchTerm=NULL  
--Product/Category/Root/Search for BK%  
exec mdm.udpHierarchyMembersGet @User_ID=1,@Version_ID=20,@Hierarchy_ID=5,@HierarchyType_ID=1,@ParentCode=null,@ParentEntity_ID=0,@RowLimit=100,@Ancestors=null,@SearchTerm='BK%'  
  
  
--Standard Hierarchy Examples  
--Account/Base/Root/Entire Hierarchy  
exec mdm.udpHierarchyMembersGet @User_ID=1,@Version_ID=4,@Hierarchy_ID=1,@HierarchyType_ID=0,@ParentCode=NULL,@ParentEntity_ID=NULL,@RowLimit=null  
--Account/Base/Root/Members under Root  
exec mdm.udpHierarchyMembersGet @User_ID=1,@Version_ID=4,@Hierarchy_ID=1,@HierarchyType_ID=0,@ParentCode=NULL,@ParentEntity_ID=7,@RowLimit=100  
--Account/Base/Root/Members under 4(Net Income)  
exec mdm.udpHierarchyMembersGet @User_ID=1,@Version_ID=4,@Hierarchy_ID=1,@HierarchyType_ID=0,@ParentCode='4',@ParentEntity_ID=7,@RowLimit=100  
--Account/Base/Root/Search for 1% (This searching all codes and names)  
exec mdm.udpHierarchyMembersGet @User_ID=1,@Version_ID=4,@Hierarchy_ID=1,@HierarchyType_ID=0,@ParentCode=NULL,@ParentEntity_ID=7,@RowLimit=100,@Ancestors=null,@SearchTerm='1%'  
--Account/Base/5050/Ancestors  
exec mdm.udpHierarchyMembersGet @User_ID=1,@Version_ID=4,@Hierarchy_ID=1,@HierarchyType_ID=0,@ParentCode='5050',@ParentEntity_ID=6,@RowLimit=100,@Ancestors=1,@SearchTerm=null  
  
--Create nonmandatory hierachy to test with  
EXEC mdm.udpEntityHierarchySave 1, null, 7, 'NonMandatory', 0, @Return_ID OUTPUT, @Return_MUID OUTPUT;  
SELECT @Return_ID, @Return_MUID;  
  
--Non Mandatory Examples  
--Account/NonMandatory/Root/Members under UnUsed  
select * from mdm.tblHIerarchy where IsMandatory=0  
exec mdm.udpHierarchyMembersGet @User_ID=1,@Version_ID=4,@Hierarchy_ID=17,@HierarchyType_ID=0,@ParentCode='MDMUNUSED',@ParentEntity_ID=NULL,@RowLimit=100  
  
*/  
CREATE PROCEDURE [mdm].[udpHierarchyMembersGet]  
(  
    @User_ID            INT,   
    @Version_ID         INT,   
    @Hierarchy_ID       INT,   
    @HierarchyType_ID   TINYINT,    
    @ParentCode         NVARCHAR(250) = NULL,  
    @ParentEntity_ID    INT = NULL,  
    @RowLimit           INT = NULL,  
    @Ancestors          INT = NULL, --1=True, otherwise False  
    @SearchTerm         NVARCHAR(500) = NULL,  
    @EntityMemberTypeID TINYINT = 0,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE   
         @ParentItem_ID             INT  
        ,@ParentItemType_ID         INT  
        ,@Item_ID                   INT  
        ,@ItemType_ID               INT  
        ,@Parent_ID                 INT  
        ,@ParentMemberType_ID       TINYINT  
        ,@NewParentCode             NVARCHAR(250)  
        ,@SQL                       NVARCHAR(MAX)  
        ,@ViewName                  sysname  
        ,@Model_ID                  INT  
        ,@ExplicitHierarchyType_ID  TINYINT = 0  
        ,@DerivedHierarchyType_ID   TINYINT = 1  
        ,@CollectionType_ID         TINYINT = 2  
        ,@AnchorNullRecursions      BIT = 0;  
      
    SET @NewParentCode = ISNULL(NULLIF(@ParentCode, N''), N'ROOT');  
      
    --Find all the Item and ItemsTypes  
    IF @HierarchyType_ID IN (@ExplicitHierarchyType_ID, @CollectionType_ID) BEGIN --Explicit or Collection  
          
        SET @Item_ID = CASE   
            WHEN @HierarchyType_ID = @CollectionType_ID THEN @ParentEntity_ID   
            ELSE (SELECT Entity_ID FROM mdm.tblHierarchy WHERE ID = @Hierarchy_ID)   
        END; --//This logic could be used for EH if the entity is now supplied, but the api check to make the sure the entity is supplied  
        SET @ItemType_ID = 0;  
        SET @ParentItem_ID = @Item_ID;  
        SET @ParentItemType_ID = @ItemType_ID;  
          
    END    ELSE IF @HierarchyType_ID = @DerivedHierarchyType_ID AND (NULLIF(@SearchTerm, N'') IS NULL) BEGIN --Derived and not searching (No need to lookup this up if searching)  
          
        IF UPPER(@NewParentCode) = N'ROOT'   
        BEGIN  
          
            SELECT TOP 1   
                @ParentEntity_ID = vdhd.Entity_ID,  
                @ParentItem_ID = dhd.ForeignParent_ID,  
                @ParentItemType_ID = 1,  
                @Item_ID = dhd.Foreign_ID,  
                @ItemType_ID = dhd.ForeignType_ID    
            FROM mdm.viw_SYSTEM_SCHEMA_HIERARCHY_DERIVED_LEVELS vdhd  
            INNER JOIN mdm.tblDerivedHierarchyDetail dhd  
            ON vdhd.ID = dhd.ID  
            WHERE   Hierarchy_ID = @Hierarchy_ID  
                AND LevelNumber = 0 -- topmost level  
              
            --For the Root node only, lookup whether this is a recursive hierarchy   
            --where only null relationships are to be anchored as top level nodes.  
            SET @AnchorNullRecursions = (SELECT TOP 1 tDH.AnchorNullRecursions  
                FROM mdm.tblDerivedHierarchy tDH  
                INNER JOIN mdm.viw_SYSTEM_SCHEMA_HIERARCHY_DERIVED_LEVELS tDHL   
                ON tDHL.Hierarchy_ID = tDH.ID  
                WHERE tDH.ID = @Hierarchy_ID   
                    AND tDHL.IsRecursive = 1);      
              
        END ELSE BEGIN  
            SELECT @Model_ID = Model_ID FROM mdm.tblModelVersion WHERE ID=@Version_ID;  
            SELECT @ViewName = CONCAT(N'viw_SYSTEM_', @Model_ID, N'_', @Hierarchy_ID, N'_PARENTCHILD_DERIVED')  
            SET @SQL = N'  
                SELECT   
                    @ParentItem_ID = ParentItem_ID,  
                    @ParentItemType_ID = ParentItemType_ID,  
                    @Item_ID = CASE @Ancestors WHEN 1 THEN Item_ID ELSE NextItem_ID END,  
                    @ItemType_ID = CASE @Ancestors WHEN 1 THEN ItemType_ID ELSE NextItemType_ID END  
                      
                FROM  
                     mdm.' + @ViewName + '  
                WHERE   
                    Version_ID = @Version_ID   
                    AND ChildCode = @ParentCode   
                    AND Entity_ID = @ParentEntity_ID  
                    ';  
                EXEC sp_executesql @SQL, N'@Ancestors INT, @Version_ID INT,@ParentEntity_ID INT,@ParentCode NVARCHAR(250), @ParentItem_ID INT OUTPUT,@ParentItemType_ID INT OUTPUT,@Item_ID INT OUTPUT,@ItemType_ID INT OUTPUT', @Ancestors, @Version_ID,@ParentEntity_ID,@ParentCode, @ParentItem_ID OUTPUT,@ParentItemType_ID OUTPUT,@Item_ID OUTPUT,@ItemType_ID OUTPUT;  
              
        END; --if  
    END; --if  
  
    ---------------------------------------  
    --Find the Parent_ID from the Code.  
    ---------------------------------------  
    IF UPPER(@NewParentCode) = N'ROOT' BEGIN  
        SET @ParentMemberType_ID = 2  
        SET @Parent_ID = 0  
    END    ELSE IF UPPER(@NewParentCode) = N'MDMUNUSED' BEGIN  
        SET @ParentMemberType_ID = 2  
        SET @Parent_ID = -1  
    END    ELSE BEGIN  
        IF NULLIF(@SearchTerm, N'') IS NULL BEGIN --No need to lookup ParentID and ParentTypeId if searching  
            --Get MemberType and ID of the Code Given  
            EXEC mdm.udpMemberTypeIDAndIDGetByCode @Version_ID, @ParentEntity_ID, @ParentCode, @ParentMemberType_ID OUTPUT, @Parent_ID OUTPUT  
        END; --if  
    END; --if  
      
    --@Item_ID IS NULL when at the bottom level of the DH  
  
    --If you are requesting all the records, then the Rowlimit is null and you need to pass in a negative Parent_ID to sub sproc (HierarchyGet)  
    SET @RowLimit = NULLIF(@RowLimit, 0);  
    IF NULLIF(@ParentCode, N'') IS NULL AND @HierarchyType_ID IN (@ExplicitHierarchyType_ID, @DerivedHierarchyType_ID) AND @RowLimit IS NULL SET @Parent_ID = -99;  
      
    SELECT   
        @Item_ID = ISNULL(@Item_ID, 0),  
        @ItemType_ID = ISNULL(NULLIF(@ItemType_ID, -1), 0),  
        @ParentItem_ID = ISNULL(@ParentItem_ID, -1),  
        @ParentItemType_ID = ISNULL(@ParentItemType_ID, -1);  
  
    IF NULLIF(@SearchTerm, N'') IS NOT NULL BEGIN  
        EXEC mdm.udpMemberSearch @User_ID, @Version_ID, @Hierarchy_ID, @HierarchyType_ID, @ParentEntity_ID, @SearchTerm;  
      
    END ELSE BEGIN  
      
        IF @Ancestors = 1 BEGIN  
      
            IF @HierarchyType_ID = @DerivedHierarchyType_ID BEGIN --Derived      
                EXEC mdm.udpHierarchyDerivedAncestorsGet @User_ID, @Version_ID, @Hierarchy_ID, @Parent_ID, @ParentMemberType_ID, @Item_ID, @ItemType_ID;                  
            END ELSE IF @HierarchyType_ID = @ExplicitHierarchyType_ID BEGIN                   
                EXEC mdm.udpHierarchyAncestorsGet @User_ID, @Version_ID, @Hierarchy_ID, @Parent_ID, @ParentMemberType_ID, 0;                  
            END; --if  
      
        END ELSE BEGIN  
                  
            --Call HierarchyGet  
            EXEC mdm.udpHierarchyGet   
                @User_ID = @User_ID,  
                @Version_ID = @Version_ID,  
                @Hierarchy_ID = @Hierarchy_ID,  
                @HierarchyType_ID = @HierarchyType_ID,  
                @Item_ID = @Item_ID,  
                @ItemType_ID = @ItemType_ID,  
                @ParentItem_ID = @ParentItem_ID,  
                @ParentItemType_ID = @ParentItemType_ID,  
                @Parent_ID = @Parent_ID,  
                @RowLimit = @RowLimit,  
                @IncludeDeny = 0,  
                @AnchorNullRecursions = @AnchorNullRecursions,  
                @ReturnXML = 0,  
                @EntityMemberTypeID = @EntityMemberTypeID;  
      
        END; --if  
    END; --if  
      
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpHierarchyMembersUpdate]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
Description: Bulk hierarchy relationship moves.  
  
The following are assumed validated prior to calling and are not validated here:  
    * User  
    * Version  
    * Entity  
  
declare  
    @HierarchyMembers AS mdm.HierarchyMembers  
  
insert into @HierarchyMembers(ChildCode, TargetCode, TargetType_ID, HierarchyName) values (N'FR-M94S-38', N'B', 1, N'Index'); -- Move to different parent.  
insert into @HierarchyMembers(ChildCode, TargetCode, TargetType_ID, HierarchyName) values (N'XXXXXXXXX', N'B', 1, N'Index'); -- Invalid child code.  
insert into @HierarchyMembers(ChildCode, TargetCode, TargetType_ID, HierarchyName) values (N'FR-R38B-44', N'XXXXXXXXX', 1, N'Index'); -- Invalid parent code.  
insert into @HierarchyMembers(ChildCode, TargetCode, TargetType_ID, HierarchyName) values (N'FR-M63B-40', N'B', 1, N'XXXXXXXXX'); -- Invalid hierarchy name.  
  
EXEC mdm.udpHierarchyMembersUpdate @User_ID=1, @Version_ID = 20, @Entity_ID = 31, @HierarchyMembers = @HierarchyMembers, @LogFlag = 1  
  
*/  
CREATE PROCEDURE [mdm].[udpHierarchyMembersUpdate]  
(  
    @User_ID                INT,  
    @Version_ID             INT,  
    @Entity_ID              INT,  
    @HierarchyMembers       mdm.HierarchyMembers READONLY,  
    @OriginalTransaction_ID INT = NULL, -- The original transaction ID that is being reversed. Leave NULL if this change is not a transaction reversal.  
    @LogFlag                INT = NULL, --1 = log the transaction; anything else = do not log  
    @IsCreateMode           BIT = 0, -- Set to 1 when calling this sproc as part of creating an entity member. This will mean relaxed security checks, such as allowing nodes to be moved from ROOT, even if the user doesn't have Update permission on ROOT  
    @CorrelationID          UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS  
BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE  
         @SQL                       NVARCHAR(MAX)  
        ,@ParamList                 NVARCHAR(max)  
        ,@TranCounter               INT  
        ,@ChildAttributeColumnName  SYSNAME  
  
        ,@TransactionLogType            TINYINT  
        ,@TransactionLogType_Attribute  TINYINT = 1  
        ,@TransactionLogType_Member     TINYINT = 2  
        ,@TransactionLogType_None       TINYINT = 3  
  
        ,@HPHistoryOutputQuery      NVARCHAR(MAX)  
        ,@HRHistoryOutputQuery      NVARCHAR(MAX)  
  
        ,@TableName                 SYSNAME  
        ,@ParentChildViewName       SYSNAME  
        ,@EntityTable               SYSNAME  
        ,@HierarchyTable            SYSNAME  
        ,@HierarchyParentTable      SYSNAME  
        ,@CollectionTable           SYSNAME  
  
        ,@TargetType_Parent         TINYINT = 1  
        ,@TargetType_Sibling        TINYINT = 2  
  
        ,@TransactionType_HierarchyParentSet    TINYINT = 4  
        ,@TransactionType_HierarchySiblingSet   TINYINT = 5  
  
        --Member Types  
        ,@MemberType_Unknown        TINYINT = 0  
        ,@MemberType_Leaf           TINYINT = 1  
        ,@MemberType_Consolidated   TINYINT = 2  
        ,@MemberType_Hierarchy      TINYINT = 4  
          
        ,@IsAdmin                           BIT  
        ,@LeafUseMemberSecurity             BIT  
        ,@ConsolidatesUseMemberSecurity     BIT  
        --Permissions  
        ,@MemberTypeLeaf_Permission         TINYINT  
        ,@MemberTypeConsolidated_Permission TINYINT  
        ,@Permission_Deny                   TINYINT = 1  
        ,@Permission_Access                 TINYINT = 4  
        ,@Permission_Inferred               TINYINT = 99  
  
        ,@AccessPermission_None        TINYINT = 0  
        ,@AccessPermission_Read        TINYINT = 0  
        ,@AccessPermission_Create      TINYINT = 1  
        ,@AccessPermission_Update      TINYINT = 2  
        ,@AccessPermission_All         TINYINT = 7  
  
        --Member status  
        ,@Status_Active             TINYINT = 1  
        ,@Status_Inactive           TINYINT = 2  
  
        --Top-level node ids and codes  
        ,@RootCode                  NVARCHAR(10) = N'ROOT'  
        ,@Root_ID                   INT = 0  
        ,@UnusedCode                NVARCHAR(10) = N'MDMUNUSED'  
        ,@Unused_ID                 INT = -1  
  
        --Error ObjectTypes  
        ,@ObjectType_Entity         TINYINT = 5  
        ,@ObjectType_Hierarchy      TINYINT = 6  
        ,@ObjectType_Attribute      TINYINT = 7  
        ,@ObjectType_MemberCode     TINYINT = 12  
        ,@ObjectType_MemberId       TINYINT = 19  
        ,@ObjectType_MemberAttribute TINYINT = 22  
  
        --Error Codes  
        ,@ErrorCode_NoPermissionForThisOperationOnThisObject    INT = 120003  
        ,@ErrorCode_ConsolidatedMemberCannotBeChildOfMdmUnused  INT = 210059  
        ,@ErrorCode_InvalidMemberCode                           INT = 300002  
        ,@ErrorCode_InvalidExplicitHierarchy                    INT = 300009  
        ,@ErrorCode_ReadOnlyMember                              INT = 300015  
        ,@ErrorCode_MemberCausesCircularReference               INT = 300020  
  
        ,@MemberIds                mdm.MemberId  
  
        --Transaction and annotation table names  
        ,@Model_ID                      INT  
        ,@TransactionTableName          SYSNAME  
    ;  
  
    -- Get the roles that pertain to the user.  
    DECLARE @SecurityRoles TABLE(RoleID INT PRIMARY KEY);  
    INSERT INTO @SecurityRoles  
    SELECT DISTINCT Role_ID FROM mdm.[viw_SYSTEM_SECURITY_USER_ROLE] WHERE User_ID = @User_ID;  
  
    DECLARE  
         @strRoot_ID                    NVARCHAR(3) = CONVERT(NVARCHAR(3), @Root_ID)  
        ,@strUnused_ID                  NVARCHAR(3) = CONVERT(NVARCHAR(3), @Unused_ID)  
        ,@strStatus_Inactive            NVARCHAR(3) = CONVERT(NVARCHAR(3), @Status_Inactive)  
        ,@strStatus_Active              NVARCHAR(3) = CONVERT(NVARCHAR(3), @Status_Active)  
        ,@strMemberType_Leaf            NVARCHAR(3) = CONVERT(NVARCHAR(3), @MemberType_Leaf)  
        ,@strMemberType_Consolidated    NVARCHAR(3) = CONVERT(NVARCHAR(3), @MemberType_Consolidated);  
  
    --Final results to be returned.  
    CREATE TABLE #HierarchyMemberWorkingSet  
        (  
          Row_ID                    INT IDENTITY(1,1) NOT NULL  
         ,Hierarchy_ID              INT NULL  
         ,HierarchyName             NVARCHAR(50) COLLATE DATABASE_DEFAULT NULL  
         ,Child_ID                  INT NULL  
         ,Child_MUID                UNIQUEIDENTIFIER NULL  
         ,ChildCode                 NVARCHAR(250) COLLATE DATABASE_DEFAULT NULL  
         ,ChildMemberType_ID        TINYINT NULL  
         ,Target_ID                 INT NULL  
         ,TargetCode                NVARCHAR(250) COLLATE DATABASE_DEFAULT NULL  
         ,TargetMemberType_ID       TINYINT NULL  
         ,TargetType_ID             TINYINT NULL  
         ,Parent_ID                 INT NULL  
         ,ParentCode                NVARCHAR(250) COLLATE DATABASE_DEFAULT NULL  
         ,PriorParent_ID            INT NULL  
         ,PriorParentCode           NVARCHAR(250) COLLATE DATABASE_DEFAULT NULL  
         ,PriorParentHierarchy_ID   INT NULL -- Used for detecting when a consolidated member is being moved to another hierarchy. Otherwise, will be the same as the Hierarchy_ID column.  
         ,PriorSortOrder            INT NULL  
         ,SortOrder                 INT NULL  
         ,RelativeSortOrder         INT NULL  
         ,Member_ID                 INT NULL --Member Id in error  
         ,MemberCode                NVARCHAR(250) COLLATE DATABASE_DEFAULT NULL --Member code in error  
         ,MemberType_ID             TINYINT NULL --Member Type in error  
         ,ErrorCode                 INT NULL  
         ,ErrorObjectType           TINYINT NULL  
        );  
  
    --Intermediate working set  
    CREATE TABLE #HierarchyMemberWorkingSet2  
        (  
          Row_ID                INT IDENTITY(1,1) NOT NULL  
         ,Hierarchy_ID          INT NULL  
         ,HierarchyName         NVARCHAR(50) COLLATE DATABASE_DEFAULT NULL  
         ,Child_ID              INT NULL  
         ,ChildCode             NVARCHAR(250) COLLATE DATABASE_DEFAULT NULL  
         ,ChildMemberType_ID    TINYINT NULL  
         ,Target_ID             INT NULL  
         ,TargetCode            NVARCHAR(250) COLLATE DATABASE_DEFAULT NULL  
         ,TargetMemberType_ID   TINYINT NULL  
         ,TargetType_ID         TINYINT NULL  
         ,Parent_ID             INT NULL  
         ,ParentCode            NVARCHAR(250) COLLATE DATABASE_DEFAULT NULL  
         ,PriorParent_ID        INT NULL  
         ,PriorParentCode       NVARCHAR(250) COLLATE DATABASE_DEFAULT NULL  
         ,PriorSortOrder        INT NULL  
         ,SortOrder             INT NULL  
         ,RelativeSortOrder     INT NULL  
         ,ErrorCode             INT NULL  
         ,ErrorObjectType       TINYINT NULL  
        );  
  
    ----------------------------------------------------------------------------------------  
    --Get Entity table information.  
    ----------------------------------------------------------------------------------------  
    SELECT  
        @EntityTable = QUOTENAME(Entities.EntityTable),  
        @HierarchyTable = QUOTENAME(Entities.HierarchyTable),  
        @HierarchyParentTable = QUOTENAME(Entities.HierarchyParentTable),  
        @CollectionTable = QUOTENAME(Entities.CollectionTable),  
        @Model_ID = Entities.Model_ID,  
        @TransactionLogType = CASE @LogFlag WHEN 1 THEN TransactionLogType ELSE @TransactionLogType_None END  
    FROM  
        mdm.tblEntity Entities  
    WHERE  
        Entities.ID = @Entity_ID;  
  
    IF @TransactionLogType = @TransactionLogType_Member  
    BEGIN  
        SET @HPHistoryOutputQuery = mdm.udfGetHistoryOutputQuery(@Entity_ID, @MemberType_Consolidated, NULL, NULL);  
        SET @HRHistoryOutputQuery = mdm.udfGetHistoryOutputQuery(@Entity_ID, @MemberType_Hierarchy, NULL, NULL);  
    END  
    ELSE IF @TransactionLogType = @TransactionLogType_Attribute  
    BEGIN  
        --Stores the transactions of the hierarchy member UPDATEs  
        CREATE TABLE #HierarchyMemberTransactions  
            (  
             TransactionType TINYINT  
            ,Hierarchy_ID    INT  
            ,ChildType_ID    TINYINT  
            ,Child_EN_ID     INT NULL  
            ,Child_EN_MUID   UNIQUEIDENTIFIER NULL  
            ,Child_HP_ID     INT NULL  
            ,Child_HP_MUID   UNIQUEIDENTIFIER NULL  
            ,ChildCode       NVARCHAR(250) COLLATE DATABASE_DEFAULT NULL  
            ,PriorParent_ID  INT NULL  
            ,PriorParentCode NVARCHAR(250) COLLATE DATABASE_DEFAULT NULL  
            ,NewParent_ID    INT NULL  
            ,NewParentCode   NVARCHAR(250) COLLATE DATABASE_DEFAULT NULL  
            );  
  
        SET @TransactionTableName = mdm.udfGetTransactionTableName(@Model_ID);  
  
    END  
  
    IF @HierarchyTable IS NULL  
    BEGIN  
        RAISERROR('MDSERR310021|For consolidated members, the entity must be enabled for hierarchies and collections.', 16, 1);  
        RETURN;  
    END;  
  
    SELECT @ParentChildViewName = QUOTENAME(mdm.udfViewNameGetByID(@Entity_ID, 4, 0, 0));  
  
    ----------------------------------------------------------------------------------------  
    -- Insert hierarchy members into working set.  
    ----------------------------------------------------------------------------------------  
    INSERT INTO #HierarchyMemberWorkingSet  
        (Hierarchy_ID, HierarchyName, Child_ID, ChildCode, ChildMemberType_ID, Target_ID, TargetCode, TargetMemberType_ID, TargetType_ID)  
    SELECT  
          NULLIF(hm.Hierarchy_ID, 0)  
         ,hm.HierarchyName  
         ,hm.Child_ID  
         ,hm.ChildCode  
         ,hm.ChildMemberType_ID  
         ,hm.Target_ID  
         ,hm.TargetCode  
         ,hm.TargetMemberType_ID  
         ,hm.TargetType_ID  
    FROM @HierarchyMembers AS hm  
  
    ----------------------------------------------------------------------------------------  
    --Get Member ID, Code, and Type  
    ----------------------------------------------------------------------------------------  
    -- Check for top-level nodes.  
    UPDATE #HierarchyMemberWorkingSet  
    SET    Target_ID = CASE UPPER(TargetCode) WHEN @RootCode THEN @Root_ID WHEN @UnusedCode THEN @Unused_ID END,  
        TargetMemberType_ID = @MemberType_Consolidated  
    WHERE UPPER(TargetCode) IN (@RootCode, @UnusedCode)  
  
    UPDATE #HierarchyMemberWorkingSet  
    SET    TargetCode = CASE Target_ID WHEN @Root_ID THEN @RootCode WHEN @Unused_ID THEN @UnusedCode END,  
        TargetMemberType_ID = @MemberType_Consolidated  
    WHERE Target_ID IN (@Root_ID, @Unused_ID)  
  
    IF EXISTS(SELECT * FROM #HierarchyMemberWorkingSet ws WHERE COALESCE(ws.Target_ID, 0) = 0 OR ws.TargetCode IS NULL OR COALESCE(ws.Child_ID, 0) = 0 OR ws.ChildCode IS NULL OR ws.Child_MUID IS NULL)  
        BEGIN  
            --Get Target IDs for leaf targets  
            IF EXISTS(SELECT * FROM #HierarchyMemberWorkingSet ws WHERE ws.TargetMemberType_ID IS NULL OR (ws.Target_ID IS NULL AND ws.TargetCode IS NOT NULL AND ws.TargetMemberType_ID = @MemberType_Leaf))  
                BEGIN  
                    SET @SQL = N'  
                        UPDATE ws  
                        SET ws.Target_ID = m.ID,  
                            ws.TargetMemberType_ID = ' + @strMemberType_Leaf + N'  
                        FROM #HierarchyMemberWorkingSet AS ws  
                        INNER JOIN mdm.' + @EntityTable + N' AS m  
                            ON m.Version_ID = @Version_ID  
                            AND m.Status_ID IS NOT NULL  
                            AND m.Status_ID = 1  
                            AND ws.TargetCode IS NOT NULL  
                            AND ws.TargetCode = m.Code  
                            AND ws.ErrorCode IS NULL  
                            AND ws.Target_ID IS NULL;';  
                    --PRINT(@SQL);  
                    EXEC sp_executesql @SQL, N'@Version_ID INT', @Version_ID;  
                END  
  
            --Get Target Codes for leaf targets  
            IF EXISTS(SELECT * FROM #HierarchyMemberWorkingSet ws WHERE ws.TargetMemberType_ID IS NULL OR (ws.TargetCode IS NULL AND ws.Target_ID IS NOT NULL AND ws.TargetMemberType_ID = @MemberType_Leaf))  
                BEGIN  
                    SET @SQL = N'  
                        UPDATE ws  
                        SET ws.TargetCode = m.Code,  
                            ws.TargetMemberType_ID = ' + @strMemberType_Leaf + N'  
                        FROM #HierarchyMemberWorkingSet AS ws  
                        INNER JOIN mdm.' + @EntityTable + N' AS m  
                            ON m.Version_ID = @Version_ID  
                            AND m.Status_ID IS NOT NULL  
                            AND m.Status_ID = 1  
                            AND ws.Target_ID IS NOT NULL  
                            AND ws.Target_ID = m.ID  
                            AND ws.ErrorCode IS NULL  
                            AND ws.TargetCode IS NULL;';  
                    --PRINT(@SQL);  
                    EXEC sp_executesql @SQL, N'@Version_ID INT', @Version_ID;  
                END  
  
           --Get Target IDs for consolidated targets  
            IF EXISTS(SELECT * FROM #HierarchyMemberWorkingSet ws WHERE ws.TargetMemberType_ID IS NULL OR (ws.Target_ID IS NULL AND ws.TargetCode IS NOT NULL AND ws.TargetMemberType_ID = @MemberType_Consolidated))  
                BEGIN  
                    SET @SQL = N'  
                        UPDATE ws  
                        SET ws.Target_ID = m.ID,  
                            ws.TargetMemberType_ID = ' + @strMemberType_Consolidated + N'  
                        FROM #HierarchyMemberWorkingSet AS ws  
                        INNER JOIN mdm.' + @HierarchyParentTable + N' AS m  
                            ON m.Version_ID = @Version_ID  
                            AND m.Status_ID IS NOT NULL  
                            AND m.Status_ID = 1  
                            AND ws.TargetCode IS NOT NULL  
                            AND ws.TargetCode = m.Code  
                            AND ws.ErrorCode IS NULL  
                            AND ws.Target_ID IS NULL;';  
                    --PRINT(@SQL);  
                    EXEC sp_executesql @SQL, N'@Version_ID INT', @Version_ID;  
                END  
  
           --Get Target Codes for consolidated targets  
            IF EXISTS(SELECT * FROM #HierarchyMemberWorkingSet ws WHERE ws.TargetMemberType_ID IS NULL OR (ws.TargetCode IS NULL AND ws.Target_ID IS NOT NULL AND ws.TargetMemberType_ID = @MemberType_Consolidated))  
                BEGIN  
                    SET @SQL = N'  
                        UPDATE ws  
                        SET ws.TargetCode = m.Code,  
                            ws.TargetMemberType_ID = ' + @strMemberType_Consolidated + N'  
                        FROM #HierarchyMemberWorkingSet AS ws  
                        INNER JOIN mdm.' + @HierarchyParentTable + N' AS m  
                            ON m.Version_ID = @Version_ID  
                            AND m.Status_ID IS NOT NULL  
                            AND m.Status_ID = 1  
                            AND ws.Target_ID IS NOT NULL  
                            AND ws.Target_ID = m.ID  
                            AND ws.ErrorCode IS NULL  
                            AND ws.TargetCode IS NULL;';  
                    --PRINT(@SQL);  
                    EXEC sp_executesql @SQL, N'@Version_ID INT', @Version_ID;  
                END  
  
            --Get Child IDs for leaf children  
            IF EXISTS(SELECT * FROM #HierarchyMemberWorkingSet ws WHERE ws.ChildMemberType_ID IS NULL OR ((ws.Child_ID IS NULL OR ws.Child_MUID IS NULL) AND ws.ChildCode IS NOT NULL AND ws.ChildMemberType_ID = @MemberType_Leaf))  
                BEGIN  
                    SET @SQL = N'  
                        UPDATE ws  
                        SET ws.Child_ID = m.ID,  
                            ws.Child_MUID = m.MUID,  
                            ws.ChildMemberType_ID = ' + @strMemberType_Leaf + N'  
                        FROM #HierarchyMemberWorkingSet AS ws  
                        INNER JOIN mdm.' + @EntityTable + N' AS m  
                            ON m.Version_ID = @Version_ID  
                            AND m.Status_ID IS NOT NULL  
                            AND m.Status_ID = 1  
                            AND ws.ChildCode IS NOT NULL  
                            AND ws.ChildCode = m.Code  
                            AND (ws.Child_ID IS NULL OR ws.Child_ID = m.ID)  
                            AND ws.ErrorCode IS NULL;';  
                    --PRINT(@SQL);  
                    EXEC sp_executesql @SQL, N'@Version_ID INT', @Version_ID;  
                END  
  
            --Get Child Codes for leaf children  
            IF EXISTS(SELECT * FROM #HierarchyMemberWorkingSet ws WHERE ws.ChildMemberType_ID IS NULL OR ((ws.ChildCode IS NULL OR ws.Child_MUID IS NULL) AND ws.Child_ID IS NOT NULL AND ws.ChildMemberType_ID = @MemberType_Leaf))  
                BEGIN  
                    SET @SQL = N'  
                        UPDATE ws  
                        SET ws.ChildCode = m.Code,  
                            ws.Child_MUID = m.MUID,  
                            ws.ChildMemberType_ID = ' + @strMemberType_Leaf + N'  
                        FROM #HierarchyMemberWorkingSet AS ws  
                        INNER JOIN mdm.' + @EntityTable + N' AS m  
                            ON m.Version_ID = @Version_ID  
                            AND m.Status_ID IS NOT NULL  
                            AND m.Status_ID = 1  
                            AND ws.Child_ID IS NOT NULL  
                            AND ws.Child_ID = m.ID  
                            AND (ws.ChildCode IS NULL OR ws.ChildCode = m.Code)  
                            AND ws.ErrorCode IS NULL;';  
                    --PRINT(@SQL);  
                    EXEC sp_executesql @SQL, N'@Version_ID INT', @Version_ID;  
                END  
  
            --Get Child IDs and MUIDs for consolidated children  
            IF EXISTS(SELECT * FROM #HierarchyMemberWorkingSet ws WHERE ws.ChildMemberType_ID IS NULL OR ((ws.Child_ID IS NULL OR ws.Child_MUID IS NULL) AND ws.ChildCode IS NOT NULL AND ws.ChildMemberType_ID = @MemberType_Consolidated))  
                BEGIN  
                    SET @SQL = N'  
                        UPDATE ws  
                        SET ws.Child_ID = m.ID,  
                            ws.Child_MUID = m.MUID,  
                            ws.ChildMemberType_ID = ' + @strMemberType_Consolidated + N'  
                        FROM #HierarchyMemberWorkingSet AS ws  
                        INNER JOIN mdm.' + @HierarchyParentTable + N' AS m  
                            ON m.Version_ID = @Version_ID  
                            AND m.Status_ID IS NOT NULL  
                            AND m.Status_ID = 1  
                            AND ws.ChildCode IS NOT NULL  
                            AND ws.ChildCode = m.Code  
                            AND (ws.Child_ID IS NULL OR ws.Child_ID = m.ID)  
                            AND ws.ErrorCode IS NULL;';  
                    --PRINT(@SQL);  
                    EXEC sp_executesql @SQL, N'@Version_ID INT', @Version_ID;  
                END  
  
            --Get Child Codes for consolidated children  
            IF EXISTS(SELECT * FROM #HierarchyMemberWorkingSet ws WHERE ws.ChildMemberType_ID IS NULL OR ((ws.ChildCode IS NULL OR ws.Child_MUID IS NULL) AND ws.Child_ID IS NOT NULL AND ws.ChildMemberType_ID = @MemberType_Consolidated))  
                BEGIN  
                    SET @SQL = N'  
                        UPDATE ws  
                        SET ws.ChildCode = m.Code,  
                            ws.Child_MUID = m.MUID,  
                            ws.ChildMemberType_ID = ' + @strMemberType_Consolidated + N'  
                        FROM #HierarchyMemberWorkingSet AS ws  
                        INNER JOIN mdm.' + @HierarchyParentTable + N' AS m  
                            ON m.Version_ID = @Version_ID  
                            AND m.Status_ID IS NOT NULL  
                            AND m.Status_ID = 1  
                            AND ws.Child_ID IS NOT NULL  
                            AND ws.Child_ID = m.ID  
                            AND (ws.ChildCode IS NULL OR ws.ChildCode = m.Code)  
                            AND ws.ErrorCode IS NULL;';  
                    --PRINT(@SQL);  
                    EXEC sp_executesql @SQL, N'@Version_ID INT', @Version_ID;  
                END  
        END  
  
    -- Invalid member code check  
    UPDATE #HierarchyMemberWorkingSet  
        SET ErrorCode = @ErrorCode_InvalidMemberCode,  
            ErrorObjectType = @ObjectType_MemberCode,  
            MemberCode = TargetCode,  
            MemberType_ID = @MemberType_Unknown  
    WHERE TargetCode IS NOT NULL AND Target_ID IS NULL  
    AND   ErrorCode IS NULL;  
  
    UPDATE #HierarchyMemberWorkingSet  
        SET ErrorCode = @ErrorCode_InvalidMemberCode,  
            ErrorObjectType = @ObjectType_MemberCode,  
            MemberCode = ChildCode,  
            MemberType_ID = @MemberType_Unknown  
    WHERE ChildCode IS NOT NULL AND Child_ID IS NULL  
    AND   ErrorCode IS NULL;  
  
    ----------------------------------------------------------------------------------------  
    -- Check object and member security  
    ----------------------------------------------------------------------------------------  
    --Check security level before going any further.  
  
    SELECT @MemberTypeLeaf_Permission = Privilege_ID,  
        @IsAdmin = IsAdmin  
    FROM mdm.viw_SYSTEM_SECURITY_USER_MEMBERTYPE  
    WHERE [User_ID] = @User_ID  
        AND [Entity_ID] = @Entity_ID  
        AND ID = @MemberType_Leaf;  
  
    SELECT @MemberTypeConsolidated_Permission = Privilege_ID  
    FROM mdm.viw_SYSTEM_SECURITY_USER_MEMBERTYPE  
    WHERE [User_ID] = @User_ID  
        AND [Entity_ID] = @Entity_ID  
        AND ID = @MemberType_Consolidated;  
  
    IF @IsAdmin != 1  
    BEGIN  
        SET @MemberTypeLeaf_Permission = COALESCE(@MemberTypeLeaf_Permission, @Permission_Deny);  
        SET @LeafUseMemberSecurity = mdm.udfUseMemberSecurity(@User_ID, @Entity_ID, @Version_ID, @MemberType_Leaf);  
  
        SET @MemberTypeConsolidated_Permission = COALESCE(@MemberTypeLeaf_Permission, @Permission_Deny);  
        SET @ConsolidatesUseMemberSecurity = mdm.udfUseMemberSecurity(@User_ID, @Entity_ID, @Version_ID, @MemberType_Consolidated);  
    END  
  
    IF @MemberTypeLeaf_Permission = @Permission_Deny  
    BEGIN  
        IF EXISTS(SELECT 1 FROM #HierarchyMemberWorkingSet WHERE ChildMemberType_ID = @MemberType_Leaf)  
        BEGIN  
            --Flag Child leaf member types with deny permissions  
            UPDATE ws  
            SET ErrorCode = @ErrorCode_NoPermissionForThisOperationOnThisObject,  
                ErrorObjectType = @ObjectType_MemberCode,  
                MemberCode = ChildCode,  
                MemberType_ID = @MemberType_Leaf  
            FROM #HierarchyMemberWorkingSet ws  
            WHERE ws.ChildMemberType_ID = @MemberType_Leaf;  
        END;  
  
        IF EXISTS(SELECT 1 FROM #HierarchyMemberWorkingSet WHERE TargetMemberType_ID = @MemberType_Leaf)  
        BEGIN  
            --Flag Target leaf member types with deny permissions  
            UPDATE ws  
            SET ErrorCode = @ErrorCode_NoPermissionForThisOperationOnThisObject,  
                ErrorObjectType = @ObjectType_MemberCode,  
                MemberCode = TargetCode,  
                MemberType_ID = @MemberType_Leaf  
            FROM #HierarchyMemberWorkingSet ws  
            WHERE ws.TargetMemberType_ID = @MemberType_Leaf;  
        END;  
    END  
  
    IF @MemberTypeConsolidated_Permission = @Permission_Deny  
    BEGIN  
        IF EXISTS(SELECT 1 FROM #HierarchyMemberWorkingSet WHERE ChildMemberType_ID = @MemberType_Consolidated)  
        BEGIN  
            --Flag Child leaf member types with deny permissions  
            UPDATE ws  
            SET ErrorCode = @ErrorCode_NoPermissionForThisOperationOnThisObject,  
                ErrorObjectType = @ObjectType_MemberCode,  
                MemberCode = ChildCode,  
                MemberType_ID = @MemberType_Consolidated  
            FROM #HierarchyMemberWorkingSet ws  
            WHERE ws.ChildMemberType_ID = @MemberType_Consolidated  
            AND ws.ErrorCode IS NULL;  
        END;  
  
        IF EXISTS(SELECT 1 FROM #HierarchyMemberWorkingSet WHERE TargetMemberType_ID = @MemberType_Consolidated)  
        BEGIN  
            --Flag Target leaf member types with deny permissions  
            UPDATE ws  
            SET ErrorCode = @ErrorCode_NoPermissionForThisOperationOnThisObject,  
                ErrorObjectType = @ObjectType_MemberCode,  
                MemberCode = TargetCode,  
                MemberType_ID = @MemberType_Consolidated  
            FROM #HierarchyMemberWorkingSet ws  
            WHERE ws.TargetMemberType_ID = @MemberType_Consolidated  
            AND ws.ErrorCode IS NULL;  
        END;  
    END ELSE  
    BEGIN  
  
        --Get hierarchies based on user's permissions  
        UPDATE ws  
        SET ws.Hierarchy_ID = h.ID  
        FROM #HierarchyMemberWorkingSet ws  
        INNER JOIN mdm.tblHierarchy h  
            ON h.Name = ws.HierarchyName  
        INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_HIERARCHY sec  
            ON h.ID = sec.ID  
            AND sec.User_ID = @User_ID  
        WHERE  
            h.Entity_ID = @Entity_ID  
            AND ws.ErrorCode IS NULL;  
  
        -- Flag any invalid hierarchy names  
        UPDATE #HierarchyMemberWorkingSet  
        SET ErrorCode = @ErrorCode_InvalidExplicitHierarchy,  
            ErrorObjectType = @ObjectType_Hierarchy  
        WHERE  
            Hierarchy_ID IS NULL  
            AND ErrorCode IS NULL;  
  
        ----------------------------------------------------------------------------------------  
        -- Lookup Parent_ID from Target_ID  
        ----------------------------------------------------------------------------------------  
        -- TargetType is Sibling  
        IF EXISTS(SELECT 1 FROM #HierarchyMemberWorkingSet WHERE TargetType_ID = @TargetType_Sibling AND ErrorCode IS NULL)  
        BEGIN  
            SET @SQL = N'  
                    UPDATE ws  
                    SET  
                        ws.Parent_ID = hr.Parent_ID,  
                        ws.ParentCode = hr.Parent_Code  
                    FROM mdm.' + @ParentChildViewName + N' AS hr  
                    INNER JOIN #HierarchyMemberWorkingSet AS ws  
                        ON  hr.Version_ID = @Version_ID  
                        AND hr.Hierarchy_ID = ws.Hierarchy_ID  
                        AND hr.Child_ID = ws.Target_ID  
                        AND hr.ChildType_ID = ws.TargetMemberType_ID  
                        AND ws.ErrorCode IS NULL  
                        AND ws.TargetType_ID = @TargetType_Sibling  
                    ';  
            SET @ParamList = N'@Version_ID INT, @TargetType_Sibling INT';  
            EXEC sp_executesql @SQL, @ParamList, @Version_ID, @TargetType_Sibling;  
  
            -- For members being moved to unused node, overwrite null parent ID and Code with correct values.  
            UPDATE #HierarchyMemberWorkingSet  
            SET  
                Parent_ID = @Unused_ID,  
                ParentCode = @UnusedCode  
            WHERE  
                ErrorCode IS NULL AND  
                TargetType_ID = @TargetType_Sibling AND  
                Parent_ID IS NULL  
        END;  
  
        -- TargetType is Parent  
        UPDATE #HierarchyMemberWorkingSet  
        SET  
            Parent_ID = COALESCE(Target_ID, @Unused_ID),  
            ParentCode = COALESCE(TargetCode, @UnusedCode)  
        WHERE  
            ErrorCode IS NULL AND  
            TargetType_ID = @TargetType_Parent  
  
        -- Ensure no consolidated members are being moved under MDMUNUSED (not supported)  
        UPDATE #HierarchyMemberWorkingSet  
            SET ErrorCode = @ErrorCode_ConsolidatedMemberCannotBeChildOfMdmUnused  
        WHERE  
                ErrorCode IS NULL  
            AND Parent_ID = @Unused_ID  
            AND ChildMemberType_ID = @MemberType_Consolidated  
  
        ----------------------------------------------------------------------------------------  
        -- Lookup prior parent info.  
        ----------------------------------------------------------------------------------------  
        -- Note that when a member is assigned to ROOT, there will be a row in the HR table whose Parent_HP_ID column is null.  
        -- But when a member is assigned to MDMUNUSED, there will be no row in the HR table.  
        -- Also, unlike leaf members, consolidated members can only be in one hierarchy at a time. If a consolidated member is  
        -- being moved and its new parent is in a different hierarchy than prior hierarchy, then record the prior parent's hierarchy id.  
        SET @SQL = N'  
        -- Get prior parent info for Leaf members  
        UPDATE ws  
        SET  
             ws.PriorParent_ID = COALESCE(hr.Parent_HP_ID, ' + @strRoot_ID + N')  
            ,ws.PriorParentCode = COALESCE(hp.Code, N''' + @RootCode + N''')  
            ,ws.PriorParentHierarchy_ID = hr.Hierarchy_ID -- For leaf members ws.PriorParentHierarchy_ID will be the same as ws.Hierarchy_ID.  
            ,ws.PriorSortOrder = hr.SortOrder  
        FROM #HierarchyMemberWorkingSet AS ws  
        INNER JOIN mdm.' + @HierarchyTable + N' hr  
        ON      ws.Child_ID = hr.Child_EN_ID  
            AND ws.ChildMemberType_ID = hr.ChildType_ID  
            AND ws.Hierarchy_ID =  hr.Hierarchy_ID -- Leaf members can be in all hierarchies, so only match with HR row that pertain to the hierarchy specified in the working set row.  
        LEFT JOIN mdm.' + @HierarchyParentTable + N' hp  
            ON      hr.Parent_HP_ID = hp.ID  
                AND hr.Version_ID = hp.Version_ID  
        WHERE  
                ws.ErrorCode IS NULL  
            AND ws.ChildMemberType_ID = ' + @strMemberType_Leaf + N'  
            AND hr.Version_ID = @Version_ID  
            AND hr.Status_ID = ' + @strStatus_Active + N'  
  
        -- Get prior parent info for Consolidated members  
        UPDATE ws  
        SET  
             ws.PriorParent_ID = COALESCE(hr.Parent_HP_ID, ' + @strRoot_ID + N')  
            ,ws.PriorParentCode = COALESCE(hp.Code, N''' + @RootCode + N''')  
            ,ws.PriorParentHierarchy_ID = hr.Hierarchy_ID -- ws.PriorParentHierarchy_ID will be the same as ws.Hierarchy_ID, except for Consolidated members moving to a different hierarchy.  
            ,ws.PriorSortOrder = hr.SortOrder  
        FROM #HierarchyMemberWorkingSet AS ws  
        INNER JOIN mdm.' + @HierarchyTable + N' hr  
        ON      ws.Child_ID = hr.Child_HP_ID  
            AND ws.ChildMemberType_ID = hr.ChildType_ID  
            -- No need to add ws.Hierarchy_ID to the JOIN condition since Consolidated (unlike Leaf) members can only belong to a single hierarchy.  
        LEFT JOIN mdm.' + @HierarchyParentTable + N' hp  
            ON      hr.Parent_HP_ID = hp.ID  
                AND hr.Version_ID = hp.Version_ID  
        WHERE  
                ws.ErrorCode IS NULL  
            AND ws.ChildMemberType_ID = ' + @strMemberType_Consolidated + N'  
            AND hr.Version_ID = @Version_ID  
            AND hr.Status_ID = ' + @strStatus_Active + N'  
        ';  
        SET @ParamList = N'@Version_ID INT';  
        EXEC sp_executesql @SQL, @ParamList, @Version_ID;  
  
        -- If the previous query didn't find a prior parent for a child, then set its prior parent to MDMUNUSED.  
        UPDATE ws  
        SET  
             ws.PriorParent_ID = @Unused_ID  
            ,ws.PriorParentCode = @UnusedCode  
        FROM #HierarchyMemberWorkingSet AS ws  
        WHERE  
                ws.ErrorCode IS NULL  
            AND ws.PriorParent_ID IS NULL;  
  
        ----------------------------------------------------------------------------------------  
        -- Check Child, Target (sibling only), Parent, and Prior Parent permissions.  
        ----------------------------------------------------------------------------------------  
        -- Object Permissions.  Mark any members the user doesn't have permission to.  
        IF @MemberTypeLeaf_Permission != @Permission_Deny OR @MemberTypeConsolidated_Permission != @Permission_Deny  
        BEGIN  
            -- Flag Child members without Update object permissions.  
            UPDATE ws  
            SET  
                 ErrorCode =  
                    CASE COALESCE(sec.Privilege_ID, @Permission_Deny)  
                        WHEN @Permission_Access THEN @ErrorCode_ReadOnlyMember -- The AccessPermission is already checked below.  
                        WHEN @Permission_Inferred THEN @ErrorCode_ReadOnlyMember  
                        ELSE @ErrorCode_NoPermissionForThisOperationOnThisObject  
                    END  
                ,ErrorObjectType = @ObjectType_MemberCode  
                ,MemberCode = ChildCode  
                ,MemberType_ID = ChildMemberType_ID  
            FROM #HierarchyMemberWorkingSet ws  
            LEFT JOIN mdm.viw_SYSTEM_SECURITY_USER_MEMBERTYPE sec  
            ON ws.ChildMemberType_ID = sec.ID  
            WHERE  
                    ws.ErrorCode IS NULL  
                AND sec.Entity_ID = @Entity_ID  
                AND sec.User_ID = @User_ID  
                AND NOT(COALESCE(sec.Privilege_ID, @Permission_Deny) = @Permission_Access AND (COALESCE(sec.AccessPermission, @AccessPermission_None) & @AccessPermission_Update) != 0);  
  
            -- Flag Target (sibling only) members that don't have at least Read object permission (Read permission is sufficient for the sibling, so long as the parent has Update).  
            UPDATE ws  
            SET  
                 ErrorCode = @ErrorCode_NoPermissionForThisOperationOnThisObject  
                ,ErrorObjectType = @ObjectType_MemberCode  
                ,MemberCode = TargetCode  
                ,MemberType_ID = TargetMemberType_ID  
            FROM #HierarchyMemberWorkingSet ws  
            LEFT JOIN mdm.viw_SYSTEM_SECURITY_USER_MEMBERTYPE sec  
            ON ws.TargetMemberType_ID = sec.ID  
            WHERE  
                    ws.ErrorCode IS NULL  
                AND ws.TargetType_ID = @TargetType_Sibling -- Only check sibling target types. Parent target types will be checked below.  
                AND sec.Entity_ID = @Entity_ID  
                AND sec.User_ID = @User_ID  
                AND COALESCE(sec.Privilege_ID, @Permission_Deny) = @Permission_Deny; -- At least need read permission  
  
            -- Flag Parent members without Update object permissions. This also covers Prior Parent.  
            DECLARE @EntityConsolidatedPermission INT = @Permission_Deny;  
            DECLARE @EntityConsolidatedAccessPermission INT = @AccessPermission_None;  
            SELECT  
                @EntityConsolidatedPermission = COALESCE(sec.Privilege_ID, @Permission_Deny),  
                @EntityConsolidatedAccessPermission = COALESCE(sec.AccessPermission, @AccessPermission_None)  
            FROM mdm.viw_SYSTEM_SECURITY_USER_MEMBERTYPE sec  
            WHERE  
                sec.ID = @MemberType_Consolidated  
                AND sec.Entity_ID = @Entity_ID  
                AND sec.User_ID = @User_ID;  
            IF NOT(@EntityConsolidatedPermission = @Permission_Access AND (@EntityConsolidatedAccessPermission & @AccessPermission_Update) != 0)  
            BEGIN  
                UPDATE ws  
                SET  
                     ErrorCode =  
                        CASE COALESCE(@EntityConsolidatedPermission, @Permission_Deny)  
                            WHEN @Permission_Access THEN @ErrorCode_ReadOnlyMember -- The AccessPermission is already checked above.  
                            WHEN @Permission_Inferred THEN @ErrorCode_ReadOnlyMember  
                            ELSE @ErrorCode_NoPermissionForThisOperationOnThisObject  
                        END  
                    ,ErrorObjectType = @ObjectType_MemberCode  
                    ,MemberCode = ParentCode  
                    ,MemberType_ID = @MemberType_Consolidated  
                FROM #HierarchyMemberWorkingSet ws  
                WHERE  
                        ws.ErrorCode IS NULL  
                    AND ws.Parent_ID <> @Root_ID; -- ROOT ignores MemberType permission, since it is a virtual member.  
            END;  
        END;  
  
        --Check Member Permissions.  Mark any members the user doesn't have permission to.  
        IF @LeafUseMemberSecurity = 1 OR @ConsolidatesUseMemberSecurity = 1  
        BEGIN  
            -- Create temp table for storing member permissions.  
            CREATE TABLE #MemberPermissions  
            (  
                ID              INT,  
                MemberType_ID   INT,  
                Privilege_ID    INT,  
                AccessPermission    TINYINT  
            );  
            CREATE UNIQUE CLUSTERED INDEX #ix_MemberPermissions_ID_MemberType_ID ON #MemberPermissions(ID, MemberType_ID);  
  
            -- Get a list of all distinct hierarchy IDs in the input  
            DECLARE @Hierarchy_ID INT = NULL;  
            DECLARE @HierarchyIds TABLE (Hierarchy_ID INT NOT NULL PRIMARY KEY);  
            INSERT INTO @HierarchyIds (Hierarchy_ID)  
            SELECT DISTINCT ws.Hierarchy_ID  
            FROM #HierarchyMemberWorkingSet ws  
            WHERE  
                    ws.ErrorCode IS NULL  
                AND ws.Hierarchy_ID IS NOT NULL  
            UNION -- not UNION ALL because deduplication is needed  
            SELECT DISTINCT ws.PriorParentHierarchy_ID AS Hierarchy_ID  
            FROM #HierarchyMemberWorkingSet ws  
            WHERE  
                    ws.ErrorCode IS NULL  
                AND ws.PriorParentHierarchy_ID IS NOT NULL;  
  
            -- Loop through each hierarchy and lookup member permissions (note that the ROOT node could have differing permissions in different hierarchies)  
            WHILE EXISTS (SELECT 1 FROM @HierarchyIds)  
            BEGIN  
                -- Get the next hierarchy in the list.  
                SELECT TOP 1  
                    @Hierarchy_ID = Hierarchy_ID  
                FROM @HierarchyIds;  
                DELETE FROM @HierarchyIds WHERE Hierarchy_ID = @Hierarchy_ID;  
  
                -- Get the member ids that pertain to the hierarchy.  
                DELETE FROM @MemberIds;  
                INSERT INTO @MemberIds (ID, MemberType_ID)  
                SELECT -- Sibling targets  
                     Target_ID  
                    ,TargetMemberType_ID  
                FROM #HierarchyMemberWorkingSet  
                WHERE  
                        Target_ID IS NOT NULL  
                    AND TargetType_ID = @TargetType_Sibling  
                    AND Hierarchy_ID = @Hierarchy_ID  
                    AND ErrorCode IS NULL  
                UNION -- not UNION ALL because deduplication is needed  
                SELECT -- Parents  
                     Parent_ID  
                    ,@MemberType_Consolidated  
                FROM #HierarchyMemberWorkingSet  
                WHERE  
                        Parent_ID IS NOT NULL  
                    AND Hierarchy_ID = @Hierarchy_ID  
                    AND ErrorCode IS NULL  
                UNION -- not UNION ALL because deduplication is needed  
                SELECT -- Prior Parents  
                     PriorParent_ID  
                    ,@MemberType_Consolidated  
                FROM #HierarchyMemberWorkingSet  
                WHERE  
                        PriorParent_ID IS NOT NULL  
                    AND PriorParentHierarchy_ID = @Hierarchy_ID  
                    AND ErrorCode IS NULL  
                UNION -- not UNION ALL because deduplication is needed  
                SELECT -- Children  
                     Child_ID  
                    ,ChildMemberType_ID  
                FROM #HierarchyMemberWorkingSet  
                WHERE  
                        Child_ID IS NOT NULL  
                    AND Hierarchy_ID = @Hierarchy_ID  
                    AND ErrorCode IS NULL;  
  
                IF EXISTS (SELECT 1 FROM @MemberIds)  
                BEGIN  
                    -- Get member permissions. It it necessary to do this once per hierarchy because each hierarchy has its  
                    -- own ROOT node, each with its own permissions.  
                    DELETE FROM #MemberPermissions;  
                    INSERT INTO #MemberPermissions  
                    EXEC mdm.udpSecurityMembersResolverGet @User_ID, @Version_ID, @Entity_ID, @MemberIds, @Hierarchy_ID;  
  
                    -- Flag Child members without Update member permission.  
                    UPDATE ws  
                    SET  
                         ErrorCode =  
                            CASE COALESCE(sec.Privilege_ID, @Permission_Deny)  
                                WHEN @Permission_Access THEN @ErrorCode_ReadOnlyMember -- The AccessPermission is already checked below.  
                                WHEN @Permission_Inferred THEN @ErrorCode_ReadOnlyMember  
                                ELSE @ErrorCode_NoPermissionForThisOperationOnThisObject  
                            END  
                        ,ErrorObjectType = @ObjectType_MemberCode  
                        ,MemberCode = ChildCode  
                        ,MemberType_ID = ChildMemberType_ID  
                    FROM #HierarchyMemberWorkingSet ws  
                    LEFT JOIN #MemberPermissions sec  
                    ON  
                            ws.Child_ID = sec.ID  
                        AND ws.ChildMemberType_ID = sec.MemberType_ID  
                    WHERE  
                            ws.ErrorCode IS NULL  
                        AND ws.Hierarchy_ID = @Hierarchy_ID  
                        AND NOT (COALESCE(sec.Privilege_ID, @Permission_Deny) = @Permission_Access AND (COALESCE(sec.AccessPermission, @AccessPermission_None) & @AccessPermission_Update) != 0);  
  
                    -- Flag Target (sibling only) members that don't have at least Read member permission (Read permission is sufficient for the sibling, so long as the parent has Update).  
                    UPDATE ws  
                    SET  
                         ErrorCode = @ErrorCode_NoPermissionForThisOperationOnThisObject  
                        ,ErrorObjectType = @ObjectType_MemberCode  
                        ,MemberCode = TargetCode  
                        ,MemberType_ID = TargetMemberType_ID  
                    FROM #HierarchyMemberWorkingSet ws  
                    LEFT JOIN #MemberPermissions sec  
                    ON  
                            ws.Target_ID = sec.ID  
                        AND ws.TargetMemberType_ID = sec.MemberType_ID  
                    WHERE  
                            ws.ErrorCode IS NULL  
                        AND ws.TargetType_ID = @TargetType_Sibling -- Only check sibling target types. Parent target types will be checked below.  
                        AND ws.Hierarchy_ID = @Hierarchy_ID  
                        AND COALESCE(sec.Privilege_ID, @Permission_Deny) = @Permission_Deny; -- At least need read permission  
  
                    -- Flag Parent members without Update member permissions.  
                    UPDATE ws  
                    SET  
                         ErrorCode =  
                            CASE COALESCE(sec.Privilege_ID, @Permission_Deny)  
                                WHEN @Permission_Access THEN @ErrorCode_ReadOnlyMember -- The AccessPermission is already checked below.  
                                WHEN @Permission_Inferred THEN @ErrorCode_ReadOnlyMember  
                                ELSE @ErrorCode_NoPermissionForThisOperationOnThisObject  
                            END  
                        ,ErrorObjectType = @ObjectType_MemberCode  
                        ,MemberCode = ParentCode  
                        ,MemberType_ID = @MemberType_Consolidated  
                    FROM #HierarchyMemberWorkingSet ws  
                    LEFT JOIN #MemberPermissions sec  
                    ON  
                            ws.Parent_ID = sec.ID  
                        AND @MemberType_Consolidated = sec.MemberType_ID  
                    WHERE  
                            ws.ErrorCode IS NULL  
                        AND ws.Hierarchy_ID = @Hierarchy_ID  
                        AND NOT (COALESCE(sec.Privilege_ID, @Permission_Deny) = @Permission_Access AND (COALESCE(sec.AccessPermission, @AccessPermission_None) & @AccessPermission_Update) != 0);  
  
                    -- Flag Prior Parent members without Update member permissions.  
                    UPDATE ws  
                    SET  
                         ErrorCode =  
                            CASE COALESCE(sec.Privilege_ID, @Permission_Deny)  
                                WHEN @Permission_Access THEN @ErrorCode_ReadOnlyMember -- The AccessPermission is already checked below.  
                                WHEN @Permission_Inferred THEN @ErrorCode_ReadOnlyMember  
                                ELSE @ErrorCode_NoPermissionForThisOperationOnThisObject  
                            END  
                        ,ErrorObjectType = @ObjectType_MemberCode  
                        ,MemberCode = PriorParentCode  
                        ,MemberType_ID = @MemberType_Consolidated  
                    FROM #HierarchyMemberWorkingSet ws  
                    LEFT JOIN #MemberPermissions sec  
                    ON  
                            ws.PriorParent_ID = sec.ID  
                        AND @MemberType_Consolidated = sec.MemberType_ID  
                    WHERE  
                            ws.ErrorCode IS NULL  
                        AND ws.PriorParentHierarchy_ID = @Hierarchy_ID  
                        AND (COALESCE(@IsCreateMode, 0) = 0 OR ws.PriorParent_ID <> @Root_ID) -- When in create mode allow moves from ROOT, even if ROOT doesn't have update permission.  
                        AND NOT (COALESCE(sec.Privilege_ID, @Permission_Deny) = @Permission_Access AND (COALESCE(sec.AccessPermission, @AccessPermission_None) & @AccessPermission_Update) != 0);  
                END;  
            END; -- while  
        END;  
  
        -- Flag duplicate rows (i.e. rows that move the same member within the same hierarchy)  
        WITH cteDuplicates AS  
        (  
            SELECT  
                 ws.Child_ID  
                ,ws.Hierarchy_ID  
                ,ws.ChildMemberType_ID  
            FROM #HierarchyMemberWorkingSet ws  
            GROUP BY  
                 ws.Child_ID  
                ,ws.Hierarchy_ID  
                ,ws.ChildMemberType_ID  
            HAVING COUNT(ws.Child_ID) > 1  
        )  
        UPDATE ws  
        SET  
            ws.ErrorCode = @ErrorCode_InvalidMemberCode,  
            ws.ErrorObjectType = @ObjectType_MemberCode,  
            ws.MemberCode = ws.ChildCode,  
            ws.MemberType_ID = ws.ChildMemberType_ID  
        FROM #HierarchyMemberWorkingSet ws  
        INNER JOIN cteDuplicates dup  
        ON      ws.Child_ID = dup.Child_ID  
            AND ws.Hierarchy_ID = dup.Hierarchy_ID  
            AND ws.ChildMemberType_ID = dup.ChildMemberType_ID  
  
        -- Check for and prevent circular relationships.  
        CREATE TABLE #CircularRelationships (Row_ID INT PRIMARY KEY);  
        SET @SQL =N'  
        WITH cteConsolidatedChildren AS -- Get all consolidated children being moved to a new parent  
        (  
            SELECT  
                 Row_ID  
                ,Child_ID  
                ,Parent_ID  
            FROM #HierarchyMemberWorkingSet  
            WHERE  
                    ErrorCode IS NULL        -- Ignore rows that already have an error  
                AND ChildMemberType_ID = ' + @strMemberType_Consolidated + N' -- Only look at consolidated child members (moving a leaf member cannot create a circular reference)  
        )  
        ,cteParents AS -- Get all parent assignments. New parent assignments (in the working set) trump existing assignments (in the HR table).  
        (  
            SELECT  
                 hr.Child_HP_ID Child_ID  
                ,COALESCE(ws.Parent_ID, hr.Parent_HP_ID) Parent_ID -- Use the existing parent only if a new parent is not defined in the working set.  
            FROM mdm.' + @HierarchyTable + N' hr  
            LEFT JOIN cteConsolidatedChildren ws  
                ON hr.Child_HP_ID = ws.Child_ID  
            WHERE COALESCE(ws.Parent_ID, hr.Parent_HP_ID) IS NOT NULL -- For efficiency, exclude null parents since they cannot be part of a circular relationship.  
        )  
        ,cteAncestors AS -- Recursively find each new ancestor (from the new parent on up) of each consolidated member being moved.  
        (  
            SELECT  
                 Row_ID  
                ,Child_ID  
                ,Parent_ID Ancestor_ID  
                ,0 [Level]  
            FROM cteConsolidatedChildren  
  
            UNION ALL  
  
            SELECT  
                 a.Row_ID  
                ,a.Child_ID  
                ,hr.Parent_ID Ancestor_ID  
                ,a.[Level] + 1 [Level]  
            FROM cteAncestors a  
            INNER JOIN cteParents hr  
                ON a.Ancestor_ID = hr.Child_ID  
            WHERE  
                    a.[Level] < 99 -- Protects against "The statement terminated. The maximum recursion 100 has been exhausted before statement completion" error.  
                AND a.Child_ID <> a.Ancestor_ID -- End the recursion once a circular relationship has been found.  
        )  
        INSERT INTO #CircularRelationships (Row_ID)  
        SELECT DISTINCT Row_ID  
        FROM cteAncestors  
        WHERE Child_ID = Ancestor_ID;-- If the move would make the consolidated member its own ancestor, then it would create a circular relationship.  
        ';  
        --PRINT @SQL;  
        EXEC sp_executesql @SQL;  
  
        UPDATE ws  
        SET  
            ws.ErrorCode = @ErrorCode_MemberCausesCircularReference,  
            ws.ErrorObjectType = @ObjectType_MemberCode,  
            ws.MemberCode = ws.ChildCode,  
            ws.MemberType_ID = @MemberType_Consolidated  
        FROM #HierarchyMemberWorkingSet AS ws  
        INNER JOIN #CircularRelationships cir  
            ON ws.Row_ID = cir.Row_ID  
  
    END;  
  
    --Exit now if we have no members to update because user doesn't have necessary security or invalid member codes.  
    IF NOT EXISTS(SELECT 1 FROM #HierarchyMemberWorkingSet WHERE ErrorCode IS NULL) BEGIN  
        SELECT DISTINCT  
             HierarchyName  
            ,ChildCode  
            ,COALESCE(ChildMemberType_ID,0) AS ChildMemberType_ID  
            ,TargetCode  
            ,COALESCE(TargetMemberType_ID,0) AS TargetMemberType_ID  
            ,ErrorCode  
            ,ErrorObjectType  
            ,MemberCode -- Member code in error  
            ,MemberType_ID -- Member type in error  
            ,NULL AS MemberName  
        FROM #HierarchyMemberWorkingSet  
        WHERE ErrorCode IS NOT NULL;  
        RETURN(0);  
    END  
  
    --Start transaction, being careful to check if we are nested  
    SET @TranCounter = @@TRANCOUNT;  
    IF @TranCounter > 0 SAVE TRANSACTION TX;  
    ELSE BEGIN TRANSACTION;  
  
    --get an applock to help avoid deadlocks  
    DECLARE @lock INT;  
    EXEC @lock = sp_getapplock  
                    @Resource=N'Mds_Hierarchy_Save',  
                    @LockMode=N'Exclusive',  
                    @LockOwner=N'Transaction',  
                    @LockTimeout=10000,  
                    @DbPrincipal=N'public';  
  
    --0 and 1 are acceptable return codes from sp_getapplock  
    IF @lock NOT IN (0,1) BEGIN  
        RAISERROR(N'Unable to acquire Lock', 16, 1);  
    END  
    ELSE BEGIN TRY  
  
        /*  
        Check to see if a consolidated relationship exists for ANY hierarchy besides the one in this save process.  
        If so the consolidated member is being moved from one hierarchy to another.  
        Move all children in old hierarchy to Root and remove record.  
        */  
        IF EXISTS(  
            SELECT 1  
            FROM #HierarchyMemberWorkingSet  
            WHERE ChildMemberType_ID = @MemberType_Consolidated  
            AND Hierarchy_ID IS NOT NULL  
            AND ErrorCode IS NULL  
            )  
        BEGIN  
            INSERT INTO #HierarchyMemberWorkingSet2  
                (Child_ID, ChildMemberType_ID, Hierarchy_ID)  
            SELECT  
                Child_ID,  
                ChildMemberType_ID,  
                Hierarchy_ID  
            FROM #HierarchyMemberWorkingSet  
            WHERE  
                    ChildMemberType_ID = @MemberType_Consolidated  
                AND Hierarchy_ID <> PriorParentHierarchy_ID  
                AND Hierarchy_ID IS NOT NULL  
                AND ErrorCode IS NULL;  
  
            IF EXISTS (SELECT 1 FROM #HierarchyMemberWorkingSet2)  
            BEGIN  
                SET @SQL = N'  
                    --Move to ROOT  
                    UPDATE hr SET  
                        hr.Parent_HP_ID = NULL' + CASE @TransactionLogType WHEN @TransactionLogType_Member THEN @HRHistoryOutputQuery ELSE N'' END + N'  
                    FROM mdm.' + @HierarchyTable + N' AS hr  
                    INNER JOIN #HierarchyMemberWorkingSet2 hm  
                    ON  ((hr.Parent_HP_ID IS NULL AND hm.Child_ID IS NULL) OR (hm.Child_ID IS NOT NULL AND hr.Parent_HP_ID = hm.Child_ID))  
                    AND Version_ID =  @Version_ID;  
  
                    UPDATE hr  
                    SET Status_ID = ' + @strStatus_Inactive + CASE @TransactionLogType WHEN @TransactionLogType_Member THEN @HRHistoryOutputQuery ELSE N'' END + N'  
                    FROM mdm.' + @HierarchyTable + N' AS hr  
                    INNER JOIN #HierarchyMemberWorkingSet2 hm  
                    ON    hr.ChildType_ID = hm.ChildMemberType_ID  
                    AND hm.Child_ID = CASE hr.ChildType_ID WHEN ' + @strMemberType_Leaf + N' THEN hr.Child_EN_ID WHEN ' + @strMemberType_Consolidated + N' THEN hr.Child_HP_ID END  
                    AND Version_ID = @Version_ID;  
  
                    UPDATE hp SET  
                        hp.Hierarchy_ID = hm.Hierarchy_ID' + CASE @TransactionLogType WHEN @TransactionLogType_Member THEN @HPHistoryOutputQuery ELSE N'' END +  N'  
                    FROM mdm.' + @HierarchyParentTable + N' AS hp  
                    INNER JOIN #HierarchyMemberWorkingSet2 hm  
                    ON ((hp.ID IS NULL AND hm.Child_ID IS NULL) OR (hm.Child_ID IS NOT NULL AND hp.ID = hm.Child_ID))  
                    AND Version_ID =  @Version_ID;';  
                --PRINT @SQL;  
                SET @ParamList = N'@Version_ID INT';  
                EXEC sp_executesql @SQL, @ParamList, @Version_ID;  
            END;  
  
        END; --if  
  
        --Check to see if a relationship exists, if not create one.  
        SET @SQL = N'  
            DELETE FROM #HierarchyMemberWorkingSet2;  
  
            INSERT INTO #HierarchyMemberWorkingSet2 (Hierarchy_ID, Child_ID, ChildMemberType_ID)  
            SELECT  
                ws.Hierarchy_ID, ws.Child_ID, ws.ChildMemberType_ID  
            FROM #HierarchyMemberWorkingSet AS ws  
            LEFT OUTER JOIN mdm.' + @HierarchyTable + N' AS hr  
                ON hr.Version_ID = @Version_ID  
                AND hr.Hierarchy_ID = ws.Hierarchy_ID  
                AND hr.Child_EN_ID = ws.Child_ID  
                AND hr.ChildType_ID = ws.ChildMemberType_ID  
            WHERE hr.Hierarchy_ID IS NULL  
            AND ws.Hierarchy_ID IS NOT NULL  
            AND ws.ErrorCode IS NULL  
            AND ws.ChildMemberType_ID = ' + @strMemberType_Leaf + N';  
  
            INSERT INTO #HierarchyMemberWorkingSet2 (Hierarchy_ID, Child_ID, ChildMemberType_ID)  
            SELECT  
                ws.Hierarchy_ID, ws.Child_ID, ws.ChildMemberType_ID  
            FROM #HierarchyMemberWorkingSet AS ws  
            LEFT OUTER JOIN mdm.' + @HierarchyTable + N' AS hr  
                ON hr.Version_ID = @Version_ID  
                AND hr.Hierarchy_ID = ws.Hierarchy_ID  
                AND hr.Child_HP_ID = ws.Child_ID  
                AND hr.ChildType_ID = ws.ChildMemberType_ID  
            WHERE hr.Hierarchy_ID IS NULL  
            AND ws.Hierarchy_ID IS NOT NULL  
            AND ws.ErrorCode IS NULL  
            AND ws.ChildMemberType_ID = ' + @strMemberType_Consolidated + N';'  
  
        --PRINT @SQL  
        SET @ParamList = N'@Version_ID INT, @User_ID INT, @Entity_ID INT';  
        EXEC sp_executesql @SQL, @ParamList, @Version_ID, @User_ID, @Entity_ID;  
  
        IF EXISTS(SELECT 1 FROM #HierarchyMemberWorkingSet2)  
        BEGIN  
            DECLARE @HierarchyMembersCreate AS mdm.HierarchyMembers  
            INSERT INTO @HierarchyMembersCreate (Hierarchy_ID, Child_ID, ChildMemberType_ID)  
            SELECT Hierarchy_ID, Child_ID, ChildMemberType_ID FROM #HierarchyMemberWorkingSet2;  
            EXEC mdm.udpHierarchyMembersCreate @User_ID, @Version_ID, @Entity_ID, @HierarchyMembersCreate, @LogFlag;  
        END;  
  
        --Delete relationship(move to Unused)  
        IF EXISTS(SELECT 1 FROM #HierarchyMemberWorkingSet WHERE COALESCE(Parent_ID, @Unused_ID) = @Unused_ID AND ErrorCode IS NULL)  
        BEGIN  
            SET @SQL = N'  
                UPDATE hr  
                SET hr.Status_ID = ' + @strStatus_Inactive +  
                    CASE @TransactionLogType  
                        WHEN @TransactionLogType_Member THEN @HRHistoryOutputQuery  
                        WHEN @TransactionLogType_Attribute THEN N'  
                OUTPUT ' + CONVERT(NVARCHAR(2), @TransactionType_HierarchyParentSet) +  
                N', inserted.Hierarchy_ID, inserted.ChildType_ID, inserted.Child_EN_ID, ws.Child_MUID, inserted.Child_HP_ID, ws.Child_MUID, ws.ChildCode, COALESCE(inserted.Parent_HP_ID, ' + @strRoot_ID + N'),  ws.PriorParentCode, ' + @strUnused_ID + N',N''' + @UnusedCode + N''' INTO #HierarchyMemberTransactions'  
                        ELSE N''  
                    END + N'  
                FROM mdm.' + @HierarchyTable + N' AS hr  
                INNER JOIN #HierarchyMemberWorkingSet AS ws  
                ON    Version_ID = @Version_ID  
                AND   hr.Hierarchy_ID = ws.Hierarchy_ID  
                AND   COALESCE(ws.Parent_ID, ' + @strUnused_ID + N') = ' + @strUnused_ID + N'  
                AND   hr.ChildType_ID = ws.ChildMemberType_ID  
                AND   ws.Child_ID = CASE hr.ChildType_ID WHEN ' + @strMemberType_Leaf + N' THEN hr.Child_EN_ID WHEN ' + @strMemberType_Consolidated + N' THEN hr.Child_HP_ID END;';  
  
            SET @ParamList = N'@Version_ID INT';  
            EXEC sp_executesql @SQL,@ParamList, @Version_ID;  
        END; --if  
  
        ELSE IF EXISTS(SELECT 1 FROM #HierarchyMemberWorkingSet WHERE TargetType_ID = @TargetType_Parent AND ErrorCode IS NULL)  
        BEGIN --Parent  
            --Get relative sort orders  
            WITH cteRelativeSortOrder AS  
            (  
                SELECT ROW_NUMBER() OVER (PARTITION BY ws.Parent_ID ORDER BY ws.PriorSortOrder) AS RelativeSortOrder, ws.Hierarchy_ID, ws.ChildMemberType_ID, ws.Child_ID  
                    FROM #HierarchyMemberWorkingSet AS ws  
            )  
            UPDATE ws  
                SET ws.RelativeSortOrder = cteRelativeSortOrder.RelativeSortOrder  
                    FROM #HierarchyMemberWorkingSet ws  
                    INNER JOIN cteRelativeSortOrder  
                        ON cteRelativeSortOrder.Hierarchy_ID = ws.Hierarchy_ID  
                        AND cteRelativeSortOrder.ChildMemberType_ID = ws.ChildMemberType_ID  
                        AND cteRelativeSortOrder.Child_ID = ws.Child_ID;  
  
            SET @ParamList = N'@Version_ID INT, @TargetType_Parent INT';  
            EXEC sp_executesql @SQL,@ParamList, @Version_ID, @TargetType_Parent;  
  
            -- Get Sort order  
            SET @SQL = N'  
                WITH cte AS  
                (  
                    SELECT hr.Hierarchy_ID, hr.Parent_HP_ID AS Parent_ID, COALESCE(MAX(hr.SortOrder), 0) AS SortOrder  
                        FROM #HierarchyMemberWorkingSet AS ws  
                        LEFT JOIN mdm.' + @HierarchyTable + N' AS hr  
                            ON hr.Version_ID = @Version_ID  
                            AND hr.Hierarchy_ID = ws.Hierarchy_ID  
                            AND ((COALESCE(ws.Target_ID, 0) = 0 AND hr.Parent_HP_ID IS NULL) OR (ws.Target_ID = hr.Parent_HP_ID))  
                            AND ws.TargetType_ID = @TargetType_Parent  
                            AND ws.ErrorCode IS NULL  
                        GROUP BY hr.Hierarchy_ID, hr.Parent_HP_ID  
                )  
                UPDATE ws  
                    SET ws.SortOrder = (COALESCE(cte.SortOrder, 0) + COALESCE(ws.RelativeSortOrder, 0))  
                    FROM #HierarchyMemberWorkingSet AS ws  
                    LEFT JOIN cte  
                        ON cte.Hierarchy_ID = ws.Hierarchy_ID  
                        AND cte.Parent_ID = ws.Target_ID  
            ';  
  
            SET @ParamList = N'@Version_ID INT, @TargetType_Parent INT';  
            EXEC sp_executesql @SQL,@ParamList, @Version_ID, @TargetType_Parent;  
  
            -- Remove rows that are not actually moving the child.  
            DELETE FROM #HierarchyMemberWorkingSet  
            WHERE  
                    PriorParent_ID = Parent_ID  
                AND PriorSortOrder = SortOrder  
                AND PriorParentHierarchy_ID = Hierarchy_ID  
                AND ErrorCode IS NULL;  
  
            --Build the update string. Ensure a @Target_ID of zero is converted to NULL, which is  
            --the correct value for children of Root.  
            --EDM-1863: Also schedule the updated member for level recalculation during validation (assign LevelNumber = -1)  
            SET @SQL = N'  
                UPDATE hr  
                SET  
                    hr.Parent_HP_ID =  NULLIF(ws.Target_ID, ' + @strRoot_ID + N'),  
                    hr.SortOrder =  ws.SortOrder,  
                    hr.LastChgDTM = GETUTCDATE(),  
                    hr.LastChgUserID = @User_ID,  
                    hr.LastChgVersionID = @Version_ID,  
                    hr.LevelNumber = -1,  
                    hr.Status_ID = ' + @strStatus_Active +  
                    CASE @TransactionLogType  
                        WHEN @TransactionLogType_Member THEN @HRHistoryOutputQuery  
                        WHEN @TransactionLogType_Attribute THEN N'  
                OUTPUT ' + CONVERT(NVARCHAR(2), @TransactionType_HierarchyParentSet) +  
                N', inserted.Hierarchy_ID, inserted.ChildType_ID, inserted.Child_EN_ID, ws.Child_MUID, inserted.Child_HP_ID, ws.Child_MUID, ws.ChildCode, ws.PriorParent_ID, ws.PriorParentCode, COALESCE(inserted.Parent_HP_ID, ' + @strRoot_ID + N'), COALESCE(ws.ParentCode, N''' + @RootCode + N''') INTO #HierarchyMemberTransactions'  
                        ELSE N''  
                    END + N'  
                FROM mdm.' + @HierarchyTable + N' AS hr  
                INNER JOIN #HierarchyMemberWorkingSet AS ws  
                    ON  hr.Version_ID = @Version_ID  
                    AND    hr.Hierarchy_ID = ws.Hierarchy_ID  
                    AND    hr.ChildType_ID = ws.ChildMemberType_ID  
                    AND    ws.Child_ID = CASE hr.ChildType_ID WHEN ' + @strMemberType_Leaf + N' THEN hr.Child_EN_ID WHEN ' + @strMemberType_Consolidated + N' THEN hr.Child_HP_ID END  
                    AND ws.TargetType_ID = ' + @strMemberType_Leaf + N'  
                    AND ws.ErrorCode IS NULL;';  
  
            SET @ParamList = N'@User_ID INT, @Version_ID INT';  
            EXEC sp_executesql @SQL, @ParamList, @User_ID, @Version_ID;  
        END  
        ELSE IF EXISTS(SELECT 1 FROM #HierarchyMemberWorkingSet WHERE TargetType_ID = @TargetType_Sibling AND ErrorCode IS NULL)  
        BEGIN --Sibling  
  
            --Get relative sort orders  
            WITH cteRelativeSortOrder AS  
            (  
                SELECT ROW_NUMBER() OVER (PARTITION BY ws.Parent_ID ORDER BY ws.PriorSortOrder) AS RelativeSortOrder, ws.Hierarchy_ID, ws.ChildMemberType_ID, ws.Child_ID  
                    FROM #HierarchyMemberWorkingSet AS ws  
            )  
            UPDATE ws  
                SET ws.RelativeSortOrder = cteRelativeSortOrder.RelativeSortOrder  
                    FROM #HierarchyMemberWorkingSet ws  
                    INNER JOIN cteRelativeSortOrder  
                        ON cteRelativeSortOrder.Hierarchy_ID = ws.Hierarchy_ID  
                        AND cteRelativeSortOrder.ChildMemberType_ID = ws.ChildMemberType_ID  
                        AND cteRelativeSortOrder.Child_ID = ws.Child_ID;  
  
            SET @ParamList = N'@Version_ID INT';  
            EXEC sp_executesql @SQL,@ParamList, @Version_ID;  
  
            -- Get Sort order  
            SET @SQL = N'  
                WITH cte AS  
                (  
                    SELECT hr.Hierarchy_ID, hr.ChildType_ID, hr.Child_ID, COALESCE(MAX(hr.Child_SortOrder), 0) AS SortOrder  
                        FROM #HierarchyMemberWorkingSet AS ws  
                        LEFT JOIN mdm.' + @ParentChildViewName + N' AS hr  
                            ON Version_ID = @Version_ID  
                            AND hr.Hierarchy_ID = ws.Hierarchy_ID  
                            AND ((ws.Target_ID IS NULL AND hr.Child_ID IS NULL)  
                            OR (ws.Target_ID = hr.Child_ID))  
                            AND ws.TargetType_ID = ' + @strMemberType_Consolidated + N'  
                            AND ws.ErrorCode IS NULL  
                        GROUP BY hr.Hierarchy_ID, hr.ChildType_ID, hr.Child_ID  
                )  
                UPDATE ws  
                    SET ws.SortOrder = COALESCE(cte.SortOrder, 0) + COALESCE(ws.RelativeSortOrder, 0)  
                        FROM #HierarchyMemberWorkingSet AS ws  
                        LEFT JOIN cte  
                            ON cte.Hierarchy_ID = ws.Hierarchy_ID  
                            AND cte.ChildType_ID = ws.TargetMemberType_ID  
                            AND cte.Child_ID = ws.Target_ID  
            ';  
  
            SET @ParamList = N'@Version_ID INT';  
            EXEC sp_executesql @SQL,@ParamList, @Version_ID;  
  
          -- Remove rows that are not actually moving the child.  
            DELETE FROM #HierarchyMemberWorkingSet  
            WHERE  
                    PriorParent_ID = Parent_ID  
                AND PriorSortOrder = SortOrder  
                AND PriorParentHierarchy_ID = Hierarchy_ID  
                AND ErrorCode IS NULL;  
  
            --Update the childen SortOrder to Sort + Number of children pasted  
            SET @SQL = N'  
                WITH cteMaxRelativeSortOrder AS  
                (  
                    SELECT MAX(COALESCE(ws.RelativeSortOrder, 0)) as MaxRelativeSortOrder, Target_ID  
                        FROM #HierarchyMemberWorkingSet AS ws  
                            WHERE ws.TargetType_ID = ' + @strMemberType_Consolidated + N'  
                            AND ws.ErrorCode IS NULL  
                        GROUP BY ws.Target_ID  
                )  
                UPDATE hr  
                SET  
                    hr.SortOrder = (hr.SortOrder + COALESCE(cteMaxRelativeSortOrder.MaxRelativeSortOrder, 0)),  
                    hr.Status_ID = ' + @strStatus_Active + N',  
                    hr.LastChgDTM = GETUTCDATE(),  
                    hr.LastChgUserID =  @User_ID,  
                    hr.LastChgVersionID =  @Version_ID' + CASE @TransactionLogType WHEN @TransactionLogType_Member THEN @HRHistoryOutputQuery ELSE N'' END + N'  
                FROM #HierarchyMemberWorkingSet AS ws  
                LEFT JOIN mdm.' + @HierarchyTable + N' AS hr  
                    ON  hr.Version_ID = @Version_ID  
                    AND    hr.Hierarchy_ID = ws.Hierarchy_ID  
                    AND    ((COALESCE(ws.Parent_ID, 0) = 0 AND hr.Parent_HP_ID IS NULL) OR (ws.Parent_ID IS NOT NULL AND hr.Parent_HP_ID = ws.Parent_ID))  
                    AND ws.TargetType_ID = ' + @strMemberType_Consolidated + N'  
                    AND hr.SortOrder IS NOT NULL AND hr.SortOrder >= ws.SortOrder  
                    AND ws.ErrorCode IS NULL  
                LEFT JOIN cteMaxRelativeSortOrder  
                    ON cteMaxRelativeSortOrder.Target_ID = ws.Target_ID  
                    ;';  
  
            SET @ParamList = N'@User_ID INT, @Version_ID INT';  
            EXEC sp_executesql @SQL, @ParamList, @User_ID, @Version_ID;  
  
            --Update the Member being Moved. Ensure a @Parent_ID of zero is converted to NULL, which is  
            --the correct value for children of Root.  
            --Schedule the updated member for level recalculation during validation (assign LevelNumber = -1)  
            SET @SQL = N'  
                UPDATE hr  
                SET  
                    hr.Parent_HP_ID =  NULLIF(ws.Parent_ID, ' + @strRoot_ID + N'),  
                    hr.SortOrder =  ws.SortOrder,  
                    hr.Status_ID = ' + @strStatus_Active + N',  
                    hr.LastChgDTM = GETUTCDATE(),  
                    hr.LastChgUserID = @User_ID,  
                    hr.LastChgVersionID = @Version_ID,  
                    hr.LevelNumber = -1' +  
                        CASE @TransactionLogType  
                            WHEN @TransactionLogType_Member THEN @HRHistoryOutputQuery  
                            WHEN @TransactionLogType_Attribute THEN N'  
                OUTPUT ' + CONVERT(NVARCHAR(2), @TransactionType_HierarchySiblingSet) +  
                N', inserted.Hierarchy_ID, inserted.ChildType_ID, inserted.Child_EN_ID, ws.Child_MUID, inserted.Child_HP_ID, ws.Child_MUID, ws.ChildCode, ws.PriorParent_ID, ws.PriorParentCode, COALESCE(inserted.Parent_HP_ID, ' + @strRoot_ID + N'), COALESCE(ws.ParentCode, N''' + @RootCode + N''') INTO #HierarchyMemberTransactions'  
                            ELSE N''  
                        END + N'  
                FROM mdm.' + @HierarchyTable + N' AS hr  
                INNER JOIN #HierarchyMemberWorkingSet AS ws  
                    ON  hr.Version_ID = @Version_ID  
                    AND    hr.Hierarchy_ID = ws.Hierarchy_ID  
                    AND    hr.ChildType_ID = ws.ChildMemberType_ID  
                    AND    ws.Child_ID = CASE hr.ChildType_ID WHEN ' + @strMemberType_Leaf + N' THEN hr.Child_EN_ID WHEN ' + @strMemberType_Consolidated + N' THEN hr.Child_HP_ID END  
                    AND ws.TargetType_ID = ' + @strMemberType_Consolidated + N'  
                    AND ws.ErrorCode IS NULL;';  
  
            SET @ParamList = N'@User_ID INT, @Version_ID INT';  
            EXEC sp_executesql @SQL, @ParamList, @User_ID, @Version_ID;  
  
        END; --if  
  
        --Log the transaction  
        IF @TransactionLogType = @TransactionLogType_Attribute  
        BEGIN  
            SET @SQL = N'  
                UPDATE txn  
                SET  
                    txn.Child_EN_MUID = ws.Child_MUID  
                FROM #HierarchyMemberTransactions AS txn  
                INNER JOIN #HierarchyMemberWorkingSet as ws  
                    ON ws.Child_ID = txn.Child_EN_ID  
                    AND ws.ChildMemberType_ID = ' + @strMemberType_Leaf;  
  
            EXEC sp_executesql @SQL;  
  
            SET @SQL = N'  
                UPDATE txn  
                SET  
                    txn.Child_HP_MUID = ws.Child_MUID  
                FROM #HierarchyMemberTransactions AS txn  
                INNER JOIN #HierarchyMemberWorkingSet as ws  
                    ON ws.Child_ID = txn.Child_HP_ID  
                    AND ws.ChildMemberType_ID = ' + @strMemberType_Consolidated;  
  
            EXEC sp_executesql @SQL;  
  
            SET @SQL = N'  
            INSERT INTO [mdm].' + QUOTENAME(@TransactionTableName) + N'  
            (  
                Version_ID,  
                TransactionType_ID,  
                OriginalTransaction_ID,  
                Hierarchy_ID,  
                Entity_ID,  
                Member_ID,  
                Member_MUID,  
                MemberType_ID,  
                MemberCode,  
                OldValue,  
                OldCode,  
                NewValue,  
                NewCode,  
                EnterDTM,  
                EnterUserID,  
                LastChgDTM,  
                LastChgUserID  
            )  
            SELECT  
                @Version_ID  
                ,txn.TransactionType  
                ,COALESCE(@OriginalTransaction_ID, 0)  
                ,txn.Hierarchy_ID  
                ,@Entity_ID  
                ,CASE txn.ChildType_ID WHEN @MemberType_Leaf THEN txn.Child_EN_ID ELSE txn.Child_HP_ID END --Member_ID  
                ,CASE txn.ChildType_ID WHEN @MemberType_Leaf THEN txn.Child_EN_MUID ELSE txn.Child_HP_MUID END --Member_MUID  
                ,txn.ChildType_ID --MemberType_ID  
                ,txn.ChildCode --MemberCode  
                ,COALESCE(txn.PriorParent_ID, @Unused_ID) --OldValue  
                ,CASE COALESCE(txn.PriorParent_ID, @Unused_ID) WHEN @Unused_ID THEN @UnusedCode WHEN @Root_ID THEN @RootCode ELSE txn.PriorParentCode END --OldCode  
                ,COALESCE(txn.NewParent_ID, @Unused_ID) --NewValue  
                ,CASE COALESCE(txn.NewParent_ID, @Unused_ID) WHEN @Unused_ID THEN @UnusedCode WHEN @Root_ID THEN @RootCode ELSE txn.NewParentCode END --NewCode  
                ,GETUTCDATE()  
                ,@User_ID  
                ,GETUTCDATE()  
                ,@User_ID  
            FROM #HierarchyMemberTransactions AS txn  
            ';  
            EXEC sp_executesql @SQL, N'@Version_ID INT, @OriginalTransaction_ID INT, @Entity_ID INT, @MemberType_Leaf INT, @Unused_ID INT, @UnusedCode NVARCHAR(10), @Root_ID INT, @RootCode NVARCHAR(10), @User_ID INT',  
                                       @Version_ID,     @OriginalTransaction_ID,     @Entity_ID,     @MemberType_Leaf,     @Unused_ID,     @UnusedCode,              @Root_ID,     @RootCode,              @User_ID;  
        END; --if @TransactionType = @TransactionType_Column  
  
  
        --Put a msg onto the SB queue to process member security  
        EXEC mdm.udpSecurityMemberQueueSave  
            @User_ID    = NULL,-- update member security for all users  
            @Version_ID = @Version_ID,  
            @Entity_ID  = @Entity_ID;  
  
        EXEC @lock = sp_releaseapplock  
                        @Resource=N'Mds_Hierarchy_Save',  
                        @DbPrincipal = N'public',  
                        @LockOwner = N'Transaction';  
  
        --Return any errors  
        SELECT DISTINCT  
             HierarchyName  
            ,ChildCode  
            ,COALESCE(ChildMemberType_ID,0) AS ChildMemberType_ID  
            ,TargetCode  
            ,COALESCE(TargetMemberType_ID,0) AS TargetMemberType_ID  
            ,ErrorCode  
            ,ErrorObjectType  
            ,MemberCode -- Member code in error  
            ,MemberType_ID -- Member type in error  
            ,NULL AS MemberName  
        FROM #HierarchyMemberWorkingSet  
        WHERE ErrorCode IS NOT NULL;  
  
        --Commit only if we are not nested  
        IF @TranCounter = 0 COMMIT TRANSACTION;  
  
    END TRY  
    BEGIN CATCH  
  
        -- Get error info.  
        DECLARE  
            @ErrorMessage NVARCHAR(4000),  
            @ErrorSeverity INT,  
            @ErrorState INT,  
            @ErrorNumber INT,  
            @ErrorLine INT,  
            @ErrorProcedure NVARCHAR(126);  
        EXEC mdm.udpGetErrorInfo  
            @ErrorMessage = @ErrorMessage OUTPUT,  
            @ErrorSeverity = @ErrorSeverity OUTPUT,  
            @ErrorState = @ErrorState OUTPUT,  
            @ErrorNumber = @ErrorNumber OUTPUT,  
            @ErrorLine = @ErrorLine OUTPUT,  
            @ErrorProcedure = @ErrorProcedure OUTPUT  
  
        SET @ErrorMessage = CONCAT(@ErrorMessage, N', @ErrorNumber = ', @ErrorNumber, N', @ErrorProcedure = "', @ErrorProcedure, N'", line ', @ErrorLine);  
  
        IF @TranCounter = 0  
            ROLLBACK TRANSACTION;  
        ELSE IF XACT_STATE() <> -1  
            ROLLBACK TRANSACTION TX;  
  
        RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);  
        RETURN(1);  
  
    END CATCH  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpHierarchyMembersValidationStatusUpdate]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
Description:  
This procedure updates the validation status of a hierarchy tree starting at a given   
consolidated apex member node.  
  
Example:  
declare	@parentIdList mdm.IdList;   
INSERT INTO @parentIdList (ID) VALUES (390);  
  
EXEC mdm.udpHierarchyMembersValidationStatusUpdate  
     @Entity_ID = 31  
    ,@Version_ID = 20  
    ,@Hierarchy_ID = null  
    ,@ParentIdList = @parentIdList  
    ,@ValidationStatus_ID = 5  
    ,@MaxLevel = 0  
    ,@IncludeParent = 0;  
  
*/  
CREATE PROCEDURE [mdm].[udpHierarchyMembersValidationStatusUpdate]  
(  
    @Entity_ID				 INT,  
    @Version_ID				 INT,  
    @Hierarchy_ID			 INT = NULL,  
    @ParentIdList mdm.IdList READONLY,   
    @ValidationStatus_ID	 INT,  
    @MaxLevel				 INT = 0, -- 0 = Include all levels  
    @IncludeParent			 BIT = 1,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON  
  
    DECLARE   
        @parentChildViewName sysname,  
        @entityTableName sysname,  
        @hierarchyParentTableName sysname,  
        @Model_ID   INT,  
        @sql nvarchar(max);  
  
    -- Initialize any null parameters  
    SELECT  
         @ValidationStatus_ID = ISNULL(@ValidationStatus_ID, 0)  
        ,@MaxLevel = ISNULL(@MaxLevel, 0)  
        ,@IncludeParent = ISNULL(@IncludeParent, 0);  
          
    CREATE TABLE #descendentIDs (ID INT, ChildType_ID INT);  
  
    --Get the physical table names  
    SELECT  
         @entityTableName =  EntityTable  
        ,@hierarchyParentTableName = HierarchyParentTable  
        ,@Model_ID = Model_ID  
    FROM mdm.tblEntity  
    WHERE ID = @Entity_ID;  
  
    --Get the name of the ParentChild view name  
    DECLARE @MemberType_ParentChild TINYINT = 4;  
    SET @parentChildViewName = mdm.udfViewNameGet(@Model_ID, @Entity_ID, @MemberType_ParentChild, 0, 0);  
  
     --Get Hierarchy IDs FROM Member.  All Parent Ids must be FROM the same Hierarchy.  Pick the first one    
    IF @Hierarchy_ID IS NULL   
    SET @sql = N'   
        SELECT TOP 1    
            @Hierarchy_ID = pc.Hierarchy_ID    
        FROM mdm.' + quotename(@parentChildViewName) + N' pc      
        WHERE    
                pc.Version_ID = @Version_ID    
            AND pc.Child_ID IN (SELECT ID FROM @ParentIdList)    
            AND pc.ChildType_ID = 2    
        ORDER BY pc.Hierarchy_ID';  
    EXEC sp_executesql @sql,     
        N'@Version_ID INT, @ParentIdList mdm.IdList READONLY, @Hierarchy_ID INT OUTPUT',     
        @Version_ID, @ParentIdList, @Hierarchy_ID OUTPUT;    
  
    --Use a recursive CTE to get all children for the ParentIdList, consolidated AND leaf  
    SELECT @sql = N'  
    WITH HierRecurse AS (  
        SELECT Child_ID, Parent_ID, 1 [Level]  
        FROM mdm.' + quotename(@parentChildViewName) + N'  
        WHERE Version_ID = @Version_ID  
        AND Hierarchy_ID = @Hierarchy_ID  
        AND Child_ID IN (SELECT ID FROM @ParentIdList)  
        AND ChildType_ID = 2  
  
        UNION ALL  
  
        SELECT c.Child_ID, c.Parent_ID, r.[Level] + 1  
        FROM mdm.' + quotename(@parentChildViewName) + N' AS c  
        INNER JOIN HierRecurse AS r  
            ON  c.Version_ID = @Version_ID  
            AND c.Hierarchy_ID = @Hierarchy_ID  
            AND c.ChildType_ID = 2  
            AND c.Parent_ID = r.Child_ID  
    )  
    INSERT INTO #descendentIDs (ID, ChildType_ID)  
    Select   
        pc.Child_ID, pc.ChildType_ID  
    From mdm.' + quotename(@parentChildViewName) + N' AS pc  
    INNER JOIN HierRecurse AS r  
        ON pc.Parent_ID = r.Child_ID  
    OPTION (MAXRECURSION ' + CAST(@MaxLevel AS NVARCHAR(30)) + N')  
    ';  
  
    EXEC sp_executesql @sql,   
        N'@Hierarchy_ID INT, @Version_ID INT, @ParentIdList mdm.IdList READONLY',   
        @Hierarchy_ID, @Version_ID, @ParentIdList;  
  
    IF @IncludeParent = 1  
        INSERT INTO #descendentIDs (ID, ChildType_ID)   
            SELECT ID, 2  
            FROM @ParentIdList;  
  
    -- Update the Hierarchy Parent table (consolidated)  
    SET @sql =   
        'UPDATE	mdm.' + quotename(@hierarchyParentTableName) + N'  
           SET	ValidationStatus_ID = @ValidationStatus_ID   
         FROM   mdm.' + quotename(@hierarchyParentTableName) + N' AS hp    
         INNER JOIN #descendentIDs d   
            ON  hp.ID = d.ID   
            AND d.ChildType_ID = 2  
            AND hp.Hierarchy_ID = @Hierarchy_ID  
            AND hp.Version_ID = @Version_ID  
            AND hp.Status_ID = 1   
            AND hp.ValidationStatus_ID <> @ValidationStatus_ID;  
     ';  
  
    EXEC sp_executesql @sql,   
        N'@Version_ID INT, @ValidationStatus_ID INT, @Hierarchy_ID INT',   
          @Version_ID, @ValidationStatus_ID, @Hierarchy_ID;  
  
    -- Update the Entity table (leaf)  
    SET @sql =   
        N'UPDATE mdm.' + quotename(@entityTableName) + N'  
            SET	 ValidationStatus_ID = @ValidationStatus_ID  
          FROM   mdm.' + quotename(@entityTableName) + N' AS en  
         INNER JOIN #descendentIDs d   
            ON  en.ID = d.ID   
            AND d.ChildType_ID = 1  
            AND en.Version_ID = @Version_ID  
            AND en.Status_ID = 1   
            AND en.ValidationStatus_ID <> @ValidationStatus_ID;  
     ';  
  
                 
    EXEC sp_executesql @sql,   
        N'@Version_ID INT, @ValidationStatus_ID INT',   
          @Version_ID, @ValidationStatus_ID;  
  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpHierarchyParentIDGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
	mdm.udpHierarchyParentIDGet 20,9,32,1,1  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpHierarchyParentIDGet]  
(  
	@Version_ID			INT,  
	@Hierarchy_ID		INT,  
	@Entity_ID			INT,  
	@ChildMember_ID		INT,  
	@ChildType_ID		TINYINT,  
	@Parent_ID			INT = NULL OUTPUT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
	SET NOCOUNT ON;  
  
	--Get the Hierarchy RelationShip Table Name  
	DECLARE @HierarchyTable AS sysname;  
	SET @HierarchyTable = mdm.udfTableNameGetByID(@Entity_ID, 4);  
  
	--Get The Target SortOrder  
	DECLARE @SQL AS NVARCHAR(MAX);  
	SET @Parent_ID = NULL; --In case a value was passed-in by mistake  
	  
	SET @SQL = N'  
		SELECT @Parent_ID = [Parent_HP_ID]  
		FROM mdm.' + quotename(@HierarchyTable) + N'   
		WHERE   
			Version_ID = @Version_ID AND  
			Hierarchy_ID = @Hierarchy_ID AND  
			ChildType_ID = @ChildType_ID AND  
			@ChildMember_ID = CASE ChildType_ID WHEN 1 THEN Child_EN_ID WHEN 2 THEN Child_HP_ID END;';  
			  
	EXEC sp_executesql @SQL,   
	    N'@Version_ID INT, @Hierarchy_ID INT, @ChildType_ID TINYINT, @ChildMember_ID INT, @Parent_ID INT OUTPUT',   
	    @Version_ID, @Hierarchy_ID, @ChildType_ID, @ChildMember_ID, @Parent_ID OUTPUT;  
  
	SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpHierarchySortOrderSave]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
Procedure  : mdm.udpHierarchySortOrderSave  
Component  : Import (Staging)  
Description: mdm.udpHierarchySortOrderSave recalculates the sort order for an entire hierarchy.  It assumes that the level number is current and correct.  
Parameters : Model Version ID, Hierarchy ID  
Return     : N/A  
Example    : EXEC mdm.udpHierarchySortOrderSave 1, 1  
*/  
CREATE PROCEDURE [mdm].[udpHierarchySortOrderSave]  
(  
    @Version_ID   INT,  
    @Hierarchy_ID INT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE @SQL             NVARCHAR(MAX) --SQL string     
    DECLARE @tblRelationship sysname    --Hierarchy relationships table  
    DECLARE @Entity_ID       INT            --Entity ID  
  
    SELECT @Entity_ID = Entity_ID FROM mdm.tblHierarchy WHERE ID = @Hierarchy_ID  
    SELECT @tblRelationship = HierarchyTable FROM [mdm].tblEntity WHERE ID = @Entity_ID  
  
  
    --Temporary table to store list of descendants  
    CREATE TABLE #tblHierarchy   
    (  
        LevelNumber SMALLINT,   
        ID INT,   
        Parent_ID INT,   
        Descendants INT,   
        Child_ID INT,   
        SeqNum INT IDENTITY (1, 1),   
        PriorParent_ID INT,   
        FirstChildSeqNum INT,   
        InitSortOrder INT NOT NULL DEFAULT 1  
    );  
  
    SET @SQL = N'  
        INSERT INTO #tblHierarchy   
        (  
            LevelNumber,   
            ID,   
            Parent_ID,   
            Descendants,   
            Child_ID  
        )   
        SELECT   
            tSource.LevelNumber,   
            tSource.ID,   
            tSource.Parent_HP_ID,   
            tDerived.Descendants,   
            CASE tSource.ChildType_ID WHEN 1 THEN tSource.Child_EN_ID WHEN 2 THEN tSource.Child_HP_ID END  
        FROM mdm.' + quotename(@tblRelationship) + N' AS tSource   
        INNER JOIN (  
                SELECT LevelNumber, Parent_HP_ID, COUNT(*) AS Descendants   
                FROM mdm.' + quotename(@tblRelationship) + N'   
                WHERE Version_ID = @Version_ID   
                    AND Hierarchy_ID = @Hierarchy_ID   
                GROUP BY Parent_HP_ID, LevelNumber  
            ) AS tDerived  
            ON tSource.Parent_HP_ID = tDerived.Parent_HP_ID  
        WHERE Version_ID = @Version_ID   
            AND Hierarchy_ID = @Hierarchy_ID  
        ORDER BY   
            tSource.Parent_HP_ID, tSource.SortOrder, tSource.LastChgDTM;';  
    EXEC sp_executesql @SQL, N'@Version_ID INT, @Hierarchy_ID INT', @Version_ID, @Hierarchy_ID;  
  
    --Compute initial sort order  
    UPDATE #tblHierarchy SET InitSortOrder = SeqNum % Descendants + 1  
  
    --Compute prior parent ID  
    UPDATE tOrig SET PriorParent_ID = tDerived.Parent_ID FROM #tblHierarchy tOrig JOIN #tblHierarchy tDerived ON tOrig.SeqNum-1 = tDerived.SeqNum  
  
    --Compute first child sequence number  
    UPDATE tOrig SET FirstChildSeqNum = tDerived.MinSeqNum   
    FROM #tblHierarchy tOrig   
       JOIN (SELECT Parent_ID, MIN(SeqNum) MinSeqNum FROM #tblHierarchy GROUP BY Parent_ID) tDerived ON tOrig.Parent_ID = tDerived.Parent_ID  
  
    SET @SQL = N'  
        UPDATE tSource SET   
            SortOrder = tDerived.SortOrder   
        FROM mdm.' + quotename(@tblRelationship) + N' AS tSource   
        INNER JOIN (  
                SELECT ID, SeqNum - FirstChildSeqNum + 1 AS SortOrder   
                FROM #tblHierarchy  
            ) AS tDerived  
            ON tSource.ID = tDerived.ID   
        WHERE Version_ID = @Version_ID   
            AND Hierarchy_ID = @Hierarchy_ID   
            AND tSource.SortOrder <> tDerived.SortOrder;';  
              
    EXEC sp_executesql @SQL, N'@Version_ID INT, @Hierarchy_ID INT', @Version_ID, @Hierarchy_ID;  
  
    DROP TABLE #tblHierarchy;  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpHierarchySystemAttributesSave]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
recalculates the level number, sort order, and index code for each member relationship in a hierarchy within a version  
*/  
CREATE PROCEDURE [mdm].[udpHierarchySystemAttributesSave]   
(  
    @Version_ID INT,   
    @Hierarchy_ID INT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON;  
    --Calculate level numbers for the hierarchy  
    EXEC mdm.udpHierarchyMemberLevelSave @Version_ID, @Hierarchy_ID, 0, 2  
  
    --Recalibrate sort orders for the hierarchy   
    EXEC mdm.udpHierarchySortOrderSave @Version_ID, @Hierarchy_ID  
  
    --Recalculate index codes for the hierarchy   
    --EXEC mdm.udpHierarchyIndexCodeSave @Version_ID, @Hierarchy_ID  
  
    SET NOCOUNT OFF;  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpIDParameterCheck]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
EXEC @Parameter = 1, @Table1 = 1461580245, @MinimumValue = NULL, @MaximumValue = NULL, @CheckIsNull = 0  
EXEC @Parameter = 2, @Table1 = 1461580246, @MinimumValue = 1, @MaximumValue = 9999, @CheckIsNull = 1  
EXEC @Parameter = 2, @Table1 = 1461580246, @MinimumValue = NULL, @MaximumValue = 9999, @CheckIsNull = 1  
  
@Table_ID should be match Object_Type Enum in the API namespace Microsoft.Office.MDM.Core.BusinessEntities  
*/  
/*==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
================================================================================  
*/  
CREATE PROCEDURE [mdm].[udpIDParameterCheck]  
(@Parameter INT,  
 @TableID INT = NULL,  
 @MinimumValue  INT = 1,  
 @MaximumValue  INT = NULL,  
 @CheckIsNull BIT = 1,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
	SET NOCOUNT ON;  
  
	DECLARE @IsValid bit;  
	  
	SET @IsValid = 1;  
	  
	-- Check for record in table  
	IF (@TableID IS NOT NULL)  
	BEGIN   
		DECLARE @SQL NVARCHAR(MAX);  
  
		SET @IsValid = 0;  
		SET @SQL = N'SELECT @HasRecords = 1 FROM mdm.' +  
		  
		-- look up Object_ID from Object_Type Enum in the API namespace Microsoft.Office.MDM.Core.BusinessEntities  
		CASE @TableID  
		   WHEN 1 THEN N'tblModel'  
		   WHEN 2 THEN N'tblDerivedHierarchy'  
		   WHEN 4 THEN N'tblModelVersion'  
		   WHEN 5 THEN N'tblEntity'  
		   WHEN 6 THEN N'tblHierarchy'  
		   WHEN 7 THEN N'tblAttribute'  
		   WHEN 8 THEN N'tblAttributeGroup'  
		   WHEN 9 THEN N'tblStgBatch'  
		   WHEN 10 THEN N'tblModelVersionFlag'  
		   WHEN 11 THEN N'tblUser'  
	    END  
  
		  + N' WHERE ID = @Parameter;';  
		    
		EXEC sp_executesql @SQL, N'@Parameter INT, @HasRecords TINYINT OUTPUT', @Parameter, @IsValid OUTPUT;  
	END		  
		-- Check against null value or 0 - since we are validating an ID assume 0 is invalid  
		IF (@CheckIsNull = 1  AND @IsValid <> 0)  
		BEGIN  
			IF (@Parameter IS NULL OR @Parameter < 1)  
				SET @IsValid = 0;  
		END;	  
		  
		IF (@MaximumValue IS NOT NULL AND @IsValid <> 0)  
		BEGIN  
			IF @MaximumValue < 1   
				SET @IsValid =0;  
		END  
		  
		IF (@MinimumValue IS NOT NULL AND @IsValid <> 0)  
		BEGIN  
			IF @MinimumValue < 1   
				SET @IsValid =0;  
		END  
  
		-- Check against maximum value ONLY  
		IF (@MaximumValue IS NOT NULL AND @MinimumValue IS NULL AND @IsValid <> 0)  
		BEGIN  
			IF (@Parameter > @MaximumValue)  
				SET @IsValid = 0;  
		END;  
  
		-- Check against minimum value ONLY  
		IF (@MinimumValue IS NOT NULL AND @MaximumValue IS NULL AND @IsValid <> 0)  
		BEGIN  
			IF (@Parameter < @MinimumValue)  
				SET @IsValid = 0;  
		END;  
  
		-- Check against range  ONLY  
		IF (@MinimumValue IS NOT NULL AND @MaximumValue IS NOT NULL AND @IsValid <> 0)  
		BEGIN  
			IF (@Parameter < @MinimumValue OR @Parameter > @MaximumValue OR @MinimumValue > @MaximumValue)  
				SET @IsValid = 0;  
		END;  
	  
	RETURN @IsValid;  
  
	SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpIndexAttributeListCheck]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpIndexAttributeListCheck]  
(  
    @Attribute_MUID		    UNIQUEIDENTIFIER,  
    @IsUnique               BIT,  
    @Return_ID              INT = NULL OUTPUT,  
    @CorrelationID          UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON  
  
  
    DECLARE	@AttributeID   INT,  
            @AttributeTypeID TINYINT;  
  
    --Default the Value  
    SELECT @Return_ID = 0;  
  
    SELECT @AttributeID = ID, @AttributeTypeID = AttributeType_ID FROM mdm.tblAttribute WHERE MUID = @Attribute_MUID  
  
    IF (@IsUnique = 0 ) BEGIN  
        IF @AttributeTypeID = 2 BEGIN --domain-based attribute  
            SET @Return_ID = 1;  
        END ELSE IF ((SELECT IsName FROM mdm.tblAttribute where ID = @AttributeID) = 1 ) BEGIN --There already exists a non-unique index on Name  
            SET @Return_ID = 2;  
        END  
    END ELSE BEGIN --There is a unique index on Code  
        IF ((SELECT IsCode FROM mdm.tblAttribute where ID = @AttributeID) = 1) BEGIN  
            SET @Return_ID = 3;  
        END  
    END  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpIndexDelete]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    EXEC mdm.udpIndexDelete null,1;  
    SELECT * FROM mdm.tblIndex;  
*/  
CREATE PROCEDURE [mdm].[udpIndexDelete]  
(  
    @ID		    INT = NULL,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON;  
  
    --Start transaction, being careful to check if we are nested  
    DECLARE @TranCounter INT;   
    DECLARE	@Object_ID	INT;  
    DECLARE @IndexMUID UNIQUEIDENTIFIER;  
    DECLARE @TempModel_ID        INT,  
        @TempEntity_ID        INT;  
  
      
      
    IF @ID IS NULL RETURN;  
    --Get Entity  
    SELECT   
        @TempEntity_ID = Entity_ID,  
        @IndexMUID = MUID   
        FROM mdm.tblIndex WHERE ID = @ID;  
    IF @IndexMUID IS NULL RETURN;  
      
  
    --Get Model  
    SELECT   
        @TempModel_ID = e.Model_ID  
    FROM mdm.tblModelVersion AS mv  
    INNER JOIN mdm.tblEntity AS e ON (mv.Model_ID = e.Model_ID)  
    WHERE e.ID = @TempEntity_ID  
    GROUP BY e.Model_ID;  
      
      
  
    SET @TranCounter = @@TRANCOUNT;  
    IF @TranCounter > 0 SAVE TRANSACTION TX;  
    ELSE BEGIN TRANSACTION;  
  
    BEGIN TRY  
  
        DECLARE @SQL                    NVARCHAR(MAX);  
        DECLARE @TableName              sysname;  
        SET @TableName = CONCAT(N'tbl_', @TempModel_ID, N'_', @TempEntity_ID, N'_', N'EN');  
        DECLARE @SystemIndexName sysname;  
        DECLARE @EntityObjectID INT = OBJECT_ID(N'[mdm].' + QUOTENAME(@TableName));  
        SELECT @SystemIndexName = name from sys.indexes WHERE object_id = @EntityObjectID AND index_id = (SELECT SysIndex_ID from mdm.tblIndex where ID = @ID);  
  
          
        IF @SystemIndexName IS NOT NULL BEGIN  
            SET @SQL =  CONCAT(N'DROP INDEX', QUOTENAME(@SystemIndexName), N'ON mdm.', quotename(@TableName));  
            EXEC sp_executesql @SQL;  
        END  
  
        DELETE FROM mdm.tblIndex WHERE ID = @ID;  
  
        --Commit only if we are not nested  
        IF @TranCounter = 0 COMMIT TRANSACTION;  
        RETURN(0);  
  
    END TRY  
    --Compensate as necessary  
    BEGIN CATCH  
  
        -- Get error info.  
        DECLARE  
            @ErrorMessage NVARCHAR(4000),  
            @ErrorSeverity INT,  
            @ErrorState INT,  
            @ErrorNumber INT,  
            @ErrorLine INT,  
            @ErrorProcedure NVARCHAR(126);  
        EXEC mdm.udpGetErrorInfo  
            @ErrorMessage = @ErrorMessage OUTPUT,  
            @ErrorSeverity = @ErrorSeverity OUTPUT,  
            @ErrorState = @ErrorState OUTPUT,  
            @ErrorNumber = @ErrorNumber OUTPUT,  
            @ErrorLine = @ErrorLine OUTPUT,  
            @ErrorProcedure = @ErrorProcedure OUTPUT  
  
        SET @ErrorMessage = CONCAT(@ErrorMessage, N', @ErrorNumber = ', @ErrorNumber, N', @ErrorProcedure = "', @ErrorProcedure, N'", line ', @ErrorLine);  
  
        IF @TranCounter = 0 ROLLBACK TRANSACTION;  
        ELSE IF XACT_STATE() <> -1 ROLLBACK TRANSACTION TX;  
  
        RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);		  
  
        --On error, return NULL results  
        --SELECT @Return_ID = NULL;  
        RETURN(1);  
  
    END CATCH;  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpIndexGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpIndexGet]  
(  
     @User_ID       INT  
  
    ,@Model_MUID    UNIQUEIDENTIFIER = NULL  
    ,@Model_Name    NVARCHAR(50) = NULL  
    ,@Model_ID      INT = NULL -- set internally only  
  
    ,@Entity_MUID   UNIQUEIDENTIFIER = NULL  
    ,@Entity_Name   NVARCHAR(50) = NULL  
    ,@Entity_ID     INT = NULL -- set internally only  
  
    ,@Index_MUID   UNIQUEIDENTIFIER = NULL  
    ,@Index_Name   NVARCHAR(50) = NULL  
  
    ,@ResultOption TINYINT -- None = 0, Identifiers = 1, Details = 2.   
  
    ,@IncludeParentIdentifiers  BIT = 1 -- Return results sets for parent Model and Entity identifiers. Set to 0 when getting explicit hierarchies as part of a parent object (because the parent identifiers will already have been looked up).  
    ,@OmitAttributes            BIT = 0 -- When 1, a result set is not returned for attributes. This should be set to 1 when the caller will return Attributes. Ignored when @ResultOption is not Details.  
    ,@Debug                     BIT = 0  
    ,@CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
  
    SET NOCOUNT ON  
  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), ': begin udpIndexGet')  
  
    DECLARE   
         @ResultOption_Identifiers  TINYINT = 1  
        ,@ResultOption_Details      TINYINT = 2  
  
    -- Get model ID  
    IF @Model_ID IS NULL -- If the ID was already provided, don't bother looking it up again  
        AND (@Model_Name IS NOT NULL OR @Model_MUID IS NOT NULL)  
    BEGIN  
        SELECT   
             @Model_ID = ID  
            ,@Model_MUID = MUID  
            ,@Model_Name = Name  
        FROM mdm.tblModel  
        WHERE   MUID = ISNULL(@Model_MUID, MUID)  
            AND Name = ISNULL(@Model_Name, Name)  
  
        SET @Model_ID = COALESCE(@Model_ID, 0)  
    END  
  
    -- Get entity ID  
    IF @Entity_ID IS NULL -- If the ID was already provided, don't bother looking it up again  
        AND (@Entity_Name IS NOT NULL OR @Entity_MUID IS NOT NULL)  
    BEGIN  
        SELECT  
             @Model_ID = Model_ID  
            ,@Entity_ID = ID  
            ,@Entity_MUID = MUID  
            ,@Entity_Name = Name  
        FROM mdm.tblEntity  
        WHERE   MUID = ISNULL(@Entity_MUID, MUID)  
            AND Name = ISNULL(@Entity_Name, Name)  
            AND Model_ID = ISNULL(@Model_ID, Model_ID) -- If a model filter is specified, use it  
  
        SET @Entity_ID = COALESCE(@Entity_ID, 0)  
    END  
  
    -- Get index ID  
    DECLARE @Index_ID INT = NULL;  
    IF @Index_Name IS NOT NULL OR @Index_MUID IS NOT NULL  
    BEGIN  
        SELECT @Index_ID = ID  
        FROM mdm.tblIndex  
        WHERE   MUID = ISNULL(@Index_MUID, MUID)  
            AND Name = ISNULL(@Index_Name, Name)  
            AND Entity_ID = ISNULL(@Entity_ID, Entity_ID) -- If an entity filter is specified, use it  
  
        SET @Index_ID = COALESCE(@Index_ID, 0)  
    END  
  
    DECLARE @SelectedIndex TABLE   
    (  
         ID                 INT PRIMARY KEY  
        ,SysIndex_ID        INT  
        ,Entity_ID          INT  
        ,Model_ID           INT  
        ,Privilege_ID       TINYINT  
        ,AccessPermission   TINYINT  
    )  
  
    INSERT INTO @SelectedIndex  
    SELECT  
         i.Index_ID AS ID  
        ,i.SysIndex_ID  
        ,i.Entity_ID  
        ,i.Model_ID  
        ,acl.Privilege_ID  
        ,acl.AccessPermission  
    FROM mdm.viw_SYSTEM_SCHEMA_INDEXES i  
    INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_INDEX acl  
    ON acl.ID = i.Index_ID   
    WHERE acl.User_ID = @User_ID  
        AND i.Model_ID = ISNULL(@Model_ID, i.Model_ID)  
        AND i.Entity_ID = ISNULL(@Entity_ID, i.Entity_ID)  
        AND i.Index_ID = ISNULL(@Index_ID, i.Index_ID)  
  
  
  
    IF @IncludeParentIdentifiers = 1  
    BEGIN  
        -- Return model Identifier(s)  
        IF @Model_ID IS NOT NULL  
        BEGIN  
            IF @Model_Name IS NULL OR @Model_MUID IS NULL  
            BEGIN  
                SELECT   
                     @Model_MUID = MUID  
                    ,@Model_Name = Name  
                FROM mdm.tblModel  
                WHERE ID = @Model_ID  
            END  
  
            -- A single model was specified, and its info has already been looked up, so simply return it  
            SELECT   
                 @Model_MUID    AS Model_MUID  
                ,@Model_Name    AS Model_Name  
                ,@Model_ID      AS Model_ID  
        END ELSE  
        BEGIN  
            SELECT DISTINCT  
                 m.MUID AS Model_MUID  
                ,m.Name AS Model_Name  
                ,m.ID   AS Model_ID  
            FROM @SelectedIndex i  
            INNER JOIN mdm.tblEntity e  
            ON i.Entity_ID = e.ID  
            INNER JOIN mdm.tblModel m  
            ON e.Model_ID = m.ID  
        END  
  
        -- Return entity Identifier(s)  
        IF @Entity_ID IS NOT NULL  
        BEGIN  
            -- A single entity was specified, and its info has already been looked up, so simply return it  
            SELECT   
                 @Model_ID      AS Model_ID  
                ,@Entity_MUID   AS Entity_MUID  
                ,@Entity_Name   AS Entity_Name  
                ,@Entity_ID     AS Entity_ID  
        END ELSE  
        BEGIN  
            SELECT DISTINCT  
                 e.Model_ID AS Model_ID  
                ,e.MUID AS Entity_MUID  
                ,e.Name AS Entity_Name  
                ,e.ID   AS Entity_ID  
            FROM @SelectedIndex i  
            INNER JOIN mdm.tblEntity e  
            ON i.Entity_ID = e.ID  
        END  
    END  
  
  
    SELECT  
         i.Index_MUID  
        ,i.Index_Name  
        ,i.Index_ID  
        ,si.Privilege_ID  
        ,si.AccessPermission  
  
        ,si.Entity_ID  
        ,i.Index_IsUnique AS IsUnique  
  
        ,i.EnteredUser_DTM  
        ,i.EnteredUser_MUID  
        ,i.EnteredUser_UserName  
        ,i.EnteredUser_ID  
        ,i.LastChgUser_DTM  
        ,i.LastChgUser_MUID  
        ,i.LastChgUser_UserName  
        ,i.LastChgUser_ID  
    FROM @SelectedIndex si  
    INNER JOIN mdm.viw_SYSTEM_SCHEMA_INDEXES i  
    ON si.ID = i.Index_ID  
    ORDER BY si.Model_ID, si.Entity_ID, i.SysIndex_ID  
  
    IF @ResultOption = @ResultOption_Details  
    BEGIN  
        -- return index-to-attribute mapping  
        DECLARE @IndexToAttribute TABLE  
        (   
             Index_ID       INT NOT NULL  
            ,Attribute_ID   INT NOT NULL  
        );  
  
        INSERT INTO @IndexToAttribute  
        SELECT  
             si.ID  AS Index_ID  
            ,a.ID   AS Attribute_ID  
        FROM @SelectedIndex si  
        INNER JOIN mdm.tblEntity e  
        ON si.Entity_ID = e.ID  
        INNER JOIN sys.indexes i  
        ON      OBJECT_ID(N'[mdm].' + QUOTENAME(e.EntityTable)) = i.object_id  
            AND si.SysIndex_ID = i.index_id  
        INNER JOIN sys.index_columns ic   
        ON      i.object_id = ic.object_id  
            AND i.index_id = ic.index_id  
        INNER JOIN mdm.tblAttribute a  
        ON      e.ID = a.Entity_ID -- Use index ux_tblAttribute_Entity_ID_MemberType_ID_Name  
            AND a.MemberType_ID = 1/*Leaf*/  
            AND COL_NAME(ic.object_id, ic.column_id) = a.TableColumn  
        WHERE   i.type = 2/*NONCLUSTERED*/  
            AND a.AttributeType_ID <> 3/*System*/  
  
        -- Note: this many include attributes to which the user does not have permission, because we don't want to repeat  
        -- the expensive attribute permission check here. Caller must ignore any rows that don't have a match in the   
        -- permission-checked Attributes result set  
        SELECT  
             Index_ID  
            ,Attribute_ID  
        FROM @IndexToAttribute  
        ORDER BY Index_ID  
  
  
        -- Return attributes (unless omitted)  
        IF COALESCE(@OmitAttributes, 1) = 0  
        BEGIN  
            DECLARE @AttributeIds mdm.IdList;  
            INSERT INTO @AttributeIds (ID)  
            SELECT DISTINCT Attribute_ID  
            FROM @IndexToAttribute  
  
            EXEC mdm.udpAttributeGet  
                 @User_ID = @User_ID  
                ,@Model_ID = @Model_ID  
                ,@Entity_ID = @Entity_ID  
                ,@MemberType_ID = 1/*Leaf*/  
                ,@IncludeParentIdentifiers = 0 -- parent Ids already returned  
                ,@Debug = @Debug  
                ,@AttributeIds = @AttributeIds  
                ,@CorrelationID = @CorrelationID  
        END  
  
    END   
  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), ': end udpIndexGet')  
  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpIndexIDResolve]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
/*  
Resolves Index MUID and Name to ID.   
If ID is already provided, it is returned with no validation.  
If ID is NULL and MUID/Name match an ID, the ID is returned.  
If no matching ID is found for the given (MUID,Name) pair, ID is set to -1  
*/  
CREATE PROCEDURE [mdm].[udpIndexIDResolve]  
    @EntityID       INT,  
    @Index_MUID     UNIQUEIDENTIFIER = NULL,  
    @Index_Name     NVARCHAR(50) = NULL,  
    @Index_ID       INT OUTPUT,  
    @CorrelationID  UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
AS BEGIN  
    DECLARE @Invalid_ID INT = -1  
  
    IF @Index_ID IS NULL  
    BEGIN  
        IF @Index_MUID IS NOT NULL OR @Index_Name IS NOT NULL  
        BEGIN  
            SELECT @Index_ID = ID FROM mdm.tblIndex WHERE (MUID = ISNULL(@Index_MUID, MUID)) AND (Name = ISNULL(@Index_Name, Name))   
                AND (Entity_ID = ISNULL(@EntityID, Entity_ID))  
      
            IF @Index_ID IS NULL  
            BEGIN  
                SELECT @Index_ID = @Invalid_ID  
            END  
        END  
    END  
             
END
GO
/****** Object:  StoredProcedure [mdm].[udpIndexSave]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*        
==============================================================================        
 Copyright (c) Microsoft Corporation. All Rights Reserved.        
==============================================================================        
        
    --Create Index        
    DECLARE @Return_ID INT, @Return_MUID UNIQUEIDENTIFIER;        
    --SET @Return_MUID = NEWID(); SELECT @Return_MUID; --Uncomment to test clone operation        
    EXEC mdm.udpIndexSave        
    @User_ID = 1,        
    @ModelName = N'Product',        
    @EntityName = N'Product',        
    @Name = 'Group 2',        
    @EditMode = 0, --Create        
    @Return_ID = @Return_ID OUTPUT,        
    @Return_MUID = @Return_MUID OUTPUT;        
    SELECT @Return_ID, @Return_MUID;        
    SELECT * FROM mdm.tblIndex WHERE ID = @Return_ID;        
        
    --Update Index        
    DECLARE @Return_ID INT, @Return_MUID UNIQUEIDENTIFIER;        
    EXEC mdm.udpIndexSave        
    @User_ID = 1,        
    @ModelName = N'Product',        
    @EntityName = N'Product',       
    @Name = 'Group 2',        
    @EditMode = 1, --Update       
    @Return_ID = @Return_ID OUTPUT,        
    @Return_MUID = @Return_MUID OUTPUT;        
    SELECT @Return_ID, @Return_MUID;        
    SELECT * FROM mdm.tblIndex WHERE ID = @Return_ID;        
*/        
CREATE PROCEDURE [mdm].[udpIndexSave]  
(        
    @User_ID            INT,        
    @Model_ID           INT, -- caller should validate  
    @Entity_ID          INT, -- caller should validate  
    @DataCompression    TINYINT, -- caller should validate  
    @MUID               UNIQUEIDENTIFIER = NULL,        
    @Name               NVARCHAR(50),       
    @IsUnique           BIT = 0,      
    @IndexDetails       mdm.CustomIndexDetail READONLY,        
    @EditMode           TINYINT = 0, --0: Create, 1: Update, 4: Clone, defaults to Create    
    @IsSync             BIT = 0,  
    @Return_ID          INT = NULL OUTPUT,        
    @Return_MUID        UNIQUEIDENTIFIER = NULL OUTPUT,        
    @CorrelationID      UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability        
)        
/*WITH*/        
AS BEGIN        
    SET NOCOUNT ON;        
        
    SET @Return_ID = NULL;        
    SET @Return_MUID = NULL;        
        
        
    DECLARE   
            @CurrentDTM         AS DATETIME2(3),        
            @GuidEmpty          UNIQUEIDENTIFIER = CAST(0x0 AS UNIQUEIDENTIFIER),        
            @EditMode_Create    TINYINT = 0,        
            @EditMode_Update    TINYINT = 1,        
            @EditMode_Clone     TINYINT = 4,        
            @ExistingIndex_MUID UNIQUEIDENTIFIER = NULL,        
            @ExistingIndex_ID   INT = NULL,        
            @ExistingIndexName  NVARCHAR(MAX),        
            @TableOptions       NVARCHAR(MAX) = N'',        
            @IndexOptions       NVARCHAR(MAX) = N'',      
            @TableName          SYSNAME,  
            @SystemIndexName    SYSNAME,        
            @SQL                NVARCHAR(MAX);         
        
    --Initialize output parameters and local variables        
    SELECT        
        @Name = NULLIF(LTRIM(RTRIM(@Name)), N''), --Convert empty @Name to NULL        
        @IsUnique = ISNULL(@IsUnique, 0), --Convert NULL @IsUnique to 0        
        @Return_ID = NULL,        
        @CurrentDTM = GETUTCDATE(),        
        @MUID = NULLIF(@MUID, @GuidEmpty);       
        
    BEGIN TRY        
   
        --Raise an error if we are missing the entity ID        
        IF @Entity_ID IS NULL        
        BEGIN        
            RAISERROR('MDSERR200303|The index cannot be saved. The entity ID is not valid.', 16, 1);        
            RETURN;        
        END;        
  
        --If we are in the Update or Clone mode get the missing pieces of the identifier        
        IF @EditMode IN (@EditMode_Update, @EditMode_Clone)        
        BEGIN        
            --Only use the name if MUID is not available. This is important because we don't want        
            --to look up by name if the name is what the user is trying to update.        
            IF @MUID IS NULL        
            BEGIN        
                SELECT TOP 1  
                    @ExistingIndex_ID =  ID,  
                    @ExistingIndex_MUID = MUID,  
                    @ExistingIndexName = Name  
                FROM mdm.tblIndex  
                WHERE        
                    [Name] = @Name AND  
                    Entity_ID = @Entity_ID;  
            END        
            --Use the Index ID and MUID to look up the full identifier  
            ELSE  
            BEGIN  
                SELECT  
                    @ExistingIndex_ID =  ID,  
                    @ExistingIndex_MUID = MUID,  
                    @ExistingIndexName = Name  
                FROM mdm.tblIndex  
                WHERE  
                    MUID = @MUID AND  
                    Entity_ID = @Entity_ID;  
            END  
        
            --If we are in the Clone mode we need to figure out whether we are creating or updating an index       
            IF @EditMode = @EditMode_Clone        
            BEGIN        
                --If there is no existing index then set the edit mode to Create        
                IF @ExistingIndex_MUID IS NULL AND @ExistingIndex_ID IS NULL        
                BEGIN        
                    SET @EditMode = @EditMode_Create;        
                END        
                --If there is an existing index then set the edit mode to Update        
                ELSE        
                BEGIN        
                    SET @EditMode = @EditMode_Update;        
                    SET @MUID = @ExistingIndex_MUID;        
                END        
            END        
            --If we are in Update mode and could not find a matching existing index we need to raise an error and quit now        
            ELSE IF @EditMode = @EditMode_Update        
            BEGIN        
                IF @ExistingIndex_ID IS NULL OR @ExistingIndex_MUID IS NULL        
                BEGIN        
                    --On error, return NULL results        
                    SELECT @Return_ID = NULL, @Return_MUID = NULL;        
                    RAISERROR('MDSERR110007|The ID is not valid.', 16, 1);        
                    RETURN;        
                END        
                ELSE        
                BEGIN        
                    SET @MUID = @ExistingIndex_MUID;        
                END        
            END        
        END        
        
        --If the edit mode is Create. This code also needs to execute if the user sent in EditMode clone which ended up becoming Create (hence the IF instead of ELSE IF)      
        IF (@EditMode = @EditMode_Create)  
        BEGIN        
            --Set ID to null. We don't care what came in.        
            --SET @ID = NULL;        
        
            --If @MUID is not null then we need to ensure it does not already exist (since this is a create)        
            IF @MUID IS NOT NULL AND EXISTS(SELECT 1 FROM mdm.tblIndex WHERE MUID = @MUID)        
            BEGIN        
                --On error, return NULL results        
                SELECT @Return_ID = NULL, @Return_MUID = NULL;        
                RAISERROR('MDSERR110007|The ID is not valid.', 16, 1);        
                RETURN;        
            END        
        END        
        
        --Test for invalid parameters        
        IF (@Entity_ID IS NULL OR @User_ID IS NULL)        
        BEGIN        
            RAISERROR('MDSERR100010|The Parameters are not valid.', 16, 1);        
            RETURN;        
        END; --if        
        
        --Check the name of the index for duplicates        
        IF EXISTS        
        (        
            SELECT 1   
            FROM mdm.tblIndex  
            WHERE  
                @Name = Name AND  
                (@MUID IS NULL OR MUID <> @MUID) AND  
                Entity_ID = @Entity_ID  
        )        
        BEGIN        
            --On error, return NULL resultsudpSecurityPrivilegesSave        
            SELECT @Return_ID = NULL, @Return_MUID = NULL;        
            RAISERROR('MDSERR110003|The name already exists. Type a different name.', 16, 1);        
            RETURN;        
        END      
      
          
        --Update/Insert Index details        
        IF @EditMode = @EditMode_Update        
        --Update Index    
        BEGIN      
            --we need to get attributes of an index and check to see if the list has been changed or not      
            DECLARE @entityTable SYSNAME;      
            SELECT @entityTable = EntityTable FROM mdm.tblEntity WHERE ID = @Entity_ID;  
            DECLARE @sysIndex INT;      
            SELECT @sysIndex = SysIndex_ID FROM mdm.tblIndex WHERE ID = @ExistingIndex_ID;      
            DECLARE @entityObject_ID INT = OBJECT_ID(N'[mdm].' + QUOTENAME(@entityTable));      
      
            DECLARE @column_ids TABLE      
            (       
                id INT not null      
            )      
            DECLARE @AttributeIDs TABLE      
            (      
                MUID UNIQUEIDENTIFIER not null      
            )      
      
            INSERT INTO @column_ids       
            SELECT DISTINCT ic.column_id       
            FROM sys.indexes AS i       
            INNER JOIN sys.index_columns AS ic       
            ON i.object_id = ic.object_id AND i.index_id = ic.index_id       
            WHERE i.type= 2 and i.object_id = @entityObject_ID AND i.index_id = @sysIndex       
              
            WHILE EXISTS(SELECT 1 FROM @column_ids)   
            BEGIN      
                DECLARE @TempID INT;      
                SELECT TOP 1           
                    @TempID = id         
                FROM @column_ids         
                ORDER BY id ASC;      
      
                DECLARE @TempName sysname = COL_NAME(@entityObject_ID,@TempID);      
      
                INSERT INTO @AttributeIDs      
                SELECT MUID FROM mdm.tblAttribute att WHERE att.TableColumn = @TempName AND (att.IsSystem = 0 OR att.IsCode = 1 OR att.IsName = 1);      
      
                DELETE FROM @column_ids WHERE id = @TempID;      
           
            END --while      
      
            IF EXISTS (SELECT MUID FROM (SELECT DISTINCT(details.MUID) FROM @IndexDetails details UNION ALL SELECT DISTINCT(atr.MUID) from @AttributeIDs atr) data GROUP BY MUID HAVING count(*)!=2)   
                OR (@IsUnique <> (SELECT IsUnique FROM mdm.tblIndex where ID = @ExistingIndex_ID))      
            BEGIN -- the old index should be dropped and new one should be created      
    
                SELECT @SystemIndexName = name from sys.indexes WHERE object_id = @entityObject_ID AND index_id = @sysIndex;  
  
                IF @SystemIndexName IS NOT NULL   
                BEGIN      
                    SET @SQL =  CONCAT(N'DROP INDEX', QUOTENAME(@SystemIndexName),  N'ON mdm.', quotename(@entityTable));      
                    EXEC sp_executesql @SQL;      
                END      
                  
                SET @EditMode = @EditMode_Create  
            END ELSE   
            BEGIN  
                UPDATE mdm.tblIndex   
                SET        
                    [Name] = ISNULL(@Name, [Name]),      
                    [IsUnique] = ISNULL(@IsUnique, [IsUnique]),      
                    LastChgDTM = @CurrentDTM,        
                    LastChgUserID = @User_ID        
                WHERE        
                    ID = @ExistingIndex_ID;  
  
                SET @Return_MUID = @ExistingIndex_MUID  
            END        
        END         
          
        IF @EditMode <> @EditMode_Update          
        --New Index        
        BEGIN        
            --Accept an explicit MUID (for clone operations) or generate a new one        
            SET @Return_MUID = ISNULL(@MUID, NEWID());        
                  
            IF ((SELECT COUNT(*) FROM @IndexDetails) = 0)   
            BEGIN  
                RAISERROR('MDSERR200304| To create or update an index at least one attribute must be selected.', 16, 1);  
                RETURN;      
            END  
  
            DECLARE   
                    @StatusCheck            NVARCHAR(MAX) = N'Where [Status_ID] = 1 ',  
                    @Condition              NVARCHAR(MAX) =N'AND ',  
                    @VersionColumnName      sysname,  
                    @Status_IDColumName     sysname,  
                    @TableColumn            sysname,      
                    @IndexColumns           NVARCHAR(MAX),      
                    @IndexColumnsWithQuote  NVARCHAR(MAX),      
                    @Attribute_ID           INT,  
                    @AttributeName          NVARCHAR(100);  
                  
            SET @TableName = CONCAT(N'tbl_', @Model_ID, N'_', @Entity_ID, N'_', N'EN');      
      
            SET @SystemIndexName = CASE @IsUnique      
                WHEN 1 THEN CONCAT( N'uixud_' , @TableName , N'_Version_ID')      
                ELSE  CONCAT( N'ixud_' , @TableName , N'_Version_ID')      
                END      
              
            SET @IndexOptions = mdm.udfGetIndexOptions(@DataCompression, @Model_ID);  
  
            SET @VersionColumnName = N'Version_ID';  
            SET @Status_IDColumName = N'Status_ID';  
              
  
            DECLARE @TempDetailTable  TABLE  
            (  
                ID      INT,  
                MUID    UNIQUEIDENTIFIER NULL,  
                Name    NVARCHAR(100) NULL  
            );  
            INSERT INTO @TempDetailTable (MUID,Name)   
            SELECT MUID, Name   
            FROM @IndexDetails;  
  
            UPDATE @TempDetailTable   
            SET  
                    ID = atr.ID,  
                    MUID = atr.MUID,  
                    Name = atr.Name   
            FROM @TempDetailTable temp   
            INNER JOIN mdm.tblAttribute atr  
            ON      atr.Entity_ID = @Entity_ID   
                AND atr.MemberType_ID = 1 --only looking for leaf attributes   
            WHERE   (temp.MUID IS NOT NULL OR temp.Name IS NOT NULL)  
                AND (temp.MUID IS NULL OR temp.MUID = atr.MUID)  
                AND (temp.Name IS NULL OR temp.Name = atr.Name);  
              
            IF(EXISTS(SELECT 1 FROM @TempDetailTable temp JOIN mdm.tblAttribute atr ON temp.ID = atr.ID AND atr.AttributeType_ID = 4))  
            BEGIN  
                RAISERROR('MDSERR200305| The index cannot be created on file attributes.', 16, 1);  
                RETURN;   
            END  
            --check for already existing non-clustered index on dba attributes and Name attribute.  
            IF ((SELECT COUNT(*) FROM @TempDetailTable) = 1)   
            BEGIN  
                DECLARE @Attribute_MUID UNIQUEIDENTIFIER;  
                SELECT TOP 1 @Attribute_MUID = MUID FROM @TempDetailTable;  
                DECLARE @ReturnError AS INT;  
                EXEC mdm.udpIndexAttributeListCheck @Attribute_MUID, @IsUnique, @ReturnError OUTPUT;  
                IF @ReturnError != 0    
                BEGIN  
                    RAISERROR('MDSERR200306| There is already an index created by the system on the selected attribute.', 16, 1);  
                    RETURN;      
                END  
            END  
  
            WHILE EXISTS(SELECT 1 FROM @TempDetailTable )   
            BEGIN      
                SET @TableColumn = N'';      
                SELECT TOP 1      
                    @Attribute_ID = ID,  
                    @AttributeName = Name   
                    FROM @TempDetailTable ORDER BY ID ASC      
                          
                IF (@AttributeName = N'Code' OR @AttributeName = N'Name')   
                BEGIN  
                    SET @TableColumn = @AttributeName  
                END ELSE   
                BEGIN  
                    SET @TableColumn = CONCAT(N'uda_', @Entity_ID, N'_',@Attribute_ID);  
                END  
                SET @Condition = CONCAT(@Condition, @TableColumn, N' IS NOT NULL');  
                SET @SystemIndexName = CONCAT( @SystemIndexName , N'_', @Attribute_ID);  
                SET @IndexColumns = CONCAT(@IndexColumns, QUOTENAME(@TableColumn));  
                SET @IndexColumnsWithQuote = CONCAT(@IndexColumnsWithQuote, N'''',@TableColumn, N'''');  
      
                IF ((SELECT COUNT(*) from @TempDetailTable) > 1)   
                BEGIN      
                    SET @Condition = CONCAT (@Condition, N' AND ');      
                    SET @IndexColumns = CONCAT (@IndexColumns, N' , ');      
                    SET @IndexColumnsWithQuote = CONCAT (@IndexColumnsWithQuote, N' , ');      
                END       
      
                DELETE FROM @TempDetailTable WHERE ID = @Attribute_ID;  
            END      
      
            --check if the maximum index keys size exceeds 900 bytes.       
                  
                  
            DECLARE @TotalIndexKeySize INT;      
            DECLARE @TableNameWithQuote sysname;       
            SET @TableNameWithQuote = CONCAT(N'''mdm.',@TableName,N'''');  
            SET @SQL = CONCAT(N'      
            SELECT @TotalIndexKeySize = SUM(max_length)       
                    FROM sys.columns      
            WHERE name IN (',@IndexColumnsWithQuote,N')       
                    AND object_id = OBJECT_ID(',@TableNameWithQuote,N');');  
      
            EXEC sp_executesql @SQL, N'@TotalIndexKeySize INT OUTPUT ', @TotalIndexKeySize OUTPUT;      
      
            IF (@TotalIndexKeySize > 900)      
            BEGIN        
                --On error, return NULL resultsudpSecurityPrivilegesSave        
                SELECT @Return_ID = NULL, @Return_MUID = NULL;        
                RAISERROR('MDSERR200307| The index cannot be saved because the total size of the selected attributes exceeds the maximum index key size of 900 bytes.', 16, 1);  
                RETURN;        
            END      
      
            IF @IsUnique=1      
            BEGIN --CREATE UNIQUE Index      
                SET @SQL = CONCAT( N'      
                        -- CREATE NONCLUSTERED INDEX ON SELECTED ATTRIBUTES      
                        CREATE UNIQUE NONCLUSTERED INDEX ' , quotename(@SystemIndexName) , N'      
                            ON mdm.' , quotename(@TableName) , N'(' , quotename(@VersionColumnName), N',', quotename(@Status_IDColumName), N',', @IndexColumns , N')      
                            INCLUDE(ID)      
                            ' , @StatusCheck, @Condition , N' ', @IndexOptions, N';');      
            END ELSE   
            BEGIN      
                SET @SQL = CONCAT( N'      
                        -- CREATE NONCLUSTERED INDEX ON SELECTED ATTRIBUTES      
                        CREATE NONCLUSTERED INDEX ' , quotename(@SystemIndexName) , N'      
                            ON mdm.' , quotename(@TableName) , N'(' , quotename(@VersionColumnName), N',', quotename(@Status_IDColumName), N',', @IndexColumns , N')      
                            INCLUDE(ID)      
                            ' , N' ', @IndexOptions, N';');      
            END      
                      
      
            EXEC sp_executesql @SQL;       
            --finding the system index      
                  
            DECLARE @SysIdx int;      
            SELECT @SysIdx = index_id from sys.indexes where name = @SystemIndexName;      
      
            IF (@ExistingIndex_ID IS NULL)   
            BEGIN    
                INSERT INTO mdm.tblIndex        
                (        
                     [Entity_ID]      
                    ,[SysIndex_ID]       
                    ,[Name]         
                    ,[IsUnique]        
                    ,[MUID]        
                    ,[EnterDTM]        
                    ,[EnterUserID]        
                    ,[LastChgDTM]        
                    ,[LastChgUserID]        
                )        
                VALUES  
                (        
                    @Entity_ID,      
                    @SysIdx,         
                    @Name,        
                    @IsUnique,        
                    @Return_MUID,        
                    @CurrentDTM,        
                    @User_ID,        
                    @CurrentDTM,        
                    @User_ID  
                )     
                      
                --Save the identity value        
                SET @Return_ID = SCOPE_IDENTITY();        
            END ELSE    
            BEGIN    
                    UPDATE mdm.tblIndex SET      
                    [SysIndex_ID] = ISNULL(@SysIdx, [SysIndex_ID]),    
                    [Name] = ISNULL(@Name, [Name]),      
                    [IsUnique] = ISNULL(@IsUnique, [IsUnique]),      
                    LastChgDTM = @CurrentDTM,        
                    LastChgUserID = @User_ID        
                WHERE        
                    ID = @ExistingIndex_ID;    
            END    
  
        
        END; --if  for new index      
        
        RETURN(0);        
        
    END TRY        
    --Compensate as necessary        
    BEGIN CATCH        
        
        -- Get error info.        
        DECLARE        
            @ErrorMessage NVARCHAR(4000),        
            @ErrorSeverity INT,        
            @ErrorState INT,        
            @ErrorNumber INT,        
            @ErrorLine INT,        
            @ErrorProcedure NVARCHAR(126);        
        EXEC mdm.udpGetErrorInfo        
            @ErrorMessage = @ErrorMessage OUTPUT,        
            @ErrorSeverity = @ErrorSeverity OUTPUT,        
            @ErrorState = @ErrorState OUTPUT,        
            @ErrorNumber = @ErrorNumber OUTPUT,        
            @ErrorLine = @ErrorLine OUTPUT,        
            @ErrorProcedure = @ErrorProcedure OUTPUT        
        
        SET @ErrorMessage = CONCAT(@ErrorMessage, N', @ErrorNumber = ', @ErrorNumber, N', @ErrorProcedure = "', @ErrorProcedure, N'", line ', @ErrorLine);        
        
        IF (@ErrorMessage LIKE N'SYSERR1505|%') BEGIN    
            RAISERROR('MDSERR200308|The unique index cannot be saved because duplicate value(s) were found for the selected list of attributes.', 16, 1);  
        END   
        ELSE IF (@ErrorMessage LIKE N'SYSERR1913|%') BEGIN   
            RAISERROR('MDSERR200309|The index cannot be saved because an index with the same list of attributes and the same unique flag already exists.', 16, 1);  
        END ELSE  
        BEGIN    
            RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);    
        END       
        
        --On error, return NULL results    
        SELECT @Return_ID = NULL, @Return_MUID = NULL;    
        RETURN;        
        
    END CATCH;        
        
    SET NOCOUNT OFF;        
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpInformationLookupAttribute]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    DECLARE @ID INT;  
    DECLARE @Name NVARCHAR(MAX);  
    DECLARE @MUID UniqueIdentifier;  
    DECLARE @Privilege_ID INT;  
    EXEC mdm.udpInformationLookupAttribute 	  
             @User_ID			=	1  
            ,@Attribute_MUID	=	NULL	  
            ,@Attribute_ID		=	NULL  
            ,@Attribute_Name	=	'PostalCode'  
            ,@MemberType_ID		=	1  
            ,@Entity_ID			=	11  
            ,@Entity_MUID		=	NULL  
            ,@ID				=	@ID				OUTPUT  
            ,@Name				=	@Name			OUTPUT  
            ,@MUID				=	@MUID			OUTPUT  
            ,@Privilege_ID		=	@Privilege_ID	OUTPUT  
    SELECT @ID, @Name, @MUID, @Privilege_ID;  
      
*/		  
CREATE PROCEDURE [mdm].[udpInformationLookupAttribute]  
(  
    @User_ID			INT = NULL,  
    @Attribute_MUID		UNIQUEIDENTIFIER = NULL,	--\  
    @Attribute_ID		INT = NULL,					--One of these 3 always required  
    @Attribute_Name		NVARCHAR(MAX) = NULL,		--/  
    @MemberType_ID		TINYINT=NULL,				  
    @Entity_ID			INT = NULL,					--\ One of these always required (except Model)  
    @Entity_MUID		UNIQUEIDENTIFIER = NULL,	--/  
    @ID					INTEGER = NULL OUTPUT,  
    @Name				NVARCHAR(MAX) = NULL OUTPUT,  
    @MUID				UNIQUEIDENTIFIER = NULL OUTPUT,  
    @Privilege_ID		INTEGER = NULL OUTPUT,  
    @AccessPermission   INTEGER = NULL OUTPUT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON;  
    SET @User_ID = ISNULL(@User_ID, 0);  
    SET @Attribute_MUID = NULLIF(@Attribute_MUID, 0x0);  
    SET @Attribute_ID = NULLIF(@Attribute_ID, 0);  
    IF (@MemberType_ID IS NULL AND @Attribute_ID IS NULL AND @Attribute_MUID IS NULL)  
    BEGIN  
        SET @MemberType_ID = 1; --If there is no MemberType, MUID, or int ID provided, default to 1 (Leaf).    
    END  
  
    SELECT TOP 1  
                @ID = att.ID,   
                @Name = att.[Name],   
                @MUID = att.MUID,  
                @Privilege_ID = S.Privilege_ID,  
                @AccessPermission = S.AccessPermission  
    FROM mdm.tblAttribute att     
    INNER JOIN mdm.tblEntity ent ON att.Entity_ID = ent.ID AND AttributeType_ID <> 3 --AND att.MemberType_ID=1    
    LEFT JOIN mdm.viw_SYSTEM_SECURITY_USER_ATTRIBUTE S ON S.ID=att.ID   
    WHERE   
        S.User_ID = @User_ID  
        AND (att.MemberType_ID = @MemberType_ID OR @MemberType_ID IS NULL)  
        AND (att.ID = @Attribute_ID OR @Attribute_ID IS NULL)  
        AND (att.[Name] = @Attribute_Name OR @Attribute_Name IS NULL)  
        AND (att.MUID = @Attribute_MUID OR @Attribute_MUID IS NULL)  
        AND (att.Entity_ID = @Entity_ID OR @Entity_ID IS NULL)  
        AND (ent.MUID = @Entity_MUID OR @Entity_MUID IS NULL)  
    ORDER BY att.ID;  
          
    SET NOCOUNT OFF;  
END
GO
/****** Object:  StoredProcedure [mdm].[udpInformationLookupAttributeGroup]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
    DECLARE @ID INT;  
    DECLARE @Name NVARCHAR(MAX);  
    DECLARE @MUID UniqueIdentifier;  
    DECLARE @Privilege_ID INT;  
    EXEC mdm.udpInformationLookupAttributeGroup 	  
             @User_ID				=	1  
            ,@AttributeGroup_MUID	=	NULL	  
            ,@AttributeGroup_ID		=	NULL  
            ,@AttributeGroup_Name	=	'General Model Information'  
            ,@Entity_ID				=	1  
            ,@Entity_MUID			=	NULL  
            ,@ID					=	@ID				OUTPUT  
            ,@Name					=	@Name			OUTPUT  
            ,@MUID					=	@MUID			OUTPUT  
            ,@Privilege_ID			=	@Privilege_ID	OUTPUT  
    SELECT @ID, @Name, @MUID, @Privilege_ID;  
  
*/  
CREATE PROCEDURE [mdm].[udpInformationLookupAttributeGroup]  
(  
    @User_ID				INT = NULL,  
    @AttributeGroup_MUID	UNIQUEIDENTIFIER = NULL,	--\  
    @AttributeGroup_ID		INT = NULL,					--One of these 3 always required  
    @AttributeGroup_Name	NVARCHAR(MAX) = NULL,		--/  
    @MemberType_ID          TINYINT = NULL,  
    @Entity_ID				INT = NULL,					--\ One of these always required (except Model)  
    @Entity_MUID			UNIQUEIDENTIFIER = NULL,	--/  
    @ID						INTEGER = NULL OUTPUT,  
    @Name					NVARCHAR(MAX) = NULL OUTPUT,  
    @MUID					UNIQUEIDENTIFIER = NULL OUTPUT,  
    @Privilege_ID			INTEGER = NULL OUTPUT,  
    @AccessPermission       TINYINT = NULL OUTPUT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
  
    SET NOCOUNT ON;  
    SET @User_ID = ISNULL(@User_ID, 0);  
      
    SELECT TOP 1  
    @ID= grp.ID   
    , @Name= grp.[Name]  
    , @MUID= grp.MUID  
    , @Privilege_ID= S.Privilege_ID  
    , @AccessPermission= S.AccessPermission  
    FROM mdm.tblAttributeGroup grp     
    INNER JOIN mdm.tblEntity ent ON grp.Entity_ID = ent.ID    
    LEFT JOIN mdm.viw_SYSTEM_SECURITY_USER_ATTRIBUTEGROUP S ON S.ID=grp.ID   
    WHERE   
        S.User_ID = @User_ID  
        AND (grp.ID = @AttributeGroup_ID OR @AttributeGroup_ID IS NULL)  
        AND (grp.[Name] = @AttributeGroup_Name OR @AttributeGroup_Name IS NULL)  
        AND (grp.MUID = @AttributeGroup_MUID OR @AttributeGroup_MUID IS NULL)  
        AND (grp.MemberType_ID = @MemberType_ID OR @MemberType_ID IS NULL)  
        AND (grp.Entity_ID = @Entity_ID OR @Entity_ID IS NULL)  
        AND (ent.MUID = @Entity_MUID OR @Entity_MUID IS NULL)  
    ORDER BY grp.ID;  
      
    SET NOCOUNT OFF;  
      
END
GO
/****** Object:  StoredProcedure [mdm].[udpInformationLookupDerivedHierarchy]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
	DECLARE @ID INT;  
	DECLARE @Name NVARCHAR(MAX);  
	DECLARE @MUID UniqueIdentifier;  
	DECLARE @Privilege_ID INT;  
	EXEC mdm.udpInformationLookupDerivedHierarchy 	  
			 @User_ID				=	1		  
			,@DerivedHierarchy_MUID =	NULL	  
			,@DerivedHierarchy_ID	=	NULL  
			,@DerivedHierarchy_Name =	'AccountType'  
			,@Model_ID				=	2  
			,@Model_MUID			=	NULL  
			,@ID					=	@ID				OUTPUT  
			,@Name					=	@Name			OUTPUT  
			,@MUID					=	@MUID			OUTPUT  
			,@Privilege_ID			=	@Privilege_ID	OUTPUT  
	SELECT @ID, @Name, @MUID, @Privilege_ID;  
	  
*/		  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpInformationLookupDerivedHierarchy]  
(  
	@User_ID				INT = NULL,  
	@DerivedHierarchy_MUID	UNIQUEIDENTIFIER = NULL,	--\  
	@DerivedHierarchy_ID	INT = NULL,					--One of these 3 always required  
	@DerivedHierarchy_Name	NVARCHAR(MAX) = NULL,		--/  
	@Model_ID				INT = NULL,					--\ One of these always required (except Model)  
	@Model_MUID				UNIQUEIDENTIFIER = NULL,	--/  
	@ID						INTEGER = NULL OUTPUT,  
	@Name					NVARCHAR(MAX) = NULL OUTPUT,  
	@MUID					UNIQUEIDENTIFIER = NULL OUTPUT,  
	@Privilege_ID			INTEGER = NULL OUTPUT,  
    @AccessPermission       INT =NULL OUTPUT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
	SET NOCOUNT ON;  
	SET @User_ID = ISNULL(@User_ID, 0);  
  
	SELECT TOP 1  
		@ID= dh.ID   
		, @Name= dh.[Name]  
		, @MUID= dh.MUID  
		, @Privilege_ID= S.Privilege_ID  
        , @AccessPermission = S.AccessPermission  
		FROM mdm.tblDerivedHierarchy dh   
		INNER JOIN mdm.tblModel mdl ON dh.Model_ID = mdl.ID  
		LEFT JOIN mdm.viw_SYSTEM_SECURITY_USER_HIERARCHY_DERIVED S ON S.ID=dh.ID  
		WHERE   
			S.User_ID = @User_ID  
			AND (dh.ID = @DerivedHierarchy_ID OR @DerivedHierarchy_ID IS NULL)  
			AND (dh.[Name] = @DerivedHierarchy_Name OR @DerivedHierarchy_Name IS NULL)  
			AND (dh.MUID = @DerivedHierarchy_MUID OR @DerivedHierarchy_MUID IS NULL)  
			AND (dh.Model_ID = @Model_ID OR @Model_ID IS NULL)  
			AND (mdl.MUID = @Model_MUID OR @Model_MUID IS NULL)  
		ORDER BY dh.ID;  
		  
	SET NOCOUNT OFF;  
END
GO
/****** Object:  StoredProcedure [mdm].[udpInformationLookupEntity]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
    DECLARE @ID INT;  
    DECLARE @Name NVARCHAR(MAX);  
    DECLARE @MUID UniqueIdentifier;  
    DECLARE @Privilege_ID INT;  
    EXEC mdm.udpInformationLookupEntity  
             @User_ID       =    1  
            ,@Entity_MUID   =    NULL  
            ,@Entity_ID     =    NULL  
            ,@Entity_Name   =   'Account'  
            ,@MemberType_ID =    1  
            ,@Model_ID      =    2  
            ,@Model_MUID    =    NULL  
            ,@ID            =    @ID                OUTPUT  
            ,@Name          =    @Name            OUTPUT  
            ,@MUID          =    @MUID            OUTPUT  
            ,@Privilege_ID  =    @Privilege_ID    OUTPUT  
    SELECT @ID, @Name, @MUID, @Privilege_ID;  
  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpInformationLookupEntity]  
(  
    @User_ID            INT = NULL,  
    @Entity_MUID        UNIQUEIDENTIFIER = NULL,    --\  
    @Entity_ID          INT = NULL,                    --One of these 3 always required  
    @Entity_Name        NVARCHAR(MAX) = NULL,       --/  
    @Model_ID           INT = NULL,                 --\ One of these always required (except Model)  
    @Model_MUID         UNIQUEIDENTIFIER = NULL,    --/  
    @ID                 INTEGER = NULL OUTPUT,  
    @Name               NVARCHAR(MAX) = NULL OUTPUT,  
    @MUID               UNIQUEIDENTIFIER = NULL OUTPUT,  
    @IsCollectionEnabled    BIT = NULL OUTPUT,  
    @IsHierarchyEnabled     BIT = NULL OUTPUT,  
    @Privilege_ID       INTEGER = NULL OUTPUT,  
    @AccessPermission   INT = NULL OUTPUT,  
    @CorrelationID      UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON;  
    SET @User_ID = ISNULL(@User_ID, 0);  
  
    SELECT TOP 1  
                @ID = ent.ID,  
                @Name = ent.[Name],  
                @MUID = ent.MUID,  
                @Privilege_ID = S.Privilege_ID,  
                @AccessPermission = S.AccessPermission,  
                @IsCollectionEnabled = CASE WHEN CollectionTable IS NULL THEN 0 ELSE 1 END,  
                @IsHierarchyEnabled = CASE WHEN HierarchyTable  IS NULL THEN 0 ELSE 1 END  
            FROM mdm.tblEntity ent  
            INNER JOIN mdm.tblModel mdl ON ent.Model_ID = mdl.ID  
            LEFT JOIN mdm.viw_SYSTEM_SECURITY_USER_ENTITY S ON S.ID=ent.ID  
            WHERE  
                S.User_ID = @User_ID  
                AND (ent.ID =@Entity_ID OR @Entity_ID IS NULL)  
                AND (ent.[Name] = @Entity_Name OR @Entity_Name IS NULL)  
                AND (ent.MUID = @Entity_MUID OR @Entity_MUID IS NULL)  
                AND (ent.Model_ID = @Model_ID OR @Model_ID IS NULL)  
                AND (mdl.MUID = @Model_MUID OR @Model_MUID IS NULL)  
                AND S.Privilege_ID > 1 --Needed to make sure that all Denied objects are treated as the same as invalid(non existent) objects  
  
    SET NOCOUNT OFF;  
  
END
GO
/****** Object:  StoredProcedure [mdm].[udpInformationLookupExportView]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
    DECLARE @ID INT;  
    DECLARE @Name NVARCHAR(MAX);  
    DECLARE @MUID UniqueIdentifier;  
    DECLARE @Privilege_ID INT;  
    EXEC mdm.udpInformationLookupExportView 	  
             @ExportView_MUID	=	NULL	  
            ,@ExportView_ID		=	1  
            ,@ExportView_Name	=	NULL  
            ,@ID				=	@ID				OUTPUT  
            ,@Name				=	@Name			OUTPUT  
            ,@MUID				=	@MUID			OUTPUT  
            ,@Privilege_ID		=	@Privilege_ID	OUTPUT  
    SELECT @ID, @Name, @MUID, @Privilege_ID;  
      
*/		  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpInformationLookupExportView]  
(  
    @ExportView_MUID		UNIQUEIDENTIFIER = NULL,	--\  
    @ExportView_ID			INT = NULL,					--One of these 3 always required  
    @ExportView_Name		NVARCHAR(MAX) = NULL,		--/  
    @ID						INTEGER = NULL OUTPUT,  
    @Name					sysname = NULL OUTPUT,  
    @MUID					UNIQUEIDENTIFIER = NULL OUTPUT,  
    @Privilege_ID			INTEGER = NULL OUTPUT,  
    @AccessPermission		TINYINT = NULL OUTPUT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON;  
      
    SELECT TOP 1  
        @ID =  ID,   
        @Name = [Name],   
        @MUID = MUID,  
        @Privilege_ID = 4, -- Access  
        @AccessPermission = 7 -- All  
    FROM mdm.tblSubscriptionView    
    WHERE   
        (ID = @ExportView_ID OR @ExportView_ID IS NULL)  
        AND ([Name] = @ExportView_Name OR @ExportView_Name IS NULL)  
        AND (MUID = @ExportView_MUID OR @ExportView_MUID IS NULL)  
    ORDER BY ID;  
          
    SET NOCOUNT OFF;  
END
GO
/****** Object:  StoredProcedure [mdm].[udpInformationLookupHierarchy]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
    DECLARE @ID INT;  
    DECLARE @Name NVARCHAR(MAX);  
    DECLARE @MUID UniqueIdentifier;  
    DECLARE @Privilege_ID INT;  
    EXEC mdm.udpInformationLookupHierarchy 	  
             @User_ID			=	1  
            ,@Hierarchy_MUID	=	NULL	  
            ,@Hierarchy_ID		=	NULL  
            ,@Hierarchy_Name	=	'AccountType'  
            ,@Entity_ID			=	7  
            ,@Entity_MUID		=	NULL  
            ,@ID				=	@ID				OUTPUT  
            ,@Name				=	@Name			OUTPUT  
            ,@MUID				=	@MUID			OUTPUT  
            ,@Privilege_ID		=	@Privilege_ID	OUTPUT  
    SELECT @ID, @Name, @MUID, @Privilege_ID;  
      
*/		  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpInformationLookupHierarchy]  
(  
    @User_ID			INT = NULL,  
    @Hierarchy_MUID		UNIQUEIDENTIFIER = NULL,	--\  
    @Hierarchy_ID		INT = NULL,					--One of these 3 always required  
    @Hierarchy_Name		NVARCHAR(MAX) = NULL,		--/  
    @Entity_ID			INT = NULL,					--\ One of these always required (except Model)  
    @Entity_MUID		UNIQUEIDENTIFIER = NULL,	--/  
    @ID					INTEGER = NULL OUTPUT,  
    @Name				NVARCHAR(MAX) = NULL OUTPUT,  
    @MUID				UNIQUEIDENTIFIER = NULL OUTPUT,  
    @Privilege_ID		INTEGER = NULL OUTPUT,  
    @AccessPermission   INTEGER = NULL OUTPUT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
  
    SET NOCOUNT ON;  
    SET @User_ID = ISNULL(@User_ID, 0);  
    SET @Entity_ID = NULLIF(@Entity_ID, 0);   
    SET @Hierarchy_ID = NULLIF(@Hierarchy_ID, 0);   
      
    SELECT TOP 1  
    @ID= hir.ID   
    , @Name= hir.[Name]  
    , @MUID= hir.MUID  
    , @Privilege_ID= S.Privilege_ID  
    , @AccessPermission= S.AccessPermission  
    FROM mdm.tblHierarchy hir     
    INNER JOIN mdm.tblEntity ent ON hir.Entity_ID = ent.ID    
    LEFT JOIN mdm.viw_SYSTEM_SECURITY_USER_HIERARCHY S ON S.ID=hir.ID   
    WHERE   
        S.User_ID = @User_ID  
        AND (hir.ID = @Hierarchy_ID OR @Hierarchy_ID IS NULL)  
        AND (hir.[Name] = @Hierarchy_Name OR @Hierarchy_Name IS NULL)  
        AND (hir.MUID = @Hierarchy_MUID OR @Hierarchy_MUID IS NULL)  
        AND (hir.Entity_ID = @Entity_ID OR @Entity_ID IS NULL)  
        AND (ent.MUID = @Entity_MUID OR @Entity_MUID IS NULL)  
    ORDER BY hir.ID;  
      
    SET NOCOUNT OFF;  
END
GO
/****** Object:  StoredProcedure [mdm].[udpInformationLookupModel]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
    DECLARE @ID INT;  
    DECLARE @Name NVARCHAR(MAX);  
    DECLARE @MUID UniqueIdentifier;  
    DECLARE @Privilege_ID INT;  
    EXEC mdm.udpInformationLookupModel 	  
             @User_ID =		1		  
            ,@Model_MUID =	NULL	  
            ,@Model_ID =	NULL  
            ,@Model_Name =	'Product'  
            ,@ID =			@ID				OUTPUT  
            ,@Name	=		@Name			OUTPUT  
            ,@MUID	=		@MUID			OUTPUT  
            ,@Privilege_ID = @Privilege_ID	OUTPUT  
    SELECT @ID, @Name, @MUID, @Privilege_ID;  
      
*/		  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
  
CREATE PROCEDURE [mdm].[udpInformationLookupModel]  
(  
    @User_ID				INT = NULL,  
    @Model_MUID				UNIQUEIDENTIFIER = NULL,	--\  
    @Model_ID				INT = NULL,					--One of these 3 always required  
    @Model_Name				NVARCHAR(MAX) = NULL,		--/  
    @ID						INTEGER = NULL OUTPUT,  
    @Name					NVARCHAR(MAX) = NULL OUTPUT,  
    @MUID					UNIQUEIDENTIFIER = NULL OUTPUT,  
    @Privilege_ID			INTEGER = NULL OUTPUT,  
    @AccessPermission       TINYINT = NULL OUTPUT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON;  
    SET @User_ID = ISNULL(@User_ID, 0);  
      
    SELECT TOP 1  
        @ID =  M.ID,   
        @Name = M.[Name],   
        @MUID = M.MUID,  
        @Privilege_ID=CASE S.Privilege_ID WHEN 99 THEN 4 /*Access*/ ELSE S.Privilege_ID END,  
        @AccessPermission=CASE S.Privilege_ID WHEN 99 THEN 0 /*ReadOnly*/ ELSE S.AccessPermission END  
    FROM mdm.tblModel M  
    LEFT JOIN mdm.viw_SYSTEM_SECURITY_USER_MODEL S ON S.ID=M.ID  
    WHERE   
            (@Model_Name IS NOT NULL OR @Model_MUID IS NOT NULL OR @Model_ID IS NOT NULL)  
        AND (M.ID = @Model_ID OR @Model_ID IS NULL)  
        AND (M.[Name] = @Model_Name OR @Model_Name IS NULL)  
        AND (M.MUID = @Model_MUID OR @Model_MUID IS NULL)  
        AND S.User_ID = @User_ID  
        AND S.Privilege_ID > 1 --Needed to make sure that all Denied objects are treated as the same as invalid(non existent) objects  
    ORDER BY M.ID;  
      
    SET NOCOUNT OFF;  
END
GO
/****** Object:  StoredProcedure [mdm].[udpInformationLookupStagingBatch]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
    DECLARE @ID INT;  
    DECLARE @Name NVARCHAR(MAX);  
    DECLARE @MUID UniqueIdentifier;  
    DECLARE @Privilege_ID INT;  
    EXEC mdm.udpInformationLookupStagingBatch 	  
             @StagingBatch_MUID	=	NULL	  
            ,@StagingBatch_ID	=	1  
            ,@StagingBatch_Name	=	NULL  
            ,@ID				=	@ID				OUTPUT  
            ,@Name				=	@Name			OUTPUT  
            ,@MUID				=	@MUID			OUTPUT  
            ,@Privilege_ID		=	@Privilege_ID	OUTPUT  
    SELECT @ID, @Name, @MUID, @Privilege_ID;  
      
*/		  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpInformationLookupStagingBatch]  
(  
    @StagingBatch_MUID		UNIQUEIDENTIFIER = NULL,	--\  
    @StagingBatch_ID		INT = NULL,					--One of these 3 always required  
    @StagingBatch_Name		NVARCHAR(MAX) = NULL,		--/  
    @ID						INTEGER = NULL OUTPUT,  
    @Name					NVARCHAR(MAX) = NULL OUTPUT,  
    @MUID					UNIQUEIDENTIFIER = NULL OUTPUT,  
    @Privilege_ID			INTEGER = NULL OUTPUT,  
    @AccessPermission       TINYINT = NULL OUTPUT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON;  
      
    SELECT TOP 1  
        @ID =  ID,   
        @Name = [Name],   
        @MUID = MUID,  
        @Privilege_ID = 4, -- Access  
        @AccessPermission = 7 -- ALL  
    FROM mdm.tblStgBatch    
    WHERE   
        (ID = @StagingBatch_ID OR @StagingBatch_ID IS NULL)  
        AND ([Name] = @StagingBatch_Name OR @StagingBatch_Name IS NULL)  
        AND (MUID = @StagingBatch_MUID OR @StagingBatch_MUID IS NULL)  
    ORDER BY ID;  
          
    SET NOCOUNT OFF;  
END
GO
/****** Object:  StoredProcedure [mdm].[udpInformationLookupVersion]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
    DECLARE @ID INT;  
    DECLARE @Name NVARCHAR(MAX);  
    DECLARE @MUID UniqueIdentifier;  
    DECLARE @Privilege_ID INT;  
    EXEC mdm.udpInformationLookupVersion  
             @User_ID        =    1  
            ,@Version_MUID    =    NULL  
            ,@Version_ID    =    NULL  
            ,@Version_Name    =    'Version 1'  
            ,@Model_ID        =    4  
            ,@Model_MUID    =    NULL  
            ,@ID            =    @ID                OUTPUT  
            ,@Name            =    @Name            OUTPUT  
            ,@MUID            =    @MUID            OUTPUT  
            ,@Privilege_ID    =    @Privilege_ID    OUTPUT  
    SELECT @ID, @Name, @MUID, @Privilege_ID;  
  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpInformationLookupVersion]  
(  
    @User_ID                INT = NULL,  
    @Version_MUID           UNIQUEIDENTIFIER = NULL,    --\  
    @Version_ID             INT = NULL,                 --One of these 3 always required  
    @Version_Name           NVARCHAR(MAX) = NULL,       --/  
    @Model_ID               INT = NULL,                 --\ One of these always required (except Model)  
    @Model_MUID             UNIQUEIDENTIFIER = NULL,    --/  
    @ID                     INTEGER = NULL OUTPUT,  
    @Name                   NVARCHAR(MAX) = NULL OUTPUT,  
    @MUID                   UNIQUEIDENTIFIER = NULL OUTPUT,  
    @Privilege_ID           INTEGER = NULL OUTPUT,  
    @AccessPermission       TINYINT = NULL OUTPUT,  
    @CorrelationID          UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON;  
    SET @User_ID = ISNULL(@User_ID, 0);  
    SELECT TOP 1  
                @ID = ver.ID,  
                @Name = ver.[Name],  
                @MUID = ver.MUID,  
                @Privilege_ID=4,  
                @AccessPermission = CASE  
                                WHEN (ver.Status_ID = 2 AND S.Privilege_ID <> 5 /*Admin*/) OR ver.Status_ID = 3 THEN 0 /*ReadOnly*/  
                                ELSE 7 /*All*/  
                             END  
            FROM mdm.tblModelVersion ver  
            INNER JOIN mdm.tblModel mdl ON ver.Model_ID = mdl.ID  
            LEFT JOIN mdm.viw_SYSTEM_SECURITY_USER_MODEL S ON S.ID=ver.Model_ID  
            WHERE  
                S.User_ID = @User_ID  
                AND (@Version_MUID IS NOT NULL OR @Version_ID IS NOT NULL OR @Version_Name IS NOT NULL)  
                AND (@Version_MUID IS NOT NULL OR @Model_ID IS NOT NULL OR @Model_MUID IS NOT NULL)  
                AND (ver.ID = @Version_ID OR @Version_ID IS NULL)  
                AND (ver.[Name] = @Version_Name OR @Version_Name IS NULL)  
                AND (ver.MUID = @Version_MUID OR @Version_MUID IS NULL)  
                AND (ver.Model_ID = @Model_ID OR @Model_ID IS NULL)  
                AND (mdl.MUID = @Model_MUID OR @Model_MUID IS NULL)  
                AND S.Privilege_ID > 1 --Needed to make sure that all Denied objects are treated as the same as invalid(non existent) objects  
            ORDER BY ver.ID;  
  
    SET NOCOUNT OFF;  
  
END
GO
/****** Object:  StoredProcedure [mdm].[udpInformationLookupVersionFlag]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
    DECLARE @ID INT;  
    DECLARE @Name NVARCHAR(MAX);  
    DECLARE @MUID UniqueIdentifier;  
    DECLARE @Privilege_ID INT;  
    EXEC mdm.udpInformationLookupVersionFlag  
             @User_ID            =    1  
            ,@VersionFlag_MUID    =    NULL  
            ,@VersionFlag_ID    =    NULL  
            ,@VersionFlag_Name    =    'Current'  
            ,@Model_ID            =    1  
            ,@Model_MUID        =    NULL  
            ,@ID                =    @ID                OUTPUT  
            ,@Name                =    @Name            OUTPUT  
            ,@MUID                =    @MUID            OUTPUT  
            ,@Privilege_ID        =    @Privilege_ID    OUTPUT  
    SELECT @ID, @Name, @MUID, @Privilege_ID;  
  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpInformationLookupVersionFlag]  
(  
    @User_ID                    INT = NULL,  
    @VersionFlag_MUID           UNIQUEIDENTIFIER = NULL,    --\  
    @VersionFlag_ID             INT = NULL,                 --One of these 3 always required  
    @VersionFlag_Name           NVARCHAR(MAX) = NULL,       --/  
    @Model_ID                   INT = NULL,                 --\ One of these always required (except Model)  
    @Model_MUID                 UNIQUEIDENTIFIER = NULL,    --/  
    @ID                         INTEGER = NULL OUTPUT,  
    @Name                       NVARCHAR(MAX) = NULL OUTPUT,  
    @MUID                       UNIQUEIDENTIFIER = NULL OUTPUT,  
    @Privilege_ID               INTEGER = NULL OUTPUT,  
    @AccessPermission           TINYINT = NULL OUTPUT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
  
    SET NOCOUNT ON;  
    SET @User_ID = ISNULL(@User_ID, 0);  
  
    SELECT TOP 1  
    @ID= flg.ID  
    , @Name= flg.[Name]  
    , @MUID= flg.MUID  
    , @Privilege_ID= 4  
    , @AccessPermission = CASE  
                        WHEN (flg.Status_ID = 2 AND S.Privilege_ID <> 5 /*Admin*/) OR flg.Status_ID = 3 THEN 0 /*ReadOnly*/  
                        ELSE 7 /*All*/  
                    END  
    FROM mdm.tblModelVersionFlag flg INNER JOIN mdm.tblModel mdl ON flg.Model_ID = mdl.ID  
    LEFT JOIN mdm.viw_SYSTEM_SECURITY_USER_MODEL S ON S.ID=flg.Model_ID  
    WHERE  
        S.User_ID = @User_ID  
        AND (flg.ID = @VersionFlag_ID OR @VersionFlag_ID IS NULL)  
        AND (flg.[Name] = @VersionFlag_Name OR @VersionFlag_Name IS NULL)  
        AND (flg.MUID = @VersionFlag_MUID OR @VersionFlag_MUID IS NULL)  
        AND (flg.Model_ID = @Model_ID OR @Model_ID IS NULL)  
        AND (mdl.MUID = @Model_MUID OR @Model_MUID IS NULL)  
        AND S.Privilege_ID  > 1 --Needed to make sure that all Denied objects are treated as the same as invalid(non existent) objects  
    ORDER BY flg.ID;  
  
    SET NOCOUNT OFF;  
  
END
GO
/****** Object:  StoredProcedure [mdm].[udpIsCodeGenEnabled]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
Call the udpIsCodeGenEnabled to check whether an entity supports code generation.  
  
Example  
    DECLARE @IsCodeGenEnabled BIT;  
    EXEC @IsCodeGenEnabled = mdm.udpIsCodeGenEnabled @Entity_ID = 20;  
*/  
CREATE PROCEDURE [mdm].[udpIsCodeGenEnabled]  
(  
    @Entity_ID		INT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
AS BEGIN  
  
    SET NOCOUNT ON;  
  
    DECLARE @IsCodeGenEnabled BIT = 0;  
  
    IF EXISTS(SELECT * FROM mdm.tblCodeGenInfo WHERE EntityId = @Entity_ID)  
        BEGIN  
            SET @IsCodeGenEnabled = 1;  
        END  
  
    -- Return the result of the SPROC  
    RETURN @IsCodeGenEnabled;  
  
END; --proc mdm.udpIsCodeGenEnabled
GO
/****** Object:  StoredProcedure [mdm].[udpIsSystemInValidState]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
    A simple stored procedure that the API can call to determine  
      1) Is the connection to the database still alive  
      2) If so (this sproc will get called) are the system tables populated.  
  
    DECLARE @RET AS INT;  
    EXEC mdm.udpIsSystemInValidState @RET OUTPUT;  
    SELECT @RET;  
*/  
CREATE PROCEDURE [mdm].[udpIsSystemInValidState]  
(  
    @Return_ID BIT OUTPUT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON  
  
    --Check core system tables for the existence of records  
    IF  EXISTS (SELECT 1 FROM mdm.tblSystemSetting)   
        AND EXISTS (SELECT 1 FROM mdm.tblUser)  
        AND EXISTS (SELECT 1 FROM mdm.tblList)  
        AND EXISTS (SELECT 1 FROM mdm.tblSecurityPrivilegeFunctional)  
        AND EXISTS (SELECT 1 FROM mdm.tblSecurityObject)  
        AND EXISTS (SELECT 1 FROM mdm.tblSecurityPrivilege)  
        AND EXISTS (SELECT 1 FROM mdm.tblBRItemTypeAppliesTo)  
        SET @Return_ID = 1;  
    ELSE  
        SET @Return_ID = 0;  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpLogCleanup]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
Cleans up logfs for all models based on the LogRetention policy for each model.  
If model has LogRetentionDays as default(0) then inherits the value from System Setting  
If model has LogRetentionDays as -1 then no cleanup will be done for this model ignoring system setting.  
    EXEC mdm.udpLogCLeanup ;  
*/  
CREATE PROCEDURE [mdm].[udpLogCleanup]  
(  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS N'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON  
  
    BEGIN TRY  
  
    DECLARE @TempTable 	TABLE (RowNumber INT IDENTITY (1, 1) PRIMARY KEY CLUSTERED NOT NULL , ID INT NOT NULL, LogRetentionDays SMALLINT NULL);  
  
    DECLARE @CleanupOlderThanDate   DATE,  
            @TempModelID            INT,  
            @TempLogRetention       SMALLINT;  
  
    INSERT INTO @TempTable SELECT ID, LogRetentionDays FROM mdm.viw_SYSTEM_SCHEMA_MODEL ORDER BY ID DESC;  
  
    DECLARE @Counter INT = 1;  
    DECLARE @MaxCounter INT = (SELECT MAX(RowNumber) FROM @TempTable);  
  
    WHILE @Counter <= @MaxCounter  
    BEGIN  
        SELECT @TempModelID = ID, @TempLogRetention = LogRetentionDays FROM @TempTable WHERE [RowNumber] = @Counter;  
  
        SET @TempLogRetention =  COALESCE(@TempLogRetention, mdm.udfSystemSettingGet('LogRetentionDays'));  
        --if system level setting  OR Model level is -1 then skip the cleanup for this model.  
        IF(@TempLogRetention >= 0)  
        BEGIN  
            SET @CleanupOlderThanDate = CONVERT(DATE, GETDATE() - CONVERT(DATETIME, @TempLogRetention));  
  
            --Cleanup Transaction Logs  
            EXEC mdm.udpTransactionsCleanup @TempModelID, @CleanupOlderThanDate;  
  
            --Claenup EBS tables  
            EXEC mdm.udpEntityStagingBatchTableCleanup @TempModelID, @CleanupOlderThanDate;  
        END  
        SET @Counter = @Counter +1;  
    END -- while  
    RETURN(0);  
    END TRY  
    --Compensate as necessary  
    BEGIN CATCH  
  
        -- Get error info.  
        DECLARE  
            @ErrorMessage NVARCHAR(4000),  
            @ErrorSeverity INT,  
            @ErrorState INT,  
            @ErrorNumber INT,  
            @ErrorLine INT,  
            @ErrorProcedure NVARCHAR(126);  
        EXEC mdm.udpGetErrorInfo  
            @ErrorMessage = @ErrorMessage OUTPUT,  
            @ErrorSeverity = @ErrorSeverity OUTPUT,  
            @ErrorState = @ErrorState OUTPUT,  
            @ErrorNumber = @ErrorNumber OUTPUT,  
            @ErrorLine = @ErrorLine OUTPUT,  
            @ErrorProcedure = @ErrorProcedure OUTPUT  
  
        SET @ErrorMessage = CONCAT(@ErrorMessage, N', @ErrorNumber = ', @ErrorNumber, N', @ErrorProcedure = "', @ErrorProcedure, N'", line ', @ErrorLine);  
  
        RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);  
  
        RETURN(1);  
  
    END CATCH;  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpMemberAttributeGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    DECLARE @Tempvar NVARCHAR(2000)  
    EXEC mdm.udpMemberAttributeGet 111, 1, 1, 1, 'SourceKey', @TempVar OUTPUT  
    SELECT @Tempvar  
  
*/  
CREATE PROCEDURE [mdm].[udpMemberAttributeGet]  
(  
    @Version_ID		INTEGER,  
    @Entity_ID     	INTEGER,  
    @Member_ID		INTEGER,  
    @MemberType_ID	TINYINT,  
    @AttributeName	NVARCHAR(250),  
    @ReturnValue	NVARCHAR(2000) = NULL OUTPUT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE @SQL 			NVARCHAR(MAX),  
            @TableName 		sysname,  
            @TableColumn	sysname,  
            @Value			NVARCHAR(2000);  
  
    SET @TableName = mdm.udfTableNameGetByID(@Entity_ID, @MemberType_ID);  
  
    SELECT @TableColumn = TableColumn FROM mdm.tblAttribute   
    WHERE Entity_ID = @Entity_ID AND MemberType_ID = @MemberType_ID AND [Name] = @AttributeName;  
  
    IF @TableColumn IS NULL BEGIN  
        RAISERROR('MDSERR300010|The supplied attribute is not valid.', 16, 1, @SQL);  
    END ELSE BEGIN  
        SET @SQL = N'  
            SELECT @Value = CONVERT(NVARCHAR(2000), ' + quotename(@TableColumn) + N', 121) --ensure dates are ANSI  
            FROM mdm.' + quotename(@TableName) + N'  
            WHERE Version_ID = @Version_ID  
            AND ID = @Member_ID;';  
        --PRINT(@SQL);  
        EXEC sp_executesql @SQL, N'@Version_ID INT, @Member_ID INT, @Value NVARCHAR(2000) OUTPUT', @Version_ID, @Member_ID, @Value OUTPUT;	  
  
        SET @ReturnValue = ISNULL(@Value, N'');   
    END; --if  
      
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpMemberAttributeSave]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    EXEC mdm.udpMemberAttributeSave @User_ID = 1, @Version_ID = 1, @Entity_ID = 1, @MemberCode = NULL, @Member_ID = 2,  
    @MemberType_ID = 1, @AttributeName = 'Name', @AttributeValue = ' B ', @LogFlag = 1;  
  
    EXEC mdm.udpMemberAttributeSave @User_ID = 1, @Version_ID = 1, @Entity_ID = 1, @MemberCode = NULL, @Member_ID = 2,  
    @MemberType_ID = 1, @AttributeName = 'Code', @AttributeValue = '  ', @LogFlag = 1;  
  
    SELECT * FROM mdm.tblEntity WHERE ID = 2;  
    SELECT * FROM mdm.tblAttribute WHERE Entity_ID = 1;  
    SELECT * FROM mdm.tbl_1_1_EN;  
  
The udp is only used in membercopy, so no history log is required  
  
*/  
CREATE PROCEDURE [mdm].[udpMemberAttributeSave]  
(  
    @User_ID                INT,  
    @Version_ID             INT,  
    @Entity_ID              INT,  
    @MemberCode             NVARCHAR(250) = NULL,  
    @Member_ID              INT = NULL,  
    @MemberType_ID          TINYINT,  
    @AttributeName          NVARCHAR(250),  
    @AttributeValue         NVARCHAR(MAX) = NULL,  
    @DoInheritanceRuleCheck BIT = NULL,  
    @CorrelationID          UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE @TableName                  SYSNAME,  
            @TableColumn                SYSNAME,  
            @SQL                        NVARCHAR(MAX),  
            @Attribute_ID               INT,  
            @AttributeType_ID           INT,  
            @DataType_ID                INT,  
            @DataTypeNumeric            INT = 2,  
            @TempPriorValue             NVARCHAR(MAX),  
            @TempUpdatedValue           NVARCHAR(MAX),  
            @Return                     INT,  
            @ChangeTrackingGroup        INT,  
            @CodeGenEnabled             BIT = 0,  
            @Model_ID                   INT,  
            @TransactionLogType         TINYINT,  
            @TransactionLogType_Attribute   TINYINT = 1,  
  
            --Validation log table name  
            @ValidationLogTableName     SYSNAME;  
  
    DECLARE @ValidationStatus           INT = 4;  
  
    --Test for invalid parameters  
    IF @User_ID IS NULL OR @Version_ID IS NULL OR @Entity_ID IS NULL  
        OR (@AttributeName IS NULL OR LEN(@AttributeName) = 0)  
        OR ((@Member_ID IS NULL AND @MemberType_ID IS NULL)  
        AND (@MemberCode IS NULL OR LEN(@MemberCode) =0))  
    BEGIN  
        RAISERROR('MDSERR100010|The Parameters are not valid.', 16, 1);  
        RETURN(1);  
    END; --if  
  
    --Check if code gen is enabled for this entity  
    DECLARE @result INT;  
    EXEC @result = mdm.udpIsCodeGenEnabled @Entity_ID;  
    SET @CodeGenEnabled = CONVERT(BIT, @result);  
  
    --Start transaction, being careful to check if we are nested  
    DECLARE @TranCounter INT;  
    SET @TranCounter = @@TRANCOUNT;  
    IF @TranCounter > 0 SAVE TRANSACTION TX;  
    ELSE BEGIN TRANSACTION;  
  
    BEGIN TRY  
  
        IF @Member_ID IS NULL BEGIN  
            --EXEC mdm.udpMemberIDGetByCode @Version_ID, @Entity_ID, @MemberCode, @MemberType_ID, @Member_ID OUTPUT;  
  
            -- Get the Member_ID and MemberType_ID from the existing Code  
            EXEC mdm.udpMemberTypeIDAndIDGetByCode @Version_ID,@Entity_ID,@MemberCode,@MemberType_ID OUTPUT,@Member_ID OUTPUT  
        END; --if  
  
        --Initialize variables  
        SELECT  
            @Return = 0,  
            @TableName = mdm.udfTableNameGetByID(@Entity_ID, @MemberType_ID),  
            @AttributeName = NULLIF(LTRIM(RTRIM(@AttributeName)), N''),  
            @AttributeValue = CASE @AttributeName  
                --Clean member Code value  
                WHEN N'Code' THEN  
                    NULLIF(LTRIM(RTRIM(@AttributeValue)), N'')  
                --Clean member Name value  
                WHEN N'Name' THEN  
                    NULLIF(LTRIM(RTRIM(@AttributeValue)), N'') --Ditto  
                --Clean any other value  
                ELSE  
                    NULLIF(LTRIM(RTRIM(@AttributeValue)), N'') --Ditto  
            END; --case  
  
        SELECT @TransactionLogType = TransactionLogType  
        FROM mdm.tblEntity  
        WHERE ID = @Entity_ID;  
  
        --Get The Attribute ID  
        SELECT  
            @Attribute_ID = ID,  
            @AttributeType_ID = AttributeType_ID,  
            @DataType_ID = DataType_ID,  
            @TableColumn = TableColumn,  
            @AttributeName = [Name],  
            @ChangeTrackingGroup = ChangeTrackingGroup  
        FROM mdm.tblAttribute  
        WHERE [Name] = @AttributeName  
        AND Entity_ID = @Entity_ID  
        AND MemberType_ID = @MemberType_ID;  
  
        --Get Model ID  
        SELECT @Model_ID = Model_ID  
        FROM mdm.tblModelVersion  
        WHERE ID = @Version_ID;  
  
        SET @ValidationLogTableName = mdm.udfGetValidationLogTableName(@Model_ID);  
  
        --Perform additional operations for Code changes.  
        IF @AttributeName = N'Code' BEGIN  
  
            --Member code can not be null  
            IF @MemberCode IS NULL  
                BEGIN  
                    RAISERROR('MDSERR310022|The code can not be empty', 16, 1);  
                    RETURN;  
                END  
  
            --Ensure the new code is unique.  
            DECLARE  
                @ActiveCodeExists BIT = 0,  
                @DeactivatedCodeExists BIT = 0;  
  
            DECLARE @AttributeValueAsCode NVARCHAR(250) = CONVERT(NVARCHAR(250), @AttributeValue);  
            EXEC mdm.udpMemberCodeCheck @Version_ID, @Entity_ID, @AttributeValueAsCode, @ActiveCodeExists OUTPUT, @DeactivatedCodeExists OUTPUT  
            IF @ActiveCodeExists = 1 BEGIN  
                RAISERROR('MDSERR300003|The member code already exists.', 16, 1);  
            END  
  
            --If member code is non-null and code gen is enabled process the new code  
            IF @AttributeValue IS NOT NULL AND @CodeGenEnabled = 1  
                BEGIN  
                    --Gather up the valid user provided codes  
                    DECLARE @CodesToProcess mdm.MemberCodes;  
  
                    INSERT @CodesToProcess (MemberCode)  
                    VALUES (@MemberCode);  
  
                    --Process the user-provided codes to update the code gen info table with the largest one  
                    EXEC mdm.udpProcessCodes @Entity_ID, @CodesToProcess;  
                END  
  
            --Update any existing validation issues associated with this member  
            --to ensure they reference the new member code.  
            SET @SQL = N'  
            UPDATE [mdm].' + QUOTENAME(@ValidationLogTableName) + N'  
            SET MemberCode = @AttributeValue  
            WHERE Member_ID = @Member_ID  
            AND MemberType_ID = @MemberType_ID  
            AND Version_ID = @Version_ID  
            '  
            EXEC sp_executesql @SQL,N'@AttributeValue NVARCHAR(MAX), @Member_ID INT, @MemberType_ID INT, @Version_ID INT',  
                                      @AttributeValue,               @Member_ID,     @MemberType_ID,     @Version_ID;  
        END  
  
        --Get The Prior Value  
        EXEC mdm.udpMemberPriorValueGet @Version_ID, @TableName, @TableColumn, @Member_ID, @TempPriorValue OUTPUT;  
  
        DECLARE @ValueSql as NVARCHAR(MAX) = N'@Value';  
        IF (@DataType_ID = @DataTypeNumeric AND CHARINDEX(N'E', UPPER(@AttributeValue)) >= 0) BEGIN  
            -- The new value is in scientific notation, which cannot be directly converted to type DECIMAL. So, first convert it  
            -- to FLOAT.  
            SET @ValueSql = N'CONVERT(FLOAT, ' + @ValueSql + N')';  
        END  
  
        SET @SQL = N'  
            UPDATE mdm.' + quotename(@TableName) + N' SET  
                ' + quotename(@TableColumn) + N' = ' + @ValueSql + N',  
                ValidationStatus_ID = @ValidationStatus,  
                LastChgDTM = GETUTCDATE(),  
                LastChgUserID = @User_ID,  
                LastChgVersionID = @Version_ID' + CASE WHEN @MemberType_ID IN(1,2) THEN  N',  
                ChangeTrackingMask = ISNULL(ChangeTrackingMask, 0) | ISNULL(POWER(2,@ChangeTrackingGroup -1), 0)' ELSE N'' END  + N'  
            WHERE  
                ID = @Member_ID AND  
                Version_ID = @Version_ID;'  
  
        --PRINT(@SQL);  
        EXEC sp_executesql @SQL,  
            N'@Value NVARCHAR(MAX),@ValidationStatus INT, @User_ID INT, @Version_ID INT, @Member_ID INT, @ChangeTrackingGroup INT',  
            @AttributeValue, @ValidationStatus, @User_ID, @Version_ID, @Member_ID, @ChangeTrackingGroup;  
  
  
        IF @DoInheritanceRuleCheck = 1 BEGIN  
            DECLARE @ChildEntityTable            SYSNAME  
            DECLARE @ChildAttributeColumnName    SYSNAME  
  
            --Check for Inheritance Business Rules and update dependent members validation status.  
            --Attribute Inheritance  
            SELECT  
                 @ChildEntityTable = chiEnt.EntityTable  
                ,@ChildAttributeColumnName = ChildAttributeColumnName  
            FROM mdm.viw_SYSTEM_BUSINESSRULES_ATTRIBUTE_INHERITANCE_HIERARCHY i  
            INNER JOIN mdm.tblEntity chiEnt  
                ON i.ChildEntityID = chiEnt.ID  
            WHERE ParentEntityID = @Entity_ID  
            AND Attribute_MemberType_ID = @MemberType_ID  
            AND ParentAttributeColumnName = @TableColumn  
  
            IF @ChildAttributeColumnName IS NOT NULL BEGIN  
                --Update immediate dependent member table's validation status.  
                SELECT @SQL = N'  
                     UPDATE   mdm.' + quotename(@ChildEntityTable) + N'  
                     SET      ValidationStatus_ID = 5  
                     FROM  mdm.' + quotename(@ChildEntityTable) + N' ch  
                           INNER JOIN mdm.tblModelVersion dv  
                              ON ch.Version_ID = dv.ID  
                              AND dv.Status_ID <> 3  
                              AND   ch.ValidationStatus_ID <> 5  
                              AND   ch.Version_ID = @Version_ID  
                              AND   ch.' + quotename(@ChildAttributeColumnName) + N' = @Member_ID;  
                     '  
                EXEC sp_executesql @SQL, N'@Version_ID INT, @Member_ID INT', @Version_ID, @Member_ID;  
            END -- IF @ChildAttributeColumnName  
  
            --Hierarchy Inheritance.  
            --  Only need to do this if a hierarchy parent attribute is being updated.  
            IF @MemberType_ID = 2 BEGIN  
                SELECT TOP 1  
                    @ChildAttributeColumnName = i.AttributeColumnName  
                FROM mdm.viw_SYSTEM_BUSINESSRULES_HIERARCHY_CHANGEVALUE_INHERITANCE i  
                WHERE AttributeColumnName = @TableColumn  
                AND   EntityID = @Entity_ID  
                ORDER BY i.HierarchyID;  
  
                IF @ChildAttributeColumnName IS NOT NULL BEGIN  
                    DECLARE @parentIdList mdm.IdList;  
                    INSERT INTO @parentIdList (ID) VALUES (@Member_ID);  
  
                    EXEC mdm.udpHierarchyMembersValidationStatusUpdate  
                         @Entity_ID = @Entity_ID  
                        ,@Version_ID = @Version_ID  
                        ,@Hierarchy_ID = NULL  
                        ,@ParentIdList = @parentIdList  
                        ,@ValidationStatus_ID = 5  
                        ,@MaxLevel = 0  
                        ,@IncludeParent = 0;  
                END -- IF @ChildAttributeColumnName  
  
            END -- IF @MemberType_ID  
        END -- IF @DoInheritanceRuleCheck  
  
        -- File Type attribute  
        IF (@AttributeType_ID = 4)  
        BEGIN  
            -- remove old record from mdm.tblFile for updates  
            -- since the new record is being inserted in Business Logic Save  
            DECLARE @File_ID mdm.IdList;  
            INSERT INTO @File_ID (ID)  
            VALUES (CONVERT(INT, @TempPriorValue))  
  
            EXEC mdm.udpFilesDelete @File_ID = @File_ID, @CorrelationID = @CorrelationID;  
        END;  
  
        IF @TransactionLogType = @TransactionLogType_Attribute  
        BEGIN  
            --Log the Transaction if value has changed  
            --EDM-1632: calling this mdm.udp to get the updated value back in the same format so we can do a proper comparison below to see if the value has changed.  
            EXEC mdm.udpMemberPriorValueGet @Version_ID, @TableName, @TableColumn, @Member_ID, @TempUpdatedValue OUTPUT;  
  
            IF (ISNULL(@TempPriorValue, N'') <> ISNULL(@TempUpdatedValue, N''))  
            BEGIN  
                EXEC mdm.udpTransactionSave @User_ID,@Version_ID,3,NULL,NULL,@Entity_ID,@Member_ID,@MemberType_ID,@Attribute_ID,@TempPriorValue,@TempUpdatedValue;  
            END; --if  
        END;  
  
        --Put a msg onto the SB queue to process member security  
        EXEC mdm.udpSecurityMemberQueueSave  
            @User_ID    = NULL,-- update member security for all users  
            @Version_ID = @Version_ID,  
            @Entity_ID  = @Entity_ID;  
  
        --Commit only if we are not nested  
        IF @TranCounter = 0 COMMIT TRANSACTION;  
  
        RETURN(@Return);  
  
    END TRY  
    --Compensate as necessary  
    BEGIN CATCH  
  
        -- Get error info.  
        DECLARE  
            @ErrorMessage NVARCHAR(4000),  
            @ErrorSeverity INT,  
            @ErrorState INT,  
            @ErrorNumber INT,  
            @ErrorLine INT,  
            @ErrorProcedure NVARCHAR(126);  
        EXEC mdm.udpGetErrorInfo  
            @ErrorMessage = @ErrorMessage OUTPUT,  
            @ErrorSeverity = @ErrorSeverity OUTPUT,  
            @ErrorState = @ErrorState OUTPUT,  
            @ErrorNumber = @ErrorNumber OUTPUT,  
            @ErrorLine = @ErrorLine OUTPUT,  
            @ErrorProcedure = @ErrorProcedure OUTPUT  
  
        SET @ErrorMessage = CONCAT(@ErrorMessage, N', @ErrorNumber = ', @ErrorNumber, N', @ErrorProcedure = "', @ErrorProcedure, N'", line ', @ErrorLine);  
  
        IF @TranCounter = 0 ROLLBACK TRANSACTION;  
        ELSE IF XACT_STATE() <> -1 ROLLBACK TRANSACTION TX;  
  
        IF (@ErrorNumber = 8152) BEGIN  
            RAISERROR('MDSERR110017|The attribute value length cannot be greater than the maximum size allowed.', 16, 1);  
        END ELSE BEGIN  
            RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);  
        END; --if  
  
        --On error, return NULL results  
        --SELECT @Return_ID = NULL;  
        RETURN(@ErrorNumber);  
  
    END CATCH;  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpMemberCodeCheck]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
Determines whether the given member code already exists for the given entity and version,   
in either an active member or a deactivated (soft-deleted) member.  
  
    DECLARE   
        @ActiveCodeExists BIT,  
        @DeactivatedCodeExists BIT;  
    EXEC mdm.udpMemberCodeCheck 1, 1, N'1', @ActiveCodeExists OUTPUT, @DeactivatedCodeExists OUTPUT;  
    select @ActiveCodeExists, @DeactivatedCodeExists;  
*/  
CREATE PROCEDURE [mdm].[udpMemberCodeCheck]  
(  
    @Version_ID             INT,  
    @Entity_ID              INT,  
    @MemberCode             NVARCHAR(250),      
    @ActiveCodeExists       BIT = NULL OUTPUT, -- Whether a currently active member has the given code.  
    @DeactivatedCodeExists  BIT = NULL OUTPUT,  -- Whether a decativated (soft-deleted) member has the given code.  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    /****************************************/  
    /*    0(FALE) - DOES NOT EXIST          */  
    /*    1(TRUE) - DOES EXIST              */  
    /****************************************/  
      
    SET @MemberCode = (SELECT (LTRIM(RTRIM(COALESCE(@MemberCode, N'')))));  
    IF LEN(@MemberCode) = 0 OR   
       UPPER(@MemberCode) IN -- Check reserved words:  
            (N'ROOT',        -- Hierarchy root node  
             N'MDMUNUSED')   -- Non mandatory hierarchies  
    BEGIN  
        SET @ActiveCodeExists = 1;  
        SET @DeactivatedCodeExists = 0;  
    END ELSE BEGIN  
      
        DECLARE @EntityTable            SYSNAME,  
                @HierarchyParentTable   SYSNAME,  
                @CollectionTable        SYSNAME,  
                @IsCollectionEnabled    BIT,  
                @IsHierarchyEnabled     BIT,  
                @SQL                    NVARCHAR(MAX),  
                @ActiveCount            INT = 0,  
                @DeactivatedCount       INT = 0;  
      
        DECLARE @QueryPrefix            NVARCHAR(MAX) = N'  
            SELECT  
                @ActiveCount      += COALESCE(SUM(CASE Status_ID WHEN 1 /*Active*/      THEN 1 ELSE 0 END), 0),   
                @DeactivatedCount += COALESCE(SUM(CASE Status_ID WHEN 2 /*Deactivated*/ THEN 1 ELSE 0 END), 0)  
            FROM mdm.',          
                @QuerySuffix            NVARCHAR(MAX) = N'  
            WHERE  
                Version_ID = @Version_ID AND  
                Code = @MemberCodeParam;  
            ';                         
  
        SELECT      
            @EntityTable = EntityTable,  
            @HierarchyParentTable = HierarchyParentTable,  
            @CollectionTable = CollectionTable,  
            @IsCollectionEnabled = CASE WHEN CollectionTable IS NULL THEN 0 ELSE 1 END,  
            @IsHierarchyEnabled  = CASE WHEN HierarchyTable  IS NULL THEN 0 ELSE 1 END  
        FROM mdm.tblEntity   
        WHERE ID = @Entity_ID;  
      
        --Check type 1  
        SET @SQL = @QueryPrefix + QUOTENAME(@EntityTable) + @QuerySuffix;  
        EXEC sp_executesql @SQL, N'@Version_ID INT, @MemberCodeParam NVARCHAR(250), @ActiveCount INT OUTPUT, @DeactivatedCount INT OUTPUT', @Version_ID, @MemberCode, @ActiveCount OUTPUT, @DeactivatedCount OUTPUT;  
  
        IF @ActiveCount = 0 OR @DeactivatedCount = 0  
        BEGIN  
            --Check Type 2  
            IF @IsHierarchyEnabled = 1  
            BEGIN  
                SET @SQL = @QueryPrefix + QUOTENAME(@HierarchyParentTable) + @QuerySuffix;  
                EXEC sp_executesql @SQL, N'@Version_ID INT, @MemberCodeParam NVARCHAR(250), @ActiveCount INT OUTPUT, @DeactivatedCount INT OUTPUT', @Version_ID, @MemberCode, @ActiveCount OUTPUT, @DeactivatedCount OUTPUT;  
            END;  
  
            --Check Type 3  
            IF @IsCollectionEnabled  = 1   
            BEGIN  
                SET @SQL = @QueryPrefix + QUOTENAME(@CollectionTable) + @QuerySuffix;  
                EXEC sp_executesql @SQL, N'@Version_ID INT, @MemberCodeParam NVARCHAR(250), @ActiveCount INT OUTPUT, @DeactivatedCount INT OUTPUT', @Version_ID, @MemberCode, @ActiveCount OUTPUT, @DeactivatedCount OUTPUT;  
            END; --if  
        END; --if  
  
        SET @ActiveCodeExists      = CASE WHEN @ActiveCount      > 0 THEN 1 ELSE 0 END;  
        SET @DeactivatedCodeExists = CASE WHEN @DeactivatedCount > 0 THEN 1 ELSE 0 END;  
  
    END  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpMemberCodeGetByID]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    DECLARE @Tempvar NVARCHAR(250)  
    EXEC mdm.udpMemberCodeGetByID 7,5,230,1,@TempVar OUTPUT  
    SELECT @Tempvar  
*/  
CREATE PROCEDURE [mdm].[udpMemberCodeGetByID]  
(  
    @Version_ID		INTEGER,  
    @Entity_ID     	INTEGER,  
    @Member_ID		INTEGER,  
    @MemberType_ID	TINYINT,  
    @ReturnCode		NVARCHAR(250) OUTPUT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE @SQL	 		NVARCHAR(MAX),  
            @TableName 		sysname,  
            @Code			NVARCHAR(250);  
  
    IF (@MemberType_ID < 1 OR @MemberType_ID > 3) --Invalid @MemberType_ID  
    BEGIN  
        --On error, return NULL results  
        SELECT @ReturnCode = NULL  
        DECLARE @e NVARCHAR(200); SET @e = OBJECT_NAME(@@PROCID);  
        RAISERROR('MDSERR100010|The Parameters are not valid.', 16, 1);  
        RETURN(1);  
    END  
      
  
    SET @TableName = mdm.udfTableNameGetByID(@Entity_ID, @MemberType_ID);  
  
    SET @SQL = N'SELECT @Code = Code   
        FROM mdm.' + quotename(@TableName) + N'   
        WHERE Version_ID = @Version_ID   
        AND ID = @Member_ID;';  
  
    EXEC sp_executesql @SQL, N'@Version_ID INT, @Member_ID INT, @Code NVARCHAR(250) OUTPUT', @Version_ID, @Member_ID, @Code output;  
      
    SET @ReturnCode = @Code;  
      
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpMemberCopy]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    --Con  
    DECLARE @RC int;  
    EXECUTE @RC = mdm.udpMemberCopy @User_ID=1, @Version_ID=4, @Entity_ID=7,@SourceMemberCode='10',@DestinationMemberCode='10_NEW'  
    SELECT @RC;  
  
    --Leaf  
    DECLARE @RC int;  
    EXECUTE @RC = mdm.udpMemberCopy @User_ID=1, @Version_ID=4, @Entity_ID=7,@SourceMemberCode='1110',@DestinationMemberCode='1110_NEW'  
    SELECT @RC;  
  
    --Invalid - Source does NOT exist  
    EXECUTE mdm.udpMemberCopy @User_ID=1, @Version_ID=4, @Entity_ID=7,@SourceMemberCode='KABOOM',@DestinationMemberCode='1110_NEW'  
  
    --Invalid - Destination DEOS NOT exist  
    EXECUTE mdm.udpMemberCopy @User_ID=1, @Version_ID=4, @Entity_ID=7,@SourceMemberCode='1110',@DestinationMemberCode='1110'  
*/  
  
CREATE PROCEDURE [mdm].[udpMemberCopy]  
(  
    @User_ID                INT,  
    @Version_ID             INT,  
    @Entity_ID              INT,  
    @SourceMemberCode       NVARCHAR(250),  
    @DestinationMemberCode  NVARCHAR(250),  
    @CorrelationID          UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE  
         @VersionStatus_NotSpecified    TINYINT = 0  
        ,@VersionStatus_Open            TINYINT = 1  
        ,@VersionStatus_Locked          TINYINT = 2  
        ,@VersionStatus_Committed       TINYINT = 3  
  
        ,@Permission_Admin              INT = 5  
  
        ,@ModelPermission       TINYINT  
        ,@VersionStatus         TINYINT  
        ,@MemberType_ID         TINYINT  
        ,@MemberType_Consolidated   TINYINT = 2  
        ,@Member_ID             INT  
        ,@NewMember_ID          INT  
        ,@ParentMember_ID       INT  
        ,@Hierarchy_ID          INT  
        ,@TempHierarchy_ID      INT  
        ,@AttributeName         NVARCHAR(250)  
        ,@AttributeValue        NVARCHAR(2000)  
        ,@ActiveCodeExists      BIT = 0  
        ,@DeactivatedCodeExists BIT = 0;  
  
    DECLARE @TempAttributeTable TABLE([Name] NVARCHAR(250) COLLATE database_default,  
                                       SortOrder INT)  
    DECLARE    @TempHierarchyTable TABLE(ID INT)  
  
    SELECT   
         @VersionStatus = mv.Status_ID  
        ,@ModelPermission = m.Privilege_ID  
    FROM mdm.tblModelVersion mv  
    LEFT JOIN mdm.viw_SYSTEM_SECURITY_USER_MODEL m  
    ON      mv.Model_ID = m.ID  
        AND m.User_ID = @User_ID  
    WHERE mv.ID = @Version_ID  
  
    IF @VersionStatus = @VersionStatus_Committed  
        OR (@VersionStatus = @VersionStatus_Locked AND @ModelPermission <> @Permission_Admin)  
    BEGIN  
        RAISERROR('MDSERR300012|The version is read-only. You do not have permission to update the version.', 16, 1);  
        RETURN;  
    END  
  
    -- Verify the entity version is not a sync target.  
    IF EXISTS(SELECT 1 FROM mdm.tblSyncRelationship  
              WHERE TargetEntity_ID = @Entity_ID  
                AND TargetVersion_ID = @Version_ID)  
    BEGIN  
        RAISERROR('MDSERR200220|The entity member(s) cannot be saved. The entity version is the target of a sync relationship.', 16, 1);  
        RETURN;  
    END  
  
    --Check the source code to make sure it EXISTS  
    SET @ActiveCodeExists = 0;  
    SET @DeactivatedCodeExists = 0;  
    EXEC mdm.udpMemberCodeCheck @Version_ID, @Entity_ID, @SourceMemberCode, @ActiveCodeExists OUTPUT, @DeactivatedCodeExists OUTPUT;  
    IF @ActiveCodeExists = 0 --Invalid  
    BEGIN  
        RAISERROR('MDSERR300002|Error - The member code is not valid.', 16, 1);  
        RETURN(1);  
    END  
  
    --Check the destination code to make sure it DOES NOT exist  
    SET @ActiveCodeExists = 0;  
    SET @DeactivatedCodeExists = 0;  
    EXEC mdm.udpMemberCodeCheck @Version_ID, @Entity_ID, @DestinationMemberCode, @ActiveCodeExists OUTPUT, @DeactivatedCodeExists OUTPUT;  
    IF @ActiveCodeExists = 1 --Exists  
    BEGIN  
        RAISERROR('MDSERR300003|The member code already exists.', 16, 1);  
        RETURN(1);  
    END  
  
    SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED  
    BEGIN TRAN  
  
    -- Get the MemberType_ID and ID from the existing Code  
    EXEC mdm.udpMemberTypeIDAndIDGetByCode @Version_ID,@Entity_ID,@SourceMemberCode,@MemberType_ID OUTPUT,@Member_ID OUTPUT  
  
    --If consolidated, get the Hierarchy for the existing member, else NULL  
    IF @MemberType_ID = @MemberType_Consolidated  
    BEGIN  
        EXECUTE mdm.udpHierarchyIDGetByMemberID @Version_ID,@Entity_ID,@Member_ID,@MemberType_ID,0,@Hierarchy_ID OUTPUT  
    END  
    ELSE  
    BEGIN  
        SET @Hierarchy_ID = NULL  
    END  
  
    --Create the new member and get the ID  
    EXEC mdm.udpMemberCreate @User_ID,@Version_ID,@Hierarchy_ID,@Entity_ID,@MemberType_ID,'',@DestinationMemberCode, @NewMember_ID OUTPUT  
  
    --Get the List of Attributes that the user has security for  
    INSERT INTO @TempAttributeTable  
    SELECT  
        a.Name AS AttributeName,  
        a.SortOrder  
    FROM mdm.viw_SYSTEM_SECURITY_USER_ATTRIBUTE atSec  
    INNER JOIN mdm.tblAttribute a  
    ON atSec.ID = a.ID  
    WHERE atSec.User_ID = @User_ID  
        AND a.Entity_ID = @Entity_ID  
        AND a.MemberType_ID = @MemberType_ID  
        AND(a.IsSystem = 0  
            OR a.[Name] = N'Name')  
    ORDER BY a.SortOrder ASC  
  
    WHILE EXISTS(SELECT 1 FROM @TempAttributeTable)  
    BEGIN  
  
        SELECT TOP 1 @AttributeName = [Name] FROM @TempAttributeTable ORDER BY SortOrder;  
  
        --Get the value for the selected attribute for the source member  
        EXECUTE mdm.udpMemberAttributeGet @Version_ID,@Entity_ID,@Member_ID,@MemberType_ID,@AttributeName,@AttributeValue OUTPUT  
  
        --Set the value for the selected attribute for the new member  
        EXECUTE mdm.udpMemberAttributeSave @User_ID,@Version_ID,@Entity_ID,NULL,@NewMember_ID,@MemberType_ID,@AttributeName,@AttributeValue,NULL  
  
        DELETE FROM @TempAttributeTable WHERE [Name] = @AttributeName;  
    END; --while  
  
    --Get a list of Hierarchies for the Entity  
    INSERT INTO @TempHierarchyTable SELECT ID FROM tblHierarchy WHERE Entity_ID=@Entity_ID ORDER BY ID  
    WHILE EXISTS(SELECT 1 FROM @TempHierarchyTable)  
    BEGIN  
        SELECT TOP 1 @TempHierarchy_ID=ID FROM @TempHierarchyTable ORDER BY ID  
  
        --Get the parent for the selected hierachy for the new member  
        EXECUTE mdm.udpHierarchyParentIDGet @Version_ID,@TempHierarchy_ID,@Entity_ID,@Member_ID,@MemberType_ID,@ParentMember_ID OUTPUT  
  
        --Set the parent for the selected hierachy for the new member  
        IF (@ParentMember_ID > 0) --Do nothing if there is no parent  
        BEGIN  
            -- Lookup the parent member code from the ID.  
            DECLARE  
                @ParentMemberType_ID TINYINT = 2/*Consolidated*/,  
                @ParentMemberCode NVARCHAR(250);  
            EXECUTE mdm.udpMemberCodeGetByID @Version_ID=@Version_ID, @Entity_ID=@Entity_ID, @Member_ID=@ParentMember_ID, @MemberType_ID=@ParentMemberType_ID, @ReturnCode=@ParentMemberCode OUTPUT;  
  
            DECLARE @HierarchyMembers AS mdm.HierarchyMembers  
            INSERT INTO @HierarchyMembers  
                (Hierarchy_ID,      Child_ID,      ChildCode,              ChildMemberType_ID, Target_ID,        TargetCode,        TargetMemberType_ID,  TargetType_ID) VALUES  
                (@TempHierarchy_ID, @NewMember_ID, @DestinationMemberCode, @MemberType_ID,     @ParentMember_ID, @ParentMemberCode, @ParentMemberType_ID, 1/*Parent*/);  
  
            EXECUTE mdm.udpHierarchyMembersUpdate @User_ID=@User_ID, @Version_ID=@Version_ID, @Entity_ID=@Entity_ID, @HierarchyMembers=@HierarchyMembers, @LogFlag=1;  
        END  
  
        DELETE FROM @TempHierarchyTable WHERE ID = @TempHierarchy_ID;  
    END; --while  
  
  
    IF (@@ERROR <> 0) BEGIN  
        RAISERROR('MDSERR500052|The entity member cannot be copied.', 16, 1);  
        ROLLBACK TRAN;  
        RETURN(1);  
    END    ELSE BEGIN  
        COMMIT TRAN;  
        RETURN(0);  
    END; --if  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpMemberCreate]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    EXEC mdm.udpMemberCreate @User_ID=1, @Version_ID = 1, @Hierarchy_ID = 0, @Entity_ID = 7, @MemberType_ID = 1, @MemberName = ' ', @MemberCode = 'NewLeaf2', @LogFlag = 1  
    EXEC mdm.udpMemberCreate @User_ID=1, @Version_ID = 1, @Hierarchy_ID = 1, @Entity_ID = 7, @MemberType_ID = 2, @MemberName = ' ', @MemberCode = 'NewCon2', @LogFlag = 1  
    EXEC mdm.udpMemberCreate @User_ID=1, @Version_ID = 1, @Hierarchy_ID = 0, @Entity_ID = 7, @MemberType_ID = 3, @MemberName = ' ', @MemberCode = 'NewCol2', @LogFlag = 1  
  
*/  
CREATE PROCEDURE [mdm].[udpMemberCreate]  
(  
    @User_ID        INT,  
    @Version_ID     INT,  
    @Hierarchy_ID   INT = NULL,  
    @Entity_ID      INT,  
    @MemberType_ID  TINYINT,  
    @MemberName     NVARCHAR(250) = NULL,  
    @MemberCode     NVARCHAR(250) = NULL,  
    @ReturnID       INT = NULL OUTPUT,  
    @CorrelationID  UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE  
        @SQL                    NVARCHAR(MAX),  
        @TableName              SYSNAME,  
        @SecurityTableName      SYSNAME,  
        @Member_ID              INT,  
        @UseMemberSecurity      BIT,  
        @SecurityRoleID         INT,  
        @IsValidParam           INT,  
        @CodeGenEnabled         BIT = 0,  
        @TransactionLogType     TINYINT,  
        @TransactionLogType_Attribute   TINYINT = 1;  
  
    SET @IsValidParam = 1;  
  
    --Validate @User_ID  
    EXECUTE @IsValidParam = mdm.udpIDParameterCheck @User_ID, 11, NULL, NULL, 1;  
    IF (@IsValidParam = 0)  
    BEGIN  
        RAISERROR('MDSERR100009|The User ID is not valid.', 16, 1);  
        RETURN;  
    END;  
  
    --Validate @Version_ID  
    EXECUTE @IsValidParam = mdm.udpIDParameterCheck @Version_ID, 4, NULL, NULL, 1;  
    IF (@IsValidParam = 0)  
    BEGIN  
        RAISERROR('MDSERR100005|The Version ID is not valid.', 16, 1);  
        RETURN;  
    END;  
  
    --Validate @Entity_ID  
    EXECUTE @IsValidParam = mdm.udpIDParameterCheck @Entity_ID, 5, NULL, NULL, 1;  
    IF (@IsValidParam = 0)  
    BEGIN  
        RAISERROR('MDSERR100004|The Entity ID is not valid.', 16, 1);  
        RETURN;  
    END;  
  
    IF ((@MemberType_ID <> 1) AND (@MemberType_ID <> 2) AND (@MemberType_ID <> 3))  
        OR ((@MemberType_ID = 2) AND (@Hierarchy_ID IS NULL))  
    BEGIN  
        RAISERROR('MDSERR100010|The Parameters are not valid.', 16, 1);  
        RETURN;  
    END;  
  
    --Figure out whether code gen is enabled  
    DECLARE @result INT;  
    EXEC @result = mdm.udpIsCodeGenEnabled @Entity_ID;  
    SET @CodeGenEnabled = CONVERT(BIT, @result);  
  
    SELECT  
        --Clean member code value  
        @MemberCode = NULLIF(LTRIM(RTRIM(@MemberCode)), N''),  
        --Clean member name value  
        @MemberName = NULLIF(LTRIM(RTRIM(@MemberName)), N''); --Ditto, except allow NULLs  
  
    IF @MemberCode IS NULL AND (@CodeGenEnabled = 0 OR @MemberType_ID <> 1)  
        BEGIN  
            RAISERROR('MDSERR310022|The code can not be empty', 16, 1);  
            RETURN;  
        END  
  
    IF mdm.udfItemReservedWordCheck(12, @MemberCode) = 1 BEGIN --Currently, reserved words are the same for leaf, consolidation, and collection members  
        RAISERROR('MDSERR100027|The code is a reserved word. Specify a different value.', 16, 1);  
        RETURN;  
    END; --if  
  
    SELECT @TableName = mdm.udfTableNameGetByID(@Entity_ID, @MemberType_ID);  
    IF @TableName IS NULL  
    BEGIN  
        RAISERROR('MDSERR100100|The target table for the requested entity and MemberType ID does not exist.', 16, 1);  
        RETURN;  
    END; --if  
  
    SET @SecurityTableName = CAST(@TableName + '_MS' AS SYSNAME);  
  
    SELECT @TransactionLogType = TransactionLogType  
    FROM mdm.tblEntity  
    WHERE ID = @Entity_ID;  
  
    --Start transaction, being careful to check if we are nested  
    DECLARE @TranCounter INT;  
    SET @TranCounter = @@TRANCOUNT;  
    IF @TranCounter > 0 SAVE TRANSACTION TX;  
    ELSE BEGIN TRANSACTION;  
  
    BEGIN TRY  
        --If code gen is enabled on this entity  
        IF @CodeGenEnabled = 1  
            BEGIN  
                --Check if the passed in member code is null  
                IF @MemberCode IS NULL  
                    BEGIN  
                        --If the member type is leaf  
                        IF @MemberType_ID = 1  
                            BEGIN  
                                --Generate a new code and assign it  
                                DECLARE @NextCode INT;  
                                EXEC @NextCode = mdm.udpGenerateNextCode @Entity_ID = @Entity_ID;  
                                SET @MemberCode = CONVERT(NVARCHAR(250), @NextCode);  
                            END  
                    END  
                --If the provided code is non-null we still must process it to update the largest code value  
                ELSE  
                    BEGIN  
                        --Gather up the valid user provided codes  
                        DECLARE @CodesToProcess mdm.MemberCodes;  
  
                        INSERT @CodesToProcess (MemberCode)  
                        VALUES (@MemberCode);  
  
                        --Process the user-provided codes to update the code gen info table with the largest one  
                        EXEC mdm.udpProcessCodes @Entity_ID, @CodesToProcess;  
                    END  
            END  
  
        --Insert into the appropriate entity table  
        SET @SQL = N'  
            INSERT INTO mdm.' + QUOTENAME(@TableName) + N'  
            (  
                Version_ID,  
                Status_ID,  
                Name,  
                Code,' + CASE @MemberType_ID WHEN 2 THEN N'  
                Hierarchy_ID,' WHEN 3 THEN N'  
                [Owner_ID],' ELSE N'' END + N'  
                EnterDTM,  
                EnterUserID,  
                EnterVersionID,  
                LastChgDTM,  
                LastChgUserID,  
                LastChgVersionID  
            )  
            VALUES  
            (  
                @Version_ID  
                ,1  
                ,@Name  
                ,@Code' + CASE @MemberType_ID WHEN 2 THEN N'  
                ,@Hierarchy_ID' WHEN 3 THEN N'  
                ,@User_ID' ELSE N'' END + N'  
                ,GETUTCDATE()  
                ,@User_ID  
                ,@Version_ID  
                ,GETUTCDATE()  
                ,@User_ID  
                ,@Version_ID  
            );  
  
            SET @Member_ID = SCOPE_IDENTITY();';  
  
        --PRINT(@SQL);  
        EXEC sp_executesql @SQL,  
            N'@User_ID INT, @Version_ID INT, @Hierarchy_ID INT, @Name NVARCHAR(250), @Code NVARCHAR(250), @Member_ID INT OUTPUT',  
            @User_ID, @Version_ID, @Hierarchy_ID, @MemberName, @MemberCode, @Member_ID OUTPUT;  
  
        --Create the hierarchy relationship(s) and set the parent to 0 (Root). Children are assigned to all hierarchies.  
        IF @MemberType_ID = 1 BEGIN  
  
            DECLARE @TempTable TABLE(ID INT NOT NULL);  
            DECLARE @TempHierachy_ID AS INT;  
  
            INSERT INTO @TempTable(ID)  
            SELECT ID FROM mdm.tblHierarchy  
            WHERE Entity_ID = @Entity_ID AND IsMandatory = 1;  
  
            WHILE EXISTS(SELECT 1 FROM @TempTable) BEGIN  
                SELECT TOP 1 @TempHierachy_ID = ID FROM @TempTable;  
  
                EXEC mdm.udpHierarchyCreate @User_ID, @Version_ID, @Entity_ID, @TempHierachy_ID, 0, @Member_ID, 1;  
  
                DELETE FROM @TempTable WHERE ID = @TempHierachy_ID;  
            END; --while  
  
        END    ELSE IF @MemberType_ID = 2 BEGIN --Parent  
  
            EXEC mdm.udpHierarchyCreate @User_ID, @Version_ID, @Entity_ID, @Hierarchy_ID, 0, @Member_ID, 2;  
  
        END; --if  
  
        --Log the transaction  
        IF @TransactionLogType = @TransactionLogType_Attribute   
        BEGIN  
            EXEC mdm.udpTransactionSave @User_ID, @Version_ID, 1, NULL, @Hierarchy_ID, @Entity_ID, @Member_ID, @MemberType_ID, NULL, NULL, NULL;  
        END; --if  
  
        --Add a message to the Securi  
        SELECT @ReturnID = @Member_ID;  
  
        --Check to see if member security is in play  
        SET @UseMemberSecurity = mdm.udfUseMemberSecurity(@User_ID, @Entity_ID, @Version_ID, @MemberType_ID);  
  
        --Add a record to the MS table for the user which created the member so it will be visible to the creator  
        IF @MemberType_ID IN (1,2) AND @UseMemberSecurity <> 0  
        BEGIN  
            --Get the role for the user  
            SELECT @SecurityRoleID=Role_ID FROM mdm.tblSecurityAccessControl where Principal_ID=@User_ID AND PrincipalType_ID=1;  
  
            -- Role ID can be null for a user when user permissions are inherited only from a group. The permission for the member added  
            -- should be set to update for the user. This requires that the sercurity role be added for the user.  
            -- Correct security permissions are applied when the member security update batch process is run by the sql broker.  
            If(    @SecurityRoleID IS NULL)  
            BEGIN  
  
                DECLARE @Principal_Name Nvarchar (100)  
                SELECT @Principal_Name = UserName From mdm.tblUser where ID = @User_ID;  
  
                INSERT INTO mdm.tblSecurityRole ([Name], EnterUserID, LastChgUserID) VALUES  
                        (CONCAT(N'Role for UserAccount', @Principal_Name), 1, 1);  
                SET @SecurityRoleID = SCOPE_IDENTITY() ;  
  
                INSERT INTO mdm.tblSecurityAccessControl (PrincipalType_ID, Principal_ID, Role_ID, Description, EnterUserID, LastChgUserID)  
                VALUES (1, @User_ID, @SecurityRoleID, CONCAT(@Principal_Name, N' UserAccount'), 1, 1);  
  
            END  
  
            SET @SQL = N'  
                INSERT INTO mdm.' + QUOTENAME(@SecurityTableName) + N'  
                (  
                    Version_ID,  
                    User_ID,  
                    ID,  
                    AccessPermission  
                )  
                VALUES  
                (  
                     @Version_ID  
                    ,@User_ID  
                    ,@ReturnID  
                    ,7 -- All  
                );';  
            EXEC sp_executesql @SQL, N'@Version_ID INT, @User_ID INT, @ReturnID INT', @Version_ID, @User_ID, @ReturnID;  
        END  
  
        --Put a msg onto the SB queue to process member security  
        EXEC mdm.udpSecurityMemberQueueSave  
            @User_ID    = NULL,-- update member security for all users  
            @Version_ID = @Version_ID,  
            @Entity_ID  = @Entity_ID;  
  
        --Commit only if we are not nested  
        IF @TranCounter = 0 COMMIT TRANSACTION;  
  
        -- Send the message  
	    EXEC mdm.udpPerformanceQueueSave;  
  
        RETURN(0);  
  
    END TRY  
    --Compensate as necessary  
    BEGIN CATCH  
  
        -- Get error info.  
        DECLARE  
            @ErrorMessage NVARCHAR(4000),  
            @ErrorSeverity INT,  
            @ErrorState INT,  
            @ErrorNumber INT,  
            @ErrorLine INT,  
            @ErrorProcedure NVARCHAR(126);  
        EXEC mdm.udpGetErrorInfo  
            @ErrorMessage = @ErrorMessage OUTPUT,  
            @ErrorSeverity = @ErrorSeverity OUTPUT,  
            @ErrorState = @ErrorState OUTPUT,  
            @ErrorNumber = @ErrorNumber OUTPUT,  
            @ErrorLine = @ErrorLine OUTPUT,  
            @ErrorProcedure = @ErrorProcedure OUTPUT  
  
        SET @ErrorMessage = CONCAT(@ErrorMessage, N', @ErrorNumber = ', @ErrorNumber, N', @ErrorProcedure = "', @ErrorProcedure, N'", line ', @ErrorLine);  
  
        IF @TranCounter = 0 ROLLBACK TRANSACTION;  
        ELSE IF XACT_STATE() <> -1 ROLLBACK TRANSACTION TX;  
  
        RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);  
  
        --On error, return NULL results  
        SELECT @ReturnID = NULL;  
        RETURN(1);  
  
    END CATCH;  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpMemberDisplayCodeGetByID]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
  
DECLARE @Tempvar NVARCHAR(250)  
EXEC mdm.udpMemberDisplayCodeGetByID 'admin',1,9,'7',1,@TempVar OUTPUT  
select @Tempvar  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpMemberDisplayCodeGetByID]  
(  
	@Version_ID		INTEGER,  
	@Entity_ID     	INTEGER,  
	@Member_ID		INTEGER,  
	@MemberType_ID	TINYINT,  
	@DisplayType	INT,  
	@ReturnCode		NVARCHAR(1000) OUTPUT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
	SET NOCOUNT ON  
  
	DECLARE @SQL 			NVARCHAR(MAX)  
	DECLARE @TempCount 		INTEGER  
	DECLARE @TempTableName 	sysname  
	DECLARE @TempCode		NVARCHAR(502)  
	DECLARE @TempName		NVARCHAR(250)  
  
	SELECT @TempTableName = mdm.udfTableNameGetByID(@Entity_ID,@MemberType_ID);  
  
	SET @ReturnCode = CAST(N'0' AS NVARCHAR(1000)) ;  
	   
		SET @SQL = N'  
			SELECT   
				@TempCode = Code,   
				@TempName = ISNULL(Name,'''')  
			FROM mdm.' + quotename(@TempTableName) + N'   
			WHERE Version_ID = @Version_ID   
			AND ID = @Member_ID';  
		EXEC sp_executesql @SQL, N'@Version_ID INT, @Member_ID INT, @TempCode NVARCHAR(502) OUTPUT, @TempName NVARCHAR(250) OUTPUT', @Version_ID, @Member_ID, @TempCode OUTPUT, @TempName OUTPUT;  
		  
		IF @@ROWCOUNT = 1 BEGIN  
			IF @DisplayType = 1 BEGIN  
				SET @ReturnCode = CAST(@TempCode	 AS NVARCHAR(1000))  
			END ELSE IF @DisplayType = 2 BEGIN  
				SET @ReturnCode = CAST(@TempCode	+ N'{' + @TempName + N'}' AS NVARCHAR(1000))  
			END ELSE IF @DisplayType = 3 BEGIN  
				SET @ReturnCode = CAST(@TempName	+ N'{' + @TempCode + N'}' AS NVARCHAR(1000))  
			END ELSE BEGIN  
				SET @ReturnCode = CAST(N'0' AS NVARCHAR(1000))  
			END; --if  
		END ELSE BEGIN  
			SET @ReturnCode = CAST(N'0' AS NVARCHAR(1000));  
		END; --if  
  
	SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpMemberIDGetByCode]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
--Either active or inactive  
DECLARE @Tempvar NVARCHAR(250)  
EXEC mdm.udpMemberIDGetByCode 2,13,'01-A7150',1,@TempVar OUTPUT  
select @Tempvar  
  
  
  
--Active Only  
DECLARE @Tempvar NVARCHAR(250)  
EXEC mdm.udpMemberIDGetByCode 2,13,'01-A7150',1,@TempVar OUTPUT,1  
select @Tempvar  
  
*/  
CREATE PROCEDURE [mdm].[udpMemberIDGetByCode]  
(  
    @Version_ID     INTEGER,  
    @Entity_ID      INTEGER,  
    @MemberCode     NVARCHAR(250),  
    @MemberType_ID  TINYINT,  
    @ReturnID       INTEGER OUTPUT,  
    @IsActive       BIT = 1,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE @SQL            NVARCHAR(MAX),  
            @TempTableName     sysname,  
            @TempCount         INTEGER,  
            @TempID            INTEGER;  
  
    -- Trim MemberCode  
    SET @MemberCode = NULLIF(LTRIM(RTRIM(@MemberCode)), N'');  
  
    SET @TempTableName = mdm.udfTableNameGetByID(@Entity_ID, @MemberType_ID);  
  
    IF @IsActive = 1   
        -- Return the ID only if the member is still active.  
        SET @SQL = N'  
            SELECT @TempID = ID FROM mdm.' + quotename(@TempTableName) + N'   
            WHERE Status_ID=1 AND Version_ID = @Version_ID  
            AND Code = @Code;';  
    ELSE  
        -- Return the ID if the member is active or inactive  
        SELECT @SQL = N'  
            SELECT @TempID = ID FROM mdm.' + quotename(@TempTableName) + N'   
            WHERE Version_ID = @Version_ID  
            AND Code = @Code;';  
  
    EXEC sp_executesql @SQL, N'@Version_ID INT, @Code NVARCHAR(250), @TempID int OUTPUT', @Version_ID, @MemberCode, @TempID OUTPUT;  
  
    SET @ReturnID = ISNULL(@TempID, 0);  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpMemberPriorValueGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
	DECLARE @var NVARCHAR(MAX);  
	EXEC mdm.udpMemberPriorValueGet 1,'tbl_1_1_EN','uda_1_72',2,@var OUTPUT;  
	SELECT @var;  
	SELECT * FROM mdm.tbl_1_1_EN;  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpMemberPriorValueGet]  
(  
	@Version_ID	INT,  
	@TableName	sysname,  
	@ColumnName	sysname,  
	@Member_ID	INT,	  
	@PriorValue	NVARCHAR(MAX) = NULL OUTPUT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
	SET NOCOUNT ON;  
  
	DECLARE @SQL	NVARCHAR(MAX),  
			@Value	NVARCHAR(MAX);  
  
	SET @SQL = N'  
		SELECT @Value = ' + quotename(@ColumnName) + N'   
		FROM mdm.' + quotename(@TableName) + N'   
		WHERE Version_ID = @Version_ID  
		AND ID = @Member_ID';  
  
	EXEC sp_executesql @SQL, N'@Version_ID INT, @Member_ID INT, @Value NVARCHAR(MAX) OUTPUT', @Version_ID, @Member_ID, @Value OUTPUT;  
	SET @PriorValue = @Value;  
  
	SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpMemberSearch]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
*** NOTE: ANY CHANGES TO THE COLUMNS RETURNED IN THIS PROCEDURE MUST BE MADE IN THE COMPANION STORED PROCEDURE: mdm.udpSecurityHierarchyMemberSearchPrivilegesGet.  
  
  
EXEC mdm.udpMemberSearch @User_ID =1, @Version_ID = 3, @Hierarchy_ID = 1, @HierarchyType_ID = 0, @Entity_ID = 1, @SearchTerm = 'it''s'  
EXEC mdm.udpMemberSearch @User_ID =1, @Version_ID = 3, @Hierarchy_ID = 1, @HierarchyType_ID = 0, @Entity_ID = 1, @SearchTerm = '%profit%'  
--Derived Hierarchy  
EXEC mdm.udpMemberSearch @User_ID =1, @Version_ID = 19, @Hierarchy_ID = 7, @HierarchyType_ID = 1, @Entity_ID = 0, @SearchTerm = 'BK%'  
*/  
CREATE PROCEDURE [mdm].[udpMemberSearch]  
(  
    @User_ID            INT,  
    @Version_ID         INT,  
    @Hierarchy_ID       INT,  
    @HierarchyType_ID   TINYINT,  
    @Entity_ID          INT,  
    @SearchTerm         NVARCHAR(500),  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON  
  
    SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED  
    DECLARE @ParamList          NVARCHAR(MAX),  
    @SQLString                  NVARCHAR(MAX),  
    @TempCNName                 NVARCHAR(100),  
    @Entity_Muid                UNIQUEIDENTIFIER,  
    @Hierarchy_Muid             UNIQUEIDENTIFIER,  
    @ViewName                   SYSNAME,  
    @EntitySecurityTable        SYSNAME,  
    @HierarchyParentSecurityTable   SYSNAME,  
    @LeafPrivilege_ID           INT,  
    @LeafAccessPermission       TINYINT,  
    @ConsolidatedPrivilege_ID   INT,  
    @ConsolidatedAccessPermission   TINYINT,  
    @CollectionPrivilege_ID     INT,  
    @CollectionAccessPermission TINYINT,  
    @PrivilegeID                INT,  
    @UseMemberSecurity          BIT,  
    @MemberSecurityCTE          NVARCHAR(MAX),  
  
    @MemberType_Leaf                TINYINT = 1,  
    @MemberType_Consolidated        TINYINT = 2,  
      
    @HierarchyType_Explicit         TINYINT = 0,  
    @HierarchyType_Derived          TINYINT = 1,  
    @HierarchyType_Collection       TINYINT = 2;  
  
  
    IF @Entity_ID IS NOT NULL --When searching a derived hierarchy the entity might not be passed in  
    BEGIN  
        --SELECT @LeafPrivilege_ID = mdm.udfSecurityUserMemberDefault(@User_ID, @Entity_ID, 3, 1)  
        --SELECT @ConsolidatedPrivilege_ID = mdm.udfSecurityUserMemberDefault(@User_ID, @Entity_ID, 3, 2)  
        --SELECT @CollectionPrivilege_ID = mdm.udfSecurityUserMemberDefault(@User_ID, @Entity_ID, 3, 3)  
        --PERF - moved these calls to a udp to decrease the execution plan compile time.  
        EXEC mdm.udpSecurityUserMemberType @User_ID = @User_ID, @Entity_ID = @Entity_ID, @MemberType_ID = 1, @Privilege_ID = @LeafPrivilege_ID OUTPUT, @AccessPermission = @LeafAccessPermission OUTPUT;  
        EXEC mdm.udpSecurityUserMemberType @User_ID = @User_ID, @Entity_ID = @Entity_ID, @MemberType_ID = 2, @Privilege_ID = @ConsolidatedPrivilege_ID OUTPUT, @AccessPermission = @LeafAccessPermission OUTPUT;  
        EXEC mdm.udpSecurityUserMemberType @User_ID = @User_ID, @Entity_ID = @Entity_ID, @MemberType_ID = 3, @Privilege_ID = @CollectionPrivilege_ID OUTPUT, @AccessPermission = @LeafAccessPermission OUTPUT;  
  
        SELECT  
            @EntitySecurityTable = CAST(EntityTable + '_MS' AS SYSNAME),  
            @HierarchyParentSecurityTable = CASE WHEN HierarchyParentTable IS NOT NULL THEN CAST(HierarchyParentTable + '_MS' AS SYSNAME) ELSE NULL END  
        FROM mdm.tblEntity  
        WHERE ID = @Entity_ID;  
  
        SET @UseMemberSecurity = mdm.udfUseMemberSecurity(@User_ID, @Entity_ID, @Version_ID, NULL);  
  
        IF @LeafPrivilege_ID = 99  
        BEGIN  
            SET @LeafPrivilege_ID = 4; -- Access  
            SET @LeafAccessPermission = 0; -- ReadOnly  
        END  
        IF @ConsolidatedPrivilege_ID = 99  
        BEGIN  
            SET @ConsolidatedPrivilege_ID = 4; -- Access  
            SET @ConsolidatedAccessPermission = 0; -- ReadOnly  
        END  
  
        --These cte's are selectively added to the overall query based on if member security is needed to be applied  
        SET @MemberSecurityCTE = CONCAT(N'  
        WITH membersresolved as  
        (  
            SELECT  
                ID AS Member_ID,  
                ', @MemberType_Leaf, N' AS MemberType_ID,  
                AccessPermission  
            FROM  
                mdm.', QUOTENAME(@EntitySecurityTable), N' X  
            WHERE X.User_ID = @User_ID  
                AND X.Version_ID = @Version_ID',  
                CASE  
                    WHEN @HierarchyParentSecurityTable IS NOT NULL THEN CONCAT(N'  
            UNION ALL  
            SELECT  
                ID AS Member_ID,  
                ', @MemberType_Consolidated, N' AS MemberType_ID,  
                AccessPermission  
            FROM  
                mdm.', QUOTENAME(@HierarchyParentSecurityTable), N' X  
            WHERE X.User_ID = @User_ID  
                AND X.Version_ID = @Version_ID')  
                    ELSE N''  
                END, N'  
        )');  
  
    END  
  
  
  
    IF @HierarchyType_ID = @HierarchyType_Explicit  
    BEGIN  
        SELECT @ViewName   = mdm.udfViewNameGetByID(@Entity_ID, 4, 0, 0)  
        SELECT @Entity_Muid=MUID FROM mdm.tblEntity WHERE ID=@Entity_ID  
        SELECT @Hierarchy_Muid=MUID FROM mdm.tblHierarchy WHERE ID=@Hierarchy_ID  
  
        SELECT @SQLString = CASE @UseMemberSecurity WHEN 1 THEN @MemberSecurityCTE ELSE '' END + N'  
                SELECT TOP 500  
                    Child_Code AS Code,  
                    Child_Name AS Name,  
                    CONVERT(int,T.ChildType_ID) AS ChildType_ID,  
                    @Entity_Muid AS ChildEntity_MUID,  
                    Parent_Code AS ParentCode,  
                    Parent_Name AS ParentName,  
                    2 AS ParentType_ID,  
                    @Entity_Muid AS ParentEntity_MUID,  
                    @Hierarchy_Muid AS RelationshipId,  
                    2 AS RelationshipTypeId, --2 is Hierarchy ItemType '  
                    IF @UseMemberSecurity <> 0 SET @SQLString = @SQLString + N'  
                    @LeafPrivilege_ID AS Privilege_ID, CONVERT(INTEGER,ISNULL(SR.AccessPermission, @LeafAccessPermission)) AS AccessPermission'  
                    ELSE IF @UseMemberSecurity = 0 SET @SQLString = @SQLString + N'  
                    @LeafPrivilege_ID AS Privilege_ID, @LeafAccessPermission as AccessPermission'  
                    SET @SQLString = @SQLString + N'  
  
                FROM  
                    mdm.' + QUOTENAME(@ViewName) + N' T '  
        IF @UseMemberSecurity <> 0 SET @SQLString = @SQLString + N'  
                LEFT JOIN membersresolved SR  
                    ON SR.MemberType_ID = T.ChildType_ID  
                    AND SR.Member_ID = T.Child_ID'  
  
        SELECT @SQLString = @SQLString + N'  
                WHERE  
                    T.Version_ID = @Version_ID AND  
                    Hierarchy_ID = @Hierarchy_ID AND '  
        IF @UseMemberSecurity <> 0  
        BEGIN  
            SET @SQLString += N'  
                    (SR.Privilege_ID IS NOT NULL OR T.ChildType_ID <> 1) AND';  
        END  
        SELECT @SQLString = @SQLString + N'  
                    (  
                        Child_Code LIKE @SearchTerm  
                    OR Child_Name LIKE @SearchTerm  
                    )  
                ORDER BY T.Child_ID'  
  
        SET @ParamList = CAST(N'@Entity_ID   INT  
            , @LeafPrivilege_ID             INT  
            , @LeafAccessPermission         TINYINT  
            , @User_ID                      INT  
            , @Version_ID                   INT  
            , @SearchTerm                   NVARCHAR(500)  
            , @ConsolidatedPrivilege_IDx    INT  
            , @Hierarchy_ID                 INT  
            , @Entity_Muid                    UNIQUEIDENTIFIER  
            , @Hierarchy_Muid               UNIQUEIDENTIFIER' AS NVARCHAR(max))  
  
        EXEC sp_executesql @SQLString, @ParamList  
                ,@Entity_ID  
                ,@LeafPrivilege_ID  
                ,@LeafAccessPermission  
                ,@User_ID  
                ,@Version_ID  
                ,@SearchTerm  
                ,@ConsolidatedPrivilege_ID  
                ,@Hierarchy_ID  
                ,@Entity_Muid  
                ,@Hierarchy_Muid  
  
    END  
    ELSE IF @HierarchyType_ID = @HierarchyType_Derived  
    BEGIN  
  
        DECLARE   
             @Model_ID          INT  
            ,@IsModelAdmin      BIT = 0  
              
            ,@Permission_Admin  TINYINT = 5;  
  
        SELECT   
             @Model_ID = dh.Model_ID   
            ,@IsModelAdmin = CASE WHEN m.Privilege_ID = @Permission_Admin THEN 1 ELSE 0 END  
        FROM mdm.tblDerivedHierarchy dh  
        LEFT JOIN mdm.viw_SYSTEM_SECURITY_USER_MODEL m  
        ON dh.Model_ID = m.ID  
        WHERE dh.ID = @Hierarchy_ID  
  
        SELECT @ViewName = CONCAT(N'viw_SYSTEM_', @Model_ID, N'_', @Hierarchy_ID, N'_PARENTCHILD_DERIVED')  
  
        IF @IsModelAdmin = 0  
        BEGIN  
            -- Need to check security for each entity. Store the results in a temp table for processing  
            CREATE TABLE #Matches  
            (  
                 Code               NVARCHAR(250) COLLATE DATABASE_DEFAULT  
                ,Name               NVARCHAR(250) COLLATE DATABASE_DEFAULT  
                ,Child_ID           INT  
                ,ChildType_ID       INT  
                ,ChildEntity_ID     INT  
                ,ChildEntity_MUID   UNIQUEIDENTIFIER  
                ,ParentCode         NVARCHAR(250) COLLATE DATABASE_DEFAULT  
                ,ParentName         NVARCHAR(250) COLLATE DATABASE_DEFAULT  
                ,ParentType_ID      INT  
                ,RelationshipId     UNIQUEIDENTIFIER  
                ,RelationshipTypeId INT  
                ,NextItem_ID        INT  
                ,NextItemType_ID    INT  
                ,DomainAttribute_ID INT  
                ,ParentEntity_MUID  UNIQUEIDENTIFIER  
  
                ,MemberTypePrivilege_ID       TINYINT  
                ,MemberTypeAccessPermission   TINYINT  
  
                ,ChildPrivilege_ID      INT  
                ,ChildAccessPermission  INT  
            );  
            CREATE INDEX #ix_Matches_ChildEntity_ID_ChildType_ID_Child_ID ON #Matches (ChildEntity_ID, ChildType_ID, Child_ID)  
        END  
        SELECT @SQLString = CONCAT(--CASE WHEN @UseMemberSecurity = 1 THEN @MemberSecurityCTE END, N'  
            CASE WHEN @IsModelAdmin = 0 THEN N'  
    INSERT INTO #Matches  
    (  
         Code  
        ,Name  
        ,ChildType_ID  
        ,ChildEntity_MUID  
        ,ParentCode  
        ,ParentName  
        ,ParentType_ID  
        ,RelationshipId  
        ,RelationshipTypeId  
        ,NextItem_ID  
        ,NextItemType_ID  
        ,DomainAttribute_ID  
        ,ParentEntity_MUID  
        ,MemberTypePrivilege_ID  
        ,MemberTypeAccessPermission  
        ,Child_ID  
        ,ChildEntity_ID  
    )' END, N'  
    SELECT TOP 500  
        ChildCode AS Code,  
        ChildName AS Name,  
        ChildType_ID,  
        Entity_MUID AS ChildEntity_MUID,  
        ParentCode,  
        ParentName,  
        ParentType_ID,  
        Item_MUID AS RelationshipId,  
        ItemType_ID AS RelationshipTypeId,  
        NextItem_ID,  
        NextItemType_ID,  
        DomainAttribute_ID,  
        ParentEntity_MUID,  
        mtSec.Privilege_ID,  
        mtSec.AccessPermission', CASE WHEN @IsModelAdmin = 0 THEN N',  
        T.Child_ID,  
        T.Entity_ID AS ChildEntity_ID' END, N'  
    FROM mdm.', QUOTENAME(@ViewName), N' T  
    INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_MEMBERTYPE mtSec  
    ON      T.Entity_ID = mtSec.Entity_ID  
        AND T.ChildType_ID = mtSec.ID   
        AND mtSec.User_ID = @User_ID  
    WHERE   T.Version_ID = @Version_ID   
        AND T.ItemType_ID <> 3   
        AND (   T.ChildCode LIKE @SearchTerm  
             OR T.ChildName LIKE @SearchTerm  
            )   
    ORDER BY T.Item_ID')  
  
        SET @ParamList = CAST(N'  
                 @User_ID       INT  
                ,@Version_ID    INT  
                ,@SearchTerm    NVARCHAR(500)'  AS NVARCHAR(max))  
        PRINT @SQLString  
        EXEC sp_executesql @SQLString, @ParamList  
            ,@User_ID  
            ,@Version_ID  
            ,@SearchTerm  
  
        IF @IsModelAdmin = 0  
        BEGIN  
            -- The above query stored the results into a temp table. Lookup member permissions, if applicable, for each entity  
              
            -- If the hierarchy has an explicit cap, get the corresponding entity ID  
            DECLARE @ConsolidatedCapEntity_ID INT;              
            SELECT @ConsolidatedCapEntity_ID = h.Entity_ID   
            FROM mdm.tblDerivedHierarchyDetail dhd  
            INNER JOIN mdm.tblHierarchy h  
            ON dhd.Foreign_ID = h.ID  
            WHERE   dhd.DerivedHierarchy_ID = @Hierarchy_ID   
                AND dhd.ForeignType_ID = 2/*Hierarchy*/  
  
            -- Get all referenced entities  
            DECLARE @Entities TABLE  
            (  
                 ID                             INT PRIMARY KEY  
                ,EntitySecurityTable            SYSNAME COLLATE DATABASE_DEFAULT NULL  
                ,HierarchyParentSecurityTable   SYSNAME COLLATE DATABASE_DEFAULT NULL  
            );  
            INSERT INTO @Entities (ID)  
            SELECT DISTINCT ChildEntity_ID AS ID   
            FROM #Matches  
  
            -- Lookup entity member security table names  
            UPDATE eid  
            SET  EntitySecurityTable = CONCAT(e.EntityTable, N'_MS')  
                ,HierarchyParentSecurityTable = CASE WHEN HierarchyParentTable IS NOT NULL THEN CONCAT(HierarchyParentTable, N'_MS') END  
            FROM @Entities eid  
            INNER JOIN mdm.tblEntity e  
            ON eid.ID = e.ID  
  
            SET @Entity_ID = 0  
            WHILE EXISTS (SELECT 1 FROM @Entities WHERE ID > @Entity_ID)  
            BEGIN  
                SELECT TOP 1  
                     @Entity_ID = ID  
                    ,@EntitySecurityTable = EntitySecurityTable  
                    ,@HierarchyParentSecurityTable = HierarchyParentSecurityTable  
                FROM @Entities  
                WHERE ID > @Entity_ID  
                ORDER BY ID  
  
                SET @UseMemberSecurity = mdm.udfUseMemberSecurity(@User_ID, @Entity_ID, @Version_ID, @MemberType_Leaf);  
                IF @UseMemberSecurity = 1  
                BEGIN  
                    -- Get Leaf member security  
                    SET @SQLString = CONCAT (N'  
                        UPDATE m  
                        SET  ChildPrivilege_ID = MemberTypePrivilege_ID  
                            ,ChildAccessPermission = ms.AccessPermission  
                        FROM #Matches m  
                        INNER JOIN mdm.', QUOTENAME(@EntitySecurityTable), N' ms  
                        ON      ms.Version_ID = @Version_ID  
                            AND ms.User_ID = @User_ID  
                            AND m.Child_ID = ms.ID  
                            AND m.ChildEntity_ID = @Entity_ID  
                            AND m.ChildType_ID = ', @MemberType_Leaf, N'--Leaf  
                        ')  
                    SET @ParamList = N'@User_ID INT, @Version_ID INT, @Entity_ID INT';  
                    PRINT @SQLString  
                    EXEC sp_executesql @SQLString, @ParamList, @User_ID, @Version_ID, @Entity_ID  
                END ELSE  
                BEGIN  
                    -- Member security does not used for this entity's leaf members. So use the MemberType security.  
                    UPDATE #Matches  
                    SET  
                         ChildPrivilege_ID = MemberTypePrivilege_ID  
                        ,ChildAccessPermission = MemberTypeAccessPermission  
                    WHERE   ChildEntity_ID = @Entity_ID  
                        AND ChildType_ID = @MemberType_Leaf;  
                END -- Not using member security  
  
                IF @Entity_ID = @ConsolidatedCapEntity_ID AND @HierarchyParentSecurityTable IS NOT NULL  
                BEGIN  
                    -- The entity pertains to a consolidated cap. Determine if its consolidated members use member security.  
                    SET @UseMemberSecurity = mdm.udfUseMemberSecurity(@User_ID, @Entity_ID, @Version_ID, @MemberType_Consolidated);  
                    IF @UseMemberSecurity = 1  
                    BEGIN  
                        -- Get Consolidated member security  
                        SET @SQLString = CONCAT (N'  
                            UPDATE m  
                            SET  ChildPrivilege_ID = MemberTypePrivilege_ID  
                                ,ChildAccessPermission = ms.AccessPermission  
                            FROM #Matches m  
                            INNER JOIN mdm.', QUOTENAME(@HierarchyParentSecurityTable), N' ms  
                            ON      ms.Version_ID = @Version_ID  
                                AND ms.User_ID = @User_ID  
                                AND m.Child_ID = ms.ID  
                                AND m.ChildEntity_ID = @Entity_ID  
                                AND m.ChildType_ID = ', @MemberType_Consolidated, N'--Consolidated  
                            ')  
                        SET @ParamList = N'@User_ID INT, @Version_ID INT, @Entity_ID INT';  
                        PRINT @SQLString  
                        EXEC sp_executesql @SQLString, @ParamList, @User_ID, @Version_ID, @Entity_ID  
                    END ELSE  
                    BEGIN  
                        -- Member security does not used for this entity's leaf members. So use the MemberType security.  
                        UPDATE #Matches  
                        SET  
                             ChildPrivilege_ID = MemberTypePrivilege_ID  
                            ,ChildAccessPermission = MemberTypeAccessPermission  
                        WHERE   ChildEntity_ID = @Entity_ID  
                            AND ChildType_ID = @MemberType_Consolidated;  
                    END -- Not using consolidated member security  
                END -- loop through entities  
  
            END  
  
            -- Return the records which the user is authorized to see  
            SELECT   
                 Code  
                ,Name  
                ,ChildType_ID  
                ,ChildEntity_MUID  
                ,ParentCode  
                ,ParentName  
                ,ParentType_ID  
                ,RelationshipId  
                ,RelationshipTypeId  
                ,NextItem_ID  
                ,NextItemType_ID  
                ,DomainAttribute_ID  
                ,ParentEntity_MUID  
                ,ChildPrivilege_ID      AS Privilege_ID  
                ,ChildAccessPermission  AS AccessPermission  
            FROM #Matches m  
            WHERE ISNULL(ChildPrivilege_ID, 1) > 1  
        END -- Not model admin  
  
    END -- derived hierarchy  
    ELSE IF @HierarchyType_ID = @HierarchyType_Collection  
    BEGIN  
        SELECT @TempCNName = mdm.udfViewNameGetByID(@Entity_ID,3,1, 0)  
  
        SELECT @SQLString = @MemberSecurityCTE + N'  
                SELECT TOP 500  
                    ID,  
                    Code as Code,  
                    Name as Name,  
                    3 as MemberType_ID,  
                    @Entity_ID  as Item_ID,  
                    1 as ItemType_ID,  
                    @Entity_ID  as NextItem_ID,  
                    1 as NextItemType_ID,  
                    @CollectionPrivilegeID as ModelPrivilege_ID,  
                    4 AS Privilege_ID, -- Access  
                    0 AS AccessPermission  -- ReadOnly  
                WHERE  
                    T.Version_ID = @Version_ID AND  
                    @CollectionPrivilegeID <> 1 AND  
                    (  
                    Code LIKE @SearchTerm  
                    OR  
                    Name LIKE @SearchTerm  
                    )  ORDER BY ID  
                '  
  
                SET @ParamList = CAST(N'@Entity_ID       INT  
                    , @CollectionPrivilegeID       INT  
                    , @User_ID                     INT  
                    , @Version_ID                  INT  
                    , @SearchTerm                  NVARCHAR(500)'  AS NVARCHAR(max))  
  
                EXEC sp_executesql @SQLString, @ParamList  
                    ,@Entity_ID  
                    ,@CollectionPrivilege_ID  
                    ,@User_ID  
                    ,@Version_ID  
                    ,@SearchTerm  
    END  
  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpMembersStatusSet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
DECLARE @MemberIdList mdm.IdList;  
INSERT INTO @MemberIdList  
VALUES (1), (2), (3)  
  
EXEC mdm.udpMembersStatusSet @User_ID=1, @Version_ID=20, @Entity_ID=37, @MemberIds = @MemberIds, @Status_ID=2  
  
SELECT * FROM mdm.tblAttribute WHERE DomainEntity_ID=37  
  
**********************************************************  
The below code can be used to help troubleshoot issues and measure perf.  
  
-- Create a log table for measuring perf  
CREATE TABLE mdm.tblPerfLog  
(  
     ID INT IDENTITY(1,1) NOT NULL  
    ,SPID INT NOT NULL  
    ,[Message] NVARCHAR(MAX)  
    ,[Time]   DATETIME2  
)  
  
-- Create a sproc to write messages to the log table.  
CREATE PROC mdm.udpLogMessage  
(  
    @Message NVARCHAR(MAX) = NULL  
)  
AS  
BEGIN  
    PRINT CONVERT(NVARCHAR, GETDATE()) + N': ' + @Message  
    INSERT INTO mdm.tblPerfLog  
        (SPID, [Message], [Time])  
    VALUES  
        (@@SPID, @Message, GETDATE());  
END;  
  
  
-- Get the items from the perf log table, and compute duration between entries. This is useful for identifying  
-- bottlenecks in the sproc. Run this query after changing all of the "IF @Debug = 1" lines to call udpLogMessage  
-- instead of calling PRINT, and then set the @Debug flag when running this sproc.  
SELECT  
     msg.*  
    ,DATEDIFF(ms, msg.[Time], nextMessage.[Time]) AS DurationInMs  -- How much time passed between when this message and the very next message were logged.  
FROM mdm.tblPerfLog msg  
LEFT JOIN mdm.tblPerfLog nextMessage  
ON msg.ID + 1 = nextMessage.ID  
ORDER BY msg.ID  
  
*/  
  
CREATE PROCEDURE [mdm].[udpMembersStatusSet]  
(  
   @User_ID             INT,  
   @Model_ID            INT = NULL,  
   @ModelName           NVARCHAR(50) = NULL,  
   @ModelMuid           UNIQUEIDENTIFIER = NULL,  
   @Entity_ID           INT = NULL,  
   @EntityName          NVARCHAR(50) = NULL,  
   @EntityMuid          UNIQUEIDENTIFIER = NULL,  
   @Version_ID          INT = NULL,  
   @VersionName         NVARCHAR(50) = NULL,  
   @VersionMuid         UNIQUEIDENTIFIER = NULL,  
   @MemberIds           mdm.MemberId READONLY, -- ID and MemberType are always required. MUID and Code should also be provided unless @LogFlag is 0.  
   @MemberType_ID       TINYINT,  
   @Status_ID           TINYINT,  
   @ChangesetName       NVARCHAR(250) = NULL,  
   @ChangesetMuid       UNIQUEIDENTIFIER = NULL,  
   @Approved            BIT = 0, -- Called by udpEntityMemberChangesetSave  
   @ResetDbaReferences  BIT = 0,  
   @LogFlag             BIT = 1,  
   @RaiseFirstError     BIT = 0, -- When 1, the first error will be raised. Otherwise, all errors will be included in the result set.  
   @TransactionBehavior TINYINT = 0, -- 0 = BestEffort,  
                                     -- 1 = AllOrNothingByMember Same as BestEffort in this sp  
                                     -- 2 = AllOrNothingByBatch  (if any part of any member has an error, then all changes in the entire batch will be aborted)  
   @Debug               BIT = 0,  
   @CorrelationID       UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON  
  
    DECLARE  
        @MemberTableName               SYSNAME  
  
        ,@MemberType_Leaf               TINYINT = 1  
        ,@MemberType_Consolidated       TINYINT = 2  
        ,@MemberType_Collection         TINYINT = 3  
        ,@MemberType_Hierarchy          TINYINT = 4  
        ,@MemberType_CollectionMember   TINYINT = 5  
  
        ,@MemberSecurity                INT = 0  
  
        --Permission  
        ,@ModelPermission               INT  
        ,@MemberTypePermission          INT = NULL  
        ,@Permission_None               INT = 0  
        ,@Permission_Deny               INT = 1  
        ,@Permission_Access             INT = 4  
        ,@Permission_Admin              INT = 5  
        ,@Permission_Inferred           INT = 99  
  
        ,@MemberTypeAccessPermission    TINYINT = NULL  
        ,@RequiredAccessPermission      TINYINT = NULL  
        ,@AccessPermission_Create       TINYINT = 1  
        ,@AccessPermission_Delete       TINYINT = 4  
  
        ,@VersionStatus                 TINYINT  
        ,@VersionStatus_NotSpecified    TINYINT = 0  
        ,@VersionStatus_Open            TINYINT = 1  
        ,@VersionStatus_Locked          TINYINT = 2  
        ,@VersionStatus_Committed       TINYINT = 3  
  
        ,@RequireApproval               BIT  
        ,@PendingTableName              SYSNAME -- E.g. "tbl_7_31_EN_PD"  
        ,@ChangesetTableName            SYSNAME -- E.g. "tbl_7_CS"  
        ,@Changeset_ID                  INT = NULL  
        ,@ChangesetStatus               TINYINT  
        ,@ChangesetStatus_Open          TINYINT = 1  
        ,@ChangesetStatus_Pending       TINYINT = 2  
        ,@ChangesetStatus_Approved      TINYINT = 3  
        ,@ChangesetStatus_Rejected      TINYINT = 4  
        ,@ChangesetStatus_Committed     TINYINT = 5  
  
        ,@TransactionLogType            TINYINT  
        ,@TransactionLogType_Attribute  TINYINT = 1  
        ,@TransactionLogType_Member     TINYINT = 2  
        ,@TransactionLogType_None       TINYINT = 3  
  
        ,@Status_Active                 TINYINT = 1  
        ,@Status_Deactivated            TINYINT = 2  
  
        ,@ObjectType_MemberId           TINYINT = 19  
  
        ,@TransactionBehavior_AllOrNothingByBatch   TINYINT = 2  
  
        ,@ValidationStatus_AwaitingRevalidation TINYINT = 4  
  
        ,@TransactionType_ChangeMemberStatus    TINYINT = 2  
  
        ,@ErrorCode_InvalidIdError              INT = 120003 -- MDSERR120003|The user does not have permission or the object ID is not valid  
        ,@ErrorCode_MemberCodeExistsError       INT = 300003 -- MDSERR300003|The member code already exists  
  
        -- This pseudo-constant is for use in string concatenation operations to prevent string truncation. When concatenating two or more strings,  
        -- if none of the strings is an NVARCHAR(MAX) or an NVARCHAR constant that is longer than 4,000 characters, then the resulting string  
        -- will be silently truncated to 4,000 characters. Concatenating with this empty NVARCHAR(MAX), is sufficient to prevent truncation.  
        -- See http://connect.microsoft.com/SQLServer/feedback/details/283368/nvarchar-max-concatenation-yields-silent-truncation.  
        ,@TruncationGuard               NVARCHAR(MAX) = N''  
        ,@ID                            INT  
        ,@ReferringEntity_ID            INT  
        ,@ReferringAttributeColumnName  SYSNAME  
        ,@ReferringMemberType_ID        TINYINT  
        ,@ReferringEntityTableName      SYSNAME  
        ,@ReferringEntityPendingTableName       SYSNAME  
        ,@ReferringEntityName           NVARCHAR(MAX)  
        ,@Attribute_ID                  INT  
        ,@SQL                           NVARCHAR(MAX)  
        ,@GuidEmpty                     UNIQUEIDENTIFIER = CAST(0x0 AS UNIQUEIDENTIFIER)  
        ;  
  
    SET @Model_ID  = NULLIF(@Model_ID, 0);  
    SET @Entity_ID  = NULLIF(@Entity_ID, 0);  
    SET @Version_ID  = NULLIF(@Version_ID, 0);  
    SET @ModelName  = NULLIF(@ModelName, N'');  
    SET @EntityName = NULLIF(@EntityName, N'');  
    SET @VersionName = NULLIF(@VersionName, N'');  
    SET @ChangesetName = NULLIF(@ChangesetName, N'');  
    SET @ModelMuid = NULLIF(@ModelMuid, @GuidEmpty);  
    SET @EntityMuid = NULLIF(@EntityMuid, @GuidEmpty);  
    SET @VersionMuid = NULLIF(@VersionMuid, @GuidEmpty);  
    SET @ChangesetMuid = NULLIF(@ChangesetMuid, @GuidEmpty);  
  
    -- Validate @Model_ID and the user's permission to see the model.  
    IF @Debug = 1 PRINT N'validate model.'  
    SELECT  
         @Model_ID = m.ID  
        ,@ModelName = m.Name  
        ,@ModelMuid = m.MUID  
        ,@ModelPermission = s.Privilege_ID  
    FROM mdm.tblModel m  
    INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_MODEL s  
    ON m.ID = s.ID  
        AND COALESCE(s.Privilege_ID, @Permission_Deny) <> @Permission_Deny  
        AND s.User_ID = @User_ID  
    WHERE (@ModelMuid IS NOT NULL OR @ModelName IS NOT NULL OR @Model_ID IS NOT NULL) -- At least one Identifier param must be provided.  
        AND (@ModelMuid IS NULL OR @ModelMuid = m.MUID)  
        AND (@ModelName IS NULL OR @ModelName = m.Name)  
        AND (@Model_ID  IS NULL OR @Model_ID  = m.ID)  
  
    IF @Model_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR300005|The supplied model is not valid.', 16, 1);  
        RETURN;  
    END  
  
    SET @ChangesetTableName = CONCAT(N'tbl_', @Model_ID, N'_CS');  
  
    -- Validate @Version_ID  
    IF @Debug = 1 PRINT N'validate version.'  
    SELECT  
         @Version_ID = ID  
        ,@VersionName = Name  
        ,@VersionMuid = MUID  
        ,@VersionStatus = Status_ID  
    FROM mdm.tblModelVersion  
    WHERE (@VersionMuid IS NOT NULL OR @VersionName IS NOT NULL OR @Version_ID IS NOT NULL) -- At least one Identifier param must be provided.  
        AND (@VersionMuid IS NULL OR @VersionMuid = MUID)  
        AND (@VersionName IS NULL OR @VersionName = Name)  
        AND (@Version_ID  IS NULL OR @Version_ID  = ID)  
        AND Model_ID = @Model_ID  
  
    IF @Version_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR300006|The supplied version is not valid.', 16, 1);  
        RETURN;  
    END;  
  
    SET @VersionStatus = COALESCE(@VersionStatus, @VersionStatus_NotSpecified);  
    IF @VersionStatus = @VersionStatus_Committed  
        OR (@VersionStatus = @VersionStatus_Locked AND @ModelPermission <> @Permission_Admin)  
    BEGIN  
        RAISERROR(N'MDSERR300012|The version is read-only. You do not have permission to update the version.', 16, 1);  
        RETURN;  
    END;  
  
    -- Lookup @Entity_ID and related info, validating that it exists and (if applicable) that the user has permissions to see it.  
    IF @Debug = 1 PRINT N'Validate entity.'  
    SELECT  
         @Entity_ID = e.ID  
        ,@PendingTableName = CAST(e.EntityTable + '_PD' AS SYSNAME)  
        ,@RequireApproval = RequireApproval  
        ,@TransactionLogType = CASE @LogFlag WHEN 1 THEN TransactionLogType ELSE @TransactionLogType_None END  
        ,@MemberTableName =  
            CASE @MemberType_ID  
                WHEN @MemberType_Leaf           THEN e.EntityTable  
                WHEN @MemberType_Consolidated   THEN e.HierarchyParentTable  
                WHEN @MemberType_Collection     THEN e.CollectionTable  
                WHEN @MemberType_Hierarchy      THEN e.HierarchyTable  
                WHEN @MemberType_CollectionMember   THEN e.CollectionMemberTable  
            END  
    FROM mdm.tblEntity e  
    INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_ENTITY s  
    ON e.ID = s.ID  
        AND COALESCE(s.Privilege_ID, @Permission_Deny) <> @Permission_Deny  
        AND s.User_ID = @User_ID  
    WHERE (@EntityMuid IS NOT NULL OR @EntityName IS NOT NULL OR @Entity_ID IS NOT NULL) -- At least one Identifier param must be provided.  
        AND (@EntityMuid IS NULL OR @EntityMuid = e.MUID)  
        AND (@EntityName IS NULL OR @EntityName = e.Name)  
        AND (@Entity_ID  IS NULL OR @Entity_ID  = e.ID)  
        AND e.Model_ID = @Model_ID;  
  
    IF @Entity_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR300008|The supplied entity is not valid..', 16, 1);  
        RETURN;  
    END;  
  
    -- Verify the entity version is not a sync target.  
    IF EXISTS(SELECT 1 FROM mdm.tblSyncRelationship  
              WHERE TargetEntity_ID = @Entity_ID  
                AND TargetVersion_ID = @Version_ID)  
    BEGIN  
        RAISERROR('MDSERR200220|The entity member(s) cannot be saved. The entity version is the target of a sync relationship.', 16, 1);  
        RETURN;  
    END  
  
    IF @ChangesetName IS NOT NULL OR @ChangesetMuid IS NOT NULL  
    BEGIN  
        SET @SQL = CONCAT(N'  
                SELECT @Changeset_ID = ID, @ChangesetStatus = Status, @ChangesetMuid = MUID  
                FROM [mdm].', @ChangesetTableName, N'  
                WHERE Version_ID = @Version_ID  
                    AND Entity_ID = @Entity_ID  
                    AND EnterUserID = @User_ID  
                    AND (@ChangesetMuid IS NOT NULL OR @ChangesetName IS NOT NULL)  
                    AND (@ChangesetMuid IS NULL OR MUID = @ChangesetMuid)  
                    AND (@ChangesetName IS NULL OR Name = @ChangesetName)');  
        EXEC sp_executesql @SQL, N'@Version_ID INT, @Entity_ID INT, @User_ID INT, @ChangesetName NVARCHAR(250), @ChangesetMuid UNIQUEIDENTIFIER OUTPUT, @Changeset_ID INT OUTPUT, @ChangesetStatus TINYINT OUTPUT',  
                @Version_ID, @Entity_ID, @User_ID, @ChangesetName, @ChangesetMuid OUTPUT, @Changeset_ID OUTPUT, @ChangesetStatus OUTPUT;  
  
        IF @Changeset_ID IS NULL OR @ChangesetStatus NOT IN (@ChangesetStatus_Open, @ChangesetStatus_Rejected)  
        BEGIN  
            RAISERROR(N'MDSERR300028|The changeset id is invalid or you don''t have the permission to update pending changes of this changeset.', 16, 1);  
            RETURN;  
        END  
  
        IF @ChangesetStatus = @ChangesetStatus_Rejected  
        BEGIN  
            EXEC mdm.udpEntityMemberChangesetSave  
                @User_ID = @User_ID,  
                @Model_Name = @ModelName,  
                @Model_MUID = @ModelMuid,  
                @Entity_Name = @EntityName,  
                @Entity_MUID = @EntityMuid,  
                @Version_Name = @VersionName,  
                @Version_MUID = @VersionMuid,  
                @ChangesetMUID = @ChangesetMuid,  
                @ChangesetStatus = @ChangesetStatus_Open;  
        END  
    END  
  
    IF @RequireApproval = 1 AND @MemberType_ID = @MemberType_Leaf AND @Approved = 0 AND @Changeset_ID IS NULL  
    BEGIN  
        RAISERROR(N'MDSERR300023|The entity requires approval for leaf member changes.', 16, 1);  
        RETURN;  
    END;  
  
    IF @Debug = 1 PRINT N'Check member type permission.'  
    -- Check the object permission on the Entity Member Type.  
    SELECT @MemberTypePermission = Privilege_ID,  
        @MemberTypeAccessPermission = AccessPermission  
    FROM mdm.viw_SYSTEM_SECURITY_USER_MEMBERTYPE  
    WHERE [User_ID] = @User_ID  
        AND [Entity_ID] = @Entity_ID  
        AND ID = @MemberType_ID;  
  
    SET @MemberTypePermission = COALESCE(@MemberTypePermission, @Permission_Deny);  
    IF @MemberTypePermission = @Permission_Deny  
    BEGIN  
        RAISERROR(N'MDSERR120002|The user does not have permission to perform this operation.', 16, 1);  
        RETURN;  
    END;  
  
    CREATE TABLE #ReferringMemberIds (RowID INT IDENTITY (1,1), MemberCode NVARCHAR(MAX));  
    DECLARE @ReferringMembers mdm.MemberSaveList;  
    DECLARE @ReferringMemberAttributes mdm.MemberAttributeValues;  
  
    --Check to make sure that the members are not referenced by a DBA (Leaf members only. Consolidated members can't be referenced by a DBA).  
    DECLARE @ReferringEntities TABLE  
    (  
         ID                         INT IDENTITY(1, 1)  
        ,Entity_ID                  INT  
        ,MemberType_ID              TINYINT  
        ,AttributeColumnName        NVARCHAR(128) COLLATE DATABASE_DEFAULT  
        ,ReferringEntityName        NVARCHAR(MAX)  
        ,ReferringEntityTableName   SYSNAME  
        ,Attribute_ID               INT  
    )  
  
    --Convert nulls to 0  
    SET @ResetDbaReferences = ISNULL(@ResetDbaReferences, 0);  
  
    IF @Debug = 1 PRINT N'Load members into #MemberWorkingSet.'  
    -- Create a temp table as a staging area for members being processed. A temp table is used instead of a table var so that it can  
    --    1. Have a multi-column index, and  
    --    2. Be used within dynamic SQL statements.  
    CREATE TABLE #MemberWorkingSet  
    (  
        Row_ID              INT IDENTITY(1,1) NOT NULL,  
        MemberID            INT NULL,  
        MemberMUID          UNIQUEIDENTIFIER NULL,  
        MemberCode          NVARCHAR(250) COLLATE DATABASE_DEFAULT NULL,  
        PendingChange_ID    INT NULL,  
        OldStatus           TINYINT,  
        ErrorCode           INT NULL,  
        ErrorParameters     NVARCHAR(MAX)  
    );  
    CREATE INDEX #ix_MemberWorkingSet_MemberCode_MemberCode ON #MemberWorkingSet(MemberMUID, MemberCode);  
    INSERT INTO #MemberWorkingSet (MemberID, MemberMUID, MemberCode)  
    SELECT  
         NULLIF(ID, 0)  
        ,NULLIF(MUID, @GuidEmpty)  
        ,NULLIF(Code, N'')  
    FROM @MemberIds  
  
    -- !!!The following queries (to load existing members based on codes and MUID) have been separated on purpose.  
    -- Combining the two results in significantly worse performance!!!  
    -- Search on member MUID before Code, because MUID is guaranteed to be globally unique while Code may be duplicated among inactive members  
  
    IF @Debug = 1 PRINT N'Lookup pre-existing member MUIDs and IDs from the member table based on input MUIDs'  
    SET @SQL = CONCAT(@TruncationGuard, N'  
        UPDATE ws  
        SET ws.MemberID = m.ID,  
            ws.MemberCode = m.Code,  
            ws.MemberMUID = m.MUID  
        FROM #MemberWorkingSet ws  
        INNER JOIN mdm.', @MemberTableName, N' m  
        ON ws.MemberMUID = m.MUID AND m.Version_ID = @Version_ID  
        WHERE   ws.ErrorCode IS NULL  
            AND ws.MemberID IS NULL --Only look for members that have not already been looked up  
            AND ws.MemberMUID IS NOT NULL --We are only looking for members that have MUID set up');  
    IF @Debug = 1 PRINT @SQL  
    EXEC sp_executesql @SQL, N'@Version_ID INT', @Version_ID;  
  
    IF @Debug = 1 PRINT N'Lookup pre-existing member MUIDs and IDs from the member table based on input codes'  
    SET @SQL = CONCAT(@TruncationGuard, N'  
        UPDATE ws  
        SET ws.MemberID = m.ID,  
            ws.MemberCode = m.Code,  
            ws.MemberMUID = m.MUID  
        FROM #MemberWorkingSet ws  
        INNER JOIN mdm.', @MemberTableName, N' m  
        ON ws.MemberCode = m.Code AND m.Version_ID = @Version_ID  
        WHERE   ws.ErrorCode IS NULL  
            AND ws.MemberID IS NULL --Only look for members that have not already been looked up  
            AND ws.MemberCode IS NOT NULL --We are only looking for members that have MemberCode set up',  
            CASE WHEN @Status_ID = @Status_Deactivated THEN CONCAT(N'  
            AND m.Status_ID = ', @Status_Active, N' -- when soft-deleting a member, only look for matches among active members (there could be multiple code matches among already-deleted members') END);  
    IF @Debug = 1 PRINT @SQL  
    EXEC sp_executesql @SQL, N'@Version_ID INT', @Version_ID  
  
    --IF it is for pending changes, set a dummy MemberID  
    IF @Changeset_ID IS NOT NULL  
    BEGIN  
        SET @SQL = CONCAT(@TruncationGuard, N'  
            UPDATE ws  
            SET ws.MemberID = COALESCE(ws.MemberID, 0),  
                ws.MemberMUID = COALESCE(ws.MemberMUID, pd.MUID),  
                ws.PendingChange_ID = pd.ID  
            FROM #MemberWorkingSet ws  
            LEFT JOIN mdm.', @PendingTableName, N' pd  
            ON ws.MemberMUID = pd.MUID AND pd.CS_ID = @Changeset_ID AND pd.Version_ID = @Version_ID  
            WHERE ws.ErrorCode IS NULL');  
        IF @Debug = 1 PRINT @SQL  
        EXEC sp_executesql @SQL, N'@Version_ID INT, @Changeset_ID INT', @Version_ID, @Changeset_ID;  
    END  
  
    UPDATE #MemberWorkingSet  
    SET ErrorCode = @ErrorCode_InvalidIdError  
    WHERE MemberID IS NULL  
        AND ErrorCode IS NULL;  
  
    -- Check member type permission  
    SET @RequiredAccessPermission =  
        CASE @Status_ID  
            WHEN @Status_Active THEN @AccessPermission_Create  
            WHEN @Status_Deactivated THEN @AccessPermission_Delete  
        END  
  
    IF NOT(@MemberTypePermission = @Permission_Access  
        AND @MemberTypeAccessPermission & @RequiredAccessPermission = @RequiredAccessPermission)  
    BEGIN  
        RAISERROR(N'MDSERR120002|The user does not have permission to perform this operation.', 16, 1);  
        RETURN;  
    END;  
  
    --Check Member Permissions.  
    IF @Status_ID = @Status_Deactivated  
    BEGIN  
        IF @ModelPermission != @Permission_Admin  
        BEGIN  
            SET @MemberSecurity = mdm.udfUseMemberSecurity(@User_ID, @Entity_ID, @Version_ID, @MemberType_ID);  
            IF @MemberSecurity = 1  
            BEGIN  
                DECLARE @ExistingMemberIds mdm.MemberId;  
                INSERT INTO @ExistingMemberIds (ID, MemberType_ID)  
                SELECT DISTINCT  
                    ws.MemberID,  
                    @MemberType_ID  
                FROM #MemberWorkingSet ws  
                WHERE   ws.PendingChange_ID IS NULL -- Exclude pending changes  
                    AND ws.ErrorCode IS NULL;  
  
                IF EXISTS (SELECT 1 FROM @ExistingMemberIds)  
                BEGIN  
                    DECLARE @MemberPermissions AS TABLE (ID INT PRIMARY KEY, MemberType_ID INT, Privilege_ID INT, AccessPermission TINYINT);  
                    INSERT INTO @MemberPermissions  
                    EXEC mdm.udpSecurityMembersResolverGet @User_ID, @Version_ID, @Entity_ID, @ExistingMemberIds;  
  
                    UPDATE ws  
                    SET ErrorCode = @ErrorCode_InvalidIdError  
                    FROM #MemberWorkingSet ws  
                    INNER JOIN @MemberPermissions prm  
                    ON  ws.MemberID = prm.ID  
                    WHERE NOT (    prm.Privilege_ID = @Permission_Access   
                               AND prm.AccessPermission & @AccessPermission_Delete = @AccessPermission_Delete);  
                END;  
            END  
        END;  
    END  
  
    --Start transaction, being careful to check if we are nested  
    DECLARE @TranCounter INT = @@TRANCOUNT;  
    IF @TranCounter > 0  
    BEGIN  
        SAVE TRANSACTION TX;  
    END ELSE  
    BEGIN  
        BEGIN TRANSACTION;  
    END;  
  
    BEGIN TRY  
        -- If soft-deleting members, then check to see if the members are being referenced by any DBAs.  
        IF @Status_ID = @Status_Deactivated AND @Changeset_ID IS NULL AND @MemberType_ID = @MemberType_Leaf  
        BEGIN  
            IF @Debug = 1 PRINT N'Get a list of all referring entities'  
  
            -- Get Entities which referencing to this entity  
            INSERT INTO @ReferringEntities (Entity_ID, MemberType_ID, AttributeColumnName, ReferringEntityName, ReferringEntityTableName, Attribute_ID)  
            SELECT DISTINCT  
                 Attribute.Entity_ID  
                ,Attribute.MemberType_ID  
                ,Attribute.TableColumn  
                ,Entity.Name  
                ,CASE Attribute.MemberType_ID  
                    WHEN @MemberType_Leaf           THEN Entity.EntityTable  
                    WHEN @MemberType_Consolidated   THEN Entity.HierarchyParentTable  
                    WHEN @MemberType_Collection     THEN Entity.CollectionTable  
                 END  
                ,Attribute.ID  
            FROM mdm.tblAttribute Attribute  
            INNER JOIN mdm.tblEntity Entity ON Entity.ID = Attribute.Entity_ID  
            WHERE Attribute.DomainEntity_ID = @Entity_ID  
            ORDER BY Attribute.Entity_ID;  
            -- Go through each ReferringEntity  
            WHILE EXISTS(SELECT 1 FROM @ReferringEntities)  
            BEGIN  
                SELECT TOP 1  
                     @ID = ID  
                    ,@ReferringEntity_ID = Entity_ID  
                    ,@ReferringAttributeColumnName = AttributeColumnName  
                    ,@ReferringMemberType_ID = MemberType_ID  
                    ,@ReferringEntityName = ReferringEntityName  
                    ,@ReferringEntityTableName = ReferringEntityTableName  
                    ,@Attribute_ID = Attribute_ID  
                FROM @ReferringEntities;  
  
                IF @Debug = 1 PRINT @ReferringEntityName  
  
                --If we are okay with resetting DBA references to the members being deleted  
                IF @ResetDbaReferences = 1  
                BEGIN  
                    IF @Debug = 1 PRINT N'Null out DBA reference in referring entity,'  
                    --Empty the member temp tables  
                    DELETE FROM #ReferringMemberIds;  
                    DELETE FROM @ReferringMembers;  
                    DELETE FROM @ReferringMemberAttributes;  
  
                    SET @SQL = @TruncationGuard + N'  
                    INSERT INTO #ReferringMemberIds(MemberCode)  
                    SELECT ref.Code  
                    FROM #MemberWorkingSet ws  
                    INNER JOIN mdm.' + QUOTENAME(@ReferringEntityTableName) + N' ref  
                        ON ws.MemberID = ref.' + QUOTENAME(@ReferringAttributeColumnName) + N'  
                    WHERE  
                            ws.ErrorCode IS NULL  
                        AND ref.Status_ID = ' + CONVERT(NVARCHAR, @Status_Active) + '  
                        AND ref.Version_ID = @Version_ID --This is only for perf benefit';  
                    EXEC sp_executesql @SQL, N'@Version_ID INT', @Version_ID;  
  
                    INSERT INTO @ReferringMembers(RowID, MemberCode)  
                    SELECT RowID, MemberCode  
                    FROM #ReferringMemberIds  
  
                    INSERT INTO @ReferringMemberAttributes(MemberRowID, AttributeID, AttributeValue)  
                    SELECT RowID, @Attribute_ID, NULL FROM @ReferringMembers;  
  
                    EXEC mdm.udpEntityMembersSave  
                                @User_ID = @User_ID  
                                ,@Model_ID = @Model_ID  
                                ,@Entity_ID = @ReferringEntity_ID  
                                ,@Version_ID = @Version_ID  
                                ,@MemberType_ID = @ReferringMemberType_ID  
                                ,@Members = @ReferringMembers  
                                ,@MemberAttributes = @ReferringMemberAttributes  
                                ,@SaveMode = 3 -- Update  
                                ,@LogFlag = @LogFlag  
                                ,@ValidateDataTypes = 1  
                                ,@DoInheritanceRuleCheck = 0  
                                ,@ErrorReportingType = 4; --Raise any errors as an exception so everything is rolled back  
                END  
                --If DBA references are not being removed then members referenced by other members can not be deleted  
                ELSE  
                BEGIN  
                    IF @Debug = 1 PRINT N'Check for referring members'  
                    SET @SQL = CONCAT(@TruncationGuard, N'  
                    UPDATE ws  
                    SET  
                         ErrorCode = 300004  
                        ,ErrorParameters = CONCAT(REPLACE(ws.MemberCode, N''|'', N''_''), N''|'', ', QUOTENAME(REPLACE(@ReferringEntityName, N'|', N'_'), N''''), N', N''|'', REPLACE(ref.Code, N''|'', N''_''))  
                    FROM #MemberWorkingSet ws  
                    INNER JOIN mdm.', QUOTENAME(@ReferringEntityTableName), N' ref  
                        ON ws.MemberID = ref.', QUOTENAME(@ReferringAttributeColumnName), N'  
                    WHERE  
                            ws.ErrorCode IS NULL  
                        AND ref.Status_ID = ', @Status_Active, N'  
                        AND ref.Version_ID = @Version_ID --This is only for perf benefit');  
                   EXEC sp_executesql @SQL, N'@Version_ID INT', @Version_ID;  
                END  
  
                -- Reset DBA references on PD table  
                SET @ReferringEntityPendingTableName = CAST(@ReferringEntityTableName + N'_PD' AS SYSNAME)  
                  
                -- Change to pending/approved changeset to open  
                SET @SQL = CONCAT(@TruncationGuard, N'  
                    UPDATE cs  
                    SET cs.Status = ', @ChangesetStatus_Open, N'  
                    FROM mdm.', @ChangesetTableName, ' cs  
                    INNER JOIN mdm.', @ReferringEntityPendingTableName, ' pd  
                        ON cs.ID = pd.CS_ID AND cs.Version_ID = pd.Version_ID  
                    INNER JOIN #MemberWorkingSet ws  
                        ON ws.MemberID = pd.' + QUOTENAME(@ReferringAttributeColumnName) + N' AND @Version_ID = pd.Version_ID  
                    WHERE ws.ErrorCode IS NULL  
                        AND cs.Status IN (', @ChangesetStatus_Pending, N', ', @ChangesetStatus_Approved, N')');  
                EXEC sp_executesql @SQL, N'@Version_ID INT', @Version_ID;  
  
                -- Set PD DBA to null  
                SET @SQL = CONCAT(@TruncationGuard, N'  
                    UPDATE pd  
                    SET pd.', QUOTENAME(@ReferringAttributeColumnName) ,N' = NULL  
                    FROM mdm.', @ReferringEntityPendingTableName, ' pd  
                    INNER JOIN mdm.', @ChangesetTableName, ' cs  
                        ON cs.ID = pd.CS_ID AND cs.Version_ID = pd.Version_ID  
                    INNER JOIN #MemberWorkingSet ws  
                        ON ws.MemberID = pd.' + QUOTENAME(@ReferringAttributeColumnName) + N' AND @Version_ID = pd.Version_ID  
                    WHERE ws.ErrorCode IS NULL AND cs.Status <> ', @ChangesetStatus_Committed);  
                EXEC sp_executesql @SQL, N'@Version_ID INT', @Version_ID;  
                DELETE FROM @ReferringEntities WHERE ID = @ID;  
            END -- WHILE  
  
            -- Change to pending/approved changeset to open  
            SET @SQL = CONCAT(@TruncationGuard, N'  
                UPDATE cs  
                SET cs.Status = ', @ChangesetStatus_Open, N'  
                FROM mdm.', @ChangesetTableName, ' cs  
                INNER JOIN mdm.', @PendingTableName, ' pd  
                    ON cs.ID = pd.CS_ID AND cs.Version_ID = pd.Version_ID  
                INNER JOIN #MemberWorkingSet ws  
                    ON ws.MemberID = pd.EN_ID AND @Version_ID = pd.Version_ID  
                WHERE ws.ErrorCode IS NULL  
                    AND cs.Status IN (', @ChangesetStatus_Pending, N', ', @ChangesetStatus_Approved, N')');  
            EXEC sp_executesql @SQL, N'@Version_ID INT', @Version_ID;  
  
            -- Delete changes for this member  
            SET @SQL = CONCAT(@TruncationGuard, N'  
                DELETE pd  
                FROM mdm.', @PendingTableName, ' pd  
                INNER JOIN mdm.', @ChangesetTableName, ' cs  
                    ON cs.ID = pd.CS_ID AND cs.Version_ID = pd.Version_ID  
                INNER JOIN #MemberWorkingSet ws  
                    ON ws.MemberID = pd.EN_ID AND @Version_ID = pd.Version_ID  
                WHERE ws.ErrorCode IS NULL AND cs.Status <> ', @ChangesetStatus_Committed);  
            EXEC sp_executesql @SQL, N'@Version_ID INT', @Version_ID;  
  
        END -- IF deactivating members  
  
        DECLARE @MemberIdList   mdm.IdList;  
  
        IF @Changeset_ID IS NULL  
        BEGIN  
            SET @SQL = @TruncationGuard;  
  
            IF @Status_ID = @Status_Active  
            BEGIN  
                -- If reactivating members, ensure there is no active member with the same code.  
                SELECT @SQL = N'  
                WITH existingActiveCodesCte AS  
                (  
                    SELECT Code, ID  
                    FROM mdm.' + QUOTENAME(EntityTable) + N'  
                    WHERE Status_ID = ' + CONVERT(NVARCHAR, @Status_Active) + N'  
                        AND Version_ID = @Version_ID' +  
                    -- Only look at Consolidated and Collection tables if they exist  
                    CASE WHEN NULLIF(HierarchyParentTable, N'') IS NOT NULL THEN N'  
                    UNION -- not UNION ALL because deduplication is needed  
                    SELECT Code, ID  
                    FROM mdm.' + HierarchyParentTable + N'  
                    WHERE Status_ID = ' + CONVERT(NVARCHAR, @Status_Active) + N'  
                        AND Version_ID = @Version_ID'  
                        ELSE N'' END +  
                    CASE WHEN NULLIF(CollectionTable, N'') IS NOT NULL THEN N'  
                    UNION -- not UNION ALL because deduplication is needed  
                    SELECT Code, ID  
                    FROM mdm.' + CollectionTable + N'  
                    WHERE Status_ID = ' + CONVERT(NVARCHAR, @Status_Active) + N'  
                        AND Version_ID = @Version_ID'  
                        ELSE N'' END + N'  
                )'  
                FROM mdm.tblEntity  
                WHERE ID = @Entity_ID  
            END;  
  
            SET @SQL += CONCAT(N'  
            -- Add an error if the member does not exist or is reactivating using an existing code, and record the previous Status_ID value, for use in logging a transaction.  
            UPDATE ws  
            SET  
                    ws.OldStatus = mem.Status_ID  
                ,ws.ErrorCode = CASE WHEN mem.ID IS NULL THEN N''', @ErrorCode_InvalidIdError, N'''',  
            CASE WHEN @Status_ID = @Status_Active THEN CONCAT(N'  
                                        WHEN dup.ID IS NOT NULL THEN N''', @ErrorCode_MemberCodeExistsError, N'''') ELSE N'' END, N'  
                    ELSE NULL END  
            FROM #MemberWorkingSet ws  
            LEFT JOIN mdm.', QUOTENAME(@MemberTableName), N' mem  
            ON ws.MemberID = mem.ID',  
  
            CASE WHEN @Status_ID = @Status_Active THEN N'  
            LEFT JOIN existingActiveCodesCte dup  
            ON      mem.Code = dup.Code  
                AND mem.ID <> dup.ID' ELSE N'' END  
  
            , N'  
            WHERE  
                    ws.ErrorCode IS NULL  
                AND mem.Version_ID = @Version_ID;  
  
            -- Update the Status_ID in the member table.  
            DECLARE @Now DATETIME2 = GETUTCDATE();  
            UPDATE mem  
            SET  
                mem.Status_ID = @Status_ID,  
                mem.LastChgDTM = @Now,  
                mem.LastChgUserID = @User_ID,  
                mem.LastChgVersionID = @Version_ID', CASE @TransactionLogType WHEN @TransactionLogType_Member THEN mdm.udfGetHistoryOutputQuery(@Entity_ID, @MemberType_ID, NULL, NULL) ELSE N'' END, N'  
            FROM #MemberWorkingSet ws  
            INNER JOIN mdm.', QUOTENAME(@MemberTableName), N' mem  
                ON ws.MemberID = mem.ID  
            WHERE  
                    ws.ErrorCode IS NULL  
                AND mem.Version_ID = @Version_ID;  
            ');  
  
            IF @Debug = 1 PRINT N'Change member status'  
            EXEC sp_executesql @SQL, N'@Version_ID INT, @MemberType_ID TINYINT, @Status_ID TINYINT, @User_ID INT', @Version_ID, @MemberType_ID, @Status_ID, @User_ID;  
  
            IF @Debug = 1 PRINT N'Create a list of all updated member ids'  
            -- Create a list of all updated member ids.  
            INSERT INTO @MemberIdList  
            SELECT MemberID  
            FROM #MemberWorkingSet  
            WHERE ErrorCode IS NULL  
  
            -- Update validation issues or status.  
            IF @Status_ID = @Status_Deactivated  
            BEGIN  
                IF @Debug = 1 PRINT N'Delete any validation issues for deactivated members'  
                --If deleting then delete any validation issues.  
                EXEC mdm.udpValidationLogClearByMemberIDs  
                        @Version_ID = @Version_ID  
                    ,@Entity_ID = @Entity_ID  
                    ,@MemberType_ID = @MemberType_ID  
                    ,@MemberIdList = @MemberIdList;  
            END ELSE IF @Status_ID = @Status_Active  
            BEGIN  
                IF @Debug = 1 PRINT N'Set the validation status to Awaiting Revalidation for re-activated members'  
                --If reactivating then set the validation status to 'Awaiting Revalidation'.  
                EXEC mdm.udpMembersValidationStatusUpdate  
                        @Version_ID = @Version_ID  
                    ,@Entity_ID = @Entity_ID  
                    ,@MemberType_ID = @MemberType_ID  
                    ,@ValidationStatus_ID = @ValidationStatus_AwaitingRevalidation  
                    ,@MemberIdList = @MemberIdList;  
            END  
  
            -- Clear the list of updated members ids, to prepare it for reuse in the next loop iteration.  
            DELETE FROM @MemberIdList;  
        END  
        ELSE IF @MemberType_ID = @MemberType_Leaf  
        BEGIN  
            SET @SQL = CONCAT(N'  
                DECLARE @Now DATETIME2 = GETUTCDATE();  
                MERGE mdm.', @PendingTableName, N' pd  
                USING #MemberWorkingSet mws  
                ON mws.MemberMUID = pd.MUID  
                    AND pd.Version_ID = @Version_ID  
                    AND pd.CS_ID = @Changeset_ID  
                    AND mws.ErrorCode IS NULL  
                -- existing pending changes  
                WHEN MATCHED AND @Status_ID = ', @Status_Deactivated, N'  
                    THEN DELETE  
                WHEN NOT MATCHED BY TARGET  
                    THEN  
                        INSERT  
                        (  
                            Version_ID,  
                            CS_ID,  
                            EN_ID,  
                            Status_ID,  
                            MUID,  
                            EnterDTM,  
                            EnterUserID,  
                            LastChgDTM,  
                            LastChgUserID,  
                            Revision_ID  
                        )  
                        VALUES  
                        (  
                            @Version_ID,  
                            @Changeset_ID,  
                            mws.MemberID,  
                            @Status_ID,  
                            mws.MemberMUID,  
                            @Now,  
                            @User_ID,  
                            @Now,  
                            @User_ID,  
                            MIN_ACTIVE_ROWVERSION() + mws.Row_ID - 1  
                        );');  
            EXEC sp_executesql @SQL, N'@Version_ID INT, @Status_ID TINYINT, @User_ID INT, @Changeset_ID INT', @Version_ID, @Status_ID, @User_ID, @Changeset_ID;  
        END  
  
        IF @Changeset_ID IS NULL  
        BEGIN  
            DECLARE @HierarchyTableName SYSNAME = mdm.udfTableNameGetByID(@Entity_ID, @MemberType_Hierarchy),  
                    @GetHistoryOutputQuery NVARCHAR(MAX);  
  
            IF @TransactionLogType = @TransactionLogType_Member  
            BEGIN  
                SET @GetHistoryOutputQuery = mdm.udfGetHistoryOutputQuery(@Entity_ID, @MemberType_Hierarchy, NULL, NULL);  
            END;  
  
            IF LEN(@HierarchyTableName) > 0  
            BEGIN  
                DECLARE @SqlLevelString NVARCHAR(MAX) = CASE @Status_ID WHEN @Status_Deactivated THEN N'  
                        ,hr.LevelNumber = -1 ' ELSE N'' END;  
                IF @Debug = 1 PRINT N'Update The hierarchy relationship record and reset level number for recalculation'  
                SET @SQL = N'DECLARE @Now DATETIME2 = GETUTCDATE();'  
                IF @MemberType_ID = @MemberType_Leaf  
                BEGIN  
                    SET @SQL += @TruncationGuard + N'  
                    UPDATE hr  
                    SET Status_ID = @Status_ID,  
                        LastChgDTM = @Now,  
                        LastChgUserID = @User_ID,  
                        LastChgVersionID = @Version_ID' + @SqlLevelString + CASE @TransactionLogType WHEN @TransactionLogType_Member THEN @GetHistoryOutputQuery ELSE N'' END + N'  
                    FROM #MemberWorkingSet ws  
                    INNER JOIN mdm.' + QUOTENAME(@HierarchyTableName) + N' hr  
                    ON ws.MemberID = hr.Child_EN_ID  
                    WHERE   ws.ErrorCode IS NULL  
                        AND hr.Version_ID = @Version_ID;';  
                END  
              
                IF @MemberType_ID = @MemberType_Consolidated  
                BEGIN  
                    SET @SQL += @TruncationGuard + N'  
                    UPDATE hr  
                    SET Status_ID = @Status_ID,  
                        LastChgDTM = GETUTCDATE(),  
                        LastChgUserID = @User_ID,  
                        LastChgVersionID = @Version_ID' + @SqlLevelString + CASE @TransactionLogType WHEN @TransactionLogType_Member THEN @GetHistoryOutputQuery ELSE N'' END + N'  
                    FROM #MemberWorkingSet ws  
                    INNER JOIN mdm.' + QUOTENAME(@HierarchyTableName) + N' hr  
                    ON ws.MemberID = hr.Child_HP_ID  
                    WHERE   ws.ErrorCode IS NULL  
                        AND hr.Version_ID = @Version_ID  
  
                    --Update children of consolidated nodes to Root and reset level number for recalculation  
                    UPDATE hr  
                    SET Parent_HP_ID = NULL' + @SqlLevelString + CASE @TransactionLogType WHEN @TransactionLogType_Member THEN @GetHistoryOutputQuery ELSE N'' END + '  
                    FROM #MemberWorkingSet ws  
                    INNER JOIN mdm.' + QUOTENAME(@HierarchyTableName) + N' hr  
                        ON ws.MemberID = hr.Parent_HP_ID  
                    WHERE ws.ErrorCode IS NULL  
                        AND hr.Version_ID = @Version_ID;'  
                END  
  
                IF @Debug = 1 PRINT @SQL  
                EXEC sp_executesql @SQL, N'@Version_ID INT, @Status_ID TINYINT, @User_ID INT', @Version_ID, @Status_ID, @User_ID;  
            END  
  
            DECLARE @CurrentTime DATETIME2(3) = GETUTCDATE();  
  
           --Log the transactions only log it if the logging flag is set.  
           IF @TransactionLogType = @TransactionLogType_Attribute  
           BEGIN  
                IF @Debug = 1 PRINT N'Log the transactions'  
  
                DECLARE @TransactionTableName sysname = mdm.udfGetTransactionTableName(@Model_ID);  
                SET @SQL = N'  
                INSERT INTO mdm.' + QUOTENAME(@TransactionTableName) + N'  
                (  
                     TransactionType_ID  
                    ,OriginalTransaction_ID  
                    ,Hierarchy_ID  
                    ,Version_ID  
                    ,[Entity_ID]  
                    ,Attribute_ID  
                    ,Member_ID  
                    ,Member_MUID  
                    ,MemberType_ID  
                    ,MemberCode  
                    ,OldValue  
                    ,OldCode  
                    ,NewValue  
                    ,NewCode  
                    ,EnterDTM  
                    ,EnterUserID  
                    ,LastChgDTM  
                    ,LastChgUserID  
                )  
                SELECT  
                     @TransactionType_ChangeMemberStatus --TransactionType_ID  
                    ,0 --OriginalTransaction_ID  
                    ,NULL-- Hierarchy_ID  
                    ,@Version_ID  
                    ,@Entity_ID  
                    ,NULL -- Attribute_ID  
                    ,MemberID  
                    ,MemberMUID  
                    ,@MemberType_ID  
                    ,MemberCode  
                    ,CONVERT(NVARCHAR, OldStatus) --OldValue  
                    ,N'''' --OldCode  
                    ,CONVERT(NVARCHAR, @Status_ID) --NewValue  
                    ,N'''' --NewCode  
                    ,@CurrentTime  
                    ,@User_ID  
                    ,@CurrentTime  
                    ,@User_ID  
                FROM #MemberWorkingSet  
                WHERE ErrorCode IS NULL;  
                ';  
                EXEC sp_executesql @SQL, N'@TransactionType_ChangeMemberStatus INT, @Entity_ID INT, @Version_ID INT, @Status_ID INT, @CurrentTime DATETIME2(3), @User_ID INT, @MemberType_ID TINYINT',  
                                           @TransactionType_ChangeMemberStatus,     @Entity_ID,     @Version_ID,     @Status_ID,     @CurrentTime,              @User_ID,     @MemberType_ID;  
  
            END; -- IF @TransactionType = @TransactionType_Column  
        END;  
  
        IF EXISTS (SELECT 1 FROM #MemberWorkingSet WHERE ErrorCode IS NOT NULL)  
        BEGIN  
            IF @RaiseFirstError = 1  
            BEGIN  
                DECLARE @FirstError NVARCHAR(MAX);  
                SELECT TOP 1  
                    @FirstError = CONCAT('MDSERR', ErrorCode, N'|<error message placeholder, will be replaced by localized string in C# layer>',CASE WHEN ErrorParameters IS NOT NULL THEN CONCAT(N'|', ErrorParameters, N'|') END)  
                FROM #MemberWorkingSet  
                WHERE ErrorCode IS NOT NULL;  
  
                IF LEN(@FirstError) > 0  
                BEGIN  
                    RAISERROR(@FirstError, 16, 1);  
                END  
            END ELSE  
            BEGIN  
  
                -- Return error rows.  
                SELECT  
                    ErrorCode,  
                    ErrorParameters,  
                    @ObjectType_MemberId AS ErrorObjectType,  
                    MemberID,  
                    MemberMUID,  
                    MemberCode,  
                    NULL AS MemberName,  
                    NULL AS AttributeMUID,  
                    NULL AS AttributeName  
                FROM #MemberWorkingSet  
                WHERE ErrorCode IS NOT NULL;  
            END;  
        END;  
  
        --Commit only if we are not nested.  
          
        IF @TransactionBehavior = @TransactionBehavior_AllOrNothingByBatch  
            AND EXISTS(SELECT 1 FROM #MemberWorkingSet WHERE ErrorCode IS NOT NULL)  
        BEGIN  
            IF @TranCounter = 0  
            BEGIN  
                ROLLBACK TRANSACTION;  
            END  
  
            RETURN 0;  
        END  
        ELSE  
        BEGIN  
            IF @TranCounter = 0  
            BEGIN  
                COMMIT TRANSACTION;  
            END  
  
            RETURN 1;  
        END;  
  
        IF @Debug = 1 PRINT N'udpMembersStatusSet DONE'  
  
    END TRY  
    --Compensate as necessary  
    BEGIN CATCH  
  
        -- Get error info.  
        DECLARE  
            @ErrorMessage NVARCHAR(4000),  
            @ErrorSeverity INT,  
            @ErrorState INT,  
            @ErrorNumber INT,  
            @ErrorLine INT,  
            @ErrorProcedure NVARCHAR(126);  
        EXEC mdm.udpGetErrorInfo  
            @ErrorMessage = @ErrorMessage OUTPUT,  
            @ErrorSeverity = @ErrorSeverity OUTPUT,  
            @ErrorState = @ErrorState OUTPUT,  
            @ErrorNumber = @ErrorNumber OUTPUT,  
            @ErrorLine = @ErrorLine OUTPUT,  
            @ErrorProcedure = @ErrorProcedure OUTPUT  
  
        SET @ErrorMessage = CONCAT(@ErrorMessage, N', @ErrorNumber = ', @ErrorNumber, N', @ErrorProcedure = "', @ErrorProcedure, N'", line ', @ErrorLine);  
  
        IF @TranCounter = 0  
        BEGIN  
            ROLLBACK TRANSACTION;  
        END ELSE IF XACT_STATE() <> -1  
        BEGIN  
            ROLLBACK TRANSACTION TX;  
        END;  
  
        RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);  
  
        RETURN;  
  
    END CATCH;  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpMemberStatusIDGetByMemberID]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpMemberStatusIDGetByMemberID]  
(  
   @Version_ID    INT,  
   @Entity_ID     INT,  
   @Member_ID     INT,  
   @MemberType_ID TINYINT,  
   @Status_ID     TINYINT = NULL OUTPUT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
	SET NOCOUNT ON;  
  
	DECLARE @TableName sysname,  
			@SQL       NVARCHAR(MAX),  
			@ReturnID  TINYINT;  
  
	SET @TableName = mdm.udfTableNameGetByID(@Entity_ID, @MemberType_ID);  
	SET @SQL = N'  
		SELECT @ReturnID = Status_ID FROM mdm.' + quotename(@TableName) + N'   
		WHERE Version_ID = @Version_ID  
		AND ID = @Member_ID';  
  
  
	EXEC sp_executesql @SQL, N'@Version_ID INT, @Member_ID INT, @ReturnID INT OUTPUT', @Version_ID, @Member_ID, @ReturnID OUTPUT;  
  
	SET @Status_ID = @ReturnID;  
  
	SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpMembersTypeIDAndIDGetByCode]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
Looks up the IDs and MemberTypes of the given list of member codes for the given entity and version. If the code  
cannot be found, it is omitted from the result set. This is the set-based version of the udpMemberTypeIDAndIDGetByCode  
sproc that only operates on a single member.  
  
DECLARE    @MemberIds      mdm.MemberId;  
INSERT INTO @MemberIds (Code) VALUES (N'MyMemberCode')  
EXEC mdm.udpMembersTypeIDAndIDGetByCode  
     @Version_ID =    3  
    ,@Entity_ID =     6  
    ,@ActiveMembersOnly = 1  
    ,@MemberIds = @MemberIds;  
*/  
CREATE PROCEDURE [mdm].[udpMembersTypeIDAndIDGetByCode]  
(  
     @Version_ID        INT  
    ,@Entity_ID         INT  
    ,@ActiveMembersOnly BIT = 1 -- When 1, inactive (soft-deleted) members are ignored.  
    ,@MemberIds         mdm.MemberId READONLY,  
    @CorrelationID      UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
    DECLARE  
         @SQL                       NVARCHAR(MAX)  
        ,@TableName                 SYSNAME  
  
        -- Member types  
        ,@MemberType_NotSpecified   TINYINT = 0  
        ,@MemberType_Leaf           TINYINT = 1  
        ,@MemberType_Consolidated   TINYINT = 2  
        ,@MemberType_Collection     TINYINT = 3  
  
        -- IDs of special hierarchy parent node members  
        ,@MemberId_RootNode         INT = 0  
        ,@MemberCode_RootNode       NVARCHAR(250) = N'ROOT'  
        ,@MemberId_UnusedNode       INT = -1  
        ,@MemberCode_UnusedNode     NVARCHAR(250) = N'MDMUNUSED'  
          
        ,@GuidEmpty                 UNIQUEIDENTIFIER = CAST(0x0 AS UNIQUEIDENTIFIER);  
  
    -- Create a table to store member info. Use a temp table rather than a table var so that it can be used by dynamic SQL (can't pass a table var as a parameter)  
    CREATE TABLE #MemberIdsWorkingSet  
    (  
         Code           NVARCHAR(250) COLLATE DATABASE_DEFAULT  
        ,ID             INT  
        ,MemberType_ID  TINYINT  
        ,MUID           UNIQUEIDENTIFIER  
    );  
    CREATE INDEX #ix_MemberIdsWorkingSet_ID ON #MemberIdsWorkingSet(ID);  
    CREATE INDEX #ix_MemberIdsWorkingSet_Code ON #MemberIdsWorkingSet(Code);  
    CREATE INDEX #ix_MemberIdsWorkingSet_MUID ON #MemberIdsWorkingSet(MUID);  
  
    ;WITH memberIdsCte AS  
    (  
        SELECT --DISTINCT  
            NULLIF(LTRIM(RTRIM(Code)), N'') Code, -- Trim member code,  
            NULLIF(MUID, @GuidEmpty) MUID  
        FROM @MemberIds  
    )  
    INSERT INTO #MemberIdsWorkingSet (Code, MUID, MemberType_ID, ID)  
    SELECT  
         Code  
        ,MUID  
        ,CASE UPPER(Code)  
            WHEN @MemberCode_RootNode THEN @MemberType_NotSpecified  
            WHEN @MemberCode_UnusedNode THEN @MemberType_Consolidated  
            END  
        ,CASE UPPER(Code)  
            WHEN @MemberCode_RootNode THEN @MemberId_RootNode  
            WHEN @MemberCode_UnusedNode THEN @MemberId_UnusedNode  
            END  
    FROM memberIdsCte  
    WHERE Code IS NOT NULL OR MUID IS NOT NULL  
  
    DECLARE @QueryTemplate NVARCHAR(MAX) = CONCAT(N'  
UPDATE ws  
SET  
     ws.ID              = mem.ID  
    ,ws.Code            = mem.Code  
    ,ws.MUID            = mem.MUID  
    ,ws.MemberType_ID   = {MemberTypePlaceholder}  
FROM #MemberIdsWorkingSet ws  
INNER JOIN mdm.{TableNamePlaceholder} mem  
ON      mem.Version_ID = @Version_ID  
    AND ws.{ColumnNamePlaceholder} = mem.{ColumnNamePlaceholder}  
WHERE ws.ID IS NULL  -- Skip rows that have already been looked up.',   
    CASE WHEN @ActiveMembersOnly = 1 THEN N'  
    AND mem.Status_ID = 1 -- Skip rows that have been soft-deleted.'   
    END, N'  
');  
  
    --Type 1 (EntityTable)  
    SET @TableName = mdm.udfTableNameGetByID(@Entity_ID, 1 /*EntityTable*/);  
  
    DECLARE @LeafQueryTemplate NVARCHAR(MAX) =   
        REPLACE(  
            REPLACE(@QueryTemplate,   
                N'{MemberTypePlaceholder}', @MemberType_Leaf),  
            N'{TableNamePlaceholder}', @TableName);  
      
    -- !!!Matching on MUID and Code is done in two separate queries on purpose. Combining the two results in significantly worse performance!!!  
    SET @SQL = CONCAT(  
        REPLACE(@LeafQueryTemplate, N'{ColumnNamePlaceholder}', N'MUID'),  
        REPLACE(@LeafQueryTemplate, N'{ColumnNamePlaceholder}', N'Code'))  
  
    EXEC sp_executesql @SQL, N'@Version_ID INT', @Version_ID;  
  
    --Type 2 (HierarchyParentTable)  
    SET @TableName = mdm.udfTableNameGetByID(@Entity_ID, 2 /*HierarchyParentTable*/);  
    IF EXISTS(SELECT 1 FROM #MemberIdsWorkingSet WHERE ID IS NULL) AND  
       @TableName IS NOT NULL  
    BEGIN  
        DECLARE @ConsolidatedQueryTemplate NVARCHAR(MAX) =   
            REPLACE(  
                REPLACE(@QueryTemplate,   
                    N'{MemberTypePlaceholder}', @MemberType_Consolidated),  
                N'{TableNamePlaceholder}', @TableName);  
      
        SET @SQL = CONCAT(  
            REPLACE(@ConsolidatedQueryTemplate, N'{ColumnNamePlaceholder}', N'MUID'),  
            REPLACE(@ConsolidatedQueryTemplate, N'{ColumnNamePlaceholder}', N'Code'))  
  
        EXEC sp_executesql @SQL, N'@Version_ID INT', @Version_ID;  
    END  
  
  
    --Type 3 (CollectionTable)  
    SELECT @TableName = mdm.udfTableNameGetByID(@Entity_ID, 3 /*CollectionTable*/);  
    IF EXISTS(SELECT 1 FROM #MemberIdsWorkingSet WHERE ID IS NULL) AND  
       @TableName IS NOT NULL  
    BEGIN  
        DECLARE @CollectionQueryTemplate NVARCHAR(MAX) =   
            REPLACE(  
                REPLACE(@QueryTemplate,   
                    N'{MemberTypePlaceholder}', @MemberType_Collection),  
                N'{TableNamePlaceholder}', @TableName);  
  
        SET @SQL = CONCAT(  
            REPLACE(@CollectionQueryTemplate, N'{ColumnNamePlaceholder}', N'MUID'),  
            REPLACE(@CollectionQueryTemplate, N'{ColumnNamePlaceholder}', N'Code'))  
  
        EXEC sp_executesql @SQL, N'@Version_ID INT', @Version_ID;  
    END; --if  
  
    -- Return member info  
    SELECT  
        ID,  
        MemberType_ID,  
        Code,  
        MUID  
    FROM #MemberIdsWorkingSet  
    WHERE ID IS NOT NULL; -- Do not include invalid member codes in the result set  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpMembersValidationStatusUpdate]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
SELECT mdm.udfTableNameGetByID(32,1);  
select * from mdm.tblModelVersion where Model_ID = 7  
  
exec mdm.udpMembersValidationStatusUpdate 32,1,4,20  
select ID, ValidationStatus_ID FROM mdm.viw_SYSTEM_7_32_CHILDATTRIBUTES WHERE Version_ID = 20;  
  
exec mdm.udpMembersValidationStatusUpdate 32,2,4,20  
select ID, ValidationStatus_ID FROM mdm.viw_SYSTEM_7_32_PARENTATTRIBUTES WHERE Version_ID = 20;  
  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpMembersValidationStatusUpdate]  
(  
    @Entity_ID              INT,  
    @MemberType_ID          TINYINT,  
    @ValidationStatus_ID    INT,  
    @Version_ID             INT = NULL,  
    @MemberIdList           mdm.IdList READONLY,  
    @CorrelationID          UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    -- Update the all member records, for all membertypes, for non-committed versions, for the specified Entity.  
    DECLARE @SQL                NVARCHAR(MAX),  
            @memberTable        SYSNAME,  
            @annotationTable    SYSNAME,  
            @StatusPurged       TINYINT = 3;  
  
    SET @memberTable = mdm.udfTableNameGetByID(@Entity_ID, @MemberType_ID);  
    SET @annotationTable = CONVERT(SYSNAME, CONCAT(@memberTable, N'_AN'));  
  
    SET @SQL = N'  
        DECLARE @RevisionIDMapping TABLE (Old BIGINT, New BIGINT);  
        UPDATE mdm.' + QUOTENAME(@memberTable) + N' SET  
            ValidationStatus_ID = @ValidationStatus_ID  
        OUTPUT DELETED.[LastChgTS], INSERTED.[LastChgTS]  
        INTO @RevisionIDMapping  
        FROM mdm.' + QUOTENAME(@memberTable) + N' AS t  
        INNER JOIN mdm.tblModelVersion AS v  
            ON t.Version_ID = v.ID';  
    IF EXISTS(SELECT 1 FROM @MemberIdList)  
        SET @SQL += N'  
        INNER JOIN @MemberIdList AS m  
            ON t.ID = m.ID';  
    SET @SQL += N'  
        WHERE  
            v.Status_ID <> '+ CONVERT(NVARCHAR(1), @StatusPurged) + N'  
            AND t.ValidationStatus_ID <> @ValidationStatus_ID';  
    IF @Version_ID IS NOT NULL  
        SET @SQL += N'  
            AND v.ID = @Version_ID;  
         ';  
  
     SET @SQL += N'  
        UPDATE an  
        SET [Revision_ID] = map.New  
        FROM mdm.' + QUOTENAME(@annotationTable) + N' an  
        INNER JOIN @RevisionIDMapping map  
        ON an.Revision_ID = map.Old AND an.Version_ID = @Version_ID  
        ';  
  
    --PRINT @SQL;  
    EXEC sp_executesql @SQL, N'@Version_ID INT, @ValidationStatus_ID INT, @MemberIdList mdm.IdList READONLY', @Version_ID, @ValidationStatus_ID, @MemberIdList;  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpMemberTypeGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpMemberTypeGet]  
(  
     @User_ID       INT  
  
    ,@Model_MUID    UNIQUEIDENTIFIER = NULL  
    ,@Model_Name    NVARCHAR(50) = NULL  
    ,@Model_ID      INT = NULL -- set internally only  
  
    ,@Entity_MUID   UNIQUEIDENTIFIER = NULL  
    ,@Entity_Name   NVARCHAR(50) = NULL  
    ,@Entity_ID     INT = NULL -- set internally only  
  
    ,@MemberType_ID TINYINT = NULL  
  
    -- Only used when getting details  
    ,@AttributeGroup_MUID   UNIQUEIDENTIFIER = NULL  
    ,@AttributeGroup_Name   NVARCHAR(50) = NULL  
  
    ,@Attribute_MUID   UNIQUEIDENTIFIER = NULL  
    ,@Attribute_Name   NVARCHAR(100) = NULL  
  
    ,@ResultOption TINYINT -- None = 0, Identifiers = 1, Details = 2.   
   
    ,@IncludeParentIdentifiers  BIT = 1 -- Return results sets for parent Model and Entity identifiers. Set to 0 when getting attributes as part of a parent object (because the parent identifiers will already have been looked up).  
    ,@OmitAttributes            BIT = 0 -- When 1, a result set is not returned for attributes. This should be set to 1 when the caller will return Attributes. Ignored when @ResultOption is not Details.  
    ,@Debug                     BIT = 0  
    ,@CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
  
    SET NOCOUNT ON  
  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), ': begin udpMemberTypeGet, @Model_ID = ', @Model_ID, N', @Entity_ID = ', @Entity_ID, N', @MemberType_ID = ', @MemberType_ID)  
  
    DECLARE   
         @ResultOption_Identifiers  TINYINT = 1  
        ,@ResultOption_Details      TINYINT = 2  
  
    -- Get model ID  
    IF @Model_ID IS NULL -- If the ID was already provided, don't bother looking it up again  
        AND (@Model_Name IS NOT NULL OR @Model_MUID IS NOT NULL)  
    BEGIN  
        IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), ': lookup @Model_ID')  
        SELECT   
             @Model_ID = ID  
            ,@Model_MUID = MUID  
            ,@Model_Name = Name  
        FROM mdm.tblModel  
        WHERE   MUID = ISNULL(@Model_MUID, MUID)  
            AND Name = ISNULL(@Model_Name, Name)  
  
        SET @Model_ID = COALESCE(@Model_ID, 0)  
    END  
  
    -- Get entity ID  
    IF @Entity_ID IS NULL -- If the ID was already provided, don't bother looking it up again  
        AND (@Entity_Name IS NOT NULL OR @Entity_MUID IS NOT NULL)  
    BEGIN  
        IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), ': lookup @Entity_ID')  
        SELECT  
             @Model_ID = Model_ID  
            ,@Entity_ID = ID  
            ,@Entity_MUID = MUID  
            ,@Entity_Name = Name  
        FROM mdm.tblEntity  
        WHERE   MUID = ISNULL(@Entity_MUID, MUID)  
            AND Name = ISNULL(@Entity_Name, Name)  
            AND Model_ID = ISNULL(@Model_ID, Model_ID) -- If a model filter is specified, use it  
  
        SET @Entity_ID = COALESCE(@Entity_ID, 0)  
    END  
  
    DECLARE @SelectedMemberType TABLE  
    (  
         ID                 TINYINT  
        ,Entity_ID          INT  
        ,Model_ID           INT  
        ,Privilege_ID       TINYINT  
        ,AccessPermission   TINYINT  
        PRIMARY KEY (ID, Entity_ID)  
    )  
  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), ': selecting into #SelectedMemberType')  
    INSERT INTO @SelectedMemberType  
    SELECT  
         mt.ID  
        ,mt.Entity_ID  
        ,e.Model_ID  
        ,mt.Privilege_ID  
        ,mt.AccessPermission  
    FROM mdm.viw_SYSTEM_SECURITY_USER_MEMBERTYPE mt  
    INNER JOIN mdm.tblEntity e  
    ON mt.Entity_ID = e.ID  
    WHERE   mt.User_ID = @User_ID  
        AND e.Model_ID = ISNULL(@Model_ID, e.Model_ID)  
        AND mt.Entity_ID = ISNULL(@Entity_ID, mt.Entity_ID)  
        AND mt.ID = ISNULL(@MemberType_ID, mt.ID)  
        AND mt.Privilege_ID > 1/*Deny*/  
  
    IF @IncludeParentIdentifiers = 1  
    BEGIN  
        IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), ': returning parent identifiers')  
        -- Return model Identifier(s)  
        IF @Model_ID IS NOT NULL  
        BEGIN  
            IF @Model_Name IS NULL OR @Model_MUID IS NULL  
            BEGIN  
                SELECT   
                     @Model_MUID = MUID  
                    ,@Model_Name = Name  
                FROM mdm.tblModel  
                WHERE ID = @Model_ID  
            END  
  
            -- A single model was specified, and its info has already been looked up, so simply return it  
            SELECT   
                 @Model_MUID    AS Model_MUID  
                ,@Model_Name    AS Model_Name  
                ,@Model_ID      AS Model_ID  
        END ELSE  
        BEGIN  
            SELECT DISTINCT  
                 m.MUID AS Model_MUID  
                ,m.Name AS Model_Name  
                ,m.ID   AS Model_ID  
            FROM @SelectedMemberType mt  
            INNER JOIN mdm.tblEntity e  
            ON mt.Entity_ID = e.ID  
            INNER JOIN mdm.tblModel m  
            ON e.Model_ID = m.ID  
        END  
  
        -- Return entity Identifier(s)  
        IF @Entity_ID IS NOT NULL  
        BEGIN  
            -- A single entity was specified, and its info has already been looked up, so simply return it  
            SELECT   
                 @Model_ID      AS Model_ID  
                ,@Entity_MUID   AS Entity_MUID  
                ,@Entity_Name   AS Entity_Name  
                ,@Entity_ID     AS Entity_ID  
        END ELSE  
        BEGIN  
            SELECT DISTINCT  
                 e.Model_ID AS Model_ID  
                ,e.MUID AS Entity_MUID  
                ,e.Name AS Entity_Name  
                ,e.ID   AS Entity_ID  
            FROM @SelectedMemberType mt  
            INNER JOIN mdm.tblEntity e  
            ON mt.Entity_ID = e.ID  
        END  
    END  
  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), ': returning member type info')  
    SELECT  
         ID AS MemberType_ID  
        ,Entity_ID  
        ,Privilege_ID  
        ,AccessPermission  
    FROM @SelectedMemberType  
    ORDER BY Model_ID, Entity_ID, ID  
  
    IF @ResultOption = @ResultOption_Details  
    BEGIN  
        EXEC mdm.udpAttributeGroupGet  
             @User_ID = @User_ID  
            ,@Model_ID = @Model_ID  
            ,@Entity_ID = @Entity_ID  
            ,@MemberType_ID = @MemberType_ID  
            ,@AttributeGroup_MUID = @AttributeGroup_MUID  
            ,@AttributeGroup_Name = @AttributeGroup_Name  
            ,@Attribute_MUID = @Attribute_MUID  
            ,@Attribute_Name = @Attribute_Name  
            ,@ResultOption = @ResultOption_Details  
            ,@IncludeParentIdentifiers = 0 -- parent Ids already returned  
            ,@OmitAttributes = 1 -- Attributes will be returned by the next call  
            ,@Debug = @Debug  
            ,@CorrelationID = @CorrelationID  
  
        IF COALESCE(@OmitAttributes, 1) = 0  
        BEGIN  
            EXEC mdm.udpAttributeGet  
                 @User_ID = @User_ID  
                ,@Model_ID = @Model_ID  
                ,@Entity_ID = @Entity_ID  
                ,@MemberType_ID = @MemberType_ID  
                ,@AttributeGroup_MUID = @AttributeGroup_MUID  
                ,@AttributeGroup_Name = @AttributeGroup_Name  
                ,@Attribute_MUID = @Attribute_MUID  
                ,@Attribute_Name = @Attribute_Name  
                ,@IncludeParentIdentifiers = 0 -- parent Ids already returned  
                ,@Debug = @Debug  
                ,@CorrelationID = @CorrelationID  
        END  
    END   
  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), ': end udpMemberTypeGet')  
  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpMemberTypeIDAndIDGetByCode]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
    --Type 1  
    DECLARE @TempMemberType_ID INT  
    DECLARE @TempMember_ID INT  
    EXEC mdm.udpMemberTypeIDAndIDGetByCode 2,7,'1150',@TempMemberType_ID OUTPUT,@TempMember_ID OUTPUT  
    SELECT @TempMember_ID, @TempMemberType_ID  
  
    --Type 2  
    DECLARE @TempMemberType_ID INT;  
    DECLARE @TempMember_ID INT;  
    EXEC mdm.udpMemberTypeIDAndIDGetByCode 2,7,'10',@TempMemberType_ID OUTPUT,@TempMember_ID OUTPUT  
    SELECT @TempMember_ID, @TempMemberType_ID  
  
    --Error  
    DECLARE @TempMemberType_ID INT  
    DECLARE @TempMember_ID INT  
    EXEC mdm.udpMemberTypeIDAndIDGetByCode 2,8,'KABOOM',@TempMemberType_ID OUTPUT,@TempMember_ID OUTPUT  
    SELECT @TempMember_ID, @TempMemberType_ID;  
*/  
CREATE PROCEDURE [mdm].[udpMemberTypeIDAndIDGetByCode]  
(  
    @Version_ID     INTEGER,  
    @Entity_ID      INTEGER,  
    @MemberCode     NVARCHAR(250),  
    @MemberType_ID  TINYINT = NULL OUTPUT,  
    @Member_ID      INTEGER = NULL OUTPUT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
    
    DECLARE @sql            NVARCHAR(MAX);  
    DECLARE @TempTableName  sysname;  
    DECLARE @TempID         INTEGER;   
      
    --Initialize output variables  
    SELECT @MemberType_ID = NULL, @Member_ID = NULL;  
  
    -- Trim MemberCode  
    SET @MemberCode = NULLIF(LTRIM(RTRIM(@MemberCode)), N'');  
  
    --Check from ROOT  
    IF @MemberCode IS NULL OR LEN(@MemberCode) = 0 OR UPPER(@MemberCode) = N'ROOT' BEGIN              
        SELECT @MemberType_ID = 2, @Member_ID = 0;  
        RETURN(0);  
    END; --if  
  
    --Check from UnUsed(Non mandatory hierarchies)  
    IF UPPER(@MemberCode) = N'MDMUNUSED' BEGIN              
        SELECT @MemberType_ID = 2, @Member_ID = -1;  
        RETURN(0);  
    END; --if  
  
    --Type 1 (EntityTable)  
    BEGIN  
        SET @TempTableName = mdm.udfTableNameGetByID(@Entity_ID, 1);  
        SET @sql = N'  
            SELECT TOP 1 @TempID = ID FROM mdm.' + quotename(@TempTableName) + N'   
            WHERE Version_ID = @Version_ID AND Code = @Code ORDER BY ID;';  
        EXEC sp_executesql @sql, N'@Code NVARCHAR(250), @Version_ID INT, @TempID INT OUTPUT', @MemberCode, @Version_ID, @TempID OUTPUT;  
  
        IF ISNULL(@TempID, 0) <> 0 BEGIN  
            SELECT @MemberType_ID = 1, @Member_ID = @TempID;  
            RETURN(0);  
        END; --if  
    END; ---begin  
  
    --Type 2 (HierarchyParentTable)  
    SET @TempTableName = mdm.udfTableNameGetByID(@Entity_ID, 2);  
    IF @TempTableName IS NOT NULL BEGIN  
        SET @sql = N'  
            SELECT TOP 1 @TempID=ID FROM mdm.' + quotename(@TempTableName) + N'   
            WHERE Version_ID = @Version_ID AND Code = @Code ORDER BY ID;';  
        EXEC sp_executesql @sql, N'@Code NVARCHAR(250), @Version_ID INT, @TempID INT OUTPUT', @MemberCode, @Version_ID, @TempID OUTPUT;  
          
        IF ISNULL(@TempID, 0) <> 0 BEGIN  
            SELECT @MemberType_ID = 2, @Member_ID = @TempID;  
            RETURN(0);  
        END; --if  
    END  
  
    --Type 3 (CollectionTable)  
    SET @TempTableName = mdm.udfTableNameGetByID(@Entity_ID, 3);  
    IF @TempTableName IS NOT NULL BEGIN  
        SELECT @sql = N'  
            SELECT TOP 1 @TempID=ID FROM mdm.' + quotename(@TempTableName) + N'   
            WHERE Version_ID = @Version_ID AND Code = @Code ORDER BY ID;';  
        EXEC sp_executesql @sql, N'@Code NVARCHAR(250), @Version_ID INT, @TempID INT OUTPUT', @MemberCode, @Version_ID, @TempID OUTPUT;  
          
        IF ISNULL(@TempID, 0) <> 0 BEGIN  
            SELECT @MemberType_ID = 3, @Member_ID = @TempID;  
            RETURN(0);  
        END; --if  
          
    END; --if  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpMemberValidationStatusUpdate]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
  
EXEC mdm.udpMemberValidationStatusUpdate 1,9,7,1,2  
  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpMemberValidationStatusUpdate]  
(  
	@Version_ID				INTEGER,  
	@Entity_ID     			INTEGER,  
	@Member_ID				INTEGER,  
	@MemberType_ID			TINYINT,  
	@ValidationStatus_ID	INTEGER,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
	SET NOCOUNT ON  
  
	DECLARE @TempSQLString 	NVARCHAR(MAX);  
	DECLARE @TempTableName 	sysname  
  
	SELECT @TempTableName = mdm.udfTableNameGetByID(@Entity_ID,@MemberType_ID);  
  
	SELECT @TempSQLString = N'  
		UPDATE mdm.' + quotename(@TempTableName) + N'   
		SET ValidationStatus_ID = @ValidationStatus_ID  
		WHERE Version_ID = @Version_ID   
		AND ID = @Member_ID';  
	EXEC sp_executesql @TempSQLString, N'@Version_ID INT, @ValidationStatus_ID INT, @Member_ID INT', @Version_ID, @ValidationStatus_ID, @Member_ID;  
  
	SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpMetadataDeleteByMUID]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    Deletes the metadata object pertaining to the given MUID. Verifies that  
    the given user has appropriate permission  
*/  
CREATE PROCEDURE [mdm].[udpMetadataDeleteByMUID]  
(  
     @User_ID       INT  
    ,@Object_MUID   UNIQUEIDENTIFIER  
    ,@ObjectType_ID TINYINT -- The object type of the Muid being passed in.  
    ,@CorrelationID UNIQUEIDENTIFIER = NULL -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE   
         @FunctionalPrivilege_Versions  TINYINT = 2  
        ,@FunctionalPrivilege_SysAdmin  TINYINT = 5  
  
        ,@ObjectType_Model                  TINYINT = 1  
        ,@ObjectType_DerivedHierarchy       TINYINT = 2  
        ,@ObjectType_DerivedHierarchyLevel  TINYINT = 3  
        ,@ObjectType_Version                TINYINT = 4  
        ,@ObjectType_Entity                 TINYINT = 5  
        ,@ObjectType_Hierarchy              TINYINT = 6  
        ,@ObjectType_Attribute              TINYINT = 7  
        ,@ObjectType_AttributeGroup         TINYINT = 8  
        ,@ObjectType_VersionFlag            TINYINT = 10  
        ,@ObjectType_Index                  TINYINT = 23  
        ;  
  
    -- Functional permission check  
    IF mdm.udfSecurityUserFunctionIsAllowed(@User_ID, @FunctionalPrivilege_SysAdmin) = 0  
        AND (@ObjectType_ID NOT IN (@ObjectType_Version, @ObjectType_VersionFlag) -- can modify versions and version flags with Versions functional privilege  
            OR mdm.udfSecurityUserFunctionIsAllowed(@User_ID, @FunctionalPrivilege_Versions) = 0)  
    BEGIN  
        RAISERROR('MDSERR120002|The user does not have permission to perform this operation.', 16, 1);  
        RETURN;  
    END  
  
    -- Model admin check  
    DECLARE @IsModelAdmin  INT;  
    EXEC mdm.udpUserIsModelAdministrator @User_ID = @User_ID, @ObjectType_ID = @ObjectType_ID, @Object_MUID = @Object_MUID, @Return_ID = @IsModelAdmin OUTPUT  
    IF COALESCE(@IsModelAdmin, 0) = 0  
    BEGIN  
        RAISERROR('MDSERR120003|The user does not have permission or the object ID is not valid.', 16, 1);  
        RETURN;  
    END  
  
    --Start transaction, being careful to check if we are nested  
    DECLARE @TranCounter INT = @@TRANCOUNT;  
    IF @TranCounter > 0 SAVE TRANSACTION TX;  
    ELSE BEGIN TRANSACTION;  
  
    BEGIN TRY  
  
        -- Check for dependencies that would prevent deletion.  
        DECLARE @Object_ID INT;  
        EXEC mdm.udpObjectDeleteCheckByMUID @Object_MUID = @Object_MUID, @ObjectType_ID = @ObjectType_ID, @Object_ID = @Object_ID OUTPUT  
  
        IF COALESCE(@Object_ID, 0) <= 0  
        BEGIN  
            RAISERROR('MDSERR120003|The user does not have permission or the object ID is not valid.', 16, 1);  
            RETURN;  
        END  
  
        IF @ObjectType_ID = @ObjectType_Model  
        BEGIN  
            EXEC mdm.udpModelDelete @Model_ID = @Object_ID;  
        END   
          
        ELSE IF @ObjectType_ID = @ObjectType_DerivedHierarchy  
        BEGIN  
            EXEC mdm.udpDerivedHierarchyDelete @ID = @Object_ID;  
        END   
          
        ELSE IF @ObjectType_ID = @ObjectType_DerivedHierarchyLevel  
        BEGIN  
            EXEC mdm.udpDerivedHierarchyDetailDelete @ID = @Object_ID;  
        END   
          
        ELSE IF @ObjectType_ID = @ObjectType_Version  
        BEGIN  
            EXEC mdm.udpVersionDelete @Version_ID = @Object_ID;  
        END   
          
        ELSE IF @ObjectType_ID = @ObjectType_Entity  
        BEGIN  
            EXEC mdm.udpEntityDelete @Entity_ID = @Object_ID, @CreateViewsInd = 1;  
        END   
          
        ELSE IF @ObjectType_ID = @ObjectType_Hierarchy  
        BEGIN  
            EXEC mdm.udpEntityHierarchyDelete @User_ID = @User_ID, @Hierarchy_ID = @Object_ID  
        END   
          
        ELSE IF @ObjectType_ID = @ObjectType_Attribute  
        BEGIN  
            EXEC mdm.udpAttributeDelete @Attribute_ID = @Object_ID, @CreateViewsInd = 1  
        END   
          
        ELSE IF @ObjectType_ID = @ObjectType_AttributeGroup  
        BEGIN  
            EXEC mdm.udpAttributeGroupDelete @ID = @Object_ID;  
        END   
          
        ELSE IF @ObjectType_ID = @ObjectType_VersionFlag  
        BEGIN  
            EXEC mdm.udpModelVersionFlagDelete @VersionFlag_ID = @Object_ID;  
        END   
          
        ELSE IF @ObjectType_ID = @ObjectType_Index  
        BEGIN  
            EXEC mdm.udpIndexDelete @ID = @Object_ID;  
        END   
  
        --Commit only if we are not nested  
        IF @TranCounter = 0 COMMIT TRANSACTION;  
        RETURN(0);  
  
    END TRY  
    --Compensate as necessary  
    BEGIN CATCH  
  
        -- Get error info.  
        DECLARE  
            @ErrorMessage NVARCHAR(4000),  
            @ErrorSeverity INT,  
            @ErrorState INT,  
            @ErrorNumber INT,  
            @ErrorLine INT,  
            @ErrorProcedure NVARCHAR(126);  
        EXEC mdm.udpGetErrorInfo  
            @ErrorMessage = @ErrorMessage OUTPUT,  
            @ErrorSeverity = @ErrorSeverity OUTPUT,  
            @ErrorState = @ErrorState OUTPUT,  
            @ErrorNumber = @ErrorNumber OUTPUT,  
            @ErrorLine = @ErrorLine OUTPUT,  
            @ErrorProcedure = @ErrorProcedure OUTPUT  
  
        SET @ErrorMessage = CONCAT(@ErrorMessage, N', @ErrorNumber = ', @ErrorNumber, N', @ErrorProcedure = "', @ErrorProcedure, N'", line ', @ErrorLine);  
  
        IF @TranCounter = 0 ROLLBACK TRANSACTION;  
        ELSE IF XACT_STATE() <> -1 ROLLBACK TRANSACTION TX;  
  
        RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);  
  
    END CATCH;  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpMetaDataGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
This SPROC is used by the MasterData API to get a list of objects the user has access.  
The API used this proc to get the objects and then uses ModelsGet operation to export the requested data  
  
EXEC mdm.udpMetaDataGet 1  
exec mdm.udpMetaDataGet @User_ID=1,@ModelCriteria=N'202a5729-9fcb-4cbf-a302-dcdc1a567b08',@VersionCriteria=N'dd883ab8-ddee-4429-8460-6513471372e4,84c20604-bbc4-4884-9dac-40504ad88329',@EntityCriteria=N'7811f06e-7004-4389-bdbf-c1743d32efe2'  
  
*/  
  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpMetaDataGet]  
    (  
    @User_ID					INT,  
	@ModelCriteria				NVARCHAR(MAX) = NULL,  
	@VersionCriteria			NVARCHAR(MAX) = NULL,  
	@EntityCriteria				NVARCHAR(MAX) = NULL,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
	SET NOCOUNT ON  
	  
	DECLARE @SQL	NVARCHAR(MAX)  
	DECLARE @UserID	NVARCHAR(100)  
  
	SET @UserID = CONVERT(NVARCHAR(100),@User_ID)  
	SET @SQL = CAST(N'  
				SELECT   
					M.ID Model_ID,  
					M.MUID as Model_MUID,  
					M.Name as Model_Name,  
					MV.ID as Version_ID,  
					MV.MUID as Version_MUID,  
					MV.Name as Version_Name,  
					E.ID Entity_ID,  
					E.MUID as Entity_MUID,  
					E.Name as Entity_Name,  
					X.MemberType_ID,  
					X.Hierarchy_ID,  
					X.HierarchyType_ID   
				FROM  
					(  
						--Entities  
						select E.ID as Entity_ID,MT.ID as MemberType_ID,NULL as Hierarchy_ID ,NULL as HierarchyType_ID   
						from mdm.viw_SYSTEM_SECURITY_USER_ENTITY E  
							INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_MEMBERTYPE MT ON MT.Entity_ID=E.ID AND E.User_ID=MT.User_ID  
						WHERE   
							E.User_ID = @UserID AND   
							E.Privilege_ID <> 1  
					) X  
						INNER JOIN mdm.tblEntity E ON E.ID = X.Entity_ID   
						INNER JOIN mdm.tblModelVersion MV ON MV.Model_ID = E.Model_ID   
						INNER JOIN mdm.tblModel M ON M.ID = E.Model_ID   
					WHERE 1=1  
				' AS NVARCHAR(max))  
				IF (@ModelCriteria IS NOT NULL) AND (LEN(@ModelCriteria) > 0) SET @SQL = @SQL + N' AND M.MUID IN (''' + REPLACE(@ModelCriteria,N',',N''',''') + N''') '  
				IF (@VersionCriteria IS NOT NULL) AND (LEN(@VersionCriteria) > 0)  SET @SQL = @SQL + N' AND MV.MUID IN (''' + REPLACE(@VersionCriteria,N',',N''',''') + N''') '  
				IF (@EntityCriteria IS NOT NULL) AND (LEN(@EntityCriteria) > 0) SET @SQL = @SQL + N' AND E.MUID IN (''' + REPLACE(@EntityCriteria,N',',N''',''') + N''') '  
  
				SET @SQL = @SQL + N'  
				ORDER BY   
					M.ID,  
					MV.ID,  
					E.ID,  
					X.MemberType_ID,  
					X.Hierarchy_ID,  
					X.HierarchyType_ID  
				'  
		EXEC sp_executesql @SQL, N'@UserID INT', @UserID;  
  
		SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpMetadataItemReservedCharactersCheck]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
/*  
Description: mdm.udpMetadataItemReservedCharactersCheck verifies an input value against a list of reserved characters  
Parameters : @Item (to be verified) , @HasReservedCharacters (output parameter with the result. 1 if value has reserved characters, 0 otherwise)  
  
Example 1:   
DECLARE @HasReservedCharacters BIT;  
SELECT mdm.udpMetadataItemReservedCharactersCheck('Attribute1', @HasReservedCharacters OUTPUT)   --0 = Passes verification (no reserved characters)  
  
Example 2:  
DECLARE @HasReservedCharacters BIT;  
SELECT mdm.udpMetadataItemReservedCharactersCheck('Attribute<\n>2', @HasReservedCharacters OUTPUT) --1 = Fails verification (has newline. <\n> used to indicate newline)  
*/  
  
CREATE PROCEDURE [mdm].[udpMetadataItemReservedCharactersCheck]   
(  
    @Item NVARCHAR(MAX),   
    @HasReservedCharacters BIT OUTPUT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)   
/*WITH*/  
AS BEGIN   
    SET NOCOUNT ON  
  
    DECLARE @Tab                    NCHAR(1) = CHAR(9),  
            @NewLine                NCHAR(1) = CHAR(10),  
            @CarriageReturn         NCHAR(1) = CHAR(13);  
  
    --Make sure that the Item does have characters to check. No point doing all these checks for nulls or empty strings  
    IF NULLIF(@Item, N'') IS NOT NULL  
    BEGIN  
        --Check for tabs, newlines or carriage return chars  
        IF (CHARINDEX(@Tab, @Item) != 0 OR CHARINDEX(@NewLine, @Item) != 0 OR CHARINDEX(@CarriageReturn, @Item) != 0)  
        BEGIN  
            SET @HasReservedCharacters = 1;  
            RETURN;  
        END  
  
        --Check for chars that can not be serialized to XML by the SQL engine  
        BEGIN TRY  
            DECLARE @Result XML;  
            SELECT @Result = CONVERT(XML, (SELECT @Item FOR XML PATH));  
        END TRY  
        BEGIN CATCH  
            SET @HasReservedCharacters = 1;  
            RETURN;  
        END CATCH  
    END  
  
    SET @HasReservedCharacters = 0;  
  
    SET NOCOUNT OFF  
END --udpMedatataItemReservedCharactersCheck
GO
/****** Object:  StoredProcedure [mdm].[udpMetadataSave]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpMetadataSave]  
(  
    @User_ID                INT,  
    @Models                 mdm.Model READONLY,  
    @VersionFlags           mdm.VersionFlag READONLY,  
    @Entities               mdm.Entity READONLY,  
    @ExplicitHierarchies    mdm.ExplicitHierarchy READONLY,  
    @Attributes             mdm.Attribute READONLY,  
    @AttributeFilters       mdm.AttributeFilter READONLY,  
    @AttributeGroups        mdm.AttributeGroup READONLY,  
    @AttributeGroupDetails  mdm.AttributeGroupDetail READONLY,  
    @DerivedHierarchies     mdm.DerivedHierarchy READONLY,  
    @DerivedHierarchyLevels mdm.DerivedHierarchyLevel READONLY,  
    @Indexes                mdm.CustomIndex READONLY,  
    @IndexDetails           mdm.CustomIndexDetail READONLY,  
    @EditMode               TINYINT, --0: Create, 1: Update, 4: Clone  
    @CorrelationID          UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE  
         @FunctionalPrivilege_Versions  TINYINT = 2  
        ,@FunctionalPrivilege_SysAdmin  TINYINT = 5  
  
        ,@EditMode_Create   TINYINT = 0  
        ,@EditMode_Update   TINYINT = 1  
        ,@EditMode_Clone    TINYINT = 4  
  
        ,@HierarchyItemType_Entity              TINYINT = 0  
        ,@HierarchyItemType_DBA                 TINYINT = 1  
        ,@HierarchyItemType_Hierarchy           TINYINT = 2  
        ,@HierarchyItemType_ManyToMany          TINYINT = 5  
  
        ,@MemberType_Leaf           TINYINT = 1  
        ,@MemberType_Consolidated   TINYINT = 2  
        ,@MemberType_Collection     TINYINT = 3  
  
        ,@GuidEmpty  UNIQUEIDENTIFIER = CAST(0x0 AS UNIQUEIDENTIFIER)  
              
        ,@Model_ID      INT  
        ,@Model_MUID    UNIQUEIDENTIFIER  
        ,@ModelName     NVARCHAR(50)  
        ,@MaxVersion_ID INT  
        ,@Entity_ID     INT  
        ,@Entity_MUID   UNIQUEIDENTIFIER  
        ,@EntityName    NVARCHAR(50)  
        ,@MemberType_ID TINYINT  
             
        ,@Error NVARCHAR(MAX)  
        ,@Row_ID     INT  
        ,@VersionFlagsOnly BIT = CASE  
            WHEN        EXISTS (SELECT 1 FROM @VersionFlags)  
                AND NOT EXISTS (SELECT 1 FROM @Models)  
                AND NOT EXISTS (SELECT 1 FROM @Entities)  
                AND NOT EXISTS (SELECT 1 FROM @ExplicitHierarchies)  
                AND NOT EXISTS (SELECT 1 FROM @Attributes)  
                --AND NOT EXISTS (SELECT 1 FROM @AttributeFilters) -- No need to check. Checking @Attributes is sufficient  
                AND NOT EXISTS (SELECT 1 FROM @AttributeGroups)  
                --AND NOT EXISTS (SELECT 1 FROM @AttributeGroupDetails) -- No need to check. Checking @AttibuteGroups is sufficient  
                AND NOT EXISTS (SELECT 1 FROM @DerivedHierarchies)  
                AND NOT EXISTS (SELECT 1 FROM @DerivedHierarchyLevels)  
                AND NOT EXISTS (SELECT 1 FROM @Indexes)  
                --AND NOT EXISTS (SELECT 1 FROM @IndexDetails) -- No need to check. Checking @Indexes is sufficient  
            THEN 1 ELSE 0 END;  
  
    --If the user doesn't have sys admin or super user permission then they do not have permission to save metadata  
    IF mdm.udfSecurityUserFunctionIsAllowed(@User_ID, @FunctionalPrivilege_SysAdmin) = 0  
        AND (@VersionFlagsOnly = 0 -- can modify version flags with Versions functional privilege  
            OR mdm.udfSecurityUserFunctionIsAllowed(@User_ID, @FunctionalPrivilege_Versions) = 0)  
    BEGIN  
        RAISERROR('MDSERR120002|The user does not have permission to perform this operation.', 16, 1);  
        RETURN;  
    END  
  
    DECLARE @CreatedModels TABLE   
    (  
        ID INT,  
        MUID UNIQUEIDENTIFIER,  
        Name NVARCHAR(50) COLLATE DATABASE_DEFAULT  
    );  
  
    DECLARE @CreatedVersionFlags TABLE   
    (  
        ModelID INT,  
        ModelMUID UNIQUEIDENTIFIER,  
        ModelName NVARCHAR(50) COLLATE DATABASE_DEFAULT,  
        ID INT,  
        MUID UNIQUEIDENTIFIER,  
        Name NVARCHAR(50) COLLATE DATABASE_DEFAULT  
    );  
  
    DECLARE @CreatedEntities TABLE   
    (  
        ModelID INT,  
        ModelMUID UNIQUEIDENTIFIER,  
        ModelName NVARCHAR(50) COLLATE DATABASE_DEFAULT,  
        ID INT,  
        MUID UNIQUEIDENTIFIER,  
        Name NVARCHAR(50) COLLATE DATABASE_DEFAULT,  
        DidNameChange BIT  
    );  
  
    DECLARE @CreatedExplicitHierarchies TABLE   
    (  
        ModelID INT,  
        ModelMUID UNIQUEIDENTIFIER,  
        ModelName NVARCHAR(50) COLLATE DATABASE_DEFAULT,  
        EntityID INT,  
        EntityMUID UNIQUEIDENTIFIER,  
        EntityName NVARCHAR(50) COLLATE DATABASE_DEFAULT,  
        ID INT,  
        MUID UNIQUEIDENTIFIER,  
        Name NVARCHAR(50) COLLATE DATABASE_DEFAULT  
    );  
  
    DECLARE @CreatedIndexes TABLE   
    (  
        ModelID INT,  
        ModelMUID UNIQUEIDENTIFIER,  
        ModelName NVARCHAR(50) COLLATE DATABASE_DEFAULT,  
        EntityID INT,  
        EntityMUID UNIQUEIDENTIFIER,  
        EntityName NVARCHAR(50) COLLATE DATABASE_DEFAULT,  
        ID INT,  
        MUID UNIQUEIDENTIFIER,  
        Name NVARCHAR(50) COLLATE DATABASE_DEFAULT  
    );  
  
    DECLARE @CreatedAttributeGroups TABLE   
    (  
        Row_ID  INT PRIMARY KEY,  
        ModelID INT,  
        ModelMUID UNIQUEIDENTIFIER,  
        ModelName NVARCHAR(50) COLLATE DATABASE_DEFAULT,  
        Version_ID  INT, -- for audit info   
        EntityID INT,  
        EntityMUID UNIQUEIDENTIFIER,  
        EntityName NVARCHAR(50) COLLATE DATABASE_DEFAULT,  
        AttributeGroupMemberType TINYINT,  
        ID INT,  
        MUID UNIQUEIDENTIFIER,  
        Name NVARCHAR(50) COLLATE DATABASE_DEFAULT  
    );  
  
    DECLARE @CreatedDerivedHierarchies TABLE   
    (  
        ModelID INT,  
        ModelMUID UNIQUEIDENTIFIER,  
        ModelName NVARCHAR(50) COLLATE DATABASE_DEFAULT,  
        ID INT,  
        MUID UNIQUEIDENTIFIER,  
        Name NVARCHAR(50) COLLATE DATABASE_DEFAULT  
    );  
  
    DECLARE @CreatedDerivedHierarchyLevels TABLE   
    (  
        ModelID INT,  
        ModelMUID UNIQUEIDENTIFIER,  
        ModelName NVARCHAR(50) COLLATE DATABASE_DEFAULT,  
        DerivedHierarchyID INT,  
        DerivedHierarchyMUID UNIQUEIDENTIFIER,  
        DerivedHierarchyName NVARCHAR(50) COLLATE DATABASE_DEFAULT,  
        ID INT,  
        MUID UNIQUEIDENTIFIER,  
        Name NVARCHAR(100) COLLATE DATABASE_DEFAULT  
    );  
  
    --Start transaction, being careful to check if we are nested  
    DECLARE @TranCounter INT = @@TRANCOUNT;  
    IF @TranCounter > 0 SAVE TRANSACTION TX;  
    ELSE BEGIN TRANSACTION;  
  
    DECLARE @Lock INT;  
    BEGIN TRY  
  
        --Get a lock to prevent views from being regenerated until we are done updating all the metadata  
        --If a lock is not available right away give it 10 seconds  
        EXEC @Lock = sp_getapplock @Resource=N'DeferViewGeneration', @LockMode='Exclusive', @LockOwner='Session', @LockTimeout=10000;  
  
        --0 and 1 are acceptable return codes from sp_getapplock  
        IF @Lock NOT IN (0, 1)  
        BEGIN  
            RAISERROR(N'Unable to acquire Lock', 16, 1);  
            RETURN;  
        END  
  
        --BEGIN Model processing  
  
        DECLARE @ModelsToProcess TABLE  
        (  
            RowID               INT IDENTITY(1, 1) NOT NULL PRIMARY KEY,  
            Model_MUID          UNIQUEIDENTIFIER NULL,  
            ModelName           NVARCHAR(50) COLLATE DATABASE_DEFAULT NULL,  
            [Description]       NVARCHAR(500) COLLATE DATABASE_DEFAULT NULL,  
            LogRetentionDays    SMALLINT NULL  
        );  
  
        INSERT INTO @ModelsToProcess  
        (  
            Model_MUID,  
            ModelName,  
            [Description],  
            LogRetentionDays  
        )  
        SELECT  
            Model_MUID,  
            ModelName,  
            [Description],  
            LogRetentionDays  
        FROM @Models;  
  
        DECLARE @ModelDescription   NVARCHAR(500),  
                @LogRetentionDays   SMALLINT  
  
        WHILE EXISTS(SELECT 1 FROM @ModelsToProcess)  
        BEGIN  
            SELECT TOP 1  
                @Row_ID = RowID,  
                @Model_MUID = Model_MUID,  
                @ModelName = ModelName,  
                @ModelDescription = [Description],  
                @LogRetentionDays = LogRetentionDays  
            FROM @ModelsToProcess  
  
            PRINT CONCAT(SYSDATETIME(), N': Saving model ', @ModelName);  
            EXEC mdm.udpModelSave         
                @User_ID = @User_ID,  
                @Model_MUID = @Model_MUID,  
                @ModelName = @ModelName,  
                @Description = @ModelDescription,  
                @LogRetentionDays = @LogRetentionDays,  
                @EditMode = @EditMode,  
                @Return_ID = @Model_ID OUTPUT,  
                @Return_MUID = @Model_MUID OUTPUT,  
                @CorrelationID = @CorrelationID;  
  
            INSERT INTO @CreatedModels  (ID,        MUID,         Name)  
            VALUES                      (@Model_ID, @Model_MUID,  @ModelName);  
  
            DELETE @ModelsToProcess  
            WHERE RowID = @Row_ID;  
  
            -- Since viw_SYSTEM_SECURITY_USER_MODEL will use the model information, truncate copy the related views here.   
            EXEC mdm.udpPerformanceTruncateCopy;  
        END  
  
        --Output the created/updated models  
        SELECT ID, MUID, Name FROM @CreatedModels;  
  
        --END Model processing  
  
  
  
        -- Get models to which the user has access.  
        CREATE TABLE #UserModelAccess   
        (  
             ID                 INT PRIMARY KEY  
            ,Name               NVARCHAR(50) COLLATE DATABASE_DEFAULT NOT NULL   
            ,MUID               UNIQUEIDENTIFIER NOT NULL  
            ,IsAdministrator    BIT NOT NULL  
            ,MaxVersion_ID      INT NOT NULL -- Useful for tracking audit info  
        )  
        CREATE INDEX #ix_UserModelAccess_Name_MUID ON #UserModelAccess(Name, MUID); -- facilitates matching on model name and muid  
        INSERT INTO #UserModelAccess  
        SELECT  
             m.ID  
            ,m.Name  
            ,m.MUID  
            ,CASE sec.Privilege_ID WHEN 5 /*Admin*/ THEN 1 ELSE 0 END IsAdministrator  
            ,MAX(mv.ID) MaxVersion_ID  
        FROM mdm.tblModel m  
        INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_MODEL sec  
        ON m.ID = sec.ID     
        INNER JOIN mdm.tblModelVersion mv  
        ON m.ID = mv.Model_ID  
        WHERE   sec.User_ID = @User_ID   
            AND sec.Privilege_ID > 1/*Deny*/  
        GROUP BY m.ID, m.Name, m.MUID, sec.Privilege_ID  
  
        DECLARE @SyncTargetEntities TABLE  
        (  
            Entity_ID   INT PRIMARY KEY  
        )  
        INSERT INTO @SyncTargetEntities (Entity_ID)  
        SELECT DISTINCT TargetEntity_ID   
        FROM mdm.tblSyncRelationship  
  
        --BEGIN VersionFlag processing  
  
        DECLARE @VersionFlagsToProcess TABLE  
        (  
            RowID               INT IDENTITY(1, 1) NOT NULL PRIMARY KEY,  
            Model_ID            INT NULL,  
            Model_MUID          UNIQUEIDENTIFIER,  
            ModelName           NVARCHAR(50) COLLATE DATABASE_DEFAULT NULL,  
            VersionFlag_MUID    UNIQUEIDENTIFIER NULL,  
            VersionFlagName     NVARCHAR(50) COLLATE DATABASE_DEFAULT NULL,  
            [Description]       NVARCHAR(500) COLLATE DATABASE_DEFAULT NULL,  
            CommittedOnly_ID    BIT NULL,  
            Error               NVARCHAR(MAX) COLLATE DATABASE_DEFAULT NULL  
        );  
  
        INSERT INTO @VersionFlagsToProcess  
        (  
            Model_ID,  
            Model_MUID,  
            ModelName,  
            VersionFlag_MUID,  
            VersionFlagName,  
            [Description],  
            CommittedOnly_ID,  
            Error  
        )  
        SELECT  
            m.ID,  
            m.MUID,  
            m.Name,  
            vf.VersionFlag_MUID,  
            vf.VersionFlagName,  
            vf.[Description],  
            vf.CommittedOnly_ID,  
            CASE   
                WHEN m.ID IS NULL OR m.IsAdministrator = 0 THEN 'MDSERR200006|The version flag cannot be saved. The model ID is not valid.'  
                END  
        FROM @VersionFlags vf  
        -- Note: looking up model ids in a batch here is more efficient that doing it one row at a time in udpModelVersionFlagSave  
        LEFT JOIN #UserModelAccess m  
        ON      (vf.Model_MUID IS NOT NULL OR vf.ModelName IS NOT NULL)   
            AND (vf.Model_MUID IS NULL OR vf.Model_MUID = m.MUID)   
            AND (vf.ModelName  IS NULL OR vf.ModelName  = m.Name)  
  
        SELECT TOP 1 @Error = Error  
        FROM @VersionFlagsToProcess  
        WHERE Error IS NOT NULL;  
  
        IF @Error IS NOT NULL  
        BEGIN  
            SET @Error = REPLACE(@Error, '%', '%%')-- escape out format specifier  
            RAISERROR(@Error, 16, 1);  
        END  
  
        DECLARE   
            @VersionFlag_ID           INT,  
            @VersionFlag_MUID               UNIQUEIDENTIFIER,  
            @VersionFlagName                NVARCHAR(50),  
            @VersionFlagDescription         NVARCHAR(500),  
            @VersionFlagCommittedOnly_ID    BIT = NULL  
  
        WHILE EXISTS(SELECT 1 FROM @VersionFlagsToProcess)  
        BEGIN  
            SELECT  TOP 1  
                @Row_ID = RowID,  
                @Model_ID = Model_ID,  
                @Model_MUID = Model_MUID,  
                @ModelName = ModelName,  
                @VersionFlag_MUID = VersionFlag_MUID,  
                @VersionFlagName = VersionFlagName,  
                @VersionFlagDescription = [Description],  
                @VersionFlagCommittedOnly_ID = CommittedOnly_ID  
            FROM @VersionFlagsToProcess  
  
            PRINT CONCAT(SYSDATETIME(), N': Saving version flag ', @VersionFlagName);  
            EXEC mdm.udpModelVersionFlagSave  
                @User_ID = @User_ID,  
                @Model_ID = @Model_ID,  
                @MUID = @VersionFlag_MUID,  
                @Name = @VersionFlagName,  
                @Description = @VersionFlagDescription,  
                @Status_ID = 1,  
                @CommittedOnly_ID = @VersionFlagCommittedOnly_ID,  
                @EditMode = @EditMode,  
                @Return_ID = @VersionFlag_ID OUTPUT,  
                @Return_MUID = @VersionFlag_MUID OUTPUT, --Also an input parameter for clone operations  
                @CorrelationID = @CorrelationID;  
  
            INSERT INTO @CreatedVersionFlags  
            (  
                ModelID,  
                ModelMUID,  
                ModelName,  
                ID,  
                MUID,  
                Name  
            )  
            VALUES  
            (  
                @Model_ID,  
                @Model_MUID,  
                @ModelName,  
                @VersionFlag_ID,  
                @VersionFlag_MUID,  
                @VersionFlagName  
            )  
  
            DELETE @VersionFlagsToProcess  
            WHERE RowID = @Row_ID;  
        END  
  
        --Output created/updated version flags  
        SELECT ModelID, ModelMUID, ModelName, ID, MUID, Name FROM @CreatedVersionFlags;  
  
        --END VersionFlag processing  
  
  
  
        --BEGIN Entity processing  
  
        DECLARE @EntitiesToProcess TABLE  
        (  
            RowID               INT IDENTITY(1, 1) NOT NULL PRIMARY KEY,  
            Model_ID            INT NULL,  
            Model_MUID          UNIQUEIDENTIFIER NULL,  
            ModelName           NVARCHAR(50) COLLATE DATABASE_DEFAULT NULL,  
            Version_ID          INT NULL,  
            Entity_MUID         UNIQUEIDENTIFIER NULL,  
            EntityName          NVARCHAR(50) COLLATE DATABASE_DEFAULT NULL,  
            [Description]       NVARCHAR(500) COLLATE DATABASE_DEFAULT NULL,  
            IsBase              BIT NULL,  
            StagingBase         NVARCHAR(60) COLLATE DATABASE_DEFAULT DEFAULT N'',  
            CodeGenSeed         INT NULL,  
            DataCompression     TINYINT NULL,  
            TransactionLogType  TINYINT NULL,  
            RequireApproval     BIT NULL,  
            Error               NVARCHAR(MAX) COLLATE DATABASE_DEFAULT NULL  
        );  
  
        INSERT INTO @EntitiesToProcess  
        (  
            Model_ID,  
            Model_MUID,  
            ModelName,  
            Version_ID,  
            Entity_MUID,  
            EntityName,  
            [Description],  
            IsBase,  
            StagingBase,  
            CodeGenSeed,  
            DataCompression,  
            TransactionLogType,  
            RequireApproval,  
            Error  
        )  
        SELECT  
            m.ID,  
            m.MUID,  
            m.Name,  
            m.MaxVersion_ID,  
            e.Entity_MUID,  
            e.EntityName,  
            e.[Description],  
            e.IsBase,  
            e.StagingBase,  
            e.CodeGenSeed,  
            e.DataCompression,  
            e.TransactionLogType,  
            e.RequireApproval,  
            CASE   
                WHEN m.ID IS NULL           THEN N'MDSERR200002|The entity cannot be saved. The model ID is not valid.'  
                WHEN m.IsAdministrator = 0  THEN N'MDSERR120003|The user does not have permission or the object ID is not valid.'  
                END  
        FROM @Entities e  
        -- Note: looking up model ids in a batch here is more efficient that doing it one row at a time in udpEntitySave  
        LEFT JOIN #UserModelAccess m  
        ON      (e.Model_MUID IS NOT NULL OR e.ModelName IS NOT NULL)   
            AND (e.Model_MUID IS NULL OR e.Model_MUID = m.MUID)   
            AND (e.ModelName  IS NULL OR e.ModelName  = m.Name)  
  
        SELECT TOP 1 @Error = Error  
        FROM @EntitiesToProcess  
        WHERE Error IS NOT NULL;  
  
        IF @Error IS NOT NULL  
        BEGIN  
            SET @Error = REPLACE(@Error, '%', '%%')-- escape out format specifier  
            RAISERROR(@Error, 16, 1);  
        END  
  
        DECLARE   
            @EntityDescription          NVARCHAR(500),  
            @IsBase                     BIT,  
            @StagingBase                NVARCHAR(60),  
            @CodeGenSeed                INT,  
            @DataCompression            TINYINT,  
            @TransactionLogType         TINYINT,  
            @RequireApproval            BIT,  
            @RecreateStagingProc        BIT = CASE WHEN @EditMode = @EditMode_Create THEN 0 ELSE 1 END,-- defer creating the staging sprocs when in create mode  
            @EntityReturn_DidNameChange BIT --OUTPUT  
  
        WHILE EXISTS(SELECT 1 FROM @EntitiesToProcess)  
        BEGIN  
            SELECT TOP 1  
                @Row_ID = RowID,  
                @Model_ID = Model_ID,  
                @Model_MUID = Model_MUID,  
                @ModelName = ModelName,  
                @MaxVersion_ID = Version_ID,  
                @Entity_MUID = Entity_MUID,  
                @EntityName = EntityName,  
                @EntityDescription = [Description],  
                @IsBase = IsBase,  
                @StagingBase = StagingBase,  
                @CodeGenSeed = CodeGenSeed,  
                @DataCompression = DataCompression,  
                @TransactionLogType = TransactionLogType,  
                @RequireApproval = RequireApproval  
            FROM @EntitiesToProcess  
  
            PRINT CONCAT(SYSDATETIME(), N': Saving entity ', @EntityName);  
            EXEC mdm.udpEntitySave  
                @User_ID = @User_ID,  
                @Model_ID = @Model_ID,  
                @Version_ID = @MaxVersion_ID,  
                @Entity_MUID = @Entity_MUID,  
                @EntityName = @EntityName,  
                @Description = @EntityDescription,  
                @IsBase = @IsBase,  
                @StagingBase = @StagingBase,  
                @CodeGenSeed = @CodeGenSeed,  
                @EditMode = @EditMode,  
                @DataCompression = @DataCompression,  
                @TransactionLogType = @TransactionLogType,  
                @RequireApproval = @RequireApproval,  
                @RecreateStagingProc = @RecreateStagingProc,  
                @Return_DidNameChange = @EntityReturn_DidNameChange OUTPUT,  
                @Return_ID = @Entity_ID OUTPUT,  
                @Return_MUID = @Entity_MUID OUTPUT, --Also an input parameter for clone operations  
                @CorrelationID = @CorrelationID;  
  
            INSERT INTO @CreatedEntities  
            (  
                ModelID,  
                ModelMUID,  
                ModelName,  
                ID,  
                MUID,  
                Name,  
                DidNameChange  
            )  
            VALUES  
            (  
                @Model_ID,  
                @Model_MUID,  
                @ModelName,  
                @Entity_ID,  
                @Entity_MUID,  
                @EntityName,  
                @EntityReturn_DidNameChange  
            )  
  
            DELETE @EntitiesToProcess  
            WHERE RowID = @Row_ID;  
        END  
  
        --Output created/updated entities  
        SELECT ModelID, ModelMUID, ModelName, ID, MUID, Name, DidNameChange FROM @CreatedEntities;  
  
        --END Entity processing  
  
  
        --BEGIN Explicit hierarchy processing  
  
        DECLARE @ExplicitHierarchiesToProcess TABLE  
        (  
            RowID               INT IDENTITY(1, 1) NOT NULL PRIMARY KEY,  
            Model_ID            INT NULL,  
            Model_MUID          UNIQUEIDENTIFIER NULL,  
            ModelName           NVARCHAR(50) COLLATE DATABASE_DEFAULT NULL,  
            Version_ID          INT NULL,  
            Entity_ID           INT NULL,  
            Entity_MUID         UNIQUEIDENTIFIER NULL,  
            EntityName          NVARCHAR(50) COLLATE DATABASE_DEFAULT NULL,  
            Hierarchy_MUID      UNIQUEIDENTIFIER NULL,  
            HierarchyName       NVARCHAR(50) COLLATE DATABASE_DEFAULT NULL,  
            IsMandatory         BIT NULL,  
            Error               NVARCHAR(MAX) COLLATE DATABASE_DEFAULT NULL  
        );  
  
        INSERT INTO @ExplicitHierarchiesToProcess  
        (  
            Model_ID,  
            Model_MUID,  
            ModelName,  
            Version_ID,  
            Entity_ID,  
            Entity_MUID,  
            EntityName,  
            Hierarchy_MUID,  
            HierarchyName,  
            IsMandatory,  
            Error  
        )  
        SELECT  
            m.ID,  
            m.MUID,  
            m.Name,  
            m.MaxVersion_ID,  
            e.ID,  
            e.MUID,  
            e.Name,  
            eh.Hierarchy_MUID,  
            eh.HierarchyName,  
            eh.IsMandatory,  
            CASE   
                WHEN m.ID IS NULL                       THEN N'MDSERR200010|The explicit hierarchy cannot be saved. The model ID is not valid.'  
                WHEN m.IsAdministrator = 0              THEN N'MDSERR120003|The user does not have permission or the object ID is not valid.'  
                WHEN e.ID IS NULL                       THEN N'MDSERR200011|The explicit hierarchy cannot be saved. The entity ID is not valid.'  
                WHEN syncTarget.Entity_ID IS NOT NULL   THEN N'MDSERR200219|The explicit hierarchy cannot be saved. The entity is the target of a sync relationship.'  
                END  
        FROM @ExplicitHierarchies eh  
        -- Note: looking up model and entity ids in a batch here is more efficient that doing it one row at a time in udpEntityHierarchySave  
        LEFT JOIN #UserModelAccess m  
        ON      (eh.Model_MUID IS NOT NULL OR eh.ModelName IS NOT NULL)   
            AND (eh.Model_MUID IS NULL OR eh.Model_MUID = m.MUID)   
            AND (eh.ModelName  IS NULL OR eh.ModelName  = m.Name)  
        LEFT JOIN mdm.tblEntity e  
        ON      m.ID = e.Model_ID  
            AND (eh.Entity_MUID IS NOT NULL OR eh.EntityName IS NOT NULL)   
            AND (eh.Entity_MUID IS NULL OR eh.Entity_MUID = e.MUID)   
            AND (eh.EntityName  IS NULL OR eh.EntityName  = e.Name)  
        LEFT JOIN @SyncTargetEntities syncTarget  
        ON e.ID = syncTarget.Entity_ID  
  
        SELECT TOP 1 @Error = Error  
        FROM @ExplicitHierarchiesToProcess  
        WHERE Error IS NOT NULL;  
  
        IF @Error IS NOT NULL  
        BEGIN  
            SET @Error = REPLACE(@Error, '%', '%%')-- escape out format specifier  
            RAISERROR(@Error, 16, 1);  
        END  
  
        DECLARE   
            @ExplicitHierarchy_ID   INT,  
            @ExplicitHierarchy_MUID UNIQUEIDENTIFIER,  
            @ExplicitHierarchyName  NVARCHAR(50),  
            @IsMandatory            BIT  
  
        WHILE EXISTS(SELECT 1 FROM @ExplicitHierarchiesToProcess)  
        BEGIN  
            SELECT  TOP 1  
                @Row_ID = RowID,  
                @Model_ID = Model_ID,  
                @Model_MUID = Model_MUID,  
                @ModelName = ModelName,  
                @MaxVersion_ID = Version_ID,  
                @Entity_ID = Entity_ID,  
                @Entity_MUID = Entity_MUID,  
                @EntityName = EntityName,  
                @ExplicitHierarchy_MUID = Hierarchy_MUID,  
                @ExplicitHierarchyName = HierarchyName,  
                @IsMandatory = IsMandatory  
            FROM @ExplicitHierarchiesToProcess  
  
            PRINT CONCAT(SYSDATETIME(), N': Saving explicit hierarchy ', @ExplicitHierarchyName);  
            EXEC mdm.udpEntityHierarchySave  
                    @User_ID = @User_ID,  
                    @Model_ID = @Model_ID,  
                    @Version_ID = @MaxVersion_ID,  
                    @Entity_ID = @Entity_ID,  
                    @Hierarchy_MUID = @ExplicitHierarchy_MUID,  
                    @HierarchyName = @ExplicitHierarchyName,  
                    @IsMandatory = @IsMandatory,  
                    @EditMode = @EditMode,  
                    @RecreateLeafStagingProc = @RecreateStagingProc,  
                    @Return_ID = @ExplicitHierarchy_ID OUTPUT,  
                    @Return_MUID = @ExplicitHierarchy_MUID OUTPUT, --Also an input parameter for clone operations  
                    @CorrelationID = @CorrelationID;  
  
            INSERT INTO @CreatedExplicitHierarchies  
            (  
                ModelID,  
                ModelMUID,  
                ModelName,  
                EntityID,  
                EntityMUID,  
                EntityName,  
                ID,  
                MUID,  
                Name  
            )  
            VALUES  
            (  
                @Model_ID,  
                @Model_MUID,  
                @ModelName,  
                @Entity_ID,  
                @Entity_MUID,  
                @EntityName,  
                @ExplicitHierarchy_ID,  
                @ExplicitHierarchy_MUID,  
                @ExplicitHierarchyName  
            )  
  
            DELETE @ExplicitHierarchiesToProcess  
            WHERE RowID = @Row_ID;  
        END  
  
        --Output created/updated explicit hierarchies  
        SELECT ModelID, ModelMUID, ModelName, EntityID, EntityMUID, EntityName, ID, MUID, Name FROM @CreatedExplicitHierarchies;  
  
        --END Explicit hierarchy processing  
  
  
  
        --BEGIN Attribute processing  
  
        -- The schema of this table should match that defined in udpAttributeChange  
        CREATE TABLE #AttributesToProcess  
        (  
            Row_ID              INT NOT NULL PRIMARY KEY,  
            Model_ID            INT NULL,  
            Model_MUID          UNIQUEIDENTIFIER NULL,  
            ModelName           NVARCHAR(50) COLLATE DATABASE_DEFAULT NULL,  
            Version_ID          INT NULL,  
            Entity_ID           INT NULL,  
            Entity_MUID         UNIQUEIDENTIFIER NULL,  
            EntityName          NVARCHAR(50) COLLATE DATABASE_DEFAULT NULL,  
            IsHierarchyEnabled  BIT NULL,  
            IsCollectionEnabled BIT NULL,  
            DataCompression     TINYINT NULL,  
            TableName           SYSNAME NULL,  
            StagingTableName    SYSNAME NULL,  
            MemberType_ID       TINYINT NOT NULL,  
            ID                  INT NULL,  
            MUID                UNIQUEIDENTIFIER NULL,  
            Name                NVARCHAR(100) COLLATE DATABASE_DEFAULT NOT NULL,  
            [Description]       NVARCHAR(500) COLLATE DATABASE_DEFAULT NULL,  
            AttributeType_ID    TINYINT NULL,  
            DisplayName         NVARCHAR(250) COLLATE DATABASE_DEFAULT NULL,  
            DisplayWidth        INT NOT NULL,  
            DomainEntity_ID     INT NULL,  
            FilterParentAttribute_ID    INT NULL,  
            FilterHierarchyDetail_ID    INT NULL,  
            DataType_ID         TINYINT NULL,  
            DataTypeInformation INT NULL,  
            InputMask_ID        INT NULL,  
            ChangeTrackingGroup INT DEFAULT 0,  
            SortOrder           INT NULL,  
            DidNameChange       BIT NULL,  
            Error               NVARCHAR(MAX) COLLATE DATABASE_DEFAULT NULL  
        );  
  
        INSERT INTO #AttributesToProcess  
        (  
            Row_ID,  
            Model_ID,  
            Model_MUID,  
            ModelName,  
            Version_ID,  
            Entity_ID,  
            Entity_MUID,  
            EntityName,  
            IsHierarchyEnabled,  
            IsCollectionEnabled,  
            DataCompression,  
            TableName,  
            StagingTableName,  
            MemberType_ID,  
            MUID,  
            Name,  
            [Description],  
            AttributeType_ID,  
            DisplayName,  
            DisplayWidth,  
            DomainEntity_ID,  
            DataType_ID,  
            DataTypeInformation,  
            InputMask_ID,  
            ChangeTrackingGroup,  
            SortOrder,  
            Error  
        )  
        SELECT  
            a.Row_ID,  
            m.ID,  
            m.MUID,  
            m.Name,  
            m.MaxVersion_ID,  
            e.ID,  
            e.MUID,  
            e.Name,  
            CASE WHEN e.HierarchyParentTable IS NULL THEN 0 ELSE 1 END, -- IsHierarchyEnabled  
            CASE WHEN e.CollectionTable IS NULL THEN 0 ELSE 1 END, -- IsCollectionEnabled  
            e.DataCompression,  
            CASE a.MemberType_ID  
                    WHEN @MemberType_Leaf           THEN e.EntityTable  
                    WHEN @MemberType_Consolidated   THEN e.HierarchyParentTable  
                    WHEN @MemberType_Collection     THEN e.CollectionTable  
                    END, --TableName  
           CASE a.MemberType_ID  
                    WHEN @MemberType_Leaf           THEN e.StagingLeafName  
                    WHEN @MemberType_Consolidated   THEN e.StagingConsolidatedName  
                    WHEN @MemberType_Collection     THEN NULL  
                    END, -- StagingTableName  
            a.MemberType_ID,  
            a.Attribute_MUID,  
            a.AttributeName,  
            a.[Description],  
            a.AttributeType_ID,  
            a.DisplayName,  
            a.DisplayWidth,  
            domainEntity.ID,  
            a.DataType_ID,  
            a.DataTypeInformation,  
            im.OptionID, -- InputMask_ID  
            a.ChangeTrackingGroup,  
            a.SortOrder,  
            CASE   
                WHEN m.ID IS NULL                       THEN N'MDSERR200013|The attribute cannot be saved. The model ID is not valid.'  
                WHEN m.IsAdministrator = 0              THEN N'MDSERR120003|The user does not have permission or the object ID is not valid.'  
                WHEN e.ID IS NULL                       THEN N'MDSERR200014|The attribute cannot be saved. The entity ID is not valid.'  
                WHEN syncTarget.Entity_ID IS NOT NULL   THEN N'MDSERR200215|The attribute cannot be saved. The entity is the target of a sync relationship.'  
                WHEN    a.InputMask_Name IS NOT NULL   
                    AND im.OptionID IS NULL             THEN N'MDSERR200085|The attribute cannot be saved. The input mask is not valid.'  
                END  
        FROM @Attributes a  
        -- Note: looking up model ids and entity ids in a batch here is more efficient that doing it one row at a time in updAttributeSave  
        LEFT JOIN #UserModelAccess m  
        ON      (a.Model_MUID IS NOT NULL OR a.ModelName IS NOT NULL)   
            AND (a.Model_MUID IS NULL OR a.Model_MUID = m.MUID)   
            AND (a.ModelName  IS NULL OR a.ModelName  = m.Name)  
        LEFT JOIN mdm.tblEntity e  
        ON      m.ID = e.Model_ID  
            AND (a.Entity_MUID IS NOT NULL OR a.EntityName IS NOT NULL)  
            AND (a.Entity_MUID IS NULL OR a.Entity_MUID = e.MUID)  
            AND (a.EntityName  IS NULL OR a.EntityName  = e.Name)  
        LEFT JOIN mdm.tblEntity domainEntity  
        ON      m.ID = domainEntity.Model_ID  
            AND (a.DomainEntity_MUID IS NOT NULL OR a.DomainEntityName IS NOT NULL)  
            AND (a.DomainEntity_MUID IS NULL OR a.DomainEntity_MUID = domainEntity.MUID)  
            AND (a.DomainEntityName  IS NULL OR a.DomainEntityName  = domainEntity.Name)  
        LEFT JOIN @SyncTargetEntities syncTarget  
        ON e.ID = syncTarget.Entity_ID  
        LEFT JOIN mdm.tblList im  
        ON      im.ListCode = 'lstInputMask'  
            AND im.ListOption = a.InputMask_Name  
  
  
        IF @EditMode = @EditMode_Update  
        BEGIN  
            -- When in update mode, the filter parent attribute and hierarchy level should already exist, so no need to call udpAttributeSave twice. Do the ID lookups here.  
            EXEC mdm.udpMetadataSaveHelper_LookupAttributeFilterIds @AttributeFilters  
        END  
  
        SELECT TOP 1 @Error = Error  
        FROM #AttributesToProcess  
        WHERE Error IS NOT NULL;  
  
        IF @Error IS NOT NULL  
        BEGIN  
            SET @Error = REPLACE(@Error, '%', '%%')-- escape out format specifier  
            RAISERROR(@Error, 16, 1);  
        END  
  
        DECLARE   
            @IsHierarchyEnabled             BIT,  
            @IsCollectionEnabled            BIT,  
            @IsCollectionSupportAdded       BIT,  
            @TableName                      SYSNAME,  
            @StagingTableName               SYSNAME,  
            @Attribute_ID                   INT,  
            @Attribute_MUID                 UNIQUEIDENTIFIER,  
            @AttributeName                  NVARCHAR(100),  
            @AttributeDescription           NVARCHAR(500),  
            @AttributeType_ID               TINYINT,  
            @DisplayName                    NVARCHAR(250),  
            @DisplayWidth                   INT,  
            @DomainEntity_ID                INT,  
            @FilterParentAttribute_ID       INT,  
            @FilterHierarchyDetail_ID       INT,  
            @DataType_ID                    TINYINT,  
            @DataTypeInformation            INT,  
            @InputMask_ID                   INT,  
            @ChangeTrackingGroup            INT = 0,  
            @AttributeSortOrder             INT,  
            @AttributeReturn_DidNameChange  BIT --OUTPUT  
        SET @Row_ID = 0;  
  
        WHILE EXISTS(SELECT 1 FROM #AttributesToProcess WHERE Row_ID > @Row_ID)  
        BEGIN  
            SELECT TOP 1  
                @Row_ID = Row_ID,  
                @Model_ID = Model_ID,  
                @Model_MUID = Model_MUID,  
                @ModelName = ModelName,  
                @MaxVersion_ID = Version_ID,  
                @Entity_ID = Entity_ID,  
                @Entity_MUID = Entity_MUID,  
                @EntityName = EntityName,  
                @IsHierarchyEnabled = IsHierarchyEnabled,  
                @IsCollectionEnabled = IsCollectionEnabled,  
                @DataCompression = DataCompression,  
                @TableName = TableName,  
                @StagingTableName = StagingTableName,  
                @MemberType_ID = MemberType_ID,  
                @Attribute_MUID = MUID,  
                @AttributeName = Name,  
                @AttributeDescription = [Description],  
                @AttributeType_ID = AttributeType_ID,  
                @DisplayName = DisplayName,  
                @DisplayWidth = DisplayWidth,  
                @DomainEntity_ID = DomainEntity_ID,  
                @FilterParentAttribute_ID = FilterParentAttribute_ID,  
                @FilterHierarchyDetail_ID = FilterHierarchyDetail_ID,  
                @DataType_ID = DataType_ID,  
                @DataTypeInformation = DataTypeInformation,  
                @InputMask_ID = InputMask_ID,  
                @ChangeTrackingGroup = ChangeTrackingGroup,  
                @AttributeSortOrder = SortOrder  
            FROM #AttributesToProcess  
            WHERE Row_ID > @Row_ID  
            ORDER BY Row_ID  
  
            SET @IsCollectionSupportAdded = CASE WHEN @MemberType_ID = @MemberType_Collection AND @IsCollectionEnabled = 0 -- Creating the first collection attribute will cause the collection table to be created. Need to update the temp table with this info  
                THEN 1 ELSE 0 END  
  
            PRINT CONCAT(SYSDATETIME(), N': Saving attribute ', @AttributeName, ', MemberType ', @MemberType_ID);  
            EXEC mdm.udpAttributeSave  
                    @User_ID = @User_ID,  
                    @Model_ID = @Model_ID,  
                    @Version_ID = @MaxVersion_ID,  
                    @Entity_ID = @Entity_ID,  
                    @IsHierarchyEnabled = @IsHierarchyEnabled,  
                    @IsCollectionEnabled = @IsCollectionEnabled,  
                    @DataCompression = @DataCompression,  
                    @TableName = @TableName OUTPUT,  
                    @StagingTableName = @StagingTableName,  
                    @MemberType_ID = @MemberType_ID,  
                    @Attribute_MUID = @Attribute_MUID,  
                    @AttributeName = @AttributeName,  
                    @AttributeType_ID = @AttributeType_ID,  
                    @Description = @AttributeDescription,  
                    @DisplayName = @DisplayName,  
                    @DisplayWidth = @DisplayWidth,  
                    @DomainEntity_ID = @DomainEntity_ID,  
                    @FilterParentAttribute_ID = @FilterParentAttribute_ID,  
                    @FilterHierarchyDetail_ID = @FilterHierarchyDetail_ID,  
                    @DataType_ID = @DataType_ID,  
                    @DataTypeInformation = @DataTypeInformation,  
                    @InputMask_ID = @InputMask_ID,  
                    @ChangeTrackingGroup = @ChangeTrackingGroup,  
                    @SortOrder = @AttributeSortOrder OUTPUT,  
                    @EditMode = @EditMode,  
                    @RecreateStagingProc = 0, -- will create staging sprocs later  
                    @Return_DidNameChange = @AttributeReturn_DidNameChange OUTPUT,  
                    @Return_ID = @Attribute_ID OUTPUT,  
                    @Return_MUID = @Attribute_MUID OUTPUT, --Also an input parameter for clone operations  
                    @CorrelationID = @CorrelationID;  
  
            UPDATE #AttributesToProcess  
            SET  ID = @Attribute_ID -- save the ID for later use in adding attribute filters  
                ,MUID = @Attribute_MUID  
                ,DidNameChange = @AttributeReturn_DidNameChange  
                ,SortOrder = @AttributeSortOrder  
            WHERE Row_ID = @Row_ID;  
  
            IF @IsCollectionSupportAdded = 1  
            BEGIN  
                UPDATE #AttributesToProcess  
                SET  
                     IsCollectionEnabled = 1  
                    ,TableName = CASE MemberType_ID WHEN @MemberType_Collection THEN @TableName ELSE TableName/*Leave column unchanged*/ END  
                WHERE Entity_ID = @Entity_ID  
            END  
  
        END  
  
        --Output updated/created attribute information  
        SELECT Model_ID AS ModelID, Model_MUID AS ModelMUID, ModelName, Entity_ID AS EntityID, Entity_MUID AS EntityMUID, EntityName, MemberType_ID AS AttributeMemberType, ID, MUID, Name, DidNameChange FROM #AttributesToProcess;  
  
        --END Attribute processing  
  
  
        --BEGIN AttributeGroup processing  
  
        DECLARE @AttributeGroupsToProcess TABLE  
        (  
            Row_ID              INT NOT NULL PRIMARY KEY,  
            Model_ID            INT NULL,  
            Model_MUID          UNIQUEIDENTIFIER NULL,  
            ModelName           NVARCHAR(50) COLLATE DATABASE_DEFAULT NULL,  
            Version_ID          INT NULL,  
            Entity_ID           INT NULL,  
            Entity_MUID         UNIQUEIDENTIFIER NULL,  
            EntityName          NVARCHAR(50) COLLATE DATABASE_DEFAULT NULL,  
            IsHierarchyEnabled  BIT NULL,  
            IsCollectionEnabled BIT NULL,  
            DataCompression     TINYINT NULL,  
            MemberType_ID       TINYINT NOT NULL,  
            MUID                UNIQUEIDENTIFIER NULL,  
            Name                NVARCHAR(50) COLLATE DATABASE_DEFAULT NOT NULL,  
            SortOrder           INT NULL,  
            FreezeNameCode      BIT DEFAULT 0,  
            IsSystem            BIT DEFAULT 0,  
            Error               NVARCHAR(MAX) COLLATE DATABASE_DEFAULT NULL  
        );  
  
        INSERT INTO @AttributeGroupsToProcess  
        (  
            Row_ID,  
            Model_ID,  
            Model_MUID,  
            ModelName,  
            Version_ID,  
            Entity_ID,  
            Entity_MUID,  
            EntityName,  
            IsHierarchyEnabled,  
            IsCollectionEnabled,  
            DataCompression,  
            MemberType_ID,  
            MUID,  
            Name,  
            SortOrder,  
            FreezeNameCode,  
            IsSystem,   
            Error  
        )  
        SELECT  
            ag.Row_ID,  
            m.ID,  
            m.MUID,  
            m.Name,  
            m.MaxVersion_ID,  
            e.ID,  
            e.MUID,  
            e.Name,  
            CASE WHEN e.HierarchyParentTable IS NULL THEN 0 ELSE 1 END, -- IsHierarchyEnabled  
            CASE WHEN e.CollectionTable IS NULL THEN 0 ELSE 1 END, -- IsCollectionEnabled  
            e.DataCompression,  
            ag.MemberType_ID,  
            ag.MUID,  
            ag.Name,  
            ag.SortOrder,  
            ag.FreezeNameCode,  
            ag.IsSystem,  
            CASE   
                WHEN m.ID IS NULL                       THEN N'MDSERR200017|The attribute group cannot be saved. The model ID is not valid.'  
                WHEN m.IsAdministrator = 0              THEN N'MDSERR120003|The user does not have permission or the object ID is not valid.'  
                WHEN e.ID IS NULL                       THEN N'MDSERR200018|The attribute group cannot be saved. The entity ID is not valid.'  
                WHEN syncTarget.Entity_ID IS NOT NULL   THEN N'MDSERR200214|The attribute group cannot be saved. The entity is the target of a sync relationship.'  
                WHEN ag.MemberType_ID IS NULL           THEN N'MDSERR200020|The attribute group cannot be saved. The member type is not valid.'  
                END  
        FROM @AttributeGroups ag  
        -- Note: looking up model ids and entity ids in a batch here is more efficient that doing it one row at a time in updAttributeGroupSave  
        LEFT JOIN #UserModelAccess m  
        ON      (ag.Model_MUID IS NOT NULL OR ag.ModelName IS NOT NULL)   
            AND (ag.Model_MUID IS NULL OR ag.Model_MUID = m.MUID)   
            AND (ag.ModelName  IS NULL OR ag.ModelName  = m.Name)  
        LEFT JOIN mdm.tblEntity e  
        ON      m.ID = e.Model_ID  
            AND (ag.Entity_MUID IS NOT NULL OR ag.EntityName IS NOT NULL)  
            AND (ag.Entity_MUID IS NULL OR ag.Entity_MUID = e.MUID)  
            AND (ag.EntityName  IS NULL OR ag.EntityName  = e.Name)  
        LEFT JOIN @SyncTargetEntities syncTarget  
        ON e.ID = syncTarget.Entity_ID  
  
        SELECT TOP 1 @Error = Error  
        FROM @AttributeGroupsToProcess  
        WHERE Error IS NOT NULL;  
  
        IF @Error IS NOT NULL  
        BEGIN  
            SET @Error = REPLACE(@Error, '%', '%%')-- escape out format specifier  
            RAISERROR(@Error, 16, 1);  
        END  
  
        DECLARE   
            @AttributeGroup_ID              INT,  
            @AttributeGroup_MUID            UNIQUEIDENTIFIER,  
            @AttributeGroupName             NVARCHAR(50),  
            @AttributeGroupSortOrder        INT,  
            @FreezeNameCode                 BIT = 0,  
            @AttributeGroupIsSystem         BIT = 0  
  
        WHILE EXISTS(SELECT 1 FROM @AttributeGroupsToProcess)  
        BEGIN  
            SELECT TOP 1  
                @Row_ID = Row_ID,  
                @Model_ID = Model_ID,  
                @Model_MUID = Model_MUID,  
                @ModelName = ModelName,  
                @MaxVersion_ID = Version_ID,  
                @Entity_ID = Entity_ID,  
                @Entity_MUID = Entity_MUID,  
                @EntityName = EntityName,  
                @IsHierarchyEnabled = IsHierarchyEnabled,  
                @IsCollectionEnabled = IsCollectionEnabled,  
                @DataCompression = DataCompression,  
                @MemberType_ID = MemberType_ID,  
                @AttributeGroup_MUID = MUID,  
                @AttributeGroupName = Name,  
                @AttributeGroupSortOrder = SortOrder,  
                @FreezeNameCode = FreezeNameCode,  
                @AttributeGroupIsSystem = IsSystem  
            FROM @AttributeGroupsToProcess  
  
            SET @IsCollectionSupportAdded = CASE WHEN @MemberType_ID = @MemberType_Collection AND @IsCollectionEnabled = 0 -- Creating the first collection attribute group will cause the collection tables to be created. Need to update the temp table with this info  
                THEN 1 ELSE 0 END  
  
            PRINT CONCAT(SYSDATETIME(), N': Saving attribute group ', @EntityName, N'.', @AttributeGroupName);  
            EXEC mdm.udpAttributeGroupSave  
                    @User_ID = @User_ID,  
                    @Model_ID = @Model_ID,  
                    @Version_ID = @MaxVersion_ID,  
                    @Entity_ID = @Entity_ID,  
                    @IsHierarchyEnabled = @IsHierarchyEnabled,  
                    @IsCollectionEnabled = @IsCollectionEnabled,  
                    @DataCompression = @DataCompression,  
                    @MemberType_ID = @MemberType_ID,  
                    @MUID = @AttributeGroup_MUID,  
                    @Name = @AttributeGroupName,  
                    @SortOrder = @AttributeGroupSortOrder,  
                    @FreezeNameCode = @FreezeNameCode,  
                    @IsSystem = @AttributeGroupIsSystem,  
                    @EditMode = @EditMode,  
                    @Return_ID = @AttributeGroup_ID OUTPUT,  
                    @Return_MUID = @AttributeGroup_MUID OUTPUT,  
                    @CorrelationID = @CorrelationID;  
  
            INSERT INTO @CreatedAttributeGroups  
            (  
                Row_ID,  
                ModelID,  
                ModelMUID,  
                ModelName,  
                Version_ID,  
                EntityID,  
                EntityMUID,  
                EntityName,  
                AttributeGroupMemberType,  
                ID,  
                MUID,  
                Name  
            )  
            VALUES  
            (  
                @Row_ID,  
                @Model_ID,  
                @Model_MUID,  
                @ModelName,  
                @MaxVersion_ID,  
                @Entity_ID,  
                @Entity_MUID,  
                @EntityName,  
                @MemberType_ID,  
                @AttributeGroup_ID,  
                @AttributeGroup_MUID,  
                @AttributeGroupName  
            )  
  
            DELETE @AttributeGroupsToProcess  
            WHERE Row_ID = @Row_ID;  
  
            IF @IsCollectionSupportAdded = 1  
            BEGIN  
                UPDATE @AttributeGroupsToProcess  
                SET IsCollectionEnabled = 1  
                WHERE   Entity_ID = @Entity_ID  
            END  
        END  
  
        --Output created/updated attribute groups  
        SELECT ModelID, ModelMUID, ModelName, EntityID, EntityMUID, EntityName, AttributeGroupMemberType, ID, MUID, Name FROM @CreatedAttributeGroups;  
  
        --END AttributeGroup processing  
  
  
  
        --BEGIN AttributeGroupDetail processing  
  
        DECLARE @AttributeGroupDetailsToProcess TABLE  
        (  
            RowID               INT IDENTITY(1, 1) NOT NULL PRIMARY KEY,  
            Version_ID          INT NULL,  
            AttributeGroup_ID   INT NULL,  
            Attribute_ID        INT NULL,  
            Error               NVARCHAR(MAX) COLLATE DATABASE_DEFAULT NULL  
        );  
  
        --We are going to rely on the fact that the attribute group that owns these details was also supplied to the SPROC for  
        --create/update. That is a reasonable assumption since the API wraps the details the AttributeGroup contract  
        INSERT INTO @AttributeGroupDetailsToProcess  
        (  
            Version_ID,  
            AttributeGroup_ID,  
            Attribute_ID,  
            Error  
        )  
        SELECT  
            ag.Version_ID,  
            ag.ID,  
            a.ID,  
            CASE  
                WHEN a.ID IS NULL   THEN N'MDSERR110007|The ID is not valid.'  
                END  
        FROM @AttributeGroupDetails agd  
        INNER JOIN @CreatedAttributeGroups ag  
        ON agd.AttributeGroupRow_ID = ag.Row_ID  
        INNER JOIN mdm.tblAttribute a  
        ON      ag.EntityID = a.Entity_ID  
            AND ag.AttributeGroupMemberType = a.MemberType_ID  
            AND (agd.MUID IS NOT NULL OR agd.Name IS NOT NULL)  
            AND (agd.MUID IS NULL OR agd.MUID = a.MUID)  
            AND (agd.Name IS NULL OR agd.Name = a.Name)  
  
        SELECT TOP 1 @Error = Error  
        FROM @AttributeGroupDetailsToProcess  
        WHERE Error IS NOT NULL;  
  
        IF @Error IS NOT NULL  
        BEGIN  
            SET @Error = REPLACE(@Error, '%', '%%')-- escape out format specifier  
            RAISERROR(@Error, 16, 1);  
        END  
  
        --Drop all attributes from the passed attribute groups   
        DECLARE @AttributeGroupsToClear TABLE (ID INT PRIMARY KEY);  
        INSERT INTO @AttributeGroupsToClear (ID)    
        SELECT ID FROM @CreatedAttributeGroups    
   
        IF(@EditMode <> @EditMode_Create)  
        BEGIN  
            WHILE EXISTS(SELECT 1 FROM @AttributeGroupsToClear)    
            BEGIN    
                SELECT TOP 1    
                    @AttributeGroup_ID = ID    
                FROM @AttributeGroupsToClear    
    
                EXEC mdm.udpAttributeGroupDetailDelete    
                        @User_ID = @User_ID,    
                        @AttributeGroup_ID = @AttributeGroup_ID,    
                        @Type_ID = 1,    
                        @CorrelationID = @CorrelationID;    
    
                DELETE @AttributeGroupsToClear    
                WHERE ID = @AttributeGroup_ID    
            END    
        END  
  
        -- Add the attribute group details  
        WHILE EXISTS(SELECT 1 FROM @AttributeGroupDetailsToProcess)  
        BEGIN  
            SELECT TOP 1  
                @Row_ID = RowID,  
                @MaxVersion_ID = Version_ID,  
                @AttributeGroup_ID = AttributeGroup_ID,  
                @Attribute_ID = Attribute_ID  
            FROM @AttributeGroupDetailsToProcess  
  
            PRINT CONCAT(SYSDATETIME(), N': Adding attribute to attribute group ', @AttributeGroupName);  
            EXEC mdm.udpAttributeGroupDetailSave  
                    @User_ID = @User_ID,  
                    @Version_ID = @MaxVersion_ID,  
                    @AttributeGroup_ID = @AttributeGroup_ID,  
                    @Attribute_ID = @Attribute_ID,  
                    @CorrelationID = @CorrelationID;  
  
            DELETE @AttributeGroupDetailsToProcess  
            WHERE RowID = @Row_ID;  
        END  
  
        --END AttributeGroupDetail processing  
  
  
  
        --BEGIN Derived hierarchy processing  
  
        DECLARE @DerivedHierarchiesToProcess TABLE  
        (  
            RowID                   INT IDENTITY(1, 1) NOT NULL PRIMARY KEY,  
            Model_ID                INT NULL,  
            Model_MUID              UNIQUEIDENTIFIER NULL,  
            ModelName               NVARCHAR(50) COLLATE DATABASE_DEFAULT NULL,  
            Version_ID              INT NULL,  
            MUID                    UNIQUEIDENTIFIER NULL,  
            Name                    NVARCHAR(50) COLLATE DATABASE_DEFAULT NULL,  
            AnchorNullRecursions    BIT DEFAULT 1,  
            Error                   NVARCHAR(MAX) COLLATE DATABASE_DEFAULT NULL  
        );  
  
        INSERT INTO @DerivedHierarchiesToProcess  
        (  
            Model_ID,  
            Model_MUID,  
            ModelName,  
            Version_ID,  
            MUID,  
            Name,  
            AnchorNullRecursions,  
            Error  
        )  
        SELECT  
            m.ID,  
            m.MUID,  
            m.Name,  
            m.MaxVersion_ID,  
            dh.MUID,  
            dh.Name,  
            dh.AnchorNullRecursions,  
            CASE  
                WHEN m.ID IS NULL           THEN N'MDSERR200008|The derived hierarchy cannot be saved. The model ID is not valid.'  
                WHEN m.IsAdministrator = 0  THEN N'MDSERR120003|The user does not have permission or the object ID is not valid.'  
                END  
        FROM @DerivedHierarchies dh  
        -- Note: looking up model ids in a batch here is more efficient that doing it one row at a time in udpDerivedHierarchySave  
        LEFT JOIN #UserModelAccess m  
        ON      (dh.Model_MUID IS NOT NULL OR dh.ModelName IS NOT NULL)   
            AND (dh.Model_MUID IS NULL OR dh.Model_MUID = m.MUID)   
            AND (dh.ModelName  IS NULL OR dh.ModelName  = m.Name)  
  
        SELECT TOP 1 @Error = Error  
        FROM @DerivedHierarchiesToProcess  
        WHERE Error IS NOT NULL;  
  
        IF @Error IS NOT NULL  
        BEGIN  
            SET @Error = REPLACE(@Error, '%', '%%')-- escape out format specifier  
            RAISERROR(@Error, 16, 1);  
        END  
  
        DECLARE   
            @DerivedHierarchy_ID                    INT,  
            @DerivedHierarchy_MUID                  UNIQUEIDENTIFIER,  
            @DerivedHierarchyName                   NVARCHAR(50),  
            @DerivedHierarchyAnchorNullRecursions   BIT = 1;  
  
        WHILE EXISTS(SELECT * FROM @DerivedHierarchiesToProcess)  
        BEGIN  
            SELECT TOP 1  
                @Row_ID = RowID,  
                @Model_ID = Model_ID,  
                @Model_MUID = Model_MUID,  
                @ModelName = ModelName,  
                @MaxVersion_ID = Version_ID,  
                @DerivedHierarchy_MUID = MUID,  
                @DerivedHierarchyName = Name,  
                @DerivedHierarchyAnchorNullRecursions = AnchorNullRecursions  
            FROM @DerivedHierarchiesToProcess  
  
            PRINT CONCAT(SYSDATETIME(), N': Saving derived hierarchy ', @DerivedHierarchyName);  
            EXEC mdm.udpDerivedHierarchySave  
                    @User_ID = @User_ID,  
                    @Model_ID = @Model_ID,  
                    @Version_ID = @MaxVersion_ID,  
                    @MUID = @DerivedHierarchy_MUID,  
                    @Name = @DerivedHierarchyName,  
                    @AnchorNullRecursions = @DerivedHierarchyAnchorNullRecursions,  
                    @EditMode = @EditMode,  
                    @Return_ID = @DerivedHierarchy_ID OUTPUT,  
                    @Return_MUID = @DerivedHierarchy_MUID OUTPUT,  
                    @CorrelationID = @CorrelationID;  
  
            INSERT INTO @CreatedDerivedHierarchies  
            (  
                ModelID,  
                ModelMUID,  
                ModelName,  
                ID,  
                MUID,  
                Name  
            )  
            VALUES  
            (  
                @Model_ID,  
                @Model_MUID,  
                @ModelName,  
                @DerivedHierarchy_ID,  
                @DerivedHierarchy_MUID,  
                @DerivedHierarchyName  
            )  
  
            DELETE @DerivedHierarchiesToProcess  
            WHERE RowID = @Row_ID;  
        END  
  
        --Output updated/created derived hierarchies  
        SELECT ModelID, ModelMUID, ModelName, ID, MUID, Name FROM @CreatedDerivedHierarchies;  
  
        --END Derived hierarchy processing  
  
  
  
        --BEGIN Derived hierarchy level processing  
  
        DECLARE @DerivedHierarchyLevelsToProcess TABLE  
        (  
            RowID                   INT IDENTITY(1, 1) NOT NULL PRIMARY KEY,  
            Model_ID                INT NULL,  
            Model_MUID              UNIQUEIDENTIFIER NULL,  
            ModelName               NVARCHAR(50) COLLATE DATABASE_DEFAULT NULL,  
            Version_ID              INT NULL,  
            DerivedHierarchy_ID     INT NULL,  
            DerivedHierarchy_MUID   UNIQUEIDENTIFIER NULL,  
            DerivedHierarchyName    NVARCHAR(50) COLLATE DATABASE_DEFAULT NULL,  
            MUID                    UNIQUEIDENTIFIER NULL,  
            Name                    NVARCHAR(100) COLLATE DATABASE_DEFAULT NOT NULL,  
            Foreign_ID              INT NULL,  
            ForeignType_ID          TINYINT NOT NULL,  
            ManyToManyChildAttribute_ID INT NULL,  
            DisplayName             NVARCHAR(100) COLLATE DATABASE_DEFAULT NOT NULL,  
            IsVisible               BIT NOT NULL,  
            IsMemberSecurityApplied BIT NOT NULL,  
            Error                   NVARCHAR(MAX) COLLATE DATABASE_DEFAULT NULL  
        );  
  
        ;WITH hierarchiesWithMemberSecurityCte AS  
        (  
            SELECT DISTINCT DerivedHierarchy_ID  
            FROM mdm.tblSecurityRoleAccessMember  
        )  
        INSERT INTO @DerivedHierarchyLevelsToProcess  
        (  
            Model_ID,  
            Model_MUID,  
            ModelName,  
            Version_ID,  
            DerivedHierarchy_ID,  
            DerivedHierarchy_MUID,  
            DerivedHierarchyName,  
            MUID,  
            Name,  
            Foreign_ID,  
            ForeignType_ID,  
            ManyToManyChildAttribute_ID,  
            DisplayName,  
            IsVisible,  
            IsMemberSecurityApplied,  
            Error  
        )  
        SELECT  
            m.ID,  
            m.MUID,  
            m.Name,  
            m.MaxVersion_ID,  
            dh.ID,  
            dh.MUID,  
            dh.Name,  
            dhl.MUID,  
            dhl.Name,  
            COALESCE(fid_a.ID, fid_e.ID, fid_h.ID), -- Foreign_ID  
            dhl.ForeignType_ID,  
            m2mChild.ID,  
            dhl.DisplayName,  
            dhl.IsVisible,  
            CASE WHEN memSec.DerivedHierarchy_ID IS NULL THEN 0 ELSE 1 END, -- IsMemberSecurityApplied  
            -- Do more expensive error checks here (i.e. ones that require querying tables), and leave the simple checks to udpDerivedHierarchyDetailSave  
            CASE   
                WHEN m.ID IS NULL                                           THEN N'MDSERR200053|The hierarchy level cannot be saved. The model ID is not valid.'  
                WHEN m.IsAdministrator = 0                                  THEN N'MDSERR120003|The user does not have permission or the object ID is not valid.'  
                WHEN dh.ID IS NULL                                          THEN N'MDSERR200054|The derived hierarchy level cannot be saved. The derived hierarchy ID is not valid.'  
                WHEN COALESCE(fid_a.ID, fid_e.ID, fid_h.ID) IS NULL         THEN N'MDSERR200063|The derived hierarchy level cannot be saved. The Foreign ID is not valid.'  
                WHEN dhl.ForeignType_ID = @HierarchyItemType_ManyToMany   
                    AND fid_a.DomainEntity_ID = fid_a.Entity_ID             THEN N'MDSERR100060|The ForeignId is not valid. The parent attribute on a mapping entity cannot be self-referencing.'  
                WHEN ForeignType_ID = @HierarchyItemType_ManyToMany   
                    AND (  m2mChild.ID IS NULL   
                        OR m2mChild.Entity_ID = m2mChild.DomainEntity_ID)   THEN N'MDSERR100061|The ManyToManyChildAttributeId is not valid. It must belong to the same mapping entity as ForeignId (parent attribute) and cannot be self-referencing.'  
                END  
        FROM @DerivedHierarchyLevels dhl  
        -- Note: looking up model ids in a batch here is more efficient that doing it one row at a time in udpDerivedHierarchyDetailSave  
        LEFT JOIN #UserModelAccess m  
        ON      (dhl.Model_MUID IS NOT NULL OR dhl.ModelName IS NOT NULL)   
            AND (dhl.Model_MUID IS NULL OR dhl.Model_MUID = m.MUID)   
            AND (dhl.ModelName  IS NULL OR dhl.ModelName  = m.Name)  
        LEFT JOIN mdm.tblDerivedHierarchy dh  
        ON      m.ID = dh.Model_ID  
            AND (dhl.DerivedHierarchy_MUID IS NOT NULL OR dhl.DerivedHierarchyName IS NOT NULL)   
            AND (dhl.DerivedHierarchy_MUID IS NULL OR dhl.DerivedHierarchy_MUID = dh.MUID)   
            AND (dhl.DerivedHierarchyName  IS NULL OR dhl.DerivedHierarchyName  = dh.Name)  
        LEFT JOIN mdm.tblEntity fe -- ForeignEntity (might be null)  
        ON      m.ID = fe.Model_ID  
            AND (dhl.ForeignEntity_MUID IS NOT NULL OR dhl.ForeignEntityName IS NOT NULL)   
            AND (dhl.ForeignEntity_MUID IS NULL OR dhl.ForeignEntity_MUID = fe.MUID)   
            AND (dhl.ForeignEntityName  IS NULL OR dhl.ForeignEntityName  = fe.Name)  
  
        -- Foreign_ID (could be one of several types)  
        LEFT JOIN mdm.tblEntity fid_e  
        ON      dhl.ForeignType_ID = @HierarchyItemType_Entity  
            AND m.ID = fid_e.Model_ID  
            AND (dhl.Foreign_MUID IS NOT NULL OR dhl.ForeignName IS NOT NULL)   
            AND (dhl.Foreign_MUID IS NULL OR dhl.Foreign_MUID = fid_e.MUID)   
            AND (dhl.ForeignName  IS NULL OR dhl.ForeignName  = fid_e.Name)  
        LEFT JOIN mdm.tblAttribute fid_a  
        ON      dhl.ForeignType_ID IN (@HierarchyItemType_DBA, @HierarchyItemType_ManyToMany)  
            AND fid_a.MemberType_ID = 1/*Leaf*/  
            AND (fe.ID = fid_a.Entity_ID -- Must be a Leaf DBA on the ForeignEntity.   
                OR (fe.ID IS NULL AND dhl.Foreign_MUID = fid_a.MUID)) -- If ForeignEntity isn't provided, match on the attribute MUID  
            AND (dhl.Foreign_MUID IS NOT NULL OR dhl.ForeignName IS NOT NULL)   
            AND (dhl.Foreign_MUID IS NULL OR dhl.Foreign_MUID = fid_a.MUID)   
            AND (dhl.ForeignName  IS NULL OR dhl.ForeignName  = fid_a.Name)  
        LEFT JOIN mdm.tblHierarchy fid_h  
        ON      dhl.ForeignType_ID = @HierarchyItemType_Hierarchy  
            AND (fe.ID = fid_h.Entity_ID -- Must be an Explicit Hierarchy on the ForeignEntity  
                OR (fe.ID IS NULL AND dhl.Foreign_MUID = fid_h.MUID)) -- If ForeignEntity isn't provided, match on the hierarchy MUID  
            AND (dhl.Foreign_MUID IS NOT NULL OR dhl.ForeignName IS NOT NULL)   
            AND (dhl.Foreign_MUID IS NULL OR dhl.Foreign_MUID = fid_h.MUID)   
            AND (dhl.ForeignName  IS NULL OR dhl.ForeignName  = fid_h.Name)  
  
        -- Many-to-many child attribute  
        LEFT JOIN mdm.tblAttribute m2mChild  
        ON      fid_a.Entity_ID = m2mChild.Entity_ID -- Must be a Leaf DBA on the ForeignEntity  
            AND m2mChild.MemberType_ID = 1/*Leaf*/  
            AND (dhl.ManyToManyChildAttribute_MUID IS NOT NULL OR dhl.ManyToManyChildAttributeName IS NOT NULL)   
            AND (dhl.ManyToManyChildAttribute_MUID IS NULL OR dhl.ManyToManyChildAttribute_MUID = m2mChild.MUID)   
            AND (dhl.ManyToManyChildAttributeName  IS NULL OR dhl.ManyToManyChildAttributeName  = m2mChild.Name)  
  
        -- Determine if the hierarchy is used for assigning member security permissions  
        LEFT JOIN hierarchiesWithMemberSecurityCte memSec  
        ON dh.ID = memSec.DerivedHierarchy_ID  
        ORDER BY   
             dh.ID  
            ,dhl.LevelNumber DESC   
  
        SELECT TOP 1 @Error = Error  
        FROM @DerivedHierarchyLevelsToProcess  
        WHERE Error IS NOT NULL;  
  
        IF @Error IS NOT NULL  
        BEGIN  
            SET @Error = REPLACE(@Error, '%', '%%')-- escape out format specifier  
            RAISERROR(@Error, 16, 1);  
        END  
  
        DECLARE @DerivedHierarchyLevel_ID           INT,  
                @DerivedHierarchyLevel_MUID         UNIQUEIDENTIFIER,  
                @DerivedHierarchyLevelName          NVARCHAR(100),  
                @Foreign_ID                         INT,  
                @ForeignType_ID                     TINYINT,  
                @ManyToManyChildAttribute_ID        INT,  
                @DerivedHierarchyLevelDisplayName   NVARCHAR(100),  
                @DerivedHierarchyLevelIsVisible     BIT,  
                @IsMemberSecurityApplied            BIT;  
  
        WHILE EXISTS(SELECT 1 FROM @DerivedHierarchyLevelsToProcess)  
        BEGIN  
            SELECT TOP 1  
                @Row_ID = RowID,  
                @Model_ID = Model_ID,  
                @Model_MUID = Model_MUID,  
                @ModelName = ModelName,  
                @MaxVersion_ID = Version_ID,  
                @DerivedHierarchy_ID = DerivedHierarchy_ID,  
                @DerivedHierarchy_MUID = DerivedHierarchy_MUID,  
                @DerivedHierarchyName = DerivedHierarchyName,  
                @DerivedHierarchyLevel_MUID = MUID,  
                @DerivedHierarchyLevelName = Name,  
                @Foreign_ID = Foreign_ID,  
                @ForeignType_ID = ForeignType_ID,  
                @ManyToManyChildAttribute_ID = ManyToManyChildAttribute_ID,  
                @DerivedHierarchyLevelDisplayName = DisplayName,  
                @DerivedHierarchyLevelIsVisible = IsVisible,  
                @IsMemberSecurityApplied = IsMemberSecurityApplied  
            FROM @DerivedHierarchyLevelsToProcess  
            ORDER BY RowID  
  
            PRINT CONCAT(SYSDATETIME(), N': Saving derived hierarchy level ', @DerivedHierarchyName, N'.', @DerivedHierarchyLevelName);  
            EXEC mdm.udpDerivedHierarchyDetailSave  
                    @User_ID = @User_ID,  
                    @Model_ID = @Model_ID,  
                    @Version_ID = @MaxVersion_ID,  
                    @DerivedHierarchy_ID = @DerivedHierarchy_ID,  
                    @MUID = @DerivedHierarchyLevel_MUID,  
                    @Name = @DerivedHierarchyLevelName,  
                    @Foreign_ID = @Foreign_ID,  
                    @ForeignType_ID = @ForeignType_ID,  
                    @ManyToManyChildAttribute_ID = @ManyToManyChildAttribute_ID,  
                    @DisplayName = @DerivedHierarchyLevelDisplayName,  
                    @IsVisible = @DerivedHierarchyLevelIsVisible,  
                    @EditMode = @EditMode,  
                    @IsMemberSecurityApplied = @IsMemberSecurityApplied,  
                    @Return_ID = @DerivedHierarchyLevel_ID OUTPUT,  
                    @Return_MUID = @DerivedHierarchyLevel_MUID OUTPUT,  
                    @CorrelationID = @CorrelationID;  
  
            INSERT INTO @CreatedDerivedHierarchyLevels  
            (  
                ModelID,  
                ModelMUID,  
                ModelName,  
                DerivedHierarchyID,  
                DerivedHierarchyMUID,  
                DerivedHierarchyName,  
                ID,  
                MUID,  
                Name  
            )  
            VALUES  
            (  
                @Model_ID,  
                @Model_MUID,  
                @ModelName,  
                @DerivedHierarchy_ID,  
                @DerivedHierarchy_MUID,  
                @DerivedHierarchyName,  
                @DerivedHierarchyLevel_ID,  
                @DerivedHierarchyLevel_MUID,  
                @DerivedHierarchyLevelName  
            )  
  
            DELETE @DerivedHierarchyLevelsToProcess  
            WHERE RowID = @Row_ID;  
        END  
  
        -- If levels were (potentially) created, ensure the top and bottom levels of the hierarchy are visible (udpDerivedHierarchyDetailSave will do this check for level updates).  
        IF @EditMode <> @EditMode_Update -- Clone mode could create a new level, so also do the check  
        BEGIN  
            DECLARE @InvalidHierarchy_ID INT;  
            WITH changedHierarchyCte AS  
            (  
                SELECT DISTINCT DerivedHierarchyID  
                FROM @CreatedDerivedHierarchyLevels  
            )  
            ,maxAndMinLevelsCte AS  
            (  
                SELECT   
                     dhd.DerivedHierarchy_ID  
                    ,MAX(Level_ID) MaxLevel  
                    ,MIN(Level_ID) MinLevel  
                FROM mdm.tblDerivedHierarchyDetail dhd  
                INNER JOIN changedHierarchyCte h  
                ON dhd.DerivedHierarchy_ID = h.DerivedHierarchyID  
                GROUP BY dhd.DerivedHierarchy_ID  
            )              
            SELECT TOP 1   
                @InvalidHierarchy_ID = dhd.DerivedHierarchy_ID  
            FROM mdm.tblDerivedHierarchyDetail dhd  
            INNER JOIN maxAndMinLevelsCte lvl  
            ON dhd.DerivedHierarchy_ID = lvl.DerivedHierarchy_ID  
                AND (   dhd.Level_ID = MaxLevel  
                     OR dhd.Level_ID = MinLevel)  
            WHERE dhd.IsVisible = 0;  
  
            IF @InvalidHierarchy_ID > 0  
            BEGIN  
                RAISERROR(N'MDSERR200099|The top or bottom level of a derived hierarchy cannot be hidden.', 16, 1)  
            END  
        END  
  
        --Output created/updated derived hierarchy levels  
        SELECT ModelID, ModelMUID, ModelName, DerivedHierarchyID, DerivedHierarchyMUID, DerivedHierarchyName, ID, MUID, Name FROM @CreatedDerivedHierarchyLevels;  
  
        --END Derived hierarchy level processing  
  
  
        -- BEGIN Attribute Filter processing (this must be done after creating Attributes and Derived Hierarchies, rather than as part of Attribute creation, because the filters may include dependencies on Attributes and Derived Hierarchies that are being created in this same operation)  
        IF @EditMode <> @EditMode_Update -- In update mode the filter info was already handled, so no need to re-call udpAttributeSave here.  
        BEGIN  
            EXEC mdm.udpMetadataSaveHelper_LookupAttributeFilterIds @AttributeFilters  
  
            SELECT TOP 1 @Error = Error  
            FROM #AttributesToProcess  
            WHERE Error IS NOT NULL;  
  
            IF @Error IS NOT NULL  
            BEGIN  
                SET @Error = REPLACE(@Error, '%', '%%')-- escape out format specifier  
                RAISERROR(@Error, 16, 1);  
            END  
  
            SET @Row_ID = 0  
  
            WHILE EXISTS(SELECT 1 FROM #AttributesToProcess WHERE Row_ID > @Row_ID AND FilterParentAttribute_ID IS NOT NULL)  
            BEGIN  
                SELECT TOP 1  
                    @Row_ID = Row_ID,  
                    @Attribute_ID = ID,  
                    @AttributeName = Name,  
                    @Model_ID = Model_ID,  
                    @MaxVersion_ID = Version_ID,  
                    @Entity_ID = Entity_ID,  
                    @IsHierarchyEnabled = IsHierarchyEnabled,  
                    @IsCollectionEnabled = IsCollectionEnabled,  
                    @DataCompression = DataCompression,  
                    @TableName = TableName,  
                    @StagingTableName = StagingTableName,  
                    @MemberType_ID = MemberType_ID,  
                    @AttributeDescription = [Description],  
                    @AttributeType_ID = AttributeType_ID,  
                    @DisplayName = DisplayName,  
                    @DisplayWidth = DisplayWidth,  
                    @DomainEntity_ID = DomainEntity_ID,  
                    @FilterParentAttribute_ID = FilterParentAttribute_ID,  
                    @FilterHierarchyDetail_ID = FilterHierarchyDetail_ID,  
                    @DataType_ID = DataType_ID,  
                    @DataTypeInformation = DataTypeInformation,  
                    @InputMask_ID = InputMask_ID,  
                    @ChangeTrackingGroup = ChangeTrackingGroup,  
                    @AttributeSortOrder = SortOrder  
                FROM #AttributesToProcess  
                WHERE   Row_ID > @Row_ID   
                    AND FilterParentAttribute_ID IS NOT NULL  
                ORDER BY Row_ID  
  
                PRINT CONCAT(SYSDATETIME(), N': Adding filter to attribute ', @AttributeName, ', MemberType ', @MemberType_ID, '.');  
                EXEC mdm.udpAttributeSave  
                        @User_ID = @User_ID,  
                        @Model_ID = @Model_ID,  
                        @Version_ID = @MaxVersion_ID,  
                        @Entity_ID = @Entity_ID,  
                        @IsHierarchyEnabled = @IsHierarchyEnabled,  
                        @IsCollectionEnabled = @IsCollectionEnabled,  
                        @DataCompression = @DataCompression,  
                        @TableName = @TableName OUTPUT,  
                        @StagingTableName = @StagingTableName,  
                        @MemberType_ID = @MemberType_ID,  
                        @Attribute_ID = @Attribute_ID,  
                        @AttributeName = @AttributeName,  
                        @AttributeType_ID = @AttributeType_ID,  
                        @Description = @AttributeDescription,  
                        @DisplayName = @DisplayName,  
                        @DisplayWidth = @DisplayWidth,  
                        @DomainEntity_ID = @DomainEntity_ID,  
                        @FilterParentAttribute_ID = @FilterParentAttribute_ID,  
                        @FilterHierarchyDetail_ID = @FilterHierarchyDetail_ID,  
                        @DataType_ID = @DataType_ID,  
                        @DataTypeInformation = @DataTypeInformation,  
                        @InputMask_ID = @InputMask_ID,  
                        @ChangeTrackingGroup = @ChangeTrackingGroup,  
                        @SortOrder = @AttributeSortOrder,  
                        @EditMode = @EditMode_Update,-- always updating an existing attribute at this point, even if this sproc is doing Create or Clone.  
                        @RecreateStagingProc = 0, -- will create staging sprocs later  
                        @CorrelationID = @CorrelationID;  
            END  
        END  
        -- END Attribute Filter processing  
  
  
        --BEGIN Index processing  
  
        DECLARE @IndexesToProcess TABLE  
        (  
            RowID           INT IDENTITY(1, 1) NOT NULL PRIMARY KEY,  
            Model_ID        INT NULL,  
            Model_MUID      UNIQUEIDENTIFIER NULL,  
            ModelName       NVARCHAR(50) COLLATE DATABASE_DEFAULT NULL,  
            Entity_ID       INT NULL,  
            Entity_MUID     UNIQUEIDENTIFIER NULL,  
            EntityName      NVARCHAR(50) COLLATE DATABASE_DEFAULT NULL,  
            DataCompression TINYINT NULL,  
            Index_MUID      UNIQUEIDENTIFIER NULL,  
            IndexName       NVARCHAR(50) COLLATE DATABASE_DEFAULT NULL,  
            IsUnique        BIT NULL,  
            Error           NVARCHAR(MAX) COLLATE DATABASE_DEFAULT NULL  
        );  
  
        INSERT INTO @IndexesToProcess  
        (  
            Model_ID,  
            Model_MUID,  
            ModelName,  
            Entity_ID,  
            Entity_MUID,  
            EntityName,  
            DataCompression,  
            Index_MUID,  
            IndexName,  
            IsUnique,  
            Error  
        )  
        SELECT  
            m.ID,  
            m.MUID,  
            m.Name,  
            e.ID,  
            e.MUID,  
            e.Name,  
            e.DataCompression,  
            i.MUID,  
            i.Name,  
            i.IsUnique,  
            CASE   
                WHEN m.ID IS NULL                       THEN N'MDSERR200302|The index cannot be saved. The model ID is not valid.'  
                WHEN m.IsAdministrator = 0              THEN N'MDSERR120003|The user does not have permission or the object ID is not valid.'  
                WHEN e.ID IS NULL                       THEN N'MDSERR200303|The index cannot be saved. The entity ID is not valid.'  
                WHEN syncTarget.Entity_ID IS NOT NULL   THEN N'MDSERR200225|The index cannot be saved. The entity is the target of a sync relationship.'  
                END  
        FROM @Indexes i  
        -- Note: looking up model ids and entity ids in a batch here is more efficient that doing it one row at a time in udpIndexSave  
        LEFT JOIN #UserModelAccess m  
        ON      (i.Model_MUID IS NOT NULL OR i.ModelName IS NOT NULL)   
            AND (i.Model_MUID IS NULL OR i.Model_MUID = m.MUID)   
            AND (i.ModelName  IS NULL OR i.ModelName  = m.Name)  
        LEFT JOIN mdm.tblEntity e  
        ON      m.ID = e.Model_ID  
            AND (i.Entity_MUID IS NOT NULL OR i.EntityName IS NOT NULL)  
            AND (i.Entity_MUID IS NULL OR i.Entity_MUID = e.MUID)  
            AND (i.EntityName  IS NULL OR i.EntityName  = e.Name)  
        LEFT JOIN @SyncTargetEntities syncTarget  
        ON e.ID = syncTarget.Entity_ID  
  
        SELECT TOP 1 @Error = Error  
        FROM @IndexesToProcess  
        WHERE Error IS NOT NULL;  
  
        IF @Error IS NOT NULL  
        BEGIN  
            SET @Error = REPLACE(@Error, '%', '%%')-- escape out format specifier  
            RAISERROR(@Error, 16, 1);  
        END  
  
        DECLARE @IndexDetailsToProcess mdm.CustomIndexDetail;  
        DECLARE @Index_ID       INT,  
                @Index_MUID     UNIQUEIDENTIFIER,  
                @IndexName      NVARCHAR(50),  
                @IsUnique       BIT  
  
        WHILE EXISTS(SELECT 1 FROM @IndexesToProcess)  
        BEGIN  
            SELECT TOP 1  
                @Row_ID = RowID,  
                @Model_ID = Model_ID,  
                @Model_MUID = Model_MUID,  
                @ModelName = ModelName,  
                @Entity_ID = Entity_ID,  
                @Entity_MUID = Entity_MUID,  
                @EntityName = EntityName,  
                @DataCompression = DataCompression,  
                @Index_MUID = Index_MUID,  
                @IndexName = IndexName,  
                @IsUnique = IsUnique  
            FROM @IndexesToProcess  
  
            DELETE FROM @IndexDetailsToProcess;  
            INSERT INTO @IndexDetailsToProcess  
            (  
                Model_MUID,  
                ModelName,  
                Entity_MUID,  
                EntityName,  
                CustomIndex_MUID,  
                CustomIndexName,  
                MUID,  
                Name  
            )  
            SELECT  
                Model_MUID,  
                ModelName,  
                Entity_MUID,  
                EntityName,  
                CustomIndex_MUID,  
                CustomIndexName,  
                MUID,  
                Name  
             FROM @IndexDetails details   
             WHERE  
                (details.CustomIndex_MUID IS NULL OR (@Index_MUID IS NOT NULL AND details.CustomIndex_MUID = @Index_MUID) ) AND  
                (details.CustomIndexName IS NULL OR (@IndexName IS NOT NULL AND details.CustomIndexName = @IndexName) )  
  
            PRINT CONCAT(SYSDATETIME(), N': Saving index ', @IndexName);  
            EXEC mdm.udpIndexSave  
                    @User_ID = @User_ID,  
                    @Model_ID = @Model_ID,  
                    @Entity_ID = @Entity_ID,  
                    @DataCompression = @DataCompression,  
                    @MUID = @Index_MUID,  
                    @Name = @IndexName,  
                    @IsUnique = @IsUnique,  
                    @IndexDetails = @IndexDetailsToProcess,  
                    @EditMode = @EditMode,  
                    @Return_ID = @Index_ID OUTPUT,  
                    @Return_MUID = @Index_MUID OUTPUT,  
                    @CorrelationID = @CorrelationID;  
  
            INSERT INTO @CreatedIndexes  
            (  
                ModelID,  
                ModelMUID,  
                ModelName,  
                EntityID,  
                EntityMUID,  
                EntityName,  
                ID,  
                MUID,  
                Name  
            )  
            VALUES  
            (  
                @Model_ID,  
                @Model_MUID,  
                @ModelName,  
                @Entity_ID,  
                @Entity_MUID,  
                @EntityName,  
                @Index_ID,  
                @Index_MUID,  
                @IndexName  
            )  
  
            DELETE @IndexesToProcess  
            WHERE RowID = @Row_ID;  
        END  
  
        --Output created/updated indexes  
        SELECT ModelID, ModelMUID, ModelName, EntityID, EntityMUID, EntityName, ID, MUID, Name FROM @CreatedIndexes;  
  
        --END Index processing  
  
        --Get a list of the created/updated models  
        DECLARE @ChangedModels TABLE  
        (  
             ID     INT PRIMARY KEY  
            ,Name   NVARCHAR(50) COLLATE DATABASE_DEFAULT NOT NULL  
        )  
  
        ;WITH cteModelsChanged AS  
        (  
            SELECT ID AS ModelID  
            FROM @CreatedModels  
            UNION -- not "UNION ALL" because deduplication is needed  
            SELECT ModelID  
            FROM @CreatedEntities  
            UNION -- not "UNION ALL" because deduplication is needed  
            SELECT ModelID  
            FROM @CreatedExplicitHierarchies  
            UNION -- not "UNION ALL" because deduplication is needed  
            SELECT Model_ID  
            FROM #AttributesToProcess  
            UNION -- not "UNION ALL" because deduplication is needed  
            SELECT ModelID  
            FROM @CreatedAttributeGroups  
            UNION -- not "UNION ALL" because deduplication is needed  
            SELECT ModelID  
            FROM @CreatedDerivedHierarchies  
            UNION -- not "UNION ALL" because deduplication is needed  
            SELECT ModelID  
            FROM @CreatedDerivedHierarchyLevels  
            UNION -- not "UNION ALL" because deduplication is needed  
            SELECT ModelID  
            FROM @CreatedIndexes  
        )  
        INSERT INTO @ChangedModels  
            (ID, Name)  
        SELECT  
            m.ModelID, sec.Name  
        FROM cteModelsChanged m  
        INNER JOIN #UserModelAccess sec  
        ON m.ModelID = sec.ID  
  
        SET @Lock = -1;  
        EXEC sp_releaseapplock @Resource = N'DeferViewGeneration', @LockOwner='Session';  
  
        WHILE EXISTS(SELECT 1 FROM @ChangedModels)  
        BEGIN  
            SELECT TOP 1  
                 @Model_ID = ID  
                ,@ModelName = Name  
            FROM @ChangedModels  
  
            PRINT CONCAT(SYSDATETIME(), N': Regenerating views for model ', @ModelName);  
            EXEC mdm.udpCreateViews @Model_ID = @Model_ID, @CorrelationID = @CorrelationID;  
  
            -- Regenerate subscription views if there are any.   
            PRINT CONCAT(SYSDATETIME(), N': Regenerating subscription views for model ', @ModelName);  
            EXEC mdm.udpCreateAllSubscriptionViews @Model_ID = @Model_ID, @CorrelationID = @CorrelationID;  
  
            DELETE @ChangedModels  
            WHERE ID = @Model_ID;  
        END  
  
          
        -- All Entity and Attribute changes are finished at this point, and all views have been recreated, so (re)create staging sprocs.  
          
        -- Determine which entity member types need to have their staging sprocs recreated  
        DECLARE @StaleStagingSprocs TABLE  
        (  
             RowID          INT IDENTITY(1, 1) NOT NULL PRIMARY KEY  
            ,Entity_ID      INT  
            ,EntityName     NVARCHAR(50)  
            ,MemberType_ID  TINYINT  
        )  
        INSERT INTO @StaleStagingSprocs   
        (  
             Entity_ID  
            ,EntityName  
            ,MemberType_ID  
        )  
        SELECT  
             Entity_ID  
            ,EntityName  
            ,MemberType_ID  
        FROM #AttributesToProcess  
        UNION -- not "UNION ALL" because deduplication is needed  
        SELECT  
            ID,  
            Name,  
            @MemberType_Leaf  
        FROM @CreatedEntities  
        WHERE @EditMode = @EditMode_Create  
        UNION -- not "UNION ALL" because deduplication is needed  
        SELECT  
            EntityID,  
            EntityName,  
            @MemberType_Leaf -- udpEntityHierarchySave already avoids needlessly creating consolidated-related sprocs  
        FROM @CreatedExplicitHierarchies  
  
        WHILE EXISTS (SELECT 1 FROM @StaleStagingSprocs)  
        BEGIN  
            SELECT TOP 1  
                 @Row_ID = RowID  
                ,@Entity_ID = Entity_ID  
                ,@EntityName = EntityName  
                ,@MemberType_ID = MemberType_ID  
            FROM @StaleStagingSprocs  
  
            IF @MemberType_ID = @MemberType_Leaf  
            BEGIN  
                PRINT CONCAT(SYSDATETIME(), N': Creating Leaf staging sproc for entity ', @EntityName, N' (ID = ', @Entity_ID, N')');  
                EXEC mdm.udpEntityStagingCreateLeafStoredProcedure @Entity_ID  
            END ELSE  
            IF @MemberType_ID = @MemberType_Consolidated  
            BEGIN  
                PRINT CONCAT(SYSDATETIME(), N': Creating Consolidated staging sproc for entity ', @EntityName, N' (ID = ', @Entity_ID, N')');  
                EXEC mdm.udpEntityStagingCreateConsolidatedStoredProcedure @Entity_ID  
            END  
  
            DELETE @StaleStagingSprocs  
            WHERE RowID = @Row_ID  
        END  
  
  
        --Commit only if we are not nested  
        IF @TranCounter = 0 COMMIT TRANSACTION;  
        RETURN(0);  
  
    END TRY  
    --Compensate as necessary  
    BEGIN CATCH  
  
        -- Ensure the lock is released  
        IF @Lock IN (0, 1)  
        BEGIN  
            EXEC sp_releaseapplock @Resource = N'DeferViewGeneration', @LockOwner='Session';  
        END;  
  
        -- Get error info.  
        DECLARE  
            @ErrorMessage NVARCHAR(4000),  
            @ErrorSeverity INT,  
            @ErrorState INT,  
            @ErrorNumber INT,  
            @ErrorLine INT,  
            @ErrorProcedure NVARCHAR(126);  
        EXEC mdm.udpGetErrorInfo  
            @ErrorMessage = @ErrorMessage OUTPUT,  
            @ErrorSeverity = @ErrorSeverity OUTPUT,  
            @ErrorState = @ErrorState OUTPUT,  
            @ErrorNumber = @ErrorNumber OUTPUT,  
            @ErrorLine = @ErrorLine OUTPUT,  
            @ErrorProcedure = @ErrorProcedure OUTPUT  
  
        SET @ErrorMessage = CONCAT(@ErrorMessage, N', @ErrorNumber = ', @ErrorNumber, N', @ErrorProcedure = "', @ErrorProcedure, N'", line ', @ErrorLine);  
  
        IF @TranCounter = 0 ROLLBACK TRANSACTION;  
        ELSE IF XACT_STATE() <> -1 ROLLBACK TRANSACTION TX;  
  
        RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);  
        RETURN;  
  
    END CATCH;  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpMetadataSaveHelper_LookupAttributeFilterIds]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
Helper method called by udpMetadataSave and udpAttributeChange that looks up attribute filter IDs and loads them into the temp table,  
#AttributesToProcess, that is defined there.   
  
Note: Because this sproc references a temp table that is defined elsewhere, had to suppress on this file TSQL warning 71502.  
*/  
CREATE PROCEDURE [mdm].[udpMetadataSaveHelper_LookupAttributeFilterIds]  
(  
    @AttributeFilters       mdm.AttributeFilter READONLY  
)  
AS BEGIN  
  
    DECLARE  
         @HierarchyItemType_DBA         TINYINT = 1  
        ,@HierarchyItemType_ManyToMany  TINYINT = 5  
  
        ,@MemberType_Leaf               TINYINT = 1  
    /*  
    -- schema of temp table defined in caller (udpMetadataSave). In it useful to uncomment this when modifying the below query, to enable intellisense.  
    CREATE TABLE #AttributesToProcess  
    (  
        Row_ID              INT NOT NULL PRIMARY KEY,  
        Model_ID            INT NULL,  
        Model_MUID          UNIQUEIDENTIFIER NULL,  
        ModelName           NVARCHAR(50) COLLATE DATABASE_DEFAULT NULL,  
        Version_ID          INT NULL,  
        Entity_ID           INT NULL,  
        Entity_MUID         UNIQUEIDENTIFIER NULL,  
        EntityName          NVARCHAR(50) COLLATE DATABASE_DEFAULT NULL,  
        IsHierarchyEnabled  BIT NULL,  
        IsCollectionEnabled BIT NULL,  
        DataCompression     TINYINT NULL,  
        TableName           SYSNAME NULL,  
        StagingTableName    SYSNAME NULL,  
        MemberType_ID       TINYINT NOT NULL,  
        ID                  INT NULL,  
        MUID                UNIQUEIDENTIFIER NULL,  
        Name                NVARCHAR(100) COLLATE DATABASE_DEFAULT NOT NULL,  
        [Description]       NVARCHAR(500) COLLATE DATABASE_DEFAULT NULL,  
        AttributeType_ID    TINYINT NULL,  
        DisplayName         NVARCHAR(250) COLLATE DATABASE_DEFAULT NULL,  
        DisplayWidth        INT NOT NULL,  
        DomainEntity_ID     INT NULL,  
        FilterParentAttribute_ID    INT NULL,  
        FilterHierarchyDetail_ID    INT NULL,  
        DataType_ID         TINYINT NULL,  
        DataTypeInformation INT NULL,  
        InputMask_ID        INT NULL,  
        ChangeTrackingGroup INT DEFAULT 0,  
        SortOrder           INT NULL,  
        DidNameChange       BIT NULL,  
        Error               NVARCHAR(MAX) COLLATE DATABASE_DEFAULT NULL  
    );  
    --*/  
  
    UPDATE atp  
    SET  
        FilterParentAttribute_ID = filterParent.ID,  
        FilterHierarchyDetail_ID = dhl.ID,  
        Error = CASE   
            WHEN Error IS NOT NULL                                      THEN Error -- Don't overwrite an existing error message  
            WHEN atp.MemberType_ID <> @MemberType_Leaf                  THEN N'MDSERR200114|The attribute cannot be saved. An attribute filter can only be added to a leaf attribute.'  
            WHEN atp.DomainEntity_ID IS NULL                            THEN N'MDSERR200115|The attribute cannot be saved. An attribute filter can only be added to a domain-based attribute.'  
            WHEN filterParent.ID IS NULL   
                OR atp.ID = filterParent.ID /*Cannot filter itself*/    THEN N'MDSERR200116|The attribute cannot be saved. The attribute filter parent is not valid.'  
            WHEN filterParent.DomainEntity_ID IS NULL                   THEN N'MDSERR200118|The attribute cannot be saved. The attribute filter parent must be a domain-based attribute.'  
  
            WHEN filterHierarchy.ID IS NULL                             THEN N'MDSERR200119|The attribute cannot be saved. The attribute filter hierarchy is not valid.'  
  
            WHEN dhl.ID IS NULL                                         THEN N'MDSERR200120|The attribute cannot be saved. The attribute filter hierarchy level is not valid.'  
            WHEN dhl.ForeignType_ID NOT IN   
                (@HierarchyItemType_DBA, @HierarchyItemType_ManyToMany) THEN N'MDSERR200121|The attribute cannot be saved. The attribute filter hierarchy level type must be Domain or ManyToMany.'  
            WHEN dhl.Entity_ID <> filterParent.DomainEntity_ID          THEN N'MDSERR200122|The attribute cannot be saved. The attribute filter hierarchy level entity must be the parent attribute domain entity.'  
            WHEN atp.DomainEntity_ID <> COALESCE(m2mChild.DomainEntity_ID, dhl.ForeignEntity_ID)    
                                                                        THEN N'MDSERR200123|The attribute cannot be saved. The filter hierarchy child level entity must be the same as the attribute domain entity.'  
            WHEN dhl.IsLevelVisible = 0                                 THEN N'MDSERR200125|The attribute cannot be saved. The attribute filter hierarchy level must be visible.'  
            END  
    FROM @AttributeFilters af  
    INNER JOIN #AttributesToProcess atp -- temp table defined in caller (udpMetadataSave)  
    ON af.AttributeRow_ID = atp.Row_ID  
    -- Note: looking up ids in a batch here is more efficient that doing it one row at a time in updAttributeSave  
    LEFT JOIN mdm.tblAttribute filterParent  
    ON      (af.ParentAttribute_MUID IS NOT NULL OR af.ParentAttributeName IS NOT NULL)  
        AND (af.ParentAttribute_MUID IS NULL OR af.ParentAttribute_MUID = filterParent.MUID)  
        AND (af.ParentAttributeName  IS NULL OR af.ParentAttributeName  = filterParent.Name)  
        AND atp.Entity_ID = filterParent.Entity_ID  
        AND atp.MemberType_ID = filterParent.MemberType_ID  
    LEFT JOIN mdm.tblDerivedHierarchy filterHierarchy  
    ON      (af.Hierarchy_MUID IS NOT NULL OR af.HierarchyName IS NOT NULL)  
        AND (af.Hierarchy_MUID IS NULL OR af.Hierarchy_MUID = filterHierarchy.MUID)  
        AND (af.HierarchyName  IS NULL OR af.HierarchyName  = filterHierarchy.Name)  
        AND atp.Model_ID = filterHierarchy.Model_ID  
    LEFT JOIN mdm.viw_SYSTEM_SCHEMA_HIERARCHY_DERIVED_LEVELS dhl  
    ON      filterHierarchy.ID = dhl.Hierarchy_ID  
        AND af.HierarchyLevelNumber = dhl.LevelNumber  
    LEFT JOIN mdm.tblAttribute m2mChild  
    ON  dhl.ManyToManyChildAttribute_ID = m2mChild.ID  
END
GO
/****** Object:  StoredProcedure [mdm].[udpModelDelete]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    EXEC mdm.udpModelDelete '5'  
*/  
CREATE PROCEDURE [mdm].[udpModelDelete]  
(  
    @Model_ID INT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON  
  
    --Start transaction, being careful to check if we are nested  
    DECLARE @TranCounter INT;   
    SET @TranCounter = @@TRANCOUNT;  
    IF @TranCounter > 0 SAVE TRANSACTION TX;  
    ELSE BEGIN TRANSACTION;  
  
    BEGIN TRY  
  
        DECLARE @tblEntityID    TABLE (  
                                RowNumber INT IDENTITY (1, 1) PRIMARY KEY CLUSTERED NOT NULL   
                                ,ID INT NOT NULL  
                                ,Name NVARCHAR(50) NOT NULL);  
        DECLARE @DeleteBRs      mdm.IdList;  
  
        DECLARE @TempID         INT  
        DECLARE @TempEntityName NVARCHAR(50);  
  
        --Delete all derived hierarchies  
        INSERT INTO @tblEntityID   
            SELECT D.ID, N'' FROM mdm.tblDerivedHierarchy D WHERE D.Model_ID = @Model_ID;  
        DECLARE @Counter INT = 1 ;  
        DECLARE @MaxCounter INT = (SELECT MAX(RowNumber) FROM @tblEntityID);  
          
        WHILE @Counter <= @MaxCounter  
            BEGIN  
            SELECT @TempID = ID FROM @tblEntityID WHERE [RowNumber] = @Counter ;;  
            EXEC mdm.udpDerivedHierarchyDelete @TempID;  
            SET @Counter = @Counter+1  
        END; --while  
          
        --Delete the subscription views associated with the model  
        EXEC mdm.udpSubscriptionViewsDelete   
            @Model_ID               = @Model_ID,  
            @Version_ID             = NULL,  
            @Entity_ID              = NULL,  
            @DerivedHierarchy_ID    = NULL;  
  
        --Delete business rules  
        INSERT INTO @DeleteBRs (ID) SELECT br.BusinessRule_ID FROM mdm.viw_SYSTEM_SCHEMA_BUSINESSRULES br WHERE br.Model_ID = @Model_ID;  
        EXEC mdm.udpBusinessRulesDelete @RuleIDs = @DeleteBRs  
  
        --Delete any explicitly assigned security privileges  
        DELETE FROM mdm.tblSecurityRoleAccess WHERE Model_ID = @Model_ID;  
  
  
        --Delete any indexes on model's entities. We need to do this before deleting entities since if we have an index on a dba attribute and the  
        --related entity of that attribute is going to be deleted first, the existing index have to be deleted first before deleting the entity.  
        DELETE FROM @tblEntityID;  
        INSERT INTO @tblEntityID SELECT E.ID, E.Name FROM mdm.tblEntity E WHERE E.Model_ID = @Model_ID;  
        SET @Counter = 0;  
        SET @MaxCounter = 0;  
        SELECT   
             @Counter = MIN(RowNumber)--reused table variable so the row won't start at 1.  
            ,@MaxCounter = MAX(RowNumber)  
        FROM @tblEntityID  
          
        DECLARE @tblIndexID TABLE(  
                            ID INT NOT NULL);  
        DECLARE @IndexID    INT;  
        WHILE @Counter <= @MaxCounter  
        BEGIN  
            SELECT   
                 @TempID = ID   
            FROM @tblEntityID WHERE [RowNumber] = @Counter ;  
            DELETE FROM @tblIndexID;  
            INSERT INTO @tblIndexID SELECT I.ID FROM mdm.tblIndex I WHERE I.Entity_ID = @TempID  
            PRINT CONCAT(SYSDATETIME(), ': Removing INDEXES ON Entity:', @TempEntityName, N' (ID =', @TempID, N')')  
            WHILE EXISTS(SELECT 1 FROM @tblIndexID)  
            BEGIN  
                SELECT TOP 1      
                    @IndexID = ID  
                FROM @tblIndexID  
                EXEC mdm.udpIndexDelete @ID = @IndexID;  
                DELETE FROM @tblIndexID WHERE ID = @IndexID;  
            END  
            SET @Counter = @Counter+1  
        END; --while  
  
        DELETE FROM @tblEntityID;      
        --Delete all entities within the Model  
        INSERT INTO @tblEntityID SELECT E.ID, E.Name FROM mdm.tblEntity E WHERE E.Model_ID = @Model_ID;  
        SET @Counter = 0;  
        SET @MaxCounter = 0;  
        SELECT   
             @Counter = MIN(RowNumber)--reused table variable so the row won't start at 1.  
            ,@MaxCounter = MAX(RowNumber)  
        FROM @tblEntityID  
          
        WHILE @Counter <= @MaxCounter  
        BEGIN  
            SELECT   
                 @TempID = ID   
                ,@TempEntityName = Name  
            FROM @tblEntityID WHERE [RowNumber] = @Counter ;  
            PRINT CONCAT(SYSDATETIME(), ': Removing Entity:', @TempEntityName, N' (ID = ', @TempID, N')')  
            EXEC mdm.udpEntityDelete @Entity_ID = @TempID, @CreateViewsInd = 0;  
            SET @Counter = @Counter+1  
        END; --while  
  
        --Delete all notification queue related items  
        DELETE FROM mdm.tblNotificationUsers WHERE Notification_ID IN (SELECT ID FROM mdm.tblNotificationQueue WHERE Model_ID = @Model_ID);          
        DELETE FROM mdm.tblNotificationQueue WHERE Model_ID = @Model_ID  
  
        --Delete the version record(s)  
        DELETE FROM mdm.tblModelVersion WHERE Model_ID = @Model_ID;  
        DELETE FROM mdm.tblModelVersionFlag WHERE Model_ID = @Model_ID;  
  
        --Delete the model tables  
        EXEC mdm.udpDeleteModelTablesAndViews @Model_ID = @Model_ID;  
  
        --Delete the Model record  
        DELETE FROM mdm.tblModel WHERE ID = @Model_ID;  
  
        --Commit only if we are not nested  
        IF @TranCounter = 0 COMMIT TRANSACTION;  
  
    END TRY  
    --Compensate as necessary  
    BEGIN CATCH  
  
        -- Get error info.  
        DECLARE  
            @ErrorMessage NVARCHAR(4000),  
            @ErrorSeverity INT,  
            @ErrorState INT,  
            @ErrorNumber INT,  
            @ErrorLine INT,  
            @ErrorProcedure NVARCHAR(126);  
        EXEC mdm.udpGetErrorInfo  
            @ErrorMessage = @ErrorMessage OUTPUT,  
            @ErrorSeverity = @ErrorSeverity OUTPUT,  
            @ErrorState = @ErrorState OUTPUT,  
            @ErrorNumber = @ErrorNumber OUTPUT,  
            @ErrorLine = @ErrorLine OUTPUT,  
            @ErrorProcedure = @ErrorProcedure OUTPUT  
  
        SET @ErrorMessage = CONCAT(@ErrorMessage, N', @ErrorNumber = ', @ErrorNumber, N', @ErrorProcedure = "', @ErrorProcedure, N'", line ', @ErrorLine);  
  
        IF @TranCounter = 0 ROLLBACK TRANSACTION;  
        ELSE IF XACT_STATE() <> -1 ROLLBACK TRANSACTION TX;  
  
        RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);  
  
        --On error, return NULL results  
        --SELECT @Return_ID = NULL;  
        RETURN(1);  
  
    END CATCH;  
  
    -- Send the message  
	EXEC mdm.udpPerformanceQueueSave;  
      
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpModelEntityGetIDByName]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
/*  
Resolves model and entity muid and name to the corresponding ID  
  
Sample call: EXEC mdm.udpGetModelEntityIDByName NULL, N'Customer', NULL, N'Customer', @ModelID OUT, @EntityID OUT  
  
*/  
CREATE PROCEDURE [mdm].[udpModelEntityGetIDByName]  
(  
    @Model_MUID				UNIQUEIDENTIFIER = NULL,  
    @Model_Name				NVARCHAR(50) = NULL,  
    @Entity_MUID			UNIQUEIDENTIFIER = NULL,   
    @Entity_Name			NVARCHAR(50) = NULL,  
    @Model_ID				INT OUT,  
    @Entity_ID				INT OUT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
AS BEGIN  
    DECLARE @Invalid_ID INT = -1  
  
    SELECT @Model_ID = mdm.udfModelGetIDByName(@Model_MUID, @Model_Name);  
    -- filter invalid model name/muid  
    if ((@Model_MUID IS NOT NULL) OR  (@Model_Name IS NOT NULL)) AND (@Model_ID IS NULL)  
    BEGIN  
        SELECT @Model_ID =  @Invalid_ID  
    END  
  
    SELECT @Entity_ID = CASE   
                            WHEN (@Entity_MUID IS NULL) AND (@Entity_Name IS NULL) THEN NULL  
                            ELSE mdm.udfEntityGetIDByName(@Model_MUID, @Model_Name, @Entity_MUID, @Entity_Name)  
                        END	  
END
GO
/****** Object:  StoredProcedure [mdm].[udpModelGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpModelGet]  
(  
     @User_ID       INT  
  
    ,@Model_MUID    UNIQUEIDENTIFIER = NULL  
    ,@Model_Name    NVARCHAR(50) = NULL  
   
    -- Only used when getting details  
  
    ,@Version_MUID      UNIQUEIDENTIFIER = NULL  
    ,@Version_Name      NVARCHAR(50) = NULL  
  
    ,@VersionFlag_MUID  UNIQUEIDENTIFIER = NULL  
    ,@VersionFlag_Name  NVARCHAR(50) = NULL  
  
    ,@Entity_MUID   UNIQUEIDENTIFIER = NULL  
    ,@Entity_Name   NVARCHAR(50) = NULL  
  
    ,@Index_MUID   UNIQUEIDENTIFIER = NULL  
    ,@Index_Name   NVARCHAR(50) = NULL  
  
    ,@MemberType_ID TINYINT = NULL  
  
    ,@AttributeGroup_MUID   UNIQUEIDENTIFIER = NULL  
    ,@AttributeGroup_Name   NVARCHAR(50) = NULL  
  
    ,@Attribute_MUID   UNIQUEIDENTIFIER = NULL  
    ,@Attribute_Name   NVARCHAR(100) = NULL  
  
    ,@ResultOption  TINYINT -- None = 0, Identifiers = 1, Details = 2.   
    ,@Debug         BIT = 0  
   
    ,@CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
  
    SET NOCOUNT ON  
  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), ': begin udpModelGet')  
  
    DECLARE   
         @ResultOption_Identifiers  TINYINT = 1  
        ,@ResultOption_Details      TINYINT = 2  
  
    -- Get model ID  
    DECLARE @Model_ID INT;  
    IF @Model_Name IS NOT NULL OR @Model_MUID IS NOT NULL  
    BEGIN  
        SELECT   
             @Model_ID = ID  
            ,@Model_MUID = MUID  
            ,@Model_Name = Name  
        FROM mdm.tblModel  
        WHERE   MUID = ISNULL(@Model_MUID, MUID)  
            AND Name = ISNULL(@Model_Name, Name)  
  
        SET @Model_ID = COALESCE(@Model_ID, 0)  
    END  
  
  
    DECLARE @SelectedModel TABLE   
    (  
         ID                 INT PRIMARY KEY  
        ,MUID               UNIQUEIDENTIFIER  
        ,Name               NVARCHAR(50)  
        ,Privilege_ID       TINYINT  
        ,AccessPermission   TINYINT  
    )  
  
    INSERT INTO @SelectedModel  
    SELECT  
         m.ID  
        ,m.MUID  
        ,m.Name  
        ,acl.Privilege_ID  
        ,acl.AccessPermission  
    FROM mdm.tblModel m  
    INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_MODEL acl  
    ON m.ID = acl.ID  
    WHERE   acl.User_ID = @User_ID  
        AND m.MUID = ISNULL(@Model_MUID, m.MUID)  
        AND m.Name = ISNULL(@Model_Name, m.Name)  
        AND acl.Privilege_ID <> 1 -- Deny  
  
    IF (SELECT COUNT(1) FROM @SelectedModel) = 1  
    BEGIN  
        SELECT  
             @Model_MUID = MUID  
            ,@Model_Name = Name  
            ,@Model_ID = ID  
        FROM @SelectedModel  
    END ELSE  
    BEGIN  
        SELECT  
             @Model_MUID = NULL  
            ,@Model_Name = NULL  
            ,@Model_ID = NULL  
    END  
  
  
  
    SELECT  
         m.MUID AS Model_MUID  
        ,m.Name AS Model_Name  
        ,m.ID   AS Model_ID  
        ,sm.Privilege_ID  
        ,sm.AccessPermission  
  
        ,m.Description  
        ,CONVERT(SMALLINT, m.LogRetentionDays) AS LogRetentionDays  
  
        ,m.EnteredUser_DTM  
        ,m.EnteredUser_MUID  
        ,m.EnteredUser_UserName  
        ,m.EnteredUser_ID  
        ,m.LastChgUser_DTM  
        ,m.LastChgUser_MUID  
        ,m.LastChgUser_UserName  
        ,m.LastChgUser_ID  
    FROM @SelectedModel sm  
    INNER JOIN mdm.viw_SYSTEM_SCHEMA_MODEL m  
    ON sm.ID = m.ID  
    ORDER BY m.Name   
  
    IF @ResultOption = @ResultOption_Details  
    BEGIN  
        EXEC mdm.udpVersionFlagGet  
             @User_ID = @User_ID  
            ,@Model_ID = @Model_ID  
            ,@Model_MUID = @Model_MUID  
            ,@Model_Name = @Model_Name  
            ,@VersionFlag_MUID = @VersionFlag_MUID  
            ,@VersionFlag_Name = @VersionFlag_Name  
            ,@IncludeParentIdentifiers = 0 -- parent Ids already returned  
            ,@Debug = @Debug  
            ,@CorrelationID = @CorrelationID  
  
        EXEC mdm.udpVersionGet  
             @User_ID = @User_ID  
            ,@Model_ID = @Model_ID  
            ,@Model_MUID = @Model_MUID  
            ,@Model_Name = @Model_Name  
            ,@Version_MUID = @Version_MUID  
            ,@Version_Name = @Version_Name  
            ,@IncludeParentIdentifiers = 0 -- parent Ids already returned  
            ,@Debug = @Debug  
            ,@CorrelationID = @CorrelationID  
  
        DECLARE @HierarchyTable mdm.Identifier;  
        EXEC mdm.udpDerivedHierarchyGet  
             @User_ID = @User_ID  
            ,@Model_ID = @Model_ID  
            ,@Model_MUID = @Model_MUID  
            ,@Model_Name = @Model_Name  
            ,@HierarchyTable = @HierarchyTable  
            ,@ResultOption = @ResultOption_Details  
            ,@IncludeParentIdentifiers = 0 -- parent Ids already returned  
            ,@Debug = @Debug  
            ,@CorrelationID = @CorrelationID  
  
        EXEC mdm.udpEntityGet  
             @User_ID = @User_ID  
            ,@Model_MUID = @Model_MUID  
            ,@Model_Name = @Model_Name  
            ,@Model_ID = @Model_ID  
            ,@Entity_MUID = @Entity_MUID  
            ,@Entity_Name = @Entity_Name  
            ,@HierarchyTable = @HierarchyTable  
            ,@MemberType_ID = @MemberType_ID  
            ,@AttributeGroup_MUID = @AttributeGroup_MUID  
            ,@AttributeGroup_Name = @AttributeGroup_Name  
            ,@Attribute_MUID = @Attribute_MUID  
            ,@Attribute_Name = @Attribute_Name  
            ,@ResultOption = @ResultOption_Details  
            ,@IncludeParentIdentifiers = 0 -- parent Ids already returned  
            ,@Debug = @Debug  
            ,@CorrelationID = @CorrelationID  
    END   
  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), ': end udpModelGet')  
  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpModelSave]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    --Create new Model  
    DECLARE @Return_ID INT, @Return_MUID UNIQUEIDENTIFIER;  
    EXEC mdm.udpModelSave @User_ID = 1, @ModelName = N'test', @EditMode = 0, @Return_ID = @Return_ID OUTPUT, @Return_MUID = @Return_MUID OUTPUT;  
    SELECT @Return_ID, @Return_MUID;  
    SELECT * FROM mdm.tblModel WHERE ID = @Return_ID;  
  
    --Update existing Model  
    DECLARE @Return_ID INT, @Return_MUID UNIQUEIDENTIFIER;  
    EXEC mdm.udpModelSave @User_ID = 1, @Model_ID = 1, @ModelName = N'test new', @EditMode = 1, @Return_ID = @Return_ID OUTPUT, @Return_MUID = @Return_MUID OUTPUT;  
    SELECT @Return_ID, @Return_MUID;  
    SELECT * FROM mdm.tblModel WHERE ID = @Return_ID;  
*/  
CREATE PROCEDURE [mdm].[udpModelSave]  
(  
    @User_ID                        INT,  
    @Model_MUID                     UNIQUEIDENTIFIER = NULL,  
    @ModelName                      NVARCHAR(50),  
    @Description                    NVARCHAR(500) = NULL,  
    @EditMode                       TINYINT = 0, --0: Create, 1: Update, 4: Clone, defaults to Create  
    @LogRetentionDays               SMALLINT = NULL,  
    @Return_ID                      INT = NULL OUTPUT,  
    @Return_MUID                    UNIQUEIDENTIFIER = NULL OUTPUT, --Also an input parameter for clone operations  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE @TempDescription                    NVARCHAR(250),  
            @CurrentDTM                         DATETIME2(3),  
            @CurrentModelName                   NVARCHAR(50),  
            @CurrentDescription                 NVARCHAR(MAX),  
            @CurrentLogRetentionDays            INT = NULL,  
            @SystemSettingLogRetentionDays      INT = NULL,  
            @EditMode_Create                    TINYINT = 0,  
            @EditMode_Update                    TINYINT = 1,  
            @EditMode_Clone                     TINYINT = 4,  
            @ExistingModel_MUID                 UNIQUEIDENTIFIER = NULL,  
            @ExistingModel_ID                   INT = NULL,  
            @ObjectType_Model                   INT = 1,  
            @IsModelAdmin                       INT = NULL,  
            @PartitionFunction                  SYSNAME,  
            @PartitionSchema                    SYSNAME,  
            @FileGroupName                      SYSNAME,  
            @SQL                                NVARCHAR(MAX),  
            @GuidEmpty                          UNIQUEIDENTIFIER = CAST(0x0 AS UNIQUEIDENTIFIER);  
  
    --Initialize output parameters and local variables  
    SELECT  
        @ModelName = NULLIF(LTRIM(RTRIM(@ModelName)), N''),  
        @Description = NULLIF(LTRIM(RTRIM(@Description)), N''),  
        @Return_ID = NULL,  
        @CurrentDTM = GETUTCDATE(),  
        @CurrentModelName = NULL,  
        @Model_MUID = NULLIF(@Model_MUID, @GuidEmpty),  
        @SystemSettingLogRetentionDays = CONVERT(INT,mdm.udfSystemSettingGet('LogRetentionDays'));  
    --On error, return NULL results  
    SELECT @Return_ID = NULL, @Return_MUID = NULL;  
  
    --Test for invalid EditMode  
    IF @EditMode IS NULL OR @EditMode NOT IN (@EditMode_Create, @EditMode_Update, @EditMode_Clone)  
    BEGIN  
        RAISERROR('MDSERR100010|The Parameters are not valid.', 16, 1);  
        RETURN;  
    END; --if  
  
  
    --If we are in the Update or Clone mode get the missing pieces of the identifier  
    IF @EditMode IN (@EditMode_Update, @EditMode_Clone)  
    BEGIN  
        --Only use the name if the MUID is not available. This is important because we don't want  
        --to look up by name if the name is what the user is trying to update.  
        IF @Model_MUID IS NULL  
        BEGIN  
            SELECT TOP 1  
                @ExistingModel_ID =  ID,  
                @ExistingModel_MUID = MUID,  
                @CurrentModelName = Name,  
                @CurrentDescription = [Description],  
                @CurrentLogRetentionDays = LogRetentionDays  
            FROM mdm.tblModel  
            WHERE [Name] = @ModelName;  
        END  
        --Use the Model MUID to look up the full identifier  
        ELSE  
        BEGIN  
            SELECT  
                @ExistingModel_ID =  ID,  
                @ExistingModel_MUID = MUID,  
                @CurrentModelName = Name,  
                @CurrentDescription = [Description],  
                @CurrentLogRetentionDays = LogRetentionDays  
            FROM mdm.tblModel  
            WHERE MUID = @Model_MUID;  
        END  
  
        --If we are in the Clone mode we need to figure out whether we are creating or updating a model  
        IF @EditMode = @EditMode_Clone  
        BEGIN  
            --If there is no existing model then set the edit mode to Create  
            IF @ExistingModel_MUID IS NULL AND @ExistingModel_ID IS NULL  
            BEGIN  
                SET @EditMode = @EditMode_Create;  
            END  
            --If there is an existing model then set the edit mode to Update  
            ELSE  
            BEGIN  
                SET @EditMode = @EditMode_Update;  
                SET @Model_MUID = @ExistingModel_MUID;  
            END  
        END  
        --If we are in Update mode and could not find a matching existing model we need to raise an error and quit now  
        ELSE IF @EditMode = @EditMode_Update  
        BEGIN  
            IF @ExistingModel_ID IS NULL OR @ExistingModel_MUID IS NULL  
            BEGIN  
                RAISERROR('MDSERR110007|The ID is not valid.', 16, 1);  
                RETURN;  
            END  
            ELSE  
            BEGIN  
                SET @Model_MUID = @ExistingModel_MUID;  
            END  
        END  
    END  
  
    --If the edit mode is Create. This code also needs to execute if the user sent in EditMode clone which ended up becoming Create (hence the IF instead of ELSE IF)  
    IF @EditMode = @EditMode_Create  
    BEGIN  
        --If Model_MUID is not null then we need to ensure it does not already exist (since this is a create)  
        IF @Model_MUID IS NOT NULL AND EXISTS(SELECT * FROM mdm.tblModel WHERE MUID = @Model_MUID)  
        BEGIN  
            RAISERROR('MDSERR110007|The ID is not valid.', 16, 1);  
            RETURN;  
        END  
    END  
  
    --Check the name of the model for duplicates  
    IF EXISTS (SELECT 1 FROM mdm.tblModel WHERE @ModelName = Name AND (@Model_MUID IS NULL OR MUID <> @Model_MUID))  
    BEGIN  
        RAISERROR('MDSERR110003|The name already exists. Type a different name.', 16, 1);  
        RETURN;  
    END  
  
    --Start transaction, being careful to check if we are nested  
    DECLARE @TranCounter INT;  
    SET @TranCounter = @@TRANCOUNT;  
    IF @TranCounter > 0 SAVE TRANSACTION TX;  
    ELSE BEGIN TRANSACTION;  
  
    BEGIN TRY  
  
        IF @EditMode = @EditMode_Update  
        --Update model  
        BEGIN  
                -- Ensure the user is a model admin.  
                EXEC mdm.udpUserIsModelAdministrator  
                    @User_ID  = @User_ID,  
                    @ObjectType_ID = @ObjectType_Model,  
                    @Object_MUID = @Model_MUID,  
                    @Return_ID = @IsModelAdmin OUTPUT;  
  
                IF COALESCE(@IsModelAdmin, 0) = 0  
                BEGIN  
                    RAISERROR('MDSERR120003|The user does not have permission or the object ID is not valid.', 16, 1);  
                    RETURN;  
                END;  
  
                --Update details in Model table  
                UPDATE mdm.tblModel SET  
                    [Name] = ISNULL(@ModelName, [Name]),  
                    [Description] = @Description,  
                    LogRetentionDays = @LogRetentionDays,  
                    LastChgUserID = @User_ID,  
                    LastChgDTM = @CurrentDTM  
                WHERE  
                    ID = @ExistingModel_ID;  
  
                --Populate output parameters  
                SET @Return_MUID = @ExistingModel_MUID  
                SET @Return_ID = @ExistingModel_ID  
  
        END  
        ELSE  
        --New model  
        BEGIN  
            --Accept an explicit MUID (for clone operations) or generate a new one  
            SET @Return_MUID =  ISNULL(@Model_MUID, NEWID());  
  
            PRINT CONCAT(SYSDATETIME(), N': udpModelSave- Inserting model ', @ModelName);  
                          
            --Insert details into Model table  
            INSERT INTO mdm.tblModel  
            (  
                [Name],  
                [Description],  
                MUID,  
                LogRetentionDays,  
                EnterUserID,  
                LastChgUserID  
            ) VALUES (  
                @ModelName,  
                @Description,  
                @Return_MUID,  
                @LogRetentionDays,  
                @User_ID,  
                @User_ID  
            );  
  
            --Save the identity value  
            SET @Return_ID = SCOPE_IDENTITY();  
              
            IF mdm.udfIsEnterpriseEdition() = 1  
            BEGIN  
                SET @PartitionFunction = CONCAT(N'udpfModel_', @Return_ID);  
                SET @PartitionSchema = CONCAT(N'udpsModel_', @Return_ID);  
  
                SET @SQL = CONCAT(N'CREATE PARTITION FUNCTION ', @PartitionFunction, N' (INT) AS RANGE LEFT FOR VALUES ();');  
                EXEC sp_executesql @SQL;  
  
                SELECT TOP 1 @FileGroupName = name  
                FROM sys.filegroups  
                WHERE is_read_only = 0;  
  
                SET @SQL = CONCAT(N'CREATE PARTITION SCHEME ', @PartitionSchema, N' AS PARTITION ', @PartitionFunction, N' ALL TO (', QUOTENAME(@FileGroupName), N');');  
                EXEC sp_executesql @SQL;  
            END  
  
            --Set up validation log tables and views  
            EXEC mdm.udpCreateModelTables @Model_ID = @Return_ID;  
  
            --Assign admin privileges to the user who created the model.  
            DECLARE  
                 @PermissionType_Admin TINYINT = 5  
                ,@PrincipalType_User TINYINT = 1;  
            EXEC mdm.udpSecurityPrivilegesSave  
                 @SystemUser_ID = @User_ID  
                ,@Principal_ID = @User_ID  
                ,@PrincipalType_ID = @PrincipalType_User  
                ,@Principal_Name = NULL  
                ,@RoleAccess_ID = NULL  
                ,@Object_ID = @ObjectType_Model  
                ,@Privilege_ID = @PermissionType_Admin  
                ,@AccessPermission = 0  
                ,@Model_ID = @Return_ID  
                ,@Securable_ID = @Return_ID  
                ,@Securable_Name = @ModelName  
                ,@RoleAccess_MUID = NULL  
                ;  
  
            --Create the initial version  
            SET @TempDescription = LEFT(N'Version 1 for Model: ' + @ModelName, 250);  
            EXEC mdm.udpVersionSave   
                @User_ID = @User_ID,   
                @Model_ID = @Return_ID,  
                @Version_ID = NULL,  
                @CurrentVersion_ID = NULL,   
                @Status_ID = 1/*Open*/,   
                @Name = N'VERSION_1',   
                @Description = @TempDescription;  
  
            --Recreate the views  
            EXEC mdm.udpCreateViews @Return_ID;  
        END; --if  
  
        --Commit only if we are not nested  
        IF @TranCounter = 0 COMMIT TRANSACTION;  
  
        -- Send the message  
        EXEC mdm.udpPerformanceQueueSave;  
  
        RETURN(0);  
  
    END TRY  
    --Compensate as necessary  
    BEGIN CATCH  
  
        -- Get error info.  
        DECLARE  
            @ErrorMessage NVARCHAR(4000),  
            @ErrorSeverity INT,  
            @ErrorState INT,  
            @ErrorNumber INT,  
            @ErrorLine INT,  
            @ErrorProcedure NVARCHAR(126);  
        EXEC mdm.udpGetErrorInfo  
            @ErrorMessage = @ErrorMessage OUTPUT,  
            @ErrorSeverity = @ErrorSeverity OUTPUT,  
            @ErrorState = @ErrorState OUTPUT,  
            @ErrorNumber = @ErrorNumber OUTPUT,  
            @ErrorLine = @ErrorLine OUTPUT,  
            @ErrorProcedure = @ErrorProcedure OUTPUT  
  
        SET @ErrorMessage = CONCAT(@ErrorMessage, N', @ErrorNumber = ', @ErrorNumber, N', @ErrorProcedure = "', @ErrorProcedure, N'", line ', @ErrorLine);  
  
        IF @TranCounter = 0 ROLLBACK TRANSACTION;  
        ELSE IF XACT_STATE() <> -1 ROLLBACK TRANSACTION TX;  
  
        RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);  
  
        RETURN;  
  
    END CATCH;  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpModelVersionFlagDelete]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    EXEC mdm.udpModelVersionFlagDelete 1, '1565655D-4B03-4F64-B37F-956F75BF396D'  
*/  
CREATE PROCEDURE [mdm].[udpModelVersionFlagDelete]  
(  
    @VersionFlag_ID INT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON;  
  
    --Do a hard delete of the version flag  
    UPDATE mdm.tblModelVersion SET VersionFlag_ID = NULL WHERE VersionFlag_ID = @VersionFlag_ID;  
    DELETE FROM mdm.tblModelVersionFlag	WHERE ID = @VersionFlag_ID;  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpModelVersionFlagSave]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    EXEC mdm.udpModelVersionFlagSave 1  
    EXEC mdm.udpModelVersionFlagSave '1', '7', '1', 'Version 3', 'Chuck test version', '1', @Return = ''  
*/  
CREATE PROCEDURE [mdm].[udpModelVersionFlagSave]  
(  
    @User_ID            INT,  
    @Model_ID           INT, -- Caller should validate  
    @MUID               UNIQUEIDENTIFIER = NULL,  
    @Name               NVARCHAR(50),  
    @Description        NVARCHAR(500) = NULL,  
    @Status_ID          TINYINT = 1,  
    @CommittedOnly_ID   BIT = NULL,  
    @EditMode           TINYINT = 0, --0: Create, 1: Update, 4: Clone, defaults to Create  
    @Return_ID          INT = NULL OUTPUT,  
    @Return_MUID        UNIQUEIDENTIFIER = NULL OUTPUT, --Also an input parameter for clone operations  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE @GuidEmpty          UNIQUEIDENTIFIER = CAST(0x0 AS UNIQUEIDENTIFIER),  
            @EditMode_Create    TINYINT = 0,  
            @EditMode_Update    TINYINT = 1,  
            @EditMode_Clone     TINYINT = 4,  
            @Existing_MUID      UNIQUEIDENTIFIER = NULL,  
            @Existing_ID        INT = NULL,  
            @IsModelAdmin       INT = NULL;  
  
    SELECT   
        @Description = NULLIF(LTRIM(RTRIM(@Description)), N''),   
        @Return_ID = NULL,   
        --@CurrentDTM = GETUTCDATE(),  
        @Model_ID = NULLIF(@Model_ID, 0),  
        @MUID = NULLIF(@MUID, @GuidEmpty),  
        @Name = NULLIF(LTRIM(RTRIM(@Name)), N'')  
        ;  
  
    --Test for invalid EditMode  
    IF @EditMode IS NULL OR @EditMode NOT IN (@EditMode_Create, @EditMode_Update, @EditMode_Clone)  
    BEGIN          
        RAISERROR('MDSERR100010|The Parameters are not valid.', 16, 1);  
        RETURN;  
    END; --if  
  
    --If we are in the Update or Clone mode get the missing pieces of the identifier  
    IF @EditMode IN (@EditMode_Update, @EditMode_Clone)  
    BEGIN  
        --Only use the name if neither MUID nor ID are available. This is important because we don't want  
        --to look up by name if the name is what the user is trying to update.  
        IF @MUID IS NULL  
        BEGIN  
            SELECT TOP 1  
                @Existing_ID =  ID,  
                @Existing_MUID = MUID  
            FROM mdm.tblModelVersionFlag  
            WHERE   
                [Name] = @Name AND  
                Model_ID = @Model_ID;  
        END  
        --Use the ID and MUID to look up the full identifier  
        ELSE  
        BEGIN  
            SELECT  
                @Existing_ID =  ID,   
                @Existing_MUID = MUID  
            FROM mdm.tblModelVersionFlag   
            WHERE  
                MUID = @MUID AND  
                Model_ID = @Model_ID;  
        END  
  
        --If we are in the Clone mode we need to figure out whether we are creating or updating   
        IF @EditMode = @EditMode_Clone  
        BEGIN  
            --If there is no existing model then set the edit mode to Create  
            IF @Existing_MUID IS NULL AND @Existing_ID IS NULL  
            BEGIN  
                SET @EditMode = @EditMode_Create;  
                SET @Return_ID = NULL;  
            END  
            --If there is an existing model then set the edit mode to Update  
            ELSE  
            BEGIN  
                SET @EditMode = @EditMode_Update;  
                SET @Return_ID = @Existing_ID;  
                SET @MUID = @Existing_MUID;  
            END  
        END  
        --If we are in Update mode and could not find a matching existing item we need to raise an error and quit now  
        ELSE IF @EditMode = @EditMode_Update  
        BEGIN  
            IF @Existing_ID IS NULL OR @Existing_MUID IS NULL  
            BEGIN  
                RAISERROR('MDSERR200007|The version flag cannot be saved. The version flag ID is not valid.', 16, 1);  
                RETURN;  
            END  
            ELSE  
            BEGIN  
                SET @Return_ID = @Existing_ID;  
                SET @MUID = @Existing_MUID;  
            END  
        END  
    END  
  
   --Check the name of the version flag for duplicates  
    IF EXISTS   
    (  
        SELECT 1   
        FROM mdm.tblModelVersionFlag   
        WHERE   
            @Name = Name AND   
            (@MUID IS NULL OR MUID <> @MUID) AND  
            Model_ID = @Model_ID  
    )  
    BEGIN  
        RAISERROR('MDSERR110003|The name already exists. Type a different name.', 16, 1);  
        RETURN;  
    END  
  
  
    --Start transaction, being careful to check if we are nested  
    DECLARE @TranCounter INT;   
    SET @TranCounter = @@TRANCOUNT;  
    IF @TranCounter > 0 SAVE TRANSACTION TX;  
    ELSE BEGIN TRANSACTION;  
  
    BEGIN TRY  
  
        IF @EditMode = @EditMode_Create   
        BEGIN  
  
            --Accept an explicit MUID (for clone operations) or generate a new one  
            SET @Return_MUID =  ISNULL(@MUID, NEWID());  
  
            INSERT INTO mdm.tblModelVersionFlag   
            (  
                Model_ID,  
                Status_ID,  
                [Name],  
                [Description],  
                CommittedOnly_ID,  
                MUID,   
                EnterDTM,  
                EnterUserID,  
                LastChgDTM,  
                LastChgUserID  
            )   
            VALUES   
            (  
                @Model_ID,  
                @Status_ID,  
                @Name,  
                @Description,  
                @CommittedOnly_ID,  
                @Return_MUID,  
                GETUTCDATE(),  
                @User_ID,  
                GETUTCDATE(),  
                @User_ID  
            );  
  
            --Save the identity value  
            SET @Return_ID = SCOPE_IDENTITY();  
  
        END	ELSE   
        BEGIN  
  
            IF @CommittedOnly_ID = 1   
            BEGIN  
                DECLARE @VersionStatusCommitted TINYINT = 3;  
                -- Ensure the version flag is not already being used on an uncommitted version  
                IF EXISTS (SELECT ID FROM mdm.tblModelVersion WHERE VersionFlag_ID = @Return_ID AND Status_ID <> @VersionStatusCommitted)   
                BEGIN  
                    RAISERROR('MDSERR200084|The version flag cannot be changed to committed only. It is referenced by a non-committed version.', 16, 1);  
                    RETURN;          
                END;  
            END;   
            SET @Return_MUID = @Existing_MUID;  
  
            UPDATE mdm.tblModelVersionFlag   
            SET  
                Status_ID = ISNULL(@Status_ID, Status_ID),  
                [Name] = ISNULL(@Name, [Name]),  
                [Description] = ISNULL(@Description, [Description]),  
                CommittedOnly_ID = ISNULL(@CommittedOnly_ID,CommittedOnly_ID),  
                LastChgDTM = GETUTCDATE(),  
                LastChgUserID = @User_ID  
            WHERE  
                ID = @Return_ID;  
  
        END; --if  
  
        --Commit only if we are not nested  
        IF @TranCounter = 0   
        BEGIN  
            COMMIT TRANSACTION;  
        END -- IF  
  
    END TRY  
    --Compensate as necessary  
    BEGIN CATCH  
  
        -- Get error info.  
        DECLARE  
            @ErrorMessage NVARCHAR(4000),  
            @ErrorSeverity INT,  
            @ErrorState INT,  
            @ErrorNumber INT,  
            @ErrorLine INT,  
            @ErrorProcedure NVARCHAR(126);  
        EXEC mdm.udpGetErrorInfo  
            @ErrorMessage = @ErrorMessage OUTPUT,  
            @ErrorSeverity = @ErrorSeverity OUTPUT,  
            @ErrorState = @ErrorState OUTPUT,  
            @ErrorNumber = @ErrorNumber OUTPUT,  
            @ErrorLine = @ErrorLine OUTPUT,  
            @ErrorProcedure = @ErrorProcedure OUTPUT  
  
        SET @ErrorMessage = CONCAT(@ErrorMessage, N', @ErrorNumber = ', @ErrorNumber, N', @ErrorProcedure = "', @ErrorProcedure, N'", line ', @ErrorLine);  
  
        IF @TranCounter = 0 ROLLBACK TRANSACTION;    
        ELSE IF XACT_STATE() <> -1 ROLLBACK TRANSACTION TX;    
  
        RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);  
  
        RETURN;  
  
    END CATCH;  
  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpNotificationCreateChangesetStatusChange]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
This SPROC is only called by mdm.udpEntityMemberChangesetSave, so no need to valid the parameter value again  
*/  
CREATE PROCEDURE [mdm].[udpNotificationCreateChangesetStatusChange]  
(  
    @User_ID            INT,  
    @Model_Name         NVARCHAR(50) = NULL,  
    @Model_MUID         UNIQUEIDENTIFIER = NULL,  
    @Model_ID           INT,  
    @Entity_Name        NVARCHAR(50) = NULL,  
    @Entity_MUID        UNIQUEIDENTIFIER= NULL,  
    @Entity_ID          INT,  
    @Version_Name       NVARCHAR(50) = NULL,  
    @Version_MUID       UNIQUEIDENTIFIER = NULL,  
    @Version_ID         INT,  
    @Changeset_Name     NVARCHAR(250) = NULL,  
    @Changeset_MUID     UNIQUEIDENTIFIER = NULL,  
    @Onwer_ID           INT,  
    @PriorStatus_ID     INT,  
    @NewStatus_ID       INT,  
    @CorrelationID      UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE  
        @NotificationType           INT = 3,  
        @LocalizedPriorStatus       NVARCHAR(MAX) = N'',  
        @LocalizedNewStatus         NVARCHAR(MAX) = N'',  
  
        @NotificationQueue_ID       INT,  
  
        @CurrentLanguageCode        INT = 1033, -- Default language code is English (US).  
        @StringLanguageCode         NVARCHAR(MAX) = N'',  
  
        @Permission_Admin           TINYINT = 5,  
  
        @ChangesetStatus_Open       TINYINT = 1,  
        @ChangesetStatus_Pending    TINYINT = 2,  
        @ChangesetStatus_Approved   TINYINT = 3,  
        @ChangesetStatus_Rejected   TINYINT = 4,  
        @ChangesetStatus_Committed  TINYINT = 5;  
  
    -- Use default language code to get the notification language code.  
    SET @StringLanguageCode = mdm.udfLocalizedStringGet(N'NotificationLCID', @CurrentLanguageCode, 1033);  
  
    IF @StringLanguageCode <> N''  
    BEGIN  
        SET @CurrentLanguageCode = CONVERT(INT, @StringLanguageCode)  
    END; -- if  
  
    SET @LocalizedPriorStatus =  
        CASE @PriorStatus_ID  
            WHEN @ChangesetStatus_Open THEN N'Open'  
            WHEN @ChangesetStatus_Pending THEN N'Pending'  
            WHEN @ChangesetStatus_Approved THEN N'Approved'  
            WHEN @ChangesetStatus_Rejected THEN N'Rejected'  
            WHEN @ChangesetStatus_Committed THEN N'Committed'  
        END;  
  
    SET @LocalizedNewStatus =  
        CASE @NewStatus_ID  
            WHEN @ChangesetStatus_Open THEN N'Open'  
            WHEN @ChangesetStatus_Pending THEN N'Pending'  
            WHEN @ChangesetStatus_Approved THEN N'Approved'  
            WHEN @ChangesetStatus_Rejected THEN N'Rejected'  
            WHEN @ChangesetStatus_Committed THEN N'Committed'  
        END;  
  
    -- Get the localized message texts based on the notification language code in tblLocalizedStrings.  
    SET @LocalizedPriorStatus = mdm.udfLocalizedStringGet(CONCAT(N'NotificationChangesetStatus', @LocalizedPriorStatus), @CurrentLanguageCode, @LocalizedPriorStatus);  
    SET @LocalizedNewStatus = mdm.udfLocalizedStringGet(CONCAT(N'NotificationChangesetStatus', @LocalizedNewStatus), @CurrentLanguageCode, @LocalizedNewStatus);  
  
    BEGIN TRAN  
        INSERT INTO mdm.tblNotificationQueue (  
             NotificationType_ID  
            ,Version_ID  
            ,Model_ID  
            ,[Entity_ID]  
            ,[Message]  
            ,EnterDTM  
            ,EnterUserID  
        )  
        SELECT  
            @NotificationType  
            ,@Version_ID  
            ,@Model_ID  
            ,@Entity_ID  
            ,CONCAT(N'  
                <notification>  
                  <model>', (SELECT @Model_Name FOR XML PATH('')), N'</model>  
                  <model_muid>', @Model_MUID, N'</model_muid>  
                  <version>', (SELECT @Version_Name FOR XML PATH('')), N'</version>  
                  <version_muid>', @Version_MUID, N'</version_muid>  
                  <entity>', (SELECT @Entity_Name FOR XML PATH('')), N'</entity>  
                  <entity_muid>', @Entity_MUID, N'</entity_muid>  
                  <changeset>', (SELECT @Changeset_Name FOR XML PATH('')), N'</changeset>  
                  <changeset_muid>', @Changeset_MUID, N'</changeset_muid>  
                  <prior_status>', (SELECT @LocalizedPriorStatus FOR XML PATH('')), N'</prior_status>  
                  <new_status>', (SELECT @LocalizedNewStatus FOR XML PATH('')), N'</new_status>  
                </notification>')  
            ,GETUTCDATE()  
            ,@User_ID  
  
        IF (@@ERROR <> 0)  
        BEGIN  
            RAISERROR('MDSERR100029|Cannot insert into notification queue because of general insert error.', 16, 1);  
            ROLLBACK TRAN;  
            RETURN;  
        END; --if  
  
        SET @NotificationQueue_ID = SCOPE_IDENTITY();  
  
        -- Insert into mdm.tblNotificationUsers  
        INSERT INTO mdm.tblNotificationUsers (  
            Notification_ID,  
            [User_ID]  
        )  
        SELECT @NotificationQueue_ID, [User_ID]  
        FROM mdm.viw_SYSTEM_SECURITY_USER_ENTITY  
        WHERE ID = @Entity_ID  
            AND (Privilege_ID = @Permission_Admin OR [User_ID] = @Onwer_ID);  
  
        IF (@@ERROR <> 0) BEGIN  
            RAISERROR('MDSERR100030|Cannot insert into notification users because of general insert error.', 16, 1);  
            ROLLBACK TRAN;  
            RETURN;  
        END; --if  
  
    COMMIT TRAN;  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpNotificationCreateVersionStatusChange]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    select * from mdm.viw_SYSTEM_SCHEMA_VERSION where ID = 20;  
  
    EXEC mdm.udpNotificationCreateVersionStatusChange 1, 20, 1;  
  
    SELECT * FROM mdm.tblNotificationQueue;  
*/  
CREATE PROCEDURE [mdm].[udpNotificationCreateVersionStatusChange]  
(  
     @User_ID INT  
    ,@Version_ID INT  
    ,@PriorStatus_ID INT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE   
        @NotificationType INT = 2,  
        @LocalizedPriorStatus NVARCHAR(MAX) = N'',  
        @LocalizedNewStatus NVARCHAR(MAX) = N'',  
        @CurrentLanguageCode INT = 1033, -- Default language code is English (US).  
        @StringLanguageCode NVARCHAR(MAX) = N'';  
  
    IF (@NotificationType IS NULL) BEGIN  
        RAISERROR('MDSERR100028|Notification Type ''Validation Issue'' not found.', 16, 1);  
        RETURN;    
    END; --if  
  
    -- Use default language code to get the notification language code.  
    SELECT @StringLanguageCode = mdm.udfLocalizedStringGet(N'NotificationLCID', @CurrentLanguageCode, 1033);  
      
    IF @StringLanguageCode <> N'' BEGIN  
        SELECT @CurrentLanguageCode = CONVERT(INT, @StringLanguageCode)  
    END; -- if  
  
    SELECT @LocalizedPriorStatus = L.[ListOption] FROM mdm.tblList L WHERE L.ListCode = N'lstVersionStatus' AND L.OptionID = @PriorStatus_ID;  
    SELECT @LocalizedNewStatus = v.[Status] FROM mdm.viw_SYSTEM_SCHEMA_VERSION v WHERE v.ID = @Version_ID;  
  
    -- Get the localized message texts based on the notification language code in tblLocalizedStrings.  
    SELECT @LocalizedPriorStatus = mdm.udfLocalizedStringGet(CONCAT(N'NotificationVersionStatus', @LocalizedPriorStatus), @CurrentLanguageCode, @LocalizedPriorStatus);  
    SELECT @LocalizedNewStatus = mdm.udfLocalizedStringGet(CONCAT(N'NotificationVersionStatus', @LocalizedNewStatus), @CurrentLanguageCode, @LocalizedNewStatus);  
              
    SELECT @LocalizedPriorStatus = IsNULL(@LocalizedPriorStatus, N'');  
    SELECT @LocalizedNewStatus = IsNULL(@LocalizedNewStatus, N'');  
      
    BEGIN TRAN  
        DECLARE @newQueueRecord AS TABLE (ID INT, Model_ID INT);  
          
        INSERT INTO mdm.tblNotificationQueue (  
             NotificationType_ID  
            ,Version_ID  
            ,Model_ID  
            ,[Message]  
            ,EnterDTM  
            ,EnterUserID  
        )  
        OUTPUT inserted.ID, inserted.Model_ID INTO @newQueueRecord  
        SELECT    
            @NotificationType  
            ,v.ID  
            ,v.Model_ID  
            ,CONCAT(N'  
                <notification>  
                  <model>', (SELECT v.[Model_Name] FOR XML PATH('')), N'</model>  
                  <model_muid>', v.[MUID], N'</model_muid>  
                  <version>', (SELECT v.[Name] FOR XML PATH('')), N'</version>  
                  <version_description>', (SELECT v.[Description] FOR XML PATH('')), N'</version_description>  
                  <version_muid>', v.[MUID], N'</version_muid>  
                  <prior_status>', (SELECT @LocalizedPriorStatus FOR XML PATH('')), N'</prior_status>  
                  <new_status>', (SELECT @LocalizedNewStatus FOR XML PATH('')), N'</new_status>  
                  <issued>', (SELECT CONVERT(NVARCHAR,GETDATE()) FOR XML PATH('')), N'</issued>  
                </notification>')  
            ,GETUTCDATE()  
            ,@User_ID  
        FROM mdm.viw_SYSTEM_SCHEMA_VERSION v   
        WHERE v.ID = @Version_ID  
  
        IF (@@ERROR <> 0) BEGIN  
            RAISERROR('MDSERR100029|Cannot insert into notification queue because of general insert error.', 16, 1);  
            ROLLBACK TRAN;  
            RETURN;    
        END; --if  
  
        DECLARE @ModelUserList TABLE (  
             RowNumber INT IDENTITY(1,1) NOT NULL  
            ,ID INT  
            ,UserName NVARCHAR(MAX) COLLATE database_default  
            ,Name NVARCHAR(MAX) COLLATE database_default  
            ,Description NVARCHAR(MAX) COLLATE database_default  
            ,EmailAddress NVARCHAR(MAX) COLLATE database_default  
            ,Privilege_ID INT  
            ,AccessPermission TINYINT  
            );  
  
        DECLARE   
             @newQueueID INT  
            ,@Model_ID INT  
            ,@ModelObject_ID INT = 1  
            ,@DenyPriviledge INT = 1;  
  
        SELECT  
             @newQueueID = q.ID  
            ,@Model_ID = q.Model_ID  
        FROM @newQueueRecord q;  
                              
        INSERT INTO @ModelUserList EXECUTE mdm.udpUserListGetByItem @ModelObject_ID, @Model_ID   
          
        -- Insert into mdm.tblNotificationUsers  
        INSERT INTO mdm.tblNotificationUsers (  
            Notification_ID,  
            [User_ID]  
        )  
        SELECT @newQueueID, u.[ID]  
        FROM @ModelUserList u  
        WHERE u.Privilege_ID <> @DenyPriviledge;  
          
        IF (@@ERROR <> 0) BEGIN  
            RAISERROR('MDSERR100030|Cannot insert into notification users because of general insert error.', 16, 1);  
            ROLLBACK TRAN;  
            RETURN;    
        END; --if  
  
    COMMIT TRAN;  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpNotificationQueueActivate]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    --Run this the first time to kick off the timer  
    DECLARE @handle UNIQUEIDENTIFIER;  
    BEGIN DIALOG CONVERSATION @handle  
        FROM SERVICE [microsoft/mdm/service/notification]  
        TO SERVICE N'microsoft/mdm/service/system'  
        WITH ENCRYPTION = OFF;  
    BEGIN CONVERSATION TIMER (@handle) TIMEOUT = 1;  
  
    ALTER QUEUE mdm.[microsoft/mdm/queue/notification]  
    WITH ACTIVATION  
    (  
        STATUS = ON,  
        PROCEDURE_NAME = [mdm].[udpNotificationQueueActivate],  
        MAX_QUEUE_READERS = 1,  
        --In the original queue declaration we used the standard mds_ssb_user context  
        --since the appropriate login/user we needed did not exist yet.  
        --So here we execute using the context we actually require.  
        EXECUTE AS N'mds_email_user'  
    );  
*/  
CREATE PROCEDURE [mdm].[udpNotificationQueueActivate]  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE  
         @message_type_name         SYSNAME  
        ,@handle                    UNIQUEIDENTIFIER = NULL  
        ,@interval                  INT  
        ,@need_new                  BIT = NULL  
        ,@status                    NVARCHAR(1000)  
        ,@dialog                    UNIQUEIDENTIFIER;  
  
    --Load interval setting from config, and check the defaults and ranges  
    SET @interval = COALESCE(CONVERT(INT, mdm.udfSystemSettingGet(N'NotificationInterval')), 120);  
    SET @interval =  
    CASE  
        WHEN @interval < 10 THEN 10 --Prevent negative and 'real-time' settings  
        WHEN @interval > 86400  THEN 86400 --Check at least once per day (60 x 60 x 24)  
        ELSE @interval  
    END  
  
    BEGIN TRANSACTION  
  
    WAITFOR (  
        RECEIVE TOP(1)  
            @handle = [conversation_handle],  
            @message_type_name = message_type_name  
        FROM mdm.[microsoft/mdm/queue/notification]  
    ), TIMEOUT 5000; --Always wait a constant time for any new messages  
  
    --Got a TIMER message  
    IF (@message_type_name = CAST(N'http://schemas.microsoft.com/SQL/ServiceBroker/DialogTimer' AS SYSNAME))  
    BEGIN  
  
        --Start a new TIMER and COMMIT the transaction before we do the real work, to avoid poisoning  
        BEGIN CONVERSATION TIMER (@handle) TIMEOUT = @interval;  
        COMMIT TRANSACTION;  
  
        EXEC mdm.udpNotificationQueueProcess  
  
    --Got an END DIALOG message  
    END  
    ELSE IF (@message_type_name = CAST(N'http://schemas.microsoft.com/SQL/ServiceBroker/EndDialog' AS NVARCHAR(128)))  
    BEGIN  
        PRINT N'Error in udpNotificationQueueActivate end dialog';  
        SET @need_new = 1;  
  
    --Got ERROR message  
    END  
    ELSE IF (@message_type_name = CAST(N'http://schemas.microsoft.com/SQL/ServiceBroker/Error' AS NVARCHAR(128)))  
    BEGIN  
        PRINT N'Error in udpNotificationQueueActivate error';  
        SET @need_new = 1;  
  
    --Timeout or unexpected message  
    END  
    ELSE  
    BEGIN  
  
        COMMIT TRANSACTION;  
  
    END; --if  
  
    IF (@need_new = 1)  
    BEGIN  
  
        END CONVERSATION @handle;  
  
        --DECLARE @handle UNIQUEIDENTIFIER; DECLARE @interval INT; SET @interval = 10;  
        BEGIN DIALOG CONVERSATION @handle  
            FROM SERVICE [microsoft/mdm/service/notification]  
            TO SERVICE N'microsoft/mdm/service/system'  
            WITH ENCRYPTION = OFF;  
        BEGIN CONVERSATION TIMER (@handle) TIMEOUT = @interval;  
  
        COMMIT TRANSACTION;  
  
    END; --if  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpNotificationQueueProcess]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
*/  
CREATE PROCEDURE [mdm].[udpNotificationQueueProcess]  
AS BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE  
         @databaseMailProfileName       SYSNAME  
        ,@LocalizedEmailSubject         NVARCHAR(255) = N'MDS Notification'  
        ,@LocalizedTruncatedMessage     NVARCHAR(MAX) = N'This list of issues is truncated at {0} lines when sent by email.  {1} issues have been truncated.'  
        ,@CurrentLanguageCode           INT = 1033 -- Default language code is English (US).  
        ,@StringLanguageCode            NVARCHAR(MAX) = N''  
  
    --Load Database Profile name to use from config.  
    SET @databaseMailProfileName = CONVERT(SYSNAME, mdm.udfSystemSettingGet(N'DatabaseMailProfile'));  
    SET @databaseMailProfileName = NULLIF(LTRIM(RTRIM(@databaseMailProfileName)), N'')  
    IF @databaseMailProfileName IS NULL  
    BEGIN  
        RETURN;  
    END  
  
    -- Use default language code to get the notification language code.  
    SET @StringLanguageCode = mdm.udfLocalizedStringGet(N'NotificationLCID', @CurrentLanguageCode, 1033);  
  
    IF @StringLanguageCode <> N''  
    BEGIN  
        SET @CurrentLanguageCode = CONVERT(INT, @StringLanguageCode)  
    END; -- if  
  
    -- Get the localized message texts based on the notification language code in tblLocalizedStrings.  
    SET @LocalizedEmailSubject = CONVERT(NVARCHAR(255), mdm.udfLocalizedStringGet(N'NotificationSubject', @CurrentLanguageCode, @LocalizedEmailSubject));  
    SET @LocalizedTruncatedMessage = mdm.udfLocalizedStringGet(N'NotificationTruncatedMessage', @CurrentLanguageCode, @LocalizedTruncatedMessage);  
      
    --Get the notifications  
    DECLARE @Notifications TABLE (  
            RowNumber INT IDENTITY(1,1) NOT NULL  
        ,ID INT  
        ,NotificationType_ID INT  
        ,[Message] NVARCHAR(MAX) COLLATE database_default  
        ,[User_ID] INT  
        ,EmailAddress NVARCHAR(MAX) COLLATE database_default  
        ,EmailFormat INT  
        ,DefaultEmailFormat INT  
        );  
  
    DECLARE @NotificationTypes TABLE(  
            RowNumber INT IDENTITY(1,1) NOT NULL  
        ,NotificationType_ID INT  
        ,EmailType INT  
        ,EmailAddress VARCHAR(MAX) COLLATE database_default -- can't use NVARCHAR  
        ,User_ID INT  
    );  
  
    INSERT INTO @Notifications EXECUTE mdm.udpNotificationsGet  
  
    --Get distinct list of notification types and users from the list of notifications  
    INSERT INTO @NotificationTypes  
    SELECT DISTINCT  
        NotificationType_ID  
        ,COALESCE(EmailFormat, DefaultEmailFormat)  
        ,EmailAddress  
        ,User_ID  
    FROM @Notifications  
  
    --Load Notifications per email limit from config.  
    DECLARE @NotificationsPerEmail INT = CONVERT(INT, mdm.udfSystemSettingGet(N'NotificationsPerEmail'));  
    SET @NotificationsPerEmail =  
        CASE  
            WHEN COALESCE(@NotificationsPerEmail, 0) < 1 THEN 100 --Protect against NULL, zero and negative values  
            ELSE @NotificationsPerEmail  
        END  
  
    DECLARE @Counter INT = 1;  
    DECLARE @MaxCounter INT = (SELECT MAX(RowNumber) FROM @NotificationTypes);  
  
    -- Loop through the distinct list of notification types and users to email a batched list of notifications  
    WHILE @Counter <= @MaxCounter  
    BEGIN  
        DECLARE @EmailAddress   VARCHAR(MAX), -- can't be NVARCHAR  
                @StyleSheetName NVARCHAR(100),  
  
                @EmailType      INT,  
                @HtmlEmailType  INT = 1,  
                @TextEmailType  INT = 2,  
  
                @NotificationTypeID                     INT,  
                @ValidationIssuesNotificationType       INT = 1,  
                @VersionStatusChangeNotificationType    INT = 2,  
                @ChangesetStatusChangeNotificationType  INT = 3,  
  
                @EmailSubject   NVARCHAR(255),  
                @BodyFormat     VARCHAR(20), -- can't be NVARCHAR  
                @StyleSheet     XML,  
                @MessageData    XML,  
                @NotificationID INT,  
                @EmailBody      NVARCHAR(MAX),  
                @MailId         INT,  
  
                @NotificationElements           NVARCHAR(MAX) = N'',  
                @HeaderElement                  NVARCHAR(MAX) = N'',  
                @TruncationMessageElement       NVARCHAR(MAX) = N'',  
                @LocalizedNotificationTypeName  NVARCHAR(MAX) = N'',  
  
                @UserID                         INT,  
                @NotificationCount              INT,  
                @NotificationTruncationCount    INT,  
                @SendDBMailRet                  INT;  
  
        --Get the vars  
        SELECT  
             @NotificationTypeID = NotificationType_ID  
            ,@EmailAddress = EmailAddress  
            ,@EmailType = EmailType  
            ,@UserID = User_ID  
        FROM @NotificationTypes  
        WHERE RowNumber = @Counter;  
  
        SET @BodyFormat = CASE @EmailType WHEN @HtmlEmailType THEN N'HTML' ELSE N'TEXT' END;  
  
        SET @HeaderElement =  
            CASE @NotificationTypeID  
                WHEN @ValidationIssuesNotificationType THEN mdm.udfNotificationGetValidationIssueHeader()  
                WHEN @VersionStatusChangeNotificationType THEN mdm.udfNotificationGetVersionStatusChangeHeader()  
                WHEN @ChangesetStatusChangeNotificationType THEN mdm.udfNotificationGetChangesetStatusChangeHeader()  
            END;  
  
        SET @LocalizedNotificationTypeName =  
            CASE @NotificationTypeID  
                WHEN @ValidationIssuesNotificationType THEN mdm.udfLocalizedStringGet(N'NotificationValidationIssue', @CurrentLanguageCode, @LocalizedNotificationTypeName)  
                WHEN @VersionStatusChangeNotificationType THEN mdm.udfLocalizedStringGet(N'NotificationVersionStatusChange', @CurrentLanguageCode, @LocalizedNotificationTypeName)  
                WHEN @ChangesetStatusChangeNotificationType THEN mdm.udfLocalizedStringGet(N'NotificationChangesetStatusChange', @CurrentLanguageCode, @LocalizedNotificationTypeName)  
            END;  
  
        SET @StyleSheetName =  
            CASE @NotificationTypeID  
                WHEN @ValidationIssuesNotificationType THEN  
                    CASE @EmailType WHEN @HtmlEmailType THEN N'ValidationIssueHTML' ELSE N'ValidationIssueText' END  
                WHEN @VersionStatusChangeNotificationType THEN  
                    CASE @EmailType WHEN @HtmlEmailType THEN N'VersionStatusChangeHTML' ELSE N'VersionStatusChangeText' END  
                WHEN @ChangesetStatusChangeNotificationType THEN  
                    CASE @EmailType WHEN @HtmlEmailType THEN N'ChangesetStatusChangeHTML' ELSE N'ChangesetStatusChangeText' END  
            END;  
  
        --Get the number of notifications  
        SELECT @NotificationCount = COUNT(*)  
        FROM @Notifications  
        WHERE NotificationType_ID = @NotificationTypeID  
            AND User_ID = @UserID  
  
        -- Check the number of notifications against the email notification limit config.  
        IF @NotificationCount > @NotificationsPerEmail  
        BEGIN  
            SET @NotificationTruncationCount = @NotificationCount - @NotificationsPerEmail  
            -- Replace placeholders in the message.  
            SET @LocalizedTruncatedMessage = REPLACE(@LocalizedTruncatedMessage, N'{0}' , CONVERT(NVARCHAR(20), @NotificationsPerEmail));  
            SET @LocalizedTruncatedMessage = REPLACE(@LocalizedTruncatedMessage, N'{1}' , CONVERT(NVARCHAR(20), @NotificationTruncationCount));  
            -- Add the XML element tags.  
              
            SET @TruncationMessageElement = CONCAT(N'<truncated_message>', (SELECT @LocalizedTruncatedMessage FOR XML PATH('')), N'</truncated_message>')  
        END  
  
        -- Construct the list of notification XML elements for the distinct notification type and user.  
        SELECT TOP(@NotificationsPerEmail)  
            @NotificationElements += [Message]  
        FROM @Notifications  
        WHERE NotificationType_ID = @NotificationTypeID  
            AND User_ID = @UserID  
  
        --Construct XML message data  
        SET @MessageData = CONVERT(XML,N'<root>' + @HeaderElement + N'<notifications>' + @NotificationElements + N'</notifications>' + @TruncationMessageElement + N'</root>');  
  
        --Get XSLT stylesheet  
        SET @StyleSheet = CONVERT(XML, mdm.udfSystemSettingGet(@StyleSheetName));  
  
        --Apply stylesheet to create email body  
        SET @EmailBody = mdq.XmlTransform(@MessageData, @StyleSheet);  
  
        SET @EmailSubject = CONCAT(@LocalizedEmailSubject, N' : ', @LocalizedNotificationTypeName);  
  
        --Send Email  
        EXECUTE @SendDBMailRet = [msdb].[dbo].[sp_send_dbmail]  
            @profile_name = @databaseMailProfileName  
            ,@recipients  = @EmailAddress  
            ,@body        = @EmailBody  
            ,@subject     = @EmailSubject  
            ,@body_format = @BodyFormat  
            ,@mailitem_id = @MailId OUTPUT  
  
        IF @SendDBMailRet = 0  
        BEGIN  
            --Update the SentDTM  
            UPDATE mdm.tblNotificationQueue  
            SET SentDTM = GETUTCDATE()  
            WHERE ID IN  
            (  
                SELECT ID  
                FROM @Notifications  
                WHERE NotificationType_ID = @NotificationTypeID  
                    AND User_ID = @UserID  
            );  
        END  
  
        SET @Counter += 1;  
        --PRINT N'Processed notification ID: ' + CONVERT(NVARCHAR(MAX),@NotificationID);  
    END; --while  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpNotificationsGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
EXEC mdm.udpNotificationsGet  
  
*/  
CREATE PROCEDURE [mdm].[udpNotificationsGet]  
(  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON  
  
    DECLARE @notifications TABLE (  
         RowNumber INT IDENTITY(1,1) NOT NULL  
        ,ID INT NOT NULL  
        ,NotificationTypeID TINYINT NOT NULL  
        ,UserID INT  
        ,VersionID INT  
        ,EntityID INT  
        ,MemberID INT  
        ,MemberTypeID TINYINT  
        ,BusinessRule_ID INT  
        ,CanUserSeeNotification BIT NULL  
        );  
  
    --Use a temporary table to keep track of all ID's affected  
    INSERT INTO @notifications (ID, NotificationTypeID, UserID, VersionID, EntityID, MemberID, MemberTypeID, BusinessRule_ID, CanUserSeeNotification)  
    SELECT  
        DISTINCT nq.[ID], CONVERT(TINYINT, nq.NotificationType_ID), nu.[User_ID], nq.Version_ID, nq.Entity_ID, nq.Member_ID, nq.MemberType_ID, nq.BRBusinessRule_ID, 1  
    FROM mdm.tblNotificationQueue nq  
        INNER JOIN mdm.tblNotificationUsers nu ON nq.ID = nu.Notification_ID  
        INNER JOIN mdm.tblUser us ON nu.[User_ID] = us.[ID] AND ISNULL(us.EmailAddress,N'') <> N''  
    WHERE nq.SentDTM is Null  
  
    DECLARE  
        @id                 INT,  
        @notificationtypeId INT,  
        @userId             INT,  
        @versionId          INT,  
        @entityId           INT,  
        @memberId           INT,  
        @memberTypeId       TINYINT,  
        @SerachCriteria     mdm.MemberGetCriteria,  
        @memberCount        INT;  
  
    DECLARE  
        @MemberReturnOptionData                     TINYINT = 1,  
        @MemberReturnOptionCount                    TINYINT = 2,  
        @MemberReturnOptionMembershipInformation    TINYINT = 4  
  
  
    -- Get a list of all users referenced in the notifications table, and for each user mark as hidden those  
    -- notifications that pertain to business rules that reference attributes that the user cannot see.  
    DECLARE @users TABLE (  
         RowNumber INT IDENTITY(1,1) NOT NULL  
        ,ID INT NOT NULL  
        );  
    INSERT INTO @users (ID) SELECT DISTINCT UserID FROM @notifications;  
    DECLARE @Counter INT    = 1,  
            @MaxCounter INT = (SELECT MAX(RowNumber) FROM @users);  
    WHILE @Counter <= @MaxCounter  
    BEGIN  
        SELECT TOP 1 @userId = ID FROM @users WHERE RowNumber = @Counter;  
        UPDATE @notifications  
        SET CanUserSeeNotification = 0  
        WHERE  
            UserID = @userId AND  
            (BusinessRule_ID IS NOT NULL AND  
            BusinessRule_ID NOT IN (SELECT BusinessRule_ID FROM mdm.udfSecurityUserBusinessRuleList(@userId, NULL, NULL)));  
        SET @Counter += 1;  
    END  
  
    -- Mark as hidden notifications where the user cannot see the Member.  
    SELECT @Counter = 1,  
           @MaxCounter = (SELECT MAX(RowNumber) FROM @notifications);  
    WHILE @Counter <= @MaxCounter  
    BEGIN  
        SELECT TOP 1  
             @id                 = ID  
            ,@notificationtypeId = NotificationTypeID  
            ,@userId             = UserID  
            ,@versionId          = VersionID  
            ,@entityId           = EntityID  
            ,@memberId           = MemberID  
            ,@memberTypeId       = MemberTypeID  
            ,@Counter            = RowNumber  
        FROM @notifications  
        WHERE  
            CanUserSeeNotification = 1 AND -- skip notifications that are already marked as hidden to the user.  
            RowNumber >= @Counter  
        ORDER BY RowNumber;  
  
        IF (@Counter IS NULL)  
        BEGIN  
            BREAK;  
        END;  
  
        IF (@entityId IS NOT NULL AND @memberId IS NOT NULL AND @memberTypeId IS NOT NULL)  
        BEGIN  
            -- Call udpMembersGet to determine if the user can see the member.  
            DELETE @SerachCriteria;  
            INSERT INTO @SerachCriteria values(1,N'',N'ID',N'=',N'', 0, @memberId)  
            SET @memberCount = 0;  
            DECLARE @Model_MUID UNIQUEIDENTIFIER,  
                    @Entity_MUID UNIQUEIDENTIFIER,  
                    @Version_MUID UNIQUEIDENTIFIER;  
  
            SELECT @Model_MUID = m.MUID, @Entity_MUID = e.MUID  
            FROM mdm.tblModel m  
            INNER JOIN mdm.tblEntity e ON m.ID = e.Model_ID  
            WHERE e.ID = @entityId;  
  
            SELECT @Version_MUID = MUID  
            FROM mdm.tblModelVersion  
            WHERE ID = @versionId;  
  
            EXEC mdm.udpEntityMembersGet  
                    @User_ID            = @userId,  
                    @Version_MUID       = @Version_MUID,  
                    @Entity_MUID        = @Entity_MUID,  
                    @Model_MUID         = @Model_MUID,  
                    @MemberType_ID      = @memberTypeId,  
                    @PageNumber         = 1,  
                    @PageSize           = 0,  
                    @SearchTable        = @SerachCriteria,  
                    @MemberReturnOption = @MemberReturnOptionCount, -- Getting the count is sufficient to determine if the user can see the member.  
                    @MemberCount        = @memberCount OUTPUT;  
            IF (COALESCE(@memberCount, 0) = 0)  
            BEGIN  
                UPDATE @notifications SET CanUserSeeNotification = 0 WHERE RowNumber = @Counter;  
            END  
        END  
        SET @Counter += 1;  
    END  
  
    -- Get all Notifications due to be sent out, sorted by User then Type  
    SELECT  
        DISTINCT  
        nq.[ID],  
        nq.NotificationType_ID,  
        nq.[Message],  
        nu.[User_ID],  
        us.EmailAddress,  
        up.PreferenceValue as EmailFormat,  
        ts.SettingValue as DefaultEmailFormat  
    FROM  
        @notifications tt  
        INNER JOIN mdm.tblNotificationQueue nq ON tt.[ID] = nq.[ID]  
        INNER JOIN mdm.tblNotificationUsers nu ON nq.ID = nu.Notification_ID  
        INNER JOIN mdm.tblUser us ON nu.[User_ID] = us.[ID] AND tt.UserID = us.[ID]  
        LEFT JOIN  mdm.tblUserPreference up on nu.[User_ID] = up.[User_ID] and up.PreferenceName = N'lstEmail'  
        LEFT JOIN  mdm.tblSystemSetting ts ON ts.SettingName = N'EmailFormat'  
    WHERE  
        tt.CanUserSeeNotification = 1  
    ORDER BY  
        nq.NotificationType_ID,  
        nu.[User_ID]  
  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpObjectDeleteCheckByMUID]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    Raises an error if the metadata object with the given MUID and of the given type cannot  
    be deleted. Looks up the object's ID.  
*/  
CREATE PROCEDURE [mdm].[udpObjectDeleteCheckByMUID]  
(  
    @Object_MUID    UNIQUEIDENTIFIER,  
    @ObjectType_ID  TINYINT,  
    @Object_ID      INT = NULL OUTPUT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON  
  
    SET @Object_ID = NULL;  
  
    DECLARE  
         @ErrorMessage  NVARCHAR(MAX)  
        ,@Ret           INT  
  
        ,@MemberType_Leaf           TINYINT = 1  
        ,@MemberType_Consolidated   TINYINT = 2  
              
        ,@ObjectType_Model                  TINYINT = 1  
        ,@ObjectType_DerivedHierarchy       TINYINT = 2  
        ,@ObjectType_DerivedHierarchyLevel  TINYINT = 3  
        ,@ObjectType_Version                TINYINT = 4  
        ,@ObjectType_Entity                 TINYINT = 5  
        ,@ObjectType_Hierarchy              TINYINT = 6  
        ,@ObjectType_Attribute              TINYINT = 7  
        ,@ObjectType_AttributeGroup         TINYINT = 8  
        ,@ObjectType_VersionFlag            TINYINT = 10  
        ,@ObjectType_Index                  TINYINT = 23  
;  
  
    --Default the Value  
    SET @ErrorMessage = NULL;  
  
    IF @ObjectType_ID = @ObjectType_Model  
    BEGIN  
        SELECT @Object_ID = ID FROM mdm.tblModel WHERE MUID = @Object_MUID;  
    END   
      
    ELSE IF @ObjectType_ID IN (@ObjectType_DerivedHierarchy, @ObjectType_DerivedHierarchyLevel)  
    BEGIN  
        DECLARE @DerivedHierarchy_ID INT;  
        IF @ObjectType_ID = @ObjectType_DerivedHierarchy  
        BEGIN  
            SELECT @Object_ID = ID FROM mdm.tblDerivedHierarchy WHERE MUID = @Object_MUID;  
            SET @DerivedHierarchy_ID = @Object_ID  
        END ELSE  
        BEGIN  
            SELECT  
                 @Object_ID = ID  
                ,@DerivedHierarchy_ID = DerivedHierarchy_ID  
            FROM mdm.tblDerivedHierarchyDetail  
            WHERE MUID = @Object_MUID  
        END  
  
        EXEC mdm.udpSubscriptionViewCheck @DerivedHierarchy_ID = @DerivedHierarchy_ID, @ViewFormat_ID = 8 /*Levels*/, @Return_ID = @Ret output  
        IF @Ret > 0  
        BEGIN  
            -- No reason to differentiate between Subscription with Levels vs. with ParentChild.  See TFS 360606  
            SET @ErrorMessage = N'MDSERR200049|The derived hierarchy was not deleted because a subscription view exists.  To delete the hierarchy, you must first delete all subscription views associated with this derived hierarchy.';  
        END ELSE  
        BEGIN  
            EXEC mdm.udpSubscriptionViewCheck @DerivedHierarchy_ID = @DerivedHierarchy_ID, @ViewFormat_ID = 7 /*ParentChild*/, @Return_ID = @Ret output  
            IF @Ret > 0  
            BEGIN  
                SET @ErrorMessage = N'MDSERR200049|The derived hierarchy was not deleted because a subscription view exists.  To delete the hierarchy, you must first delete all subscription views associated with this derived hierarchy.';  
            END  
        END  
    END   
      
    ELSE IF @ObjectType_ID = @ObjectType_Version   
    BEGIN  
        SELECT @Object_ID = ID FROM mdm.tblModelVersion WHERE MUID = @Object_MUID;  
    END   
      
    ELSE IF @ObjectType_ID = @ObjectType_Entity   
    BEGIN  
        SELECT @Object_ID = ID FROM mdm.tblEntity WHERE MUID = @Object_MUID  
  
        IF EXISTS(SELECT 1 FROM mdm.tblAttribute WHERE DomainEntity_ID = @Object_ID AND DomainEntity_ID <> Entity_ID)   
        BEGIN  
            SET @ErrorMessage = N'MDSERR200023|The entity cannot be deleted because it is referenced by a domain-based attribute.';  
        END ELSE IF EXISTS(SELECT 1 FROM mdm.tblBRBusinessRule WHERE Entity_ID = @Object_ID)   
        BEGIN  
            SET @ErrorMessage = N'MDSERR200024|The entity cannot be deleted because it is referenced by a business rule.';  
        END ELSE IF EXISTS(SELECT 1 FROM mdm.viw_SYSTEM_SCHEMA_HIERARCHY_DERIVED_LEVELS WHERE @Object_ID IN (ForeignEntity_ID, Entity_ID))   
        BEGIN  
            SET @ErrorMessage = N'MDSERR200025|The entity cannot be deleted because it is referenced by a derived hierarchy.';  
        END ELSE   
        BEGIN  
            EXEC mdm.udpSubscriptionViewCheck @Entity_ID = @Object_ID, @Return_ID = @Ret output  
            IF @Ret > 0  
                SET @ErrorMessage = N'MDSERR200052|The change cannot be made because there are subscription views for this entity and model.';  
        END; --if  
    END   
      
    ELSE IF @ObjectType_ID = @ObjectType_Hierarchy   
    BEGIN  
        SELECT @Object_ID = ID FROM mdm.tblHierarchy WHERE MUID = @Object_MUID  
  
        IF EXISTS(SELECT 1 FROM mdm.tblDerivedHierarchyDetail WHERE Foreign_ID = @Object_ID AND ForeignType_ID = 2/*Hierarchy*/)   
        BEGIN  
            SET @ErrorMessage = N'MDSERR200030|The explicit hierarchy cannot be deleted because it is referenced by a derived hierarchy.';  
        END ELSE IF EXISTS(  
            -- Check if there are any consolidation rules.  If this is the last hierarchy (current count = 1)  
            -- then prevent the deletion until the BR has been deleted.  
            SELECT	1  
            FROM	mdm.tblBRBusinessRule br INNER JOIN   
                    mdm.tblHierarchy h ON   
                        br.Entity_ID = h.Entity_ID AND  
                        br.MemberType_ID = @MemberType_Consolidated AND  
                        h.ID = @Object_ID  
            WHERE  
                 (SELECT COUNT(ID) FROM mdm.tblHierarchy hr WHERE h.Entity_ID = hr.Entity_ID) = 1   
            UNION ALL  
            -- Check if there are any leaf rules that refer to consolidation attributes  
            SELECT 1 FROM mdm.tblBRItemProperties WHERE PropertyType_ID = 3 AND [Value] = CONVERT(NVARCHAR(999),@Object_ID)  
        )   
        BEGIN  
            SET @ErrorMessage = N'MDSERR200031|The explicit hierarchy cannot be deleted because it is referenced by a business rule.';  
        END; --if  
    END   
      
    ELSE IF @ObjectType_ID = @ObjectType_Attribute   
    BEGIN  
        SELECT @Object_ID = ID FROM mdm.tblAttribute WHERE MUID = @Object_MUID  
  
        IF EXISTS(SELECT 1 FROM mdm.tblDerivedHierarchyDetail   
                  WHERE (   Foreign_ID = @Object_ID   
                        AND ForeignType_ID IN (1/*DBA*/, 5/*ManyToMany*/)  
                        )  
                    OR ManyToManyChildAttribute_ID = @Object_ID  
                  )   
        BEGIN  
            SET @ErrorMessage = N'MDSERR200028|The attribute cannot be deleted because it is referenced by a derived hierarchy.';  
        END ELSE IF EXISTS(SELECT 1 FROM mdm.tblBRItemProperties WHERE   
            (PropertyType_ID = 2 OR PropertyType_ID = 4) AND [Value] = CONVERT(NVARCHAR(999),@Object_ID))   
        BEGIN  
            SET @ErrorMessage = N'MDSERR200027|The attribute cannot be deleted because it is referenced by a business rule.';  
        END;  
        -- Note: if a subscription view exists that uses the attribute, then the subscription view will be updated when the attribute is deleted  
    END   
      
    ELSE IF @ObjectType_ID = @ObjectType_AttributeGroup   
    BEGIN  
        SELECT @Object_ID = ID FROM mdm.tblAttributeGroup WHERE MUID = @Object_MUID  
    END   
      
    ELSE IF @ObjectType_ID = @ObjectType_VersionFlag   
    BEGIN --Version Flag  
        SELECT @Object_ID = ID FROM mdm.tblModelVersionFlag WHERE MUID = @Object_MUID  
  
        IF EXISTS(SELECT 1 FROM mdm.tblModelVersion WHERE VersionFlag_ID = @Object_ID) BEGIN  
            SET @ErrorMessage = N'MDSERR200035|The version flag cannot be deleted because it is referenced by a version.'  
        END; --if  
    END   
      
    ELSE IF @ObjectType_ID = @ObjectType_Index   
    BEGIN  
        SELECT @Object_ID = ID FROM mdm.tblIndex WHERE MUID = @Object_MUID  
    END   
      
    ELSE  
    BEGIN  
        -- Bad object type  
        SET @ErrorMessage = N'MDSERR100010|The Parameters are not valid.';  
    END  
  
    IF @ErrorMessage IS NOT NULL  
    BEGIN  
        SET @ErrorMessage = REPLACE(@ErrorMessage, '%', '%%')-- escape out format specifier  
        RAISERROR(@ErrorMessage, 16, 1)  
    END  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpObjectInformationLookup]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
    --Model (ObjectTypeID = 1)  
    DECLARE @ID INT, @Name NVARCHAR(MAX), @MUID UniqueIdentifier, @PrivilegeID INT;	  
    EXEC mdm.udpObjectInformationLookup   
         @UserID			= 1  
        ,@ObjectMUID		= NULL  
        ,@ObjectID			= NULL  
        ,@ObjectName		= 'Product'  
        ,@ObjectTypeID		= 1  
        ,@ObjectSubTypeID	= NULL  
        ,@ParentObjectID	= NULL  
        ,@ParentObjectMUID	= NULL  
        ,@ID				= @ID			OUTPUT  
        ,@Name				= @Name			OUTPUT  
        ,@MUID				= @MUID			OUTPUT  
        ,@PrivilegeID		= @PrivilegeID	OUTPUT		  
    SELECT @ID, @Name, @MUID, @PrivilegeID;  
*/  
CREATE PROCEDURE [mdm].[udpObjectInformationLookup]  
(  
    @UserID				INT = NULL,  
    @ObjectMUID			UNIQUEIDENTIFIER = NULL,	--\  
    @ObjectID			INT = NULL,					--One of these 3 always required  
    @ObjectName			NVARCHAR(MAX) = NULL,		--/  
    @ObjectTypeID		TINYINT,					--Always required value  
    @ObjectSubTypeID	TINYINT=NULL,				--Not Required.  Only used for ObjectType of 4 and 6  
    @ParentObjectID		INT = NULL,					--\ One of these always required (except Model)  
    @ParentObjectMUID	UNIQUEIDENTIFIER = NULL,	--/  
    @ID					INTEGER = NULL OUTPUT,  
    @Name				NVARCHAR(MAX) = NULL OUTPUT,  
    @MUID				UNIQUEIDENTIFIER = NULL OUTPUT,  
    @PrivilegeID		INTEGER = NULL OUTPUT,  
    @AccessPermission   TINYINT = NULL OUTPUT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
      
/*  
    IF @ObjectSubType_ID IS NULL SET @ObjectSubType_ID =1  --If there is a SubType, default to 1 (Leaf)  
    IF @User_ID IS NULL SET @User_ID =0  
*/	  
  
    DECLARE @ObjectType_Model TINYINT = 1,  
            @ObjectType_DerivedHierarchy TINYINT = 2,  
            @ObjectType_Version TINYINT = 4,  
            @ObjectType_Entity TINYINT = 5,  
            @ObjectType_Hierarchy TINYINT = 6,  
            @ObjectType_Attribute TINYINT = 7,  
            @ObjectType_AttributeGroup TINYINT = 8,  
            @ObjectType_StagingBatch TINYINT = 9,  
            @ObjectType_VersionFlag TINYINT = 10,  
            @ObjectType_ExportView TINYINT = 20;  
  
              
    IF @ObjectTypeID = @ObjectType_Model --Model  
        BEGIN  
            EXEC mdm.udpInformationLookupModel 	  
                     @User_ID		= @UserID		  
                    ,@Model_MUID	= @ObjectMUID	  
                    ,@Model_ID		= @ObjectID  
                    ,@Model_Name	= @ObjectName  
                    ,@ID			= @ID			OUTPUT  
                    ,@Name			= @Name			OUTPUT  
                    ,@MUID			= @MUID			OUTPUT  
                    ,@Privilege_ID	= @PrivilegeID	OUTPUT  
                    ,@AccessPermission = @AccessPermission OUTPUT  
        END  
    ELSE IF @ObjectTypeID = @ObjectType_DerivedHierarchy -- Derived Hierarchy  
        BEGIN  
            EXEC mdm.udpInformationLookupDerivedHierarchy  
                     @User_ID				= @UserID						  
                    ,@DerivedHierarchy_MUID	= @ObjectMUID				  
                    ,@DerivedHierarchy_ID	= @ObjectID				  
                    ,@DerivedHierarchy_Name	= @ObjectName				  
                    ,@Model_ID				= @ParentObjectID			  
                    ,@Model_MUID			= @ParentObjectMUID		  
                    ,@ID					= @ID			OUTPUT	 					  
                    ,@Name					= @Name			OUTPUT				  
                    ,@MUID					= @MUID			OUTPUT				  
                    ,@Privilege_ID			= @PrivilegeID	OUTPUT  
                    ,@AccessPermission      = @AccessPermission OUTPUT  
        END  
    ELSE IF @ObjectTypeID = @ObjectType_Version -- Version  
        BEGIN  
            EXEC mdm.udpInformationLookupVersion  
                 @User_ID		= @UserID	  
                ,@Version_MUID	= @ObjectMUID				  
                ,@Version_ID	= @ObjectID				  
                ,@Version_Name	= @ObjectName				  
                ,@Model_ID		= @ParentObjectID			  
                ,@Model_MUID	= @ParentObjectMUID		  
                ,@ID			= @ID			OUTPUT	 					  
                ,@Name			= @Name			OUTPUT				  
                ,@MUID			= @MUID			OUTPUT				  
                ,@Privilege_ID	= @PrivilegeID	OUTPUT  
                ,@AccessPermission = @AccessPermission OUTPUT  
        END	  
    ELSE IF @ObjectTypeID = @ObjectType_Entity -- Entity  
        BEGIN  
            EXEC  mdm.udpInformationLookupEntity  
                     @User_ID		= @UserID						  
                    ,@Entity_MUID	= @ObjectMUID				  
                    ,@Entity_ID		= @ObjectID				  
                    ,@Entity_Name	= @ObjectName				  
                    ,@Model_ID		= @ParentObjectID			  
                    ,@Model_MUID	= @ParentObjectMUID		  
                    ,@ID			= @ID			OUTPUT	 					  
                    ,@Name			= @Name			OUTPUT				  
                    ,@MUID			= @MUID			OUTPUT				  
                    ,@Privilege_ID	= @PrivilegeID	OUTPUT  
                    ,@AccessPermission = @AccessPermission OUTPUT  
        END	  
    ELSE IF @ObjectTypeID = @ObjectType_Hierarchy -- Hierarchy  
        BEGIN  
            EXEC  mdm.udpInformationLookupHierarchy  
                     @User_ID			= @UserID						  
                    ,@Hierarchy_MUID	= @ObjectMUID				  
                    ,@Hierarchy_ID		= @ObjectID				  
                    ,@Hierarchy_Name	= @ObjectName					  
                    ,@Entity_ID			= @ParentObjectID			  
                    ,@Entity_MUID		= @ParentObjectMUID		  
                    ,@ID				= @ID			OUTPUT	 					  
                    ,@Name				= @Name			OUTPUT				  
                    ,@MUID				= @MUID			OUTPUT				  
                    ,@Privilege_ID		= @PrivilegeID	OUTPUT  
                    ,@AccessPermission  = @AccessPermission OUTPUT  
        END	  
    ELSE IF @ObjectTypeID = @ObjectType_Attribute -- Attribute  
        BEGIN  
            EXEC  mdm.udpInformationLookupAttribute  
                    @User_ID			= @UserID						  
                    ,@Attribute_MUID	= @ObjectMUID				  
                    ,@Attribute_ID		= @ObjectID				  
                    ,@Attribute_Name	= @ObjectName				  
                    ,@MemberType_ID		= @ObjectSubTypeID		  
                    ,@Entity_ID			= @ParentObjectID			  
                    ,@Entity_MUID		= @ParentObjectMUID		  
                    ,@ID				= @ID			OUTPUT	 					  
                    ,@Name				= @Name			OUTPUT				  
                    ,@MUID				= @MUID			OUTPUT				  
                    ,@Privilege_ID		= @PrivilegeID	OUTPUT  
                    ,@AccessPermission  = @AccessPermission OUTPUT  
        END	  
    ELSE IF @ObjectTypeID = @ObjectType_AttributeGroup -- Attribute Group  
        BEGIN  
            EXEC  mdm.udpInformationLookupAttributeGroup  
                     @User_ID				= @UserID						  
                    ,@AttributeGroup_MUID	= @ObjectMUID				  
                    ,@AttributeGroup_ID		= @ObjectID				  
                    ,@AttributeGroup_Name	= @ObjectName					  
                    ,@MemberType_ID         = @ObjectSubTypeID		  
                    ,@Entity_ID				= @ParentObjectID			  
                    ,@Entity_MUID			= @ParentObjectMUID		  
                    ,@ID					= @ID			OUTPUT	 					  
                    ,@Name					= @Name			OUTPUT				  
                    ,@MUID					= @MUID			OUTPUT				  
                    ,@Privilege_ID			= @PrivilegeID	OUTPUT  
                    ,@AccessPermission      = @AccessPermission OUTPUT  
        END		  
    ELSE IF @ObjectTypeID = @ObjectType_StagingBatch -- Staging Batch  
        BEGIN  
            EXEC  mdm.udpInformationLookupStagingBatch  
                     @StagingBatch_MUID	= @ObjectMUID				  
                    ,@StagingBatch_ID	= @ObjectID				  
                    ,@StagingBatch_Name	= @ObjectName				  
                    ,@ID				= @ID			OUTPUT	 					  
                    ,@Name				= @Name			OUTPUT				  
                    ,@MUID				= @MUID			OUTPUT				  
                    ,@Privilege_ID		= @PrivilegeID	OUTPUT  
                    ,@AccessPermission  = @AccessPermission OUTPUT  
        END  
    ELSE IF @ObjectTypeID = @ObjectType_VersionFlag -- Version Flag  
        BEGIN  
            EXEC  mdm.udpInformationLookupVersionFlag  
                     @User_ID			= @UserID						  
                    ,@VersionFlag_MUID	= @ObjectMUID				  
                    ,@VersionFlag_ID	= @ObjectID				  
                    ,@VersionFlag_Name	= @ObjectName				  
                    ,@Model_ID			= @ParentObjectID			  
                    ,@Model_MUID		= @ParentObjectMUID		  
                    ,@ID				= @ID			OUTPUT	 					  
                    ,@Name				= @Name			OUTPUT				  
                    ,@MUID				= @MUID			OUTPUT				  
                    ,@Privilege_ID		= @PrivilegeID	OUTPUT  
                    ,@AccessPermission  = @AccessPermission OUTPUT  
        END  
    ELSE IF @ObjectTypeID = @ObjectType_ExportView -- Export View  
        BEGIN  
            DECLARE @viewName sysname = CONVERT(sysname, @Name);  
            EXEC  mdm.udpInformationLookupExportView  
                     @ExportView_MUID	= @ObjectMUID				  
                    ,@ExportView_ID		= @ObjectID				  
                    ,@ExportView_Name	= @ObjectName				  
                    ,@ID				= @ID			OUTPUT	 					  
                    ,@Name				= @viewName     OUTPUT				  
                    ,@MUID				= @MUID			OUTPUT				  
                    ,@Privilege_ID		= @PrivilegeID	OUTPUT  
                    ,@AccessPermission  = @AccessPermission OUTPUT  
            SET @Name = @viewName  
        END									  
      
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpPerformanceQueueActivate]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
--Create SSB items  
CREATE QUEUE [mdm].[microsoft/mdm/queue/performance] WITH STATUS = ON , RETENTION = OFF  ON [PRIMARY]  
CREATE SERVICE [microsoft/mdm/service/performance]  AUTHORIZATION [dbo]  ON QUEUE [mdm].[microsoft/mdm/queue/performance] ([microsoft/mdm/contract/performance])  
CREATE MESSAGE TYPE [microsoft/mdm/message/performance] AUTHORIZATION [dbo] VALIDATION = WELL_FORMED_XML  
CREATE CONTRACT [microsoft/mdm/contract/performance] AUTHORIZATION [dbo] ([microsoft/mdm/message/performance] SENT BY INITIATOR)  
  
  
--Alter the queue to use the SP we just created in an activated manner  
ALTER QUEUE mdm.[microsoft/mdm/queue/performance]  
WITH STATUS = ON , RETENTION = OFF , ACTIVATION (  STATUS = ON , PROCEDURE_NAME = [mdm].[udpPerformanceQueueActivate] , MAX_QUEUE_READERS = 1 , EXECUTE AS CALLER  )  
  
*/  
CREATE PROCEDURE [mdm].[udpPerformanceQueueActivate]  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE  
         @message_type_name sysname  
        ,@handle            UNIQUEIDENTIFIER  
        ,@interval          INT  
        ,@body              XML;  
  
    --Initialize variables  
    SELECT @handle = NULL;  
  
    --Load interval setting from config, and check the defaults and ranges  
    SET @interval = 1800; --Protect against NULL values  
  
    BEGIN TRANSACTION  
  
	WHILE (1=1)  
	BEGIN  
		WAITFOR (  
			RECEIVE TOP(1)  
				@handle = [conversation_handle],  
				@message_type_name = message_type_name,  
				@body = CONVERT(XML,message_body)  
			FROM mdm.[microsoft/mdm/queue/performance]  
		), TIMEOUT 5000; --Always wait a constant time for any new messages  
		IF (@@ROWCOUNT =0 ) BREAK;  
	END  
  
    --Got a TIMER message  
    IF (@message_type_name = N'microsoft/mdm/message/performance') BEGIN  
  
        --Start a new TIMER and COMMIT the transaction before we do the real work, to avoid poisoning  
        BEGIN CONVERSATION TIMER (@handle) TIMEOUT = @interval;  
        COMMIT TRANSACTION;  
        PRINT 'Performace optimization received message';  
          
		--Do the real work here of copying the data from original views to the temporary tables  
  
        BEGIN TRANSACTION  
        BEGIN TRY  
            EXEC mdm.udpPerformanceTruncateCopy;  
            END CONVERSATION @handle;  
            COMMIT TRANSACTION  
        END TRY  
        BEGIN CATCH  
            ROLLBACK TRANSACTION  
        END CATCH  
    --Got an END DIALOG message  
    END ELSE IF (@message_type_name = N'http://schemas.microsoft.com/SQL/ServiceBroker/EndDialog') BEGIN  
  
        PRINT 'Performance EndDialog'  
  
    --Got ERROR message  
    END ELSE IF (@message_type_name = N'http://schemas.microsoft.com/SQL/ServiceBroker/Error') BEGIN  
  
        PRINT 'performance Error'  
  
    --Timeout or unexpected message  
    END ELSE BEGIN  
  
        COMMIT TRANSACTION;  
  
    END; --if  
  
    SET NOCOUNT OFF;  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpPerformanceQueueExecuted]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpPerformanceQueueExecuted]  
(  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
  
    DECLARE @retryCount INT = 0;  
    DECLARE @maxRetryCount INT;  
    DECLARE @delayTime CHAR(8);  
  
    DECLARE @enablePerformanceSetting INT;  
	SELECT @enablePerformanceSetting = CONVERT(INT, SettingValue) FROM mdm.tblSystemSetting WHERE SettingName = 'PerformanceImprovementEnable';  
	IF @enablePerformanceSetting = 0  
	BEGIN  
		RETURN;  
	END  
  
    SELECT @maxRetryCount = CONVERT(INT, SettingValue) FROM mdm.tblSystemSetting WHERE SettingName = 'PerformanceMaxRetryCount';  
    SELECT @delayTime = CONVERT(CHAR(8), ISNULL(SettingValue, '00:00:01')) FROM mdm.tblSystemSetting WHERE SettingName = 'PerformanceDelayInterval';  
  
    IF @maxRetryCount IS NULL OR @maxRetryCount <= 0  
    BEGIN  
        SET @maxRetryCount =300;  
    END  
  
    IF @delayTime IS NULL OR LEN(@delayTime) != 8  
    BEGIN  
        SET @delayTime ='00:00:01';  
    END  
  
    WHILE (1=1)  
	BEGIN  
		SELECT status, conversation_group_id, conversation_handle, service_name FROM mdm.[microsoft/mdm/queue/performance] WITH (NOLOCK);  
		IF (@@ROWCOUNT =0 ) OR @retryCount = @maxRetryCount  
        BEGIN  
             BREAK;  
        END  
        WAITFOR DELAY @delayTime;  
        SET @retryCount = @retryCount + 1;  
	END  
  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpPerformanceQueueSave]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
This proc adds a message to the Performance queue.  
It is called when ever a change has happened to any of the performance related tables  
  
--Version3/Account - Entity example call  
Exec mdm.udpPerformanceSave  
  
select * FROM mdm.[microsoft/mdm/queue/performance]  
select * FROM mdm.[microsoft/mdm/queue/performance]  
  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpPerformanceQueueSave]  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON  
  
    DECLARE @enablePerformanceSetting INT;  
	SELECT @enablePerformanceSetting = CONVERT(INT, SettingValue) FROM mdm.tblSystemSetting WHERE SettingName = 'PerformanceImprovementEnable';  
	IF @enablePerformanceSetting = 0  
	BEGIN  
		RETURN;  
	END  
      
    DECLARE @messages_conversation_group UNIQUEIDENTIFIER = CONVERT(UNIQUEIDENTIFIER, 0x2) --This is a constant.  Its used is udpSecurityMemberQueueActivate as well  
    DECLARE @conversationHandle UNIQUEIDENTIFIER = mdm.udfServiceGetConversationHandle(  
        N'microsoft/mdm/service/system',  
        N'microsoft/mdm/service/performance');  
      
    ----Start a new conversation if necessary  
    IF @conversationHandle IS NULL  
        BEGIN DIALOG CONVERSATION @conversationHandle  
            FROM SERVICE [microsoft/mdm/service/system]   
            TO SERVICE N'microsoft/mdm/service/performance'  
            ON CONTRACT [microsoft/mdm/contract/performance]   
            WITH ENCRYPTION=OFF; --is by default  
  
    --Send the message  
    SEND ON CONVERSATION @conversationHandle MESSAGE TYPE [microsoft/mdm/message/performance];  
  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpPerformanceToggleSwitch]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpPerformanceToggleSwitch]  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN   
    DECLARE @AlterViewSQL NVARCHAR(MAX) = N'';  
    DECLARE @enablePerformanceSetting INT;  
	SELECT @enablePerformanceSetting = CONVERT(INT, SettingValue) FROM mdm.tblSystemSetting WHERE SettingName = 'PerformanceImprovementEnable';  
	IF @enablePerformanceSetting = 0  
	BEGIN  
        -- Disable performance change.  
        BEGIN TRANSACTION  
        BEGIN TRY  
        	-- [mdm].[viw_SYSTEM_SECURITY_USER_ROLE]  
			SET @AlterViewSQL = N'  
			ALTER VIEW [mdm].[viw_SYSTEM_SECURITY_USER_ROLE]  
			AS  
			SELECT  
				 [User_ID]  
				,[Role_ID]  
				,[IsUserGroupAssignment]  
			FROM [mdm].[viw_SYSTEM_SECURITY_USER_ROLE_ORIGINAL]';  
			EXEC sp_executesql @AlterViewSQL;  
  
			--[mdm].[viw_SYSTEM_SECURITY_USER_MEMBERTYPE]  
			SET @AlterViewSQL = N'  
			ALTER VIEW [mdm].[viw_SYSTEM_SECURITY_USER_MEMBERTYPE]  
			AS  
			SELECT  
				[User_ID]  
				,[IsAdmin]  
				,[IsSyncTarget]  
				,[Entity_ID]  
				,[ID]  
				,[Privilege_ID]  
				,[AccessPermission]  
			FROM [mdm].[viw_SYSTEM_SECURITY_USER_MEMBERTYPE_ORIGINAL]';  
			EXEC sp_executesql @AlterViewSQL;  
  
			-- [mdm].[viw_SYSTEM_SECURITY_USER_ATTRIBUTE]  
			SET @AlterViewSQL = N'  
			ALTER VIEW [mdm].[viw_SYSTEM_SECURITY_USER_ATTRIBUTE]  
			AS  
			SELECT   
				[User_ID]  
				,[IsAdmin]  
				,[ID]  
				,[Privilege_ID]  
				,[AccessPermission]  
			FROM    
			[mdm].[viw_SYSTEM_SECURITY_USER_ATTRIBUTE_ORIGINAL]'  
			EXEC sp_executesql @AlterViewSQL;  
  
			-- [mdm].[viw_SYSTEM_SECURITY_ROLE]  
			SET @AlterViewSQL = N'  
			ALTER VIEW [mdm].[viw_SYSTEM_SECURITY_ROLE]  
			AS  
			SELECT  
				[Role_ID]  
				,[Model_ID]  
				,[Model_PrivilegeID]  
				,[Model_AccessPermission]  
				,[Model_IsExplicit]  
				,[Entity_ID]  
				,[Entity_PrivilegeID]  
				,[Entity_AccessPermission]  
				,[Entity_IsExplicit]  
				,[MemberType_ID]  
				,[MemberType_PrivilegeID]  
				,[MemberType_AccessPermission]  
				,[MemberType_IsExplicit]  
				,[Attribute_ID]  
				,[Attribute_PrivilegeID]  
				,[Attribute_AccessPermission]  
				,[Attribute_IsExplicit]  
			FROM  
			   [mdm].[viw_SYSTEM_SECURITY_ROLE_ORIGINAL]';  
			EXEC sp_executesql @AlterViewSQL;  
  
			-- [mdm].[viw_SYSTEM_SCHEMA_ATTRIBUTES]  
			SET @AlterViewSQL = N'  
			ALTER VIEW [mdm].[viw_SYSTEM_SCHEMA_ATTRIBUTES]  
			AS  
			SELECT  
				[Model_ID]  
				,[Model_MUID]  
				,[Model_Name]  
				,[Entity_ID]  
				,[Entity_MUID]  
				,[Entity_Name]  
				,[Attribute_ID]  
				,[Attribute_MUID]  
				,[Attribute_Name]  
				,[Attribute_Description]  
				,[Attribute_DisplayName]  
				,[Attribute_DisplayWidth]  
				,[Attribute_ChangeTrackingGroup]  
				,[Attribute_Column]  
				,[Attribute_IsSystem]  
				,[Attribute_IsReadOnly]  
				,[Attribute_IsCode]  
				,[Attribute_IsName]  
				,[Attribute_MemberType_ID]  
				,[Attribute_MemberType_Name]  
				,[Attribute_Type_ID]  
				,[Attribute_Type_Name]  
				,[Attribute_DBAEntity_ID]  
				,[Attribute_DBAEntity_MUID]  
				,[Attribute_DBAEntity_Name]  
				,[Attribute_DBAEntity_IsHierarchyEnabled]  
				,[FilterParentAttribute_ID]  
				,[FilterParentAttribute_MUID]  
				,[FilterParentAttribute_Name]  
				,[FilterParentHierarchy_ID]  
				,[FilterParentHierarchy_MUID]  
				,[FilterParentHierarchy_Name]  
				,[FilterParentHierarchy_LevelNumber]  
				,[Attribute_DataType_ID]  
				,[Attribute_DataType_Name]  
				,[Attribute_DataType_Information]  
				,[Attribute_DataMask_ID]  
				,[Attribute_DataMask_Name]  
				,[Entity_PhysicalTableName]  
				,[Attribute_SortOrder]  
				,[EnteredUser_ID]  
				,[EnteredUser_MUID]  
				,[EnteredUser_UserName]  
				,[EnteredUser_DTM]  
				,[LastChgUser_ID]  
				,[LastChgUser_MUID]  
				,[LastChgUser_UserName]  
				,[LastChgUser_DTM]  
				,[Attribute_FullyQualifiedName]  
			FROM [mdm].[viw_SYSTEM_SCHEMA_ATTRIBUTES_ORIGINAL]';  
			EXEC sp_executesql @AlterViewSQL;  
              
            -- Remove all data to save space.   
		    TRUNCATE TABLE [mdm].[tblviwSystemSecurityRole];  
            TRUNCATE TABLE [mdm].[tblviwSystemSecurityUserRole];  
            TRUNCATE TABLE [mdm].[tblViwSystemSchemaAttributes];  
            TRUNCATE TABLE [mdm].[tblviwSystemSecurityUserMemberType];  
            TRUNCATE TABLE [mdm].[tblviwSystemSecurityUserAttribute];  
  
        COMMIT TRANSACTION  
        END TRY  
        BEGIN CATCH  
            ROLLBACK TRANSACTION  
        END CATCH  
	END  
    ELSE  
    BEGIN  
        -- Enable performance change.  
        BEGIN TRANSACTION  
        BEGIN TRY  
            -- [mdm].[viw_SYSTEM_SECURITY_USER_ROLE]  
			SET @AlterViewSQL = N'  
			ALTER VIEW [mdm].[viw_SYSTEM_SECURITY_USER_ROLE]  
			AS  
			SELECT  
				 [User_ID]  
				,[Role_ID]  
				,[IsUserGroupAssignment]  
			FROM [mdm].[tblviwSystemSecurityUserRole]';  
			EXEC sp_executesql @AlterViewSQL;  
  
			--[mdm].[viw_SYSTEM_SECURITY_USER_MEMBERTYPE]  
			SET @AlterViewSQL = N'  
			ALTER VIEW [mdm].[viw_SYSTEM_SECURITY_USER_MEMBERTYPE]  
			AS  
			SELECT  
				[User_ID]  
				,[IsAdmin]  
				,[IsSyncTarget]  
				,[Entity_ID]  
				,[ID]  
				,[Privilege_ID]  
				,[AccessPermission]  
			FROM [mdm].[tblviwSystemSecurityUserMemberType]';  
			EXEC sp_executesql @AlterViewSQL;  
  
			--[mdm].[viw_SYSTEM_SECURITY_USER_ATTRIBUTE]  
			SET @AlterViewSQL = N'  
			ALTER VIEW [mdm].[viw_SYSTEM_SECURITY_USER_ATTRIBUTE]  
			AS  
			SELECT   
				[User_ID]  
				,[IsAdmin]  
				,[ID]  
				,[Privilege_ID]  
				,[AccessPermission]  
			FROM    
			[mdm].[tblviwSystemSecurityUserAttribute]';  
			EXEC sp_executesql @AlterViewSQL;  
  
			-- [mdm].[viw_SYSTEM_SECURITY_ROLE]  
			SET @AlterViewSQL = N'  
			ALTER VIEW [mdm].[viw_SYSTEM_SECURITY_ROLE]  
			AS  
			SELECT  
				[Role_ID]  
				,[Model_ID]  
				,[Model_PrivilegeID]  
				,[Model_AccessPermission]  
				,[Model_IsExplicit]  
				,[Entity_ID]  
				,[Entity_PrivilegeID]  
				,[Entity_AccessPermission]  
				,[Entity_IsExplicit]  
				,[MemberType_ID]  
				,[MemberType_PrivilegeID]  
				,[MemberType_AccessPermission]  
				,[MemberType_IsExplicit]  
				,[Attribute_ID]  
				,[Attribute_PrivilegeID]  
				,[Attribute_AccessPermission]  
				,[Attribute_IsExplicit]  
			FROM  
			   [mdm].[tblviwSystemSecurityRole]';  
			EXEC sp_executesql @AlterViewSQL;  
  
			-- [mdm].[viw_SYSTEM_SCHEMA_ATTRIBUTES]  
			SET @AlterViewSQL = N'  
			ALTER VIEW [mdm].[viw_SYSTEM_SCHEMA_ATTRIBUTES]  
			AS  
			SELECT  
				[Model_ID]  
				,[Model_MUID]  
				,[Model_Name]  
				,[Entity_ID]  
				,[Entity_MUID]  
				,[Entity_Name]  
				,[Attribute_ID]  
				,[Attribute_MUID]  
				,[Attribute_Name]  
				,[Attribute_Description]  
				,[Attribute_DisplayName]  
				,[Attribute_DisplayWidth]  
				,[Attribute_ChangeTrackingGroup]  
				,[Attribute_Column]  
				,[Attribute_IsSystem]  
				,[Attribute_IsReadOnly]  
				,[Attribute_IsCode]  
				,[Attribute_IsName]  
				,[Attribute_MemberType_ID]  
				,[Attribute_MemberType_Name]  
				,[Attribute_Type_ID]  
				,[Attribute_Type_Name]  
				,[Attribute_DBAEntity_ID]  
				,[Attribute_DBAEntity_MUID]  
				,[Attribute_DBAEntity_Name]  
				,[Attribute_DBAEntity_IsHierarchyEnabled]  
				,[FilterParentAttribute_ID]  
				,[FilterParentAttribute_MUID]  
				,[FilterParentAttribute_Name]  
				,[FilterParentHierarchy_ID]  
				,[FilterParentHierarchy_MUID]  
				,[FilterParentHierarchy_Name]  
				,[FilterParentHierarchy_LevelNumber]  
				,[Attribute_DataType_ID]  
				,[Attribute_DataType_Name]  
				,[Attribute_DataType_Information]  
				,[Attribute_DataMask_ID]  
				,[Attribute_DataMask_Name]  
				,[Entity_PhysicalTableName]  
				,[Attribute_SortOrder]  
				,[EnteredUser_ID]  
				,[EnteredUser_MUID]  
				,[EnteredUser_UserName]  
				,[EnteredUser_DTM]  
				,[LastChgUser_ID]  
				,[LastChgUser_MUID]  
				,[LastChgUser_UserName]  
				,[LastChgUser_DTM]  
				,[Attribute_FullyQualifiedName]  
			FROM [mdm].[tblViwSystemSchemaAttributes]';  
			EXEC sp_executesql @AlterViewSQL;  
  
            -- Rebulid table to sync data.   
            EXEC [mdm].[udpPerformanceTruncateCopy];  
            COMMIT TRANSACTION  
        END TRY  
        BEGIN CATCH  
            ROLLBACK TRANSACTION  
        END CATCH  
    END  
  
END
GO
/****** Object:  StoredProcedure [mdm].[udpPerformanceTruncateCopy]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpPerformanceTruncateCopy]  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
  
DECLARE @enablePerformanceSetting INT;  
SELECT @enablePerformanceSetting = CONVERT(INT, SettingValue) FROM mdm.tblSystemSetting WHERE SettingName = 'PerformanceImprovementEnable';  
IF @enablePerformanceSetting = 0  
BEGIN  
	RETURN;  
END  
  
-- Truncate and copy all the temporary tables from the original views   
TRUNCATE TABLE [mdm].[tblviwSystemSecurityRole]  
  
INSERT INTO [mdm].[tblviwSystemSecurityRole]  
SELECT * FROM [mdm].[viw_SYSTEM_SECURITY_ROLE_ORIGINAL]  
  
TRUNCATE TABLE  [mdm].[tblviwSystemSecurityUserRole]  
  
INSERT INTO  [mdm].[tblviwSystemSecurityUserRole]  
SELECT * FROM  [mdm].[viw_SYSTEM_SECURITY_USER_ROLE_ORIGINAL]  
  
MERGE INTO [mdm].[tblViwSystemSchemaAttributes] T  
USING(SELECT * FROM [mdm].[viw_SYSTEM_SCHEMA_ATTRIBUTES_ORIGINAL]) S  
ON T.Attribute_ID = S.Attribute_ID  
WHEN MATCHED THEN   
  UPDATE SET [Model_ID] = S.[Model_ID]  
      ,[Model_MUID] = S.[Model_MUID]  
      ,[Model_Name] = S.[Model_Name]  
      ,[Entity_ID] = S.[Entity_ID]  
      ,[Entity_MUID] = S.[Entity_MUID]   
      ,[Entity_Name] = S.[Entity_Name]  
      ,[Attribute_ID] = S.[Attribute_ID]  
      ,[Attribute_MUID] = S.[Attribute_MUID]  
      ,[Attribute_Name] = S.[Attribute_Name]  
      ,[Attribute_Description] = S.[Attribute_Description]  
      ,[Attribute_DisplayName] = S.[Attribute_DisplayName]  
      ,[Attribute_DisplayWidth] = S.[Attribute_DisplayWidth]  
      ,[Attribute_ChangeTrackingGroup] = S.[Attribute_ChangeTrackingGroup]  
      ,[Attribute_Column] = S.[Attribute_Column]  
      ,[Attribute_IsSystem] = S.[Attribute_IsSystem]  
      ,[Attribute_IsReadOnly] = S.[Attribute_IsReadOnly]  
      ,[Attribute_IsCode] = S.[Attribute_IsCode]  
      ,[Attribute_IsName] = S.[Attribute_IsName]  
      ,[Attribute_MemberType_ID] = S.[Attribute_MemberType_ID]  
      ,[Attribute_MemberType_Name] = S.[Attribute_MemberType_Name]  
      ,[Attribute_Type_ID] = S.[Attribute_Type_ID]  
      ,[Attribute_Type_Name] = S.[Attribute_Type_Name]   
      ,[Attribute_DBAEntity_ID] = S.[Attribute_DBAEntity_ID]  
      ,[Attribute_DBAEntity_MUID] = S.[Attribute_DBAEntity_MUID]  
      ,[Attribute_DBAEntity_Name] = S.[Attribute_DBAEntity_Name]  
      ,[Attribute_DBAEntity_IsHierarchyEnabled] = S.[Attribute_DBAEntity_IsHierarchyEnabled]  
      ,[FilterParentAttribute_ID] = S.[FilterParentAttribute_ID]  
      ,[FilterParentAttribute_MUID] = S.[FilterParentAttribute_MUID]  
      ,[FilterParentAttribute_Name] = S.[FilterParentAttribute_Name]  
      ,[FilterParentHierarchy_ID] = S.[FilterParentHierarchy_ID]  
      ,[FilterParentHierarchy_MUID] = S.[FilterParentHierarchy_MUID]  
      ,[FilterParentHierarchy_Name] = S.[FilterParentHierarchy_Name]  
      ,[FilterParentHierarchy_LevelNumber] = S.[FilterParentHierarchy_LevelNumber]  
      ,[Attribute_DataType_ID] = S.[Attribute_DataType_ID]  
      ,[Attribute_DataType_Name] = S.[Attribute_DataType_Name]  
      ,[Attribute_DataType_Information] = S.[Attribute_DataType_Information]  
      ,[Attribute_DataMask_ID] = S.[Attribute_DataMask_ID]  
      ,[Attribute_DataMask_Name] = S.[Attribute_DataMask_Name]  
      ,[Entity_PhysicalTableName] = S.[Entity_PhysicalTableName]  
      ,[Attribute_SortOrder] = S.[Attribute_SortOrder]  
      ,[EnteredUser_ID] = S.[EnteredUser_ID]  
      ,[EnteredUser_MUID] = S.[EnteredUser_MUID]  
      ,[EnteredUser_UserName] = S.[EnteredUser_UserName]  
      ,[EnteredUser_DTM] = S.[EnteredUser_DTM]  
      ,[LastChgUser_ID] = S.[LastChgUser_ID]  
      ,[LastChgUser_MUID] = S.[LastChgUser_MUID]  
      ,[LastChgUser_UserName] = S.[LastChgUser_UserName]  
      ,[LastChgUser_DTM] = S.[LastChgUser_DTM]  
      ,[Attribute_FullyQualifiedName] = S.[Attribute_FullyQualifiedName]  
   
WHEN NOT MATCHED BY SOURCE THEN DELETE  
WHEN NOT MATCHED BY TARGET THEN  
INSERT ([Model_ID]  
           ,[Model_MUID]  
           ,[Model_Name]  
           ,[Entity_ID]  
           ,[Entity_MUID]  
           ,[Entity_Name]  
           ,[Attribute_ID]  
           ,[Attribute_MUID]  
           ,[Attribute_Name]  
           ,[Attribute_Description]  
           ,[Attribute_DisplayName]  
           ,[Attribute_DisplayWidth]  
           ,[Attribute_ChangeTrackingGroup]  
           ,[Attribute_Column]  
           ,[Attribute_IsSystem]  
           ,[Attribute_IsReadOnly]  
           ,[Attribute_IsCode]  
           ,[Attribute_IsName]  
           ,[Attribute_MemberType_ID]  
           ,[Attribute_MemberType_Name]  
           ,[Attribute_Type_ID]  
           ,[Attribute_Type_Name]  
           ,[Attribute_DBAEntity_ID]  
           ,[Attribute_DBAEntity_MUID]  
           ,[Attribute_DBAEntity_Name]  
           ,[Attribute_DBAEntity_IsHierarchyEnabled]  
           ,[FilterParentAttribute_ID]  
           ,[FilterParentAttribute_MUID]  
           ,[FilterParentAttribute_Name]  
           ,[FilterParentHierarchy_ID]  
           ,[FilterParentHierarchy_MUID]  
           ,[FilterParentHierarchy_Name]  
           ,[FilterParentHierarchy_LevelNumber]  
           ,[Attribute_DataType_ID]  
           ,[Attribute_DataType_Name]  
           ,[Attribute_DataType_Information]  
           ,[Attribute_DataMask_ID]  
           ,[Attribute_DataMask_Name]  
           ,[Entity_PhysicalTableName]  
           ,[Attribute_SortOrder]  
           ,[EnteredUser_ID]  
           ,[EnteredUser_MUID]  
           ,[EnteredUser_UserName]  
           ,[EnteredUser_DTM]  
           ,[LastChgUser_ID]  
           ,[LastChgUser_MUID]  
           ,[LastChgUser_UserName]  
           ,[LastChgUser_DTM]  
           ,[Attribute_FullyQualifiedName])  
     VALUES  
           (S.[Model_ID]  
           ,S.[Model_MUID]  
           ,S.[Model_Name]  
           ,S.[Entity_ID]  
           ,S.[Entity_MUID]  
           ,S.[Entity_Name]  
           ,S.[Attribute_ID]  
           ,S.[Attribute_MUID]  
           ,S.[Attribute_Name]  
           ,S.[Attribute_Description]  
           ,S.[Attribute_DisplayName]  
           ,S.[Attribute_DisplayWidth]  
           ,S.[Attribute_ChangeTrackingGroup]  
           ,S.[Attribute_Column]  
           ,S.[Attribute_IsSystem]  
           ,S.[Attribute_IsReadOnly]  
           ,S.[Attribute_IsCode]  
           ,S.[Attribute_IsName]  
           ,S.[Attribute_MemberType_ID]  
           ,S.[Attribute_MemberType_Name]  
           ,S.[Attribute_Type_ID]  
           ,S.[Attribute_Type_Name]  
           ,S.[Attribute_DBAEntity_ID]  
           ,S.[Attribute_DBAEntity_MUID]  
           ,S.[Attribute_DBAEntity_Name]  
           ,S.[Attribute_DBAEntity_IsHierarchyEnabled]  
           ,S.[FilterParentAttribute_ID]  
           ,S.[FilterParentAttribute_MUID]  
           ,S.[FilterParentAttribute_Name]  
           ,S.[FilterParentHierarchy_ID]  
           ,S.[FilterParentHierarchy_MUID]  
           ,S.[FilterParentHierarchy_Name]  
           ,S.[FilterParentHierarchy_LevelNumber]  
           ,S.[Attribute_DataType_ID]  
           ,S.[Attribute_DataType_Name]  
           ,S.[Attribute_DataType_Information]  
           ,S.[Attribute_DataMask_ID]  
           ,S.[Attribute_DataMask_Name]  
           ,S.[Entity_PhysicalTableName]  
           ,S.[Attribute_SortOrder]  
           ,S.[EnteredUser_ID]  
           ,S.[EnteredUser_MUID]  
           ,S.[EnteredUser_UserName]  
           ,S.[EnteredUser_DTM]  
           ,S.[LastChgUser_ID]  
           ,S.[LastChgUser_MUID]  
           ,S.[LastChgUser_UserName]  
           ,S.[LastChgUser_DTM]  
           ,S.[Attribute_FullyQualifiedName]);  
  
TRUNCATE TABLE [mdm].[tblviwSystemSecurityUserMemberType]  
  
INSERT INTO [mdm].[tblviwSystemSecurityUserMemberType]  
SELECT * FROM [mdm].[viw_SYSTEM_SECURITY_USER_MEMBERTYPE_ORIGINAL]  
  
TRUNCATE TABLE [mdm].[tblviwSystemSecurityUserAttribute]  
  
INSERT INTO [mdm].[tblviwSystemSecurityUserAttribute]  
SELECT * FROM [mdm].[viw_SYSTEM_SECURITY_USER_ATTRIBUTE_ORIGINAL]  
  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpProcessCodes]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
Call the udpIsCodeGenEnabled to check whether an entity supports code generation.  
  
Example  
DECLARE @MemberCodes AS mdm.MemberCodes  
insert into @MemberCodes(MemberCode) values (N'HL-U509-BL');   
insert into @MemberCodes(MemberCode) values (N'BK-M38S-46');   
insert into @MemberCodes(MemberCode) values (N'100');   
insert into @MemberCodes(MemberCode) values (N'BK-M38Z-51');   
insert into @MemberCodes(MemberCode) values (N'BK-M38Z-55');   
insert into @MemberCodes(MemberCode) values (N'999');   
  
EXEC mdm.udpProcessCodes @Entity_ID = 20, @MemberCodes = @MemberCodes  
  
*/  
CREATE PROCEDURE [mdm].[udpProcessCodes]  
(  
    @Entity_ID		INT,  
    @MemberCodes    mdm.MemberCodes READONLY,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
AS BEGIN  
  
    SET NOCOUNT ON;  
  
    DECLARE @TempMaxValue BIGINT = NULL,  
            @CodeGenSeed INT = NULL,  
            @CurrentLargestValue    BIGINT = NULL,  
            @CodeSetMaxValue BIGINT = NULL;  
  
    IF NOT EXISTS(SELECT * FROM mdm.tblCodeGenInfo WHERE EntityId = @Entity_ID)  
        BEGIN  
            RAISERROR('MDSERR310054|This entity does not support automatic code generation', 16, 1);  
            RETURN;  
        END  
  
    --Try and get the maximum numeric value out of the set of codes we were given  
    --We need to first cast the code as a decimal because otherwise we can not convert  
    --codes that contain decimals down to a bigint. If there are no numbers in the set  
    --of codes @CodeSetMaxValue should be NULL  
    SELECT @CodeSetMaxValue = CONVERT(BIGINT, MAX(CAST(MemberCode AS DECIMAL(38,8))))   
    FROM @MemberCodes   
    WHERE mdq.IsNumber(MemberCode) = 1;  
  
    IF @CodeSetMaxValue IS NOT NULL  
        BEGIN  
            --Update the largest code value for this entity to the code set's maximum value if:  
            --1. The existing largest code value is null and the seed is smaller than code set's maximum value  
            --2. The existing largest code value is larger than or equal to the seed but is smaller than the code set's maximum value  
            --3. The seed is larger than the existing largest code value but is smaller than the code set's maximum value  
            --  
            --The expression has been broken out on purpose to aid readability of the code  
            UPDATE mdm.tblCodeGenInfo  
            SET LargestCodeValue = CASE WHEN LargestCodeValue IS NULL AND @CodeSetMaxValue > Seed THEN @CodeSetMaxValue  
                                        WHEN LargestCodeValue >= Seed AND @CodeSetMaxValue > LargestCodeValue THEN @CodeSetMaxValue  
                                        WHEN Seed > LargestCodeValue AND @CodeSetMaxValue > Seed THEN @CodeSetMaxValue  
                                        ELSE LargestCodeValue  
                                        END  
            WHERE EntityId = @Entity_ID;  
        END  
  
END; --proc mdm.udpProcessCodes
GO
/****** Object:  StoredProcedure [mdm].[udpRegenerateViewsAndStoredProcedures]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*    
==============================================================================    
 Copyright (c) Microsoft Corporation. All Rights Reserved.    
==============================================================================    
*/    
CREATE PROCEDURE [mdm].[udpRegenerateViewsAndStoredProcedures]      
(  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
AS BEGIN    
    SET NOCOUNT ON;  
        
    -- Add staging SProcs and staging error views   
  
    DECLARE @ID                 INT,  
            @EntityID           INT,  
            @IsHierarchyEnabled BIT,  
            @EntityName         NVARCHAR(MAX),  
            @StagingBase        NVARCHAR(MAX),   
            @SQL                NVARCHAR(MAX);  
              
    DECLARE @tblEntity TABLE     
    (    
        ID          INT IDENTITY (1, 1) NOT NULL,      
        Entity_ID   INT,    
        IsHierarchyEnabled      BIT,  
        EntityName NVARCHAR(MAX),  
        StagingBase NVARCHAR(MAX)  
    );    
              
    INSERT INTO @tblEntity  
    (  
        Entity_ID, IsHierarchyEnabled, EntityName, StagingBase  
    )  
    SELECT   
        ID,  
        CASE WHEN HierarchyTable IS NULL THEN 0 ELSE 1 END,  
        [Name],  
        StagingBase  
    FROM mdm.tblEntity  
          
    WHILE EXISTS(SELECT 1 FROM @tblEntity) BEGIN  
  
        SELECT TOP 1  
            @ID = ID,  
            @EntityID = Entity_ID,  
            @IsHierarchyEnabled = IsHierarchyEnabled,  
            @EntityName = EntityName,  
            @StagingBase = StagingBase  
        FROM @tblEntity  
        ORDER BY ID;	  
                  
        -- Generate staging SProcs  
        EXEC mdm.udpEntityStagingCreateLeafStoredProcedure @EntityID  
  
        IF @IsHierarchyEnabled = 1   
        BEGIN  
            EXEC mdm.udpEntityStagingCreateConsolidatedStoredProcedure @EntityID  
            EXEC mdm.udpEntityStagingCreateRelationshipStoredProcedure @EntityID  
        END  
          
        -- Change entity staging error views.   
        EXEC mdm.udpEntityStagingCreateErrorDetailViews @EntityID;    
                                           
        DELETE FROM @tblEntity WHERE ID = @ID  
          
    END -- WHILE  
  
    -- Regenerate views for entities.  
    EXEC mdm.udpCreateAllViews;  
  
    SET NOCOUNT OFF;  
        
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpResolveMemberGetCriteria]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
Convert MemberGetCriteria into SearchTerm that is injection safe.  
  
*/  
CREATE PROCEDURE [mdm].[udpResolveMemberGetCriteria]  
(  
    @SearchTable    mdm.MemberGetCriteria READONLY,  
    @SearchTerm     NVARCHAR(MAX) OUTPUT,  
    @SortTerm       NVARCHAR(MAX) OUTPUT  
)  
AS  
BEGIN  
    IF EXISTS (SELECT 1 FROM @SearchTable)  
    BEGIN  
        DECLARE @maxFilterCount     INT,  
                @groupID            INT,  
                @schemaName         SYSNAME,  
                @objectName         SYSNAME,  
                @fullObjectName     NVARCHAR(MAX),  
                @operator           NVARCHAR(15),  
                @operatorParameters NVARCHAR(MAX),  
                @filterValue        NVARCHAR(MAX),  
                @filterClause       NVARCHAR(MAX),  
                @currentGroup       INT,  
                @CurrentFilterId    INT,  
                @regexMask          INT = mdq.RegexMask(1, 1, 1, 0, 0, 0, 1); --CultureInvariant, ExplicitCapture, IgnoreCase, SingleLine (71)  
  
        --This table variable is used to keep track of unique filters in the search table. A set of records  
        --in the search table that belong to the same group (by way of having the same group ID) are considered  
        --one unique filter and are processed as such. However, records having a group ID of 0 are each considered  
        --their own separate unique filter. For example a search table like:  
        --INSERT INTO @SearchTable(ID,  SchemaName, ObjectName,     Operator,   OperatorParameters, GroupId,    [Value])  
        --                  values(1,   N'',        N'Name',        N'=',       N'',                0,          N'NewMember'),  
        --                        (2,   N'',        N'ModelName',   N'LIKE',    N'',                0,          N'%Premium'),  
        --                        (3,   N'',        N'SubCategory', N'IN',      N'',                1,          N'12'),  
        --                        (4,   N'',        N'SubCategory', N'IN',      N'',                1,          N'14'),  
        --                        (5,   N'',        N'SubCategory', N'IN',      N'',                1,          N'31'),  
        --                        (6,   N'',        N'SubCategory', N'IN',      N'',                1,          N'2'),  
        --                        (7,   N'',        N'Color',       N'IN',      N'',                2,          N'Silver'),  
        --                        (8,   N'',        N'Color',       N'IN',      N'',                2,          N'Yellow')  
        --  
        --would amount to 4 unique filters  
        DECLARE @UniqueFilters TABLE(FilterId INT PRIMARY KEY, Processed BIT DEFAULT 0);  
  
        SET @currentGroup = 0;  
        SET @SearchTerm = N'';  
  
        --Get filters with no GroupId in as unique filter  
        INSERT INTO @UniqueFilters(FilterId)  
        SELECT ID FROM @SearchTable WHERE GroupId = 0;  
  
        --Pick out the lowest ID for a group and stuff it into UniqueFilters  
        INSERT INTO @UniqueFilters(FilterId)  
        SELECT MIN(ID) FROM @SearchTable  
        WHERE GroupId <> 0  
        GROUP BY GroupId;  
  
        --Count out the total number of unique filters  
        SELECT @maxFilterCount = COUNT(1) from @UniqueFilters;  
  
        --Restrict the number of filters supported to a maximum of 100  
        IF @maxFilterCount > 100  
        BEGIN  
            RAISERROR('MDSERR100046|A maximum of 100 filter criteria are supported.', 16, 1);  
            RETURN;  
        END  
  
        --Build filter clause using table param for joins  
        WHILE EXISTS(SELECT 1 FROM @UniqueFilters WHERE Processed = 0)  
        BEGIN  
            SET @filterClause = NULL;  
            SELECT TOP 1  
                 @CurrentFilterId = UF.FilterId  
                ,@operator = UPPER(LTRIM(RTRIM(COALESCE(ST.Operator, N''))))  
                ,@filterValue = ST.[Value]  
                ,@groupID = ST.GroupId  
                ,@schemaName = LTRIM(RTRIM(COALESCE(ST.SchemaName, N'')))  
                ,@objectName = LTRIM(RTRIM(COALESCE(ST.ObjectName, N'')))  
                ,@operatorParameters = UPPER(LTRIM(RTRIM(COALESCE(ST.OperatorParameters, N''))))  
            FROM @UniqueFilters UF  
            INNER JOIN @SearchTable ST ON ST.ID = UF.FilterId  
            WHERE UF.Processed = 0;  
  
            --Validate the filter value if it is non-null  
            IF @filterValue IS NOT NULL  
            BEGIN  
                --Filter values larger than 255 chars are not allowed  
                IF (LEN(@filterValue) > 255)  
                    BEGIN  
                        RAISERROR('MDSERR100045|Filter criteria values can not be larger than 255 characters.', 16, 1);  
                        RETURN;  
                    END  
  
                --Replace any single quotes with double quotes to avoid SQL injection  
                SET @filterValue = REPLACE(@filterValue, '''', '''''');  
            END  
  
            SET @fullObjectName = CASE WHEN LEN(@schemaName) > 0 THEN QUOTENAME(@schemaName) + N'.' ELSE N'T.' END + QUOTENAME(@objectName);  
  
            DECLARE @isOperatorNegated  BIT = CASE WHEN @operator LIKE N'NOT %' THEN 1 ELSE 0 END,  
                    @isOperatorFuzzy    BIT = CASE WHEN @operator IN  
                        (N'NOT MATCH' COLLATE Latin1_General_CI_AS,  
                         N'MATCH'     COLLATE Latin1_General_CI_AS  
                        )  THEN 1 ELSE 0 END,  
                    @isOperatorRegex    BIT = CASE WHEN @operator IN  
                        (N'NOT REGEX' COLLATE Latin1_General_CI_AS,  
                         N'REGEX'     COLLATE Latin1_General_CI_AS  
                        )  THEN 1 ELSE 0 END,  
                    @isOperatorIsNull   BIT = CASE WHEN @operator IN  
                        (N'IS NOT NULL' COLLATE Latin1_General_CI_AS,  
                         N'IS NULL'     COLLATE Latin1_General_CI_AS  
                        )  THEN 1 ELSE 0 END,  
                    @isOperatorIn       BIT = CASE WHEN @operator IN  
                        (N'NOT IN' COLLATE Latin1_General_CI_AS,  
                         N'IN'     COLLATE Latin1_General_CI_AS  
                        )  THEN 1 ELSE 0 END  
            DECLARE @isOperatorValid    BIT = CASE WHEN @operator IN (  
                             N'='  
                            ,N'<>'  
                            ,N'LIKE'  
                            ,N'NOT LIKE'  
                            ,N'>'  
                            ,N'<'  
                            ,N'>='  
                            ,N'<=')  
                            OR @isOperatorFuzzy = 1  
                            OR @isOperatorRegex = 1  
                            OR @isOperatorIsNull = 1  
                            OR @isOperatorIn = 1  
                            THEN 1 ELSE 0 END;  
  
            IF (@isOperatorValid = 1  
                AND LEN(@fullObjectName) > 0  
                AND (@currentGroup <> @groupID OR @groupID = 0))  
            BEGIN  
                SET @currentGroup = @groupID;  
  
                IF (@isOperatorFuzzy = 1)  
                BEGIN  
  
                    -- do fuzzy match  
                    /*  
                     * Fuzzy matching requires operator parameters in this format: 'minSimilarity[ algorithm][ containmentBias]'  
                     *  
                     * minSimilarity: 0 <= value <= 1. Used by all algorithms.  
                     * algorithm:  
                     *      - 0 = Levenstein (default)  
                     *      - 1 = Jaccard  
                     *      - 2 = JaroWinkler  
                     *      - 3 = Longest Common Subsequence  
                     * lengthThreshold 0 <= value <= 1. Default = 0.62. Used only by Jaccard and Longest Common Subsequence algorithms.  
                     *  
                     * Example: '0.5 1 0.32' means use Jaccard algorithm with minSimilarity = 0.5 and containmentBias = 0.32  
                     */  
                    DECLARE @Levenstein  NVARCHAR(1)              = N'0',  
                            @Jaccard     NVARCHAR(1)              = N'1',  
                            @JaroWinkler NVARCHAR(1)              = N'2',  
                            @LongestCommonSubsequence NVARCHAR(1) = N'3';  
                    DECLARE @defaultAlgorithm NVARCHAR(1) = @Levenstein,  
                            @defaultLengthThreshold NVARCHAR(10) = N'0.62';  
  
                    DECLARE @minSimilarity NVARCHAR(100),  
                            @algorithm NVARCHAR(1),  
                            @lengthThreshold NVARCHAR(100)  
  
                    DECLARE @charIndex INT = CHARINDEX(N' ', @operatorParameters);  
                    IF @charIndex = 0  
                    BEGIN  
                        SET @minSimilarity = CONVERT(NVARCHAR(100), @operatorParameters)  
                    END ELSE  
                    BEGIN  
                        SET @minSimilarity = SUBSTRING(@operatorParameters, 1, @charIndex - 1);  
                        SET @operatorParameters = LTRIM(SUBSTRING(@operatorParameters, @charIndex, LEN(@operatorParameters)));  
                        SET @charIndex = CHARINDEX(N' ', @operatorParameters);  
                        IF @charIndex = 0  
                        BEGIN  
                            SET @algorithm = CONVERT(NVARCHAR(1), @operatorParameters);  
                        END ELSE  
                        BEGIN  
                            SET @algorithm = SUBSTRING(@operatorParameters, 1, @charIndex - 1);  
                            SET @lengthThreshold = LTRIM(SUBSTRING(@operatorParameters, @charIndex, LEN(@operatorParameters)));  
                        END;  
                    END;  
  
                    SET @algorithm = COALESCE(@algorithm, @defaultAlgorithm);  
                    SET @lengthThreshold = COALESCE(@lengthThreshold, @defaultLengthThreshold);  
  
                    -- validate parameters  
                    IF (ISNUMERIC(@minSimilarity) = 0)  
                    BEGIN  
                        RAISERROR('MDSERR100032|You must provide a valid similarity value for the fuzzy match operation.', 16, 1);  
                        RETURN;  
                    END  
                    IF (@algorithm NOT IN (@Levenstein, @Jaccard, @JaroWinkler, @LongestCommonSubsequence))  
                    BEGIN  
                        RAISERROR('MDSERR100033|You must provide a valid fuzzy match algorithm code.', 16, 1);  
                        RETURN;  
                    END  
                    IF (ISNUMERIC(@lengthThreshold) = 0)  
                    BEGIN  
                        RAISERROR('MDSERR100034|You must provide a valid containment bias value.', 16, 1);  
                        RETURN;  
                    END  
  
                    SET @filterClause = N'mdq.Similarity(' + @fullObjectName  
                        + N', N''' + @filterValue  
                        + N''', ' + @algorithm  
                        + N', ' + @lengthThreshold  
                        + N', '  
                        + CASE @isOperatorNegated  
                                WHEN 0 THEN @minSimilarity  
                                ELSE N'0.0'  
                        END --case  
                        + N')';  
  
                    --Add the match expression to the custom ORDER BY clause  
                    SET @SortTerm =  
                        CASE  
                            WHEN @SortTerm IS NULL THEN N''  
                            ELSE @SortTerm + N' + '  
                        END  
                        + N'  
                        '  
                        + CASE @isOperatorNegated  
                            WHEN 0 THEN @filterClause  
                            WHEN 1 THEN N'(1.0 - ' + @filterClause + N')'  
                        END; --case  
  
                    --Complete the rest of the predicate  
                    SET @filterClause =  
                        N'('  
                        + @filterClause  
                        + CASE @isOperatorNegated  
                            WHEN 0 THEN N' >= '  
                            WHEN 1 THEN N' < '  
                        END --case  
                        + @minSimilarity  
                        + N')';  
  
                END  
                ELSE IF (@isOperatorRegex = 1)  
                BEGIN  
  
                    -- do regular expression match  
  
                    -- This if statement is commented out because, for now, the desired behavior for an invalid  
                    -- regular expression is to allow an exception to be thrown when it is parsed.  
                    --IF (mdq.RegexIsValid(@filterValue) = 1)  
                    --BEGIN  
                    SET @filterClause = N'(mdq.RegexIsMatch(' + @fullObjectName + N', N''' + @filterValue + N''', ' + CONVERT(NVARCHAR(MAX), @regexMask) + N') '  
                    + CASE @isOperatorNegated  
                        WHEN 0 THEN N'='  
                        WHEN 1 THEN N'<>'  
                        END  
                    + N' 1)';  
                    --END  
                END  
                ELSE IF (@isOperatorIsNull = 1)  
                    BEGIN  
                        SET @filterClause = @fullObjectName + N' ' + @operator;  
                    END  
                ELSE IF (@isOperatorIn = 1)  
                    BEGIN  
                        SET @filterClause = @fullObjectName + N' ' + @operator + N' (SELECT [Value] FROM @SearchTable WHERE GroupId = ' + CONVERT(NVARCHAR(100), @groupID) + N')';  
                    END  
                ELSE  
                    BEGIN  
                        SET @filterClause = @fullObjectName + N' ' + @operator + N' N''' + @filterValue + N'''';  
                    END  
  
                IF @filterClause IS NOT NULL  
                BEGIN  
                    IF LEN(@SearchTerm) <> 0  
                    BEGIN  
                        SET @SearchTerm = @SearchTerm + N'  
                            AND ';  
                    END; --if  
                    SET @SearchTerm = @SearchTerm + @filterClause;  
                END; --if filterclause is not null  
            END; --if  
  
            UPDATE @UniqueFilters  
            SET Processed = 1  
            WHERE FilterId = @CurrentFilterId;  
        END;    --WHILE EXISTS(SELECT * FROM @UniqueFilters WHERE Processed = 0)  
    END; --EXISTS in @SearchTerm  
      
    SET @SearchTerm = NULLIF(@SearchTerm, N'');  
  
    IF (@SortTerm IS NOT NULL)  
    BEGIN  
        SET @SortTerm = N'(' + @SortTerm + N') DESC'  
    END  
    ELSE BEGIN  
        SET @SortTerm = N'';  
    END;  
  
END
GO
/****** Object:  StoredProcedure [mdm].[udpRestoreMaintenanceJobs]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
  
CREATE PROCEDURE [mdm].[udpRestoreMaintenanceJobs]  
(  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
AS BEGIN  
    DECLARE @databaseName SYSNAME = DB_NAME(),  
            @jobName SYSNAME,  
            @jobId UNIQUEIDENTIFIER,  
            @stepName SYSNAME,  
  
            @scheduleName SYSNAME,  
            @scheduleId INT;  
  
    SET @jobId = NULL;  
    SET @scheduleId = NULL;  
    SET @jobName = CONCAT(N'MDS_', @databaseName, N'_Index_Maintenance');  
    SELECT @jobId = job_id FROM [msdb].[dbo].[sysjobs_view] WHERE [name] = @jobName;  
    IF @jobId IS NULL  
    BEGIN  
        EXEC [msdb].[dbo].sp_add_job  
            @job_name = @jobName,  
            @job_id = @jobId OUTPUT;  
    END  
  
    SET @stepName = CONCAT(N'MDS_', @databaseName, N'_Index_Maintenance_TablePartition');  
    IF NOT EXISTS (  
        SELECT 1 FROM [msdb].[dbo].[sysjobsteps]  
        WHERE job_id = @jobId AND step_name = @stepName  
    )  
    BEGIN  
        EXEC [msdb].[dbo].sp_add_jobstep  
            @step_id = 1,  
            @job_id = @jobId,  
            @step_name = @stepName,  
            @subsystem = N'TSQL',  
            @command = N'EXEC [mdm].[udpTablePartitionCheck];',  
            @database_name = @databaseName,  
            @retry_attempts = 3,  
            @retry_interval = 60, -- 1 hour  
            @on_success_action = 3, -- Go to next step  
            @on_fail_action = 3; -- Go to next step  
    END  
  
    SET @stepName = CONCAT(N'MDS_', @databaseName, N'_Index_Maintenance_Defragmentation');  
    IF NOT EXISTS (  
        SELECT 1 FROM [msdb].[dbo].[sysjobsteps]  
        WHERE job_id = @jobId AND step_name = @stepName  
    )  
    BEGIN  
        EXEC [msdb].[dbo].sp_add_jobstep  
            @step_id = 2,  
            @job_id = @jobId,  
            @step_name = @stepName,  
            @subsystem = N'TSQL',  
            @command = N'EXEC [mdm].[udpDefragmentation];',  
            @database_name = @databaseName,  
            @retry_attempts = 3,  
            @retry_interval = 60, -- 1 hour  
            @on_success_action = 1, -- Quit with success  
            @on_fail_action = 1; -- Quit with success  
    END  
  
    SET @scheduleName = CONCAT(N'MDS_', @databaseName, N'_Index_Maintenance_Schedule');  
    SELECT @scheduleId = schedule_id FROM [msdb].[dbo].sysschedules WHERE name = @scheduleName;  
    IF @scheduleId IS NULL  
    BEGIN  
        EXEC [msdb].[dbo].sp_add_schedule  
            @schedule_name = @scheduleName,  
            @freq_type = 8, -- Weekly  
            @freq_interval = 64, -- Saturday  
            @freq_subday_type = 1, -- At the specified time  
            @freq_recurrence_factor = 1, -- Every 1 week  
            @active_start_time = 20000, -- 2AM  
            @schedule_id = @scheduleId OUTPUT;  
    END  
  
    IF NOT EXISTS(  
        SELECT 1 FROM [msdb].[dbo].[sysjobschedules]  
        WHERE job_id = @jobId AND schedule_id = @scheduleId  
    )  
    BEGIN  
        EXEC [msdb].[dbo].sp_attach_schedule  
            @job_id = @jobId,  
            @schedule_id = @scheduleId;  
    END  
  
    IF NOT EXISTS(  
        SELECT 1 FROM [msdb].[dbo].[sysjobservers]  
        WHERE job_id = @jobId  
    )  
    BEGIN  
        EXEC [msdb].[dbo].sp_add_jobserver  
            @job_id = @jobId;  
    END  
  
    SET @jobId = NULL;  
    SET @scheduleId = NULL;  
    SET @jobName = CONCAT(N'MDS_', @databaseName, N'_Log_Maintenance');  
    SELECT @jobId = job_id FROM [msdb].[dbo].[sysjobs_view] WHERE [name] = @jobName  
    IF @jobId IS NULL  
    BEGIN  
        EXEC [msdb].[dbo].sp_add_job  
            @job_name = @jobName,  
            @job_id = @jobId OUTPUT;  
    END  
  
    SET @stepName = CONCAT(N'MDS_', @databaseName, N'_Log_Maintenance_CleanUp');  
    IF NOT EXISTS (  
        SELECT 1 FROM [msdb].[dbo].[sysjobsteps]  
        WHERE job_id = @jobId AND step_name = @stepName  
    )  
    BEGIN  
        EXEC [msdb].[dbo].sp_add_jobstep  
            @job_id = @jobId,  
            @step_name = @stepName,  
            @subsystem = N'TSQL',  
            @command = N'EXEC [mdm].[udpLogCleanup];',  
            @database_name = @databaseName,  
            @retry_attempts = 3,  
            @retry_interval = 10; -- 10 minute  
    END  
  
    SET @scheduleName = CONCAT(N'MDS_', @databaseName, N'_Log_Maintenance_Schedule');  
    SELECT @scheduleId = schedule_id FROM [msdb].[dbo].sysschedules WHERE name = @scheduleName  
    IF @scheduleId IS NULL  
    BEGIN  
        EXEC [msdb].[dbo].sp_add_schedule  
            @schedule_name = @scheduleName,  
            @freq_type = 4, -- Daily  
            @freq_interval = 1, -- Every Day  
            @freq_subday_type = 1, -- At the specified time  
            @active_start_time = 20000 , -- 2AM  
            @schedule_id = @scheduleId OUTPUT;  
   END  
  
    IF NOT EXISTS(  
        SELECT 1 FROM [msdb].[dbo].[sysjobschedules]  
        WHERE job_id = @jobId AND schedule_id = @scheduleId  
    )  
    BEGIN  
        EXEC [msdb].[dbo].sp_attach_schedule  
            @job_id = @jobId,  
            @schedule_id = @scheduleId;  
    END  
  
    IF NOT EXISTS(  
        SELECT 1 FROM [msdb].[dbo].[sysjobservers]  
        WHERE job_id = @jobId  
    )  
    BEGIN  
        EXEC [msdb].[dbo].sp_add_jobserver  
            @job_id = @jobId;  
    END  
  
  
    -- Sync  
  
    SET @jobId = NULL;  
    SET @scheduleId = NULL;  
    SET @jobName = CONCAT(N'MDS_', @databaseName, N'_Sync');  
    SELECT @jobId = job_id FROM [msdb].[dbo].[sysjobs_view] WHERE [name] = @jobName;  
    IF @jobId IS NULL  
    BEGIN  
        EXEC [msdb].[dbo].sp_add_job  
            @job_name = @jobName,  
            @job_id = @jobId OUTPUT;  
    END  
  
    SET @stepName = CONCAT(N'MDS_', @databaseName, N'_Sync_Refresh');  
    IF NOT EXISTS (  
        SELECT 1 FROM [msdb].[dbo].[sysjobsteps]  
        WHERE job_id = @jobId AND step_name = @stepName  
    )  
    BEGIN  
        EXEC [msdb].[dbo].sp_add_jobstep  
            @job_id = @jobId,  
            @step_name = @stepName,  
            @subsystem = N'TSQL',  
            @command = N'EXEC [mdm].[udpSyncRefreshJob];',  
            @database_name = @databaseName,  
            @retry_attempts = 3,  
            @retry_interval = 5; -- minutes  
    END  
  
    SET @scheduleName = CONCAT(N'MDS_', @databaseName, N'_Sync_Refresh_Schedule');  
    SELECT @scheduleId = schedule_id FROM [msdb].[dbo].sysschedules WHERE name = @scheduleName;  
    IF @scheduleId IS NULL  
    BEGIN  
        EXEC [msdb].[dbo].sp_add_schedule  
            @schedule_name = @scheduleName,  
            @freq_type = 4, -- Daily  
            @freq_interval = 1, -- every 1 day  
            @freq_subday_type = 0x8, -- Hours  
            @freq_subday_interval  = 1, -- every 1 hour  
            @freq_relative_interval = 0,  
            @freq_recurrence_factor = 1, -- Every 1 hour  
            @schedule_id = @scheduleId OUTPUT;  
    END  
  
    IF NOT EXISTS(  
        SELECT 1 FROM [msdb].[dbo].[sysjobschedules]  
        WHERE job_id = @jobId AND schedule_id = @scheduleId  
    )  
    BEGIN  
        EXEC [msdb].[dbo].sp_attach_schedule  
            @job_id = @jobId,  
            @schedule_id = @scheduleId;  
    END  
  
    IF NOT EXISTS(  
        SELECT 1 FROM [msdb].[dbo].[sysjobservers]  
        WHERE job_id = @jobId  
    )  
    BEGIN  
        EXEC [msdb].[dbo].sp_add_jobserver  
            @job_id = @jobId  
    END  
END
GO
/****** Object:  StoredProcedure [mdm].[udpSecurityGroupsGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    Returns the specified groups.  
      
    DECLARE @GroupTable mdm.Identifier  
    EXEC mdm.udpSecurityGroupsGet   
        @GroupTable = @GroupTable  
*/  
CREATE PROCEDURE [mdm].[udpSecurityGroupsGet]  
(  
    @GroupTable mdm.Identifier READONLY,-- caller should ensure table does not include rows where both MUID and Name are blank  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    IF EXISTS(SELECT 1 FROM @GroupTable)  
    BEGIN  
        SELECT   
            g.ID,  
            g.MUID,  
            g.SID,  
            g.UserGroupType_ID,  
            g.Name,  
            g.Description,  
            COALESCE(g.EnterUserID, 0) AS EnterUserID,  
            eu.MUID AS EnterUserMUID,  
            COALESCE(eu.UserName, N'') AS EnterUserName,  
            COALESCE(eu.DisplayName, N'') AS EnterUserDisplayName,  
            g.EnterDTM,  
            COALESCE(g.LastChgUserID, 0) AS LastChgUserID,  
            lcu.MUID AS LastChgUserMUID,  
            COALESCE(lcu.UserName, N'') AS LastChgUserName,  
            COALESCE(lcu.DisplayName, N'') AS LastChgUserDisplayName,  
            g.LastChgDTM  
        FROM mdm.tblUserGroup g  
        INNER JOIN @GroupTable crit  
        ON   
            g.Status_ID = 1 AND   
            (crit.MUID IS NOT NULL OR crit.Name IS NOT NULL OR crit.ID IS NOT NULL) AND  
            (crit.MUID IS NULL OR crit.MUID = g.MUID) AND  
            (crit.Name IS NULL OR UPPER(crit.Name) = UPPER(g.Name)) AND  
            (crit.ID IS NULL OR crit.ID = g.ID)  
        LEFT JOIN mdm.tblUser eu   
        ON g.EnterUserID = eu.ID   
        LEFT JOIN mdm.tblUser lcu   
        ON g.LastChgUserID = lcu.ID  
        ORDER BY g.ID;  
    END ELSE  
    BEGIN  
        SELECT   
            g.ID,  
            g.MUID,  
            g.SID,  
            g.UserGroupType_ID,  
            g.Name,  
            g.Description,  
            COALESCE(g.EnterUserID, 0) AS EnterUserID,  
            eu.MUID AS EnterUserMUID,  
            COALESCE(eu.UserName, N'') AS EnterUserName,  
            COALESCE(eu.DisplayName, N'') AS EnterUserDisplayName,  
            g.EnterDTM,  
            COALESCE(g.LastChgUserID, 0) AS LastChgUserID,  
            lcu.MUID AS LastChgUserMUID,  
            COALESCE(lcu.UserName, N'') AS LastChgUserName,  
            COALESCE(lcu.DisplayName, N'') AS LastChgUserDisplayName,  
            g.LastChgDTM  
        FROM mdm.tblUserGroup g  
        LEFT JOIN mdm.tblUser eu   
        ON g.EnterUserID = eu.ID   
        LEFT JOIN mdm.tblUser lcu   
        ON g.LastChgUserID = lcu.ID  
        WHERE g.Status_ID = 1  
        ORDER BY g.ID;  
    END  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpSecurityHierarchyMemberPrivilegesGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    Returns the specified groups.  
  
    DECLARE @RoleAccessTable mdm.Identifier  
    EXEC udpSecurityHierarchyMemberPrivilegesGet  
        @SystemUser_ID          = 1,  
        @Permission_ID          = NULL,  
        @Model_MUID             = NULL,  
        @Model_Name             = NULL,  
        @Entity_MUID            = NULL,  
        @Entity_Name            = NULL,  
        @Hierarchy_MUID         = NULL,  
        @Hierarchy_Name         = NULL,  
        @HierarchyType_ID       = NULL,  
        @Principal_MUID         = NULL,  
        @Principal_Name         = NULL,  
        @PrincipalType_ID       = NULL,  
        @RoleAccessTable        = @RoleAccessTable  
*/  
CREATE PROCEDURE [mdm].[udpSecurityHierarchyMemberPrivilegesGet]  
(  
    @SystemUser_ID          INT, -- The user requesting the permissions  
    @Permission_ID          INT = NULL,  
    @AccessPermission_ID    TINYINT = NULL,  
    @Model_MUID             UNIQUEIDENTIFIER = NULL,  
    @Model_Name             NVARCHAR(100) = NULL,  
    @Entity_MUID            UNIQUEIDENTIFIER = NULL,  
    @Entity_Name            NVARCHAR(MAX) = NULL,  
    @Hierarchy_MUID         UNIQUEIDENTIFIER = NULL,  
    @Hierarchy_Name         NVARCHAR(100) = NULL,  
    @HierarchyType_ID       INT = NULL,  
    @Principal_MUID         UNIQUEIDENTIFIER = NULL,  
    @Principal_Name         NVARCHAR(355) = NULL, -- max user group name length  
    @PrincipalType_ID       INT = NULL,  
    @RoleAccessTable        mdm.Identifier READONLY,-- caller should ensure table does not include rows where both MUID and Name are blank  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    IF(EXISTS (SELECT 1 FROM sys.sysobjects WHERE name = '#tblPrivileges'))  
    BEGIN  
        DROP TABLE #tblPrivileges;  
    END  
  
    DECLARE @PrincipalType_User TINYINT = 1;  
  
    CREATE TABLE #tblPrivileges(  
               [RoleAccess_ID]      INT  
              ,[RoleAccess_MUID]    UNIQUEIDENTIFIER  
              ,[Privilege_ID]       INT  
              ,[AccessPermission]   TINYINT  
              ,[PrincipalType_ID]   TINYINT  
              ,[Principal_ID]       INT  
              ,[Principal_MUID]     UNIQUEIDENTIFIER  
              ,[Principal_Name]     NVARCHAR(100) COLLATE DATABASE_DEFAULT  
              ,[Model_ID]           INT  
              ,[Model_MUID]         UNIQUEIDENTIFIER  
              ,[Model_Name]         NVARCHAR(100) COLLATE DATABASE_DEFAULT  
              ,[Version_ID]         INT  
              ,[Version_MUID]       UNIQUEIDENTIFIER  
              ,[Version_Name]       NVARCHAR(100) COLLATE DATABASE_DEFAULT  
              ,[Entity_ID]          INT  
              ,[Entity_MUID]        UNIQUEIDENTIFIER  
              ,[Entity_Name]        NVARCHAR(MAX) COLLATE DATABASE_DEFAULT  
              ,[HierarchyType_ID]   TINYINT  
              ,[Hierarchy_ID]       INT  
              ,[Hierarchy_MUID]     UNIQUEIDENTIFIER  
              ,[Hierarchy_Name]     NVARCHAR(250) COLLATE DATABASE_DEFAULT  
              ,[MemberType_ID]      TINYINT  
              ,[Member_ID]          INT  
              ,[Member_MUID]        UNIQUEIDENTIFIER  
              ,[Member_Name]        NVARCHAR(250) COLLATE DATABASE_DEFAULT  
              ,[Member_Code]        NVARCHAR(250) COLLATE DATABASE_DEFAULT  
              ,EnterUserID          INT  
              ,EnterUserMUID        UNIQUEIDENTIFIER  
              ,EnterUser            NVARCHAR(256) COLLATE DATABASE_DEFAULT  
              ,EnterDTM             DATETIME2(2)  
              ,LastChgUserID        INT  
              ,LastChgUserMUID      UNIQUEIDENTIFIER  
              ,LastChgUser          NVARCHAR(256) COLLATE DATABASE_DEFAULT  
              ,LastChgDTM           DATETIME2(2)  
              ,IsModelAdministrator BIT  
                );  
  
    DECLARE @MemberIds TABLE (  
        ID                       INT IDENTITY (1, 1) NOT NULL,  
        Version_ID               INT,  
        Entity_ID                INT,  
        MemberType_ID            INT,  
        TableName                NVARCHAR(100) COLLATE DATABASE_DEFAULT  
            );  
  
    INSERT INTO #tblPrivileges  
    SELECT  
         r.RoleAccess_ID  
        ,r.RoleAccess_MUID  
        ,r.Privilege_ID  
        ,r.AccessPermission  
        ,r.PrincipalType_ID  
        ,r.Principal_ID  
        ,r.Principal_MUID  
        ,r.Principal_Name  
        ,r.Model_ID  
        ,r.Model_MUID  
        ,r.Model_Name  
        ,r.Version_ID  
        ,r.Version_MUID  
        ,r.Version_Name  
        ,r.Entity_ID  
        ,r.Entity_MUID  
        ,r.Entity_Name  
        ,r.HierarchyType_ID  
        ,r.Hierarchy_ID  
        ,r.Hierarchy_MUID  
        ,r.Hierarchy_Name  
        ,r.MemberType_ID  
        ,r.Member_ID  
        ,NULL Member_MUID  
        ,NULL Member_Name  
        ,NULL Member_Code  
        ,r.EnterUserID  
        ,r.EnterUserMUID  
        ,r.EnterUser  
        ,r.EnterDTM  
        ,r.LastChgUserID  
        ,r.LastChgUserMUID  
        ,r.LastChgUser  
        ,r.LastChgDTM  
        ,CASE modSec.Privilege_ID WHEN 5 /*Admin*/ THEN 1 ELSE 0 END IsModelAdministrator  
    FROM mdm.viw_SYSTEM_SECURITY_ROLE_ACCESSCONTROL_MEMBER r  
    INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_MODEL sysModelSec -- Gets the model permission of the user requesting the permissions.  
    ON      sysModelSec.User_ID = @SystemUser_ID  
        AND sysModelSec.ID = r.Model_ID  
    LEFT JOIN mdm.viw_SYSTEM_SECURITY_USER_MODEL modSec -- Gets the model permissions of the principal (user only) being requested.  
    ON      modSec.ID = r.Model_ID  
        AND modSec.User_ID = r.Principal_ID  
        AND r.PrincipalType_ID = @PrincipalType_User  
    WHERE  (   sysModelSec.Privilege_ID = 5 /*Admin*/                                         -- To see permissions, the requesting user must either be a model admin ...  
            OR (@SystemUser_ID = r.Principal_ID AND @PrincipalType_ID = @PrincipalType_User)) -- ... or asking for his own permissions  
  
    -- apply additional filtering  
    IF EXISTS(SELECT 1 FROM @RoleAccessTable)  
    BEGIN  
        DELETE p  
        FROM #tblPrivileges p  
        LEFT JOIN @RoleAccessTable crit  
        ON      p.RoleAccess_MUID = ISNULL(crit.MUID, p.RoleAccess_MUID)  
            AND p.RoleAccess_ID = ISNULL(crit.ID, p.RoleAccess_ID)  
        WHERE crit.ID IS NULL AND crit.MUID IS NULL  
    END  
  
    DECLARE @PrincialNameUpper NVARCHAR(355) = UPPER(@Principal_Name);  
    IF (@Permission_ID IS NOT NULL AND @Permission_ID > 0)  
        DELETE FROM #tblPrivileges WHERE Privilege_ID       <> @Permission_ID;  
    IF (@AccessPermission_ID IS NOT NULL)  
        DELETE FROM #tblPrivileges WHERE AccessPermission <> @AccessPermission_ID;  
    IF (@Model_MUID IS NOT NULL)  
        DELETE FROM #tblPrivileges WHERE Model_MUID         <> @Model_MUID;  
    IF (@Model_Name IS NOT NULL)  
        DELETE FROM #tblPrivileges WHERE Model_Name         <> @Model_Name;  
    IF (@Entity_MUID IS NOT NULL)  
        DELETE FROM #tblPrivileges WHERE Entity_MUID        <> @Entity_MUID;  
    IF (@Entity_Name IS NOT NULL)  
        DELETE FROM #tblPrivileges WHERE Entity_Name        <> @Entity_Name;  
    IF (@Hierarchy_MUID IS NOT NULL)  
        DELETE FROM #tblPrivileges WHERE Hierarchy_MUID     <> @Hierarchy_MUID;  
    IF (@Hierarchy_Name IS NOT NULL)  
        DELETE FROM #tblPrivileges WHERE Hierarchy_Name     <> @Hierarchy_Name;  
    DECLARE @HierarchyType_All INT = 3; -- constant  
    IF (@HierarchyType_ID IS NOT NULL AND @HierarchyType_ID <> @HierarchyType_All)  
        DELETE FROM #tblPrivileges WHERE HierarchyType_ID   <> @HierarchyType_ID;  
    IF (@Principal_MUID IS NOT NULL)  
        DELETE FROM #tblPrivileges WHERE Principal_MUID     <> @Principal_MUID;  
    IF (@Principal_Name IS NOT NULL)  
        DELETE FROM #tblPrivileges WHERE UPPER(Principal_Name)     <> @PrincialNameUpper;  
    IF (@PrincipalType_ID IS NOT NULL AND @PrincipalType_ID > 0)  
        DELETE FROM #tblPrivileges WHERE PrincipalType_ID   <> @PrincipalType_ID;  
  
    INSERT INTO @MemberIds (Version_ID, Entity_ID, MemberType_ID, TableName)  
    SELECT DISTINCT  
        Version_ID,  
        Entity_ID,  
        MemberType_ID,  
        mdm.udfTableNameGetByID(Entity_ID, MemberType_ID)  
    FROM #tblPrivileges  
    WHERE Member_ID > 0 -- Ignore ROOT and MDMUNUSED (they will be handled later)  
  
    DECLARE  
        @ID             INT,  
        @SQL            NVARCHAR(MAX),  
        @Version_ID     INT,  
        @Entity_ID      INT,  
        @MemberType_ID  INT,  
        @TableName      SYSNAME,  
        @ParamList      NVARCHAR(MAX) = N'  
            @Version_ID INT,  
            @Entity_ID INT,  
            @MemberType_ID INT';  
  
    --Update the Member_Name and Member_MUID columns  
    WHILE EXISTS(SELECT 1 FROM @MemberIds)  
    BEGIN  
        SELECT TOP 1  
             @ID = ID  
            ,@Version_ID = Version_ID  
            ,@Entity_ID = Entity_ID  
            ,@TableName = TableName  
            ,@MemberType_ID = MemberType_ID  
        FROM @MemberIds  
        ORDER BY ID;  
  
        SET @SQL = N'  
        UPDATE p  
        SET  Member_Name        = Name  
            ,Member_MUID        = MUID  
            ,Member_Code        = Code  
        FROM  mdm.' + QUOTENAME(@TableName) + N' T  
        INNER JOIN #tblPrivileges p  
        ON      T.ID = p.Member_ID  
            AND T.Version_ID = @Version_ID  
            AND p.Entity_ID = @Entity_ID  
            AND p.MemberType_ID = @MemberType_ID';  
  
        EXEC sp_executesql @SQL, @ParamList,  
            @Version_ID, @Entity_ID, @MemberType_ID;  
  
        DELETE FROM @MemberIds WHERE ID = @ID;  
    END  
  
    --Update the privileges where id is 0 or less.  
    UPDATE #tblPrivileges  
    SET  Member_Name = N'ROOT'  
        ,Member_Code = N'ROOT'  
    WHERE Member_ID = 0 ;  
    UPDATE #tblPrivileges  
    SET  Member_Name = CASE  
            WHEN Member_ID = -1 THEN NULL -- Top-level unused node  
            ELSE CONVERT(NVARCHAR, ABS(Member_ID) - 10) END -- Level number for level-specific unused node.  
        ,Member_Code = N'MDMUNUSED'  
    WHERE Member_ID < 0;  
  
    SELECT * -- It is generally considered bad practice to do a "SELECT *" because of maintainability issues if the table schema changes. But in this case, it is a temp table that is defined inside of this sproc, so it is okay.  
    FROM #tblPrivileges  
    ORDER BY  
        Hierarchy_Name,  
        Member_Name,  
        Privilege_ID;  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpSecurityMemberProcess]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    Populates the member security (MS) table for a specific entity, using the following rules:  
    1)    Within a single hierarchy, single role, an explicit DENY always wins throughout its sub-tree,  
        regardless of any descendant's other security assignments.  
    2)    Within a single hierarchy, single role, the closest assignment to a member wins.  
        So if there is a READ closer than an earlier WRITE then the READ wins  
    3)    Across 2 or more hierarchies, in a single role, the most restrictive permission should prevail.  
        So if a specific member in two hierarchies has H1=READ and H2=WRITE then READ wins  
    4)    Across 2 or more roles, 1 or more hierarchies, the least restrictive permission wins.  
        So if a specific member in two roles has R1=READ and R2=WRITE then WRITE wins  
  
    Test cases:  
    EXEC mdm.udpSecurityMemberProcess @Entity_ID = 7, @Version_ID = 4;  
    EXEC mdm.udpSecurityMemberProcess @Entity_ID = 8, @Version_ID = 4;  
    EXEC mdm.udpSecurityMemberProcess @Entity_ID = 41, @Version_ID = 21;  
    EXEC mdm.udpSecurityMemberProcess @Entity_ID = 36, @Version_ID = 20;  
    SELECT en.ID AS Entity_ID, md.ID AS Model_ID, mv.ID AS Version_ID FROM mdm.tblEntity AS en INNER JOIN mdm.tblModel AS md ON (en.Model_ID = md.ID) INNER JOIN mdm.tblModelVersion AS mv ON (md.ID = mv.Model_ID)  
    SELECT * FROM mdm.tbl_2_7_EN_MS;  
    SELECT * FROM mdm.tblHierarchy  
    SELECT * FROM mdm.tblDerivedHierarchy  
    SELECT * FROM mdm.tblDerivedHierarchyDetail  
    SELECT * FROM mdm.tblSecurityRoleAccessMember WHERE Entity_ID = 7 AND Version_ID = 4  
    DELETE FROM mdm.tblSecurityRoleAccessMember WHERE Entity_ID = 8  
    UPDATE mdm.tblSecurityRoleAccessMember SET HierarchyType_ID = 0 WHERE Entity_ID = 8 AND Version_ID = 4 AND Hierarchy_ID = 7  
  
    --ALTER DATABASE MDM_Sample SET SINGLE_USER WITH ROLLBACK IMMEDIATE;  
    --ALTER DATABASE MDM_Sample SET MULTI_USER;  
    --ALTER DATABASE MDM_Sample SET READ_COMMITTED_SNAPSHOT ON;  
*/  
CREATE PROCEDURE [mdm].[udpSecurityMemberProcess]  
(  
    @Entity_ID  INT,  
    @Version_ID INT,  
    @UserIdList mdm.IdList READONLY, -- Optional list of user IDs whose member count cache will be invalidated. If none are specified, then all users will have their cache invalidated.  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
AS BEGIN  
    SET NOCOUNT ON;  
  
    /*=================================================================  
      Declare variables, check parameters, initialize structures  
      =================================================================*/  
  
    DECLARE  
         @Model_ID                  INT  
        ,@SQL                       NVARCHAR(MAX)  
        ,@table_EN_MS               SYSNAME  
        ,@table_HP_MS               SYSNAME  
        ,@table_HR                  SYSNAME  
        ,@SecurityRole_ID           INT  
        ,@DerivedHierarchy_ID       INT  
        ,@AnchorNullRecursions      BIT  
        ,@UseUserIds                BIT = 0  
  
        -- Hierarchy types  
        ,@HierarchyType_Explicit    TINYINT = 0  
        ,@HierarchyType_Derived     TINYINT = 1  
  
        --Member Types  
        ,@MemberType_Leaf           TINYINT = 1  
        ,@MemberType_Consolidated   TINYINT = 2  
        ,@MemberType_Collection     TINYINT = 3  
  
        --Hierarchy item types (a.k.a. "ForeignType_ID")  
        ,@HierarchyItemType_Entity          TINYINT = 0  
        ,@HierarchyItemType_DBA             TINYINT = 1  
        ,@HierarchyItemType_Hierarchy       TINYINT = 2  
        ,@HierarchyItemType_ConsolidatedDBA TINYINT = 3  
  
        --Permission  
        ,@Permission_None           INT = 0  
        ,@Permission_Deny           INT = 1  
        ,@Permission_Access         INT = 4  
        ,@Permission_Inferred       INT = 99  
  
        -- This pseudo-constant is for use in string concatenation operations to prevent string truncation. When concatenating two or more strings,  
        -- if none of the strings is an NVARCHAR(MAX) or an NVARCHAR constant that is longer than 4,000 characters, then the resulting string  
        -- will be silently truncated to 4,000 characters. Concatenating with this empty NVARCHAR(MAX), is sufficient to prevent truncation.  
        -- See http://connect.microsoft.com/SQLServer/feedback/details/283368/nvarchar-max-concatenation-yields-silent-truncation.  
        ,@TruncationGuard            NVARCHAR(MAX) = N'';  
  
    --Validate that @Entity_ID is both specified and valid  
    IF @Entity_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR100004|The Entity ID is not valid.', 16, 1);  
        RETURN;  
    END; --if  
  
    IF @Version_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR100005|The Version ID is not valid.', 16, 1);  
        RETURN;  
    END; --if  
  
    --Try populate variables based on input parameters. If specific variables  
    --are still NULL after the query, that implies that an invalid combination  
    --of parameters was passed in.  
    SELECT  
        @Model_ID = en.Model_ID,  
        @table_EN_MS = CAST(en.EntityTable + '_MS' AS SYSNAME),  
        @table_HR = en.HierarchyTable,  
        @table_HP_MS = CASE WHEN HierarchyParentTable IS NOT NULL THEN CAST(HierarchyParentTable + '_MS' AS SYSNAME) ELSE NULL END  
    FROM mdm.tblEntity AS en  
    INNER JOIN mdm.tblModelVersion AS mv  
    ON en.Model_ID = mv.Model_ID  
    WHERE   en.ID = @Entity_ID  
        AND mv.ID = @Version_ID;  
  
    IF @Model_ID IS NULL  
    BEGIN  
        -- If the entity/version is not found, then it may have been deleted since the message was added to the queue.  
        -- Rather than raise an error, just return.  
        RETURN;  
    END; --if  
  
    --Cache all the security assignments in a form that saves us some computation later  
    CREATE TABLE #assignments  
    (  
        SecurityRole_ID         INT NOT NULL, --The Security Role that has this assignment.  
        Entity_ID               INT NOT NULL, --The Entity_ID that is secured. Ignored (value 0) for VirtualRoots.  
        ExplicitHierarchy_ID    INT NULL, --\ These two columns are mutually exclusive.  
        DerivedHierarchy_ID     INT NULL, --/ They point to the hierarchy that is secured.  
        EN_ID                   INT NULL, --\ These two columns are mutually exclusive. Both are NULL for VirtualRoots.  
        HP_ID                   INT NULL, --/ They point to the member row that is secured.  
        IsVirtualRoot           BIT NOT NULL, --A VirtualRoot is a non-material row providing a single place to secure the entire hierarchy.  
        Privilege_ID            INT NOT NULL, --1=DENY, 4=Access  
        AccessPermission        TINYINT NOT NULL,  
        SRAM_ID                 INT NOT NULL, --ID from mdm.tblSecurityRoleAccessMember  
        IsProcessed             BIT NOT NULL  --Loop counter to keep track of which settings have been applied  
    ); --create table  
    CREATE CLUSTERED INDEX ix_assignments ON #assignments(SecurityRole_ID, Entity_ID, ExplicitHierarchy_ID, DerivedHierarchy_ID, IsVirtualRoot, EN_ID, HP_ID);  
    CREATE INDEX ix_assignments_DerivedHierarchy_ID ON #assignments(DerivedHierarchy_ID);  
  
    CREATE TABLE #userIds  
    (  
        ID INT PRIMARY KEY  
    )  
  
    INSERT #userIds (ID)  
    SELECT DISTINCT ID  
    FROM @UserIdList  
  
    IF EXISTS (SELECT 1 FROM #userIds)  
    BEGIN  
        SET @UseUserIds = 1;  
    END  
  
    PRINT CONCAT(SYSDATETIME(), ': Started creating member security items for Entity_ID: ', @Entity_ID, ' and Version_ID: ', @Version_ID);  
  
    IF @UseUserIds = 0  
    BEGIN  
        --Populate the #assignments temporary table with just the data relevant to this model/version.  
        --For the explicit hierarchy assignments, load just the specified entity  
        --For the derived hierarchy assignments, load all entities in the model of the specified entity  
        INSERT INTO #assignments(SecurityRole_ID, Entity_ID, ExplicitHierarchy_ID, DerivedHierarchy_ID, EN_ID, HP_ID, IsVirtualRoot, Privilege_ID, AccessPermission, SRAM_ID, IsProcessed)  
        SELECT DISTINCT  
            sr.Role_ID,  
            CASE sr.HierarchyType_ID  
                WHEN @HierarchyType_Explicit THEN sr.Entity_ID  
                ELSE CASE  
                    WHEN sr.Member_ID = 0 THEN 0 --Entity_ID ignored for DH VirtualRoot records  
                    ELSE sr.Entity_ID  
                END  
            END, --case  
            CASE sr.HierarchyType_ID WHEN @HierarchyType_Explicit THEN sr.Hierarchy_ID ELSE NULL END, --ExplicitHierarchy_ID  
            CASE sr.HierarchyType_ID WHEN @HierarchyType_Derived  THEN sr.Hierarchy_ID ELSE NULL END, --DerivedHierarchy_ID  
            CASE sr.MemberType_ID WHEN @MemberType_Leaf         THEN sr.Member_ID            ELSE NULL END, --EN_ID  
            CASE sr.MemberType_ID WHEN @MemberType_Consolidated THEN NULLIF(sr.Member_ID, 0) ELSE NULL END, --HP_ID  
            CASE WHEN sr.Member_ID = 0 THEN 1 ELSE 0 END, --IsVirtualRoot  
            sr.Privilege_ID,  
            sr.AccessPermission,  
            sr.ID,  
            0 --IsProcessed=False  
        FROM mdm.tblEntity AS en  
        INNER JOIN mdm.tblSecurityRoleAccessMember AS sr  
        ON en.ID = sr.Entity_ID  
        WHERE sr.Version_ID = @Version_ID  
            AND (sr.Entity_ID = @Entity_ID OR sr.HierarchyType_ID = @HierarchyType_Derived); --Requested entity for EH, and all model's entities for DH  
    END  
    ELSE  
    BEGIN  
        --Populate the #assignments temporary table with just the data relevant to this model/version.  
        --For the explicit hierarchy assignments, load just the specified entity  
        --For the derived hierarchy assignments, load all entities in the model of the specified entity  
        INSERT INTO #assignments(SecurityRole_ID, Entity_ID, ExplicitHierarchy_ID, DerivedHierarchy_ID, EN_ID, HP_ID, IsVirtualRoot, Privilege_ID, AccessPermission, SRAM_ID, IsProcessed)  
        SELECT DISTINCT  
            sr.Role_ID,  
            CASE sr.HierarchyType_ID  
                WHEN @HierarchyType_Explicit THEN sr.Entity_ID  
                ELSE CASE  
                    WHEN sr.Member_ID = 0 THEN 0 --Entity_ID ignored for DH VirtualRoot records  
                    ELSE sr.Entity_ID  
                END  
            END, --case  
            CASE sr.HierarchyType_ID WHEN @HierarchyType_Explicit THEN sr.Hierarchy_ID ELSE NULL END, --ExplicitHierarchy_ID  
            CASE sr.HierarchyType_ID WHEN @HierarchyType_Derived  THEN sr.Hierarchy_ID ELSE NULL END, --DerivedHierarchy_ID  
            CASE sr.MemberType_ID WHEN @MemberType_Leaf         THEN sr.Member_ID            ELSE NULL END, --EN_ID  
            CASE sr.MemberType_ID WHEN @MemberType_Consolidated THEN NULLIF(sr.Member_ID, 0) ELSE NULL END, --HP_ID  
            CASE WHEN sr.Member_ID = 0 THEN 1 ELSE 0 END, --IsVirtualRoot  
            sr.Privilege_ID,  
            sr.AccessPermission,  
            sr.ID,  
            0 --IsProcessed=False  
        FROM mdm.tblEntity AS en  
        INNER JOIN mdm.tblSecurityRoleAccessMember AS sr  
        ON en.ID = sr.Entity_ID  
        INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_ROLE AS ur  
        ON sr.Role_ID = ur.Role_ID  
        INNER JOIN #userIds AS uids  
        ON uids.ID = ur.[User_ID]  
        WHERE sr.Version_ID = @Version_ID  
            AND (sr.Entity_ID = @Entity_ID OR sr.HierarchyType_ID = @HierarchyType_Derived); --Requested entity for EH, and all model's entities for DH  
    END  
  
    --Create a temporary table to hold the intermediate values. We need a staging  
    --area since maps from different hierarchies in the entity will create duplicate  
    --and overlapping entries.  
    CREATE TABLE #map  
    (  
        SecurityRole_ID     INT NOT NULL,  
        MemberType_ID       TINYINT NOT NULL,  
        ID                  INT NULL,  
        Privilege_ID        INT NOT NULL,  
        AccessPermission    TINYINT NULL  
    ); --create table  
    CREATE CLUSTERED INDEX #ix_map ON #map(SecurityRole_ID, MemberType_ID, ID);  
  
    --Effective permission for each user  
    CREATE TABLE #effectivePermissions  
    (  
        MemberType_ID       TINYINT NOT NULL,  
        [User_ID]           INT NOT NULL,  
        ID                  INT NOT NULL,  
        AccessPermission    TINYINT NOT NULL  
    ); --create table  
    CREATE UNIQUE CLUSTERED INDEX #ix_effectivePermissions ON #effectivePermissions(MemberType_ID, [User_ID], ID);  
  
    /*=================================================================  
      Explicit Hierarchy analysis  
      =================================================================*/  
  
    --Don't do anything if explicit hierarchies do not exist for this entity, or there are no relevant security assignments  
    IF @table_HR IS NOT NULL AND EXISTS(SELECT 1 FROM #assignments WHERE ExplicitHierarchy_ID IS NOT NULL AND IsProcessed = 0)  
    BEGIN  
        PRINT CONCAT(SYSDATETIME(), N': Started writing Explicit Hierarchy permissions to #map');  
        --Note that there may be multiple rows with the same SecurityRole_ID, so we use TOP 1  
        SELECT TOP 1 @SecurityRole_ID = SecurityRole_ID FROM #assignments WHERE ExplicitHierarchy_ID IS NOT NULL AND IsProcessed = 0 ORDER BY SecurityRole_ID;  
  
        --Stage the security data from any explicit hierarchies associated with the entity  
        --Filter the SRAM table to get only the rows within context of the current request  
        --Since the Privilege_ID enum is not in the order of least-privilege.  
        SET @SQL = N'  
            CREATE TABLE #stage  
            (  
                 IsVirtualRoot          BIT  
                ,ExplicitHierarchy_ID   INT  
                ,Parent_HP_ID           INT  
                ,Child_EN_ID            INT  
                ,Child_HP_ID            INT  
                ,Privilege_ID           TINYINT  
                ,AccessPermission       TINYINT  
            );  
  
            WITH sram AS  
            (    --Filter the SRAM table to get only the rows within context of the current request  
                SELECT ExplicitHierarchy_ID, EN_ID, HP_ID, IsVirtualRoot, Privilege_ID, AccessPermission  
                FROM #assignments WHERE  
                    SecurityRole_ID = @SecurityRole_ID AND --Current Security Role  
                    Entity_ID = @Entity_ID AND --Requested Entity  
                    ExplicitHierarchy_ID IS NOT NULL --Only want Explicit Hierarchies  
                    AND IsProcessed = 0  
            ),';  
  
        --Virtual roots: The user can assign a permission to the root of the hierarchy.  
        --However the root is a UE/security concept and does not exist in the actual tables.  
        --We need a virtual root member for each hierarchy for each role specified anywhere in the tree.  
        --All members that inherit directly from the virtual root have their Parent_HP_ID set to NULL.  
        --We create virtual roots regardless of whether the root is assigned explicit permissions,  
        --since we need to cater for the degenerate case (hence the LEFT join)  
        SET @SQL = @SQL + N'  
            virtualRoots AS  
            (    --Virtual roots    (with or without security assignments)  
                SELECT DISTINCT  
                    hr.Hierarchy_ID AS ExplicitHierarchy_ID,  
                    NULL AS Parent_HP_ID,  
                    NULL AS Child_EN_ID,  
                    NULL AS Child_HP_ID,  
                    sr.Privilege_ID,  
                    sr.AccessPermission,  
                    CONVERT(BIT, 1) AS IsVirtualRoot  
                FROM mdm.' + QUOTENAME(@table_HR) + N' AS hr  
                LEFT JOIN sram AS sr ON  
                    hr.Hierarchy_ID = sr.ExplicitHierarchy_ID  
                    AND sr.IsVirtualRoot = 1 --Ensure assignment is at the root  
                WHERE  
                    hr.Version_ID = @Version_ID --Requested Version  
                    AND hr.Parent_HP_ID IS NULL --Top-level nodes only  
                    AND hr.Status_ID = 1 --Active (non-deleted)  
            ),';  
  
        --The memberNodes CTE joins the raw members to the security role access member (SRAM) table  
        --in order to find the members that have explicit security assignments.  
        SET @SQL = @SQL + N'  
            memberNodes AS  
            (    --Raw members with assignments  
                SELECT  
                    hr.Hierarchy_ID AS ExplicitHierarchy_ID,  
                    hr.Parent_HP_ID,  
                    hr.Child_EN_ID,  
                    hr.Child_HP_ID,  
                    sr.Privilege_ID,  
                    sr.AccessPermission,  
                    CONVERT(BIT, 0) AS IsVirtualRoot  
                FROM mdm.' + QUOTENAME(@table_HR) + N' AS hr  
                LEFT JOIN sram AS sr ON  
                    hr.Hierarchy_ID = sr.ExplicitHierarchy_ID AND  
                    sr.IsVirtualRoot = 0 AND  
                    (  
                        (hr.ChildType_ID = 1 AND hr.Child_EN_ID = sr.EN_ID) OR  
                        (hr.ChildType_ID = 2 AND hr.Child_HP_ID = sr.HP_ID)  
                    )  
                WHERE  
                    hr.Version_ID = @Version_ID AND --Requested Version  
                    hr.Status_ID = 1 --Active (non-deleted)  
            ),';  
  
        --Instead of composing another CTE, dump the results to a temporary staging table so  
        --we can index it in order to improve performance for the next step.  
        --Use a SELECT INTO to create the staging table to get the best bulk insert performance  
        SET @SQL = @SQL + N'  
            stage AS  
            (  
                SELECT IsVirtualRoot, ExplicitHierarchy_ID, Parent_HP_ID, Child_EN_ID, Child_HP_ID, Privilege_ID, AccessPermission FROM virtualRoots  
                UNION ALL  
                SELECT IsVirtualRoot, ExplicitHierarchy_ID, Parent_HP_ID, Child_EN_ID, Child_HP_ID, Privilege_ID, AccessPermission FROM memberNodes  
            )  
            INSERT INTO #stage  
            SELECT  
                IsVirtualRoot, ExplicitHierarchy_ID, Parent_HP_ID, Child_EN_ID, Child_HP_ID, Privilege_ID, AccessPermission  
            FROM stage;  
  
            CREATE CLUSTERED INDEX ix_stage ON #stage(IsVirtualRoot, ExplicitHierarchy_ID, Parent_HP_ID, Child_EN_ID, Child_HP_ID);  
            ';  
  
        --The tree CTE is a recursive branch-walker that pulls permissions down inheritance  
        --chains. The anchor clause selects the virtual root, and the recursive clause  
        --selects any member whose ascendant is in the anchor set. It also defines the distance  
        --(delta) between assigned nodes and their non-assigned descendants which is important  
        --later on when we look for the closest assignments.  
        SET @SQL = @SQL + N'  
            WITH tree AS  
            (    --Anchor clause  
                SELECT  
                    ExplicitHierarchy_ID,  
                    Parent_HP_ID,  
                    Child_EN_ID,  
                    Child_HP_ID,  
                    Privilege_ID,  
                    AccessPermission,  
                    IsVirtualRoot,  
                    --Distance to closest assigned node (NULL=none, 0=self)  
                    CASE WHEN Privilege_ID IS NULL THEN NULL ELSE 0 END AS Delta_ID  
                FROM #stage  
                WHERE IsVirtualRoot = 1  
  
                UNION ALL --This is a recursive UNION  
  
                --Recursive clause  
                SELECT  
                    parent.ExplicitHierarchy_ID,  
                    child.Parent_HP_ID,  
                    child.Child_EN_ID,  
                    child.Child_HP_ID,  
                    CASE --Recursively inherit Privilege_ID following the specified rules  
                        WHEN parent.Privilege_ID = 1 THEN parent.Privilege_ID --Inherited explicit DENY trumps any given security on child  
                        ELSE ISNULL(child.Privilege_ID, parent.Privilege_ID) --Else use the most recent (closest) assignment  
                    END AS Privilege_ID, --case  
                    CASE  
                        WHEN parent.Privilege_ID = 1 THEN parent.AccessPermission --None/ReadOnly  
                        ELSE ISNULL(child.AccessPermission, parent.AccessPermission) --Else use the most recent (closest) assignment  
                        END AS AccessPermission,  
                    child.IsVirtualRoot,  
                    CASE --Distance to most recently (closest) assigned node (NULL=none, 0=self)  
                        WHEN parent.Privilege_ID = 1 THEN 0 --Since an inherited explicit DENY trumps all, treat it as a local assignment  
                        WHEN child.Privilege_ID IS NULL THEN parent.Delta_ID + 1 --If no local assignment, get distance to closest inherited assignment  
                        ELSE 0 --Reset distance to 0, since current node has an explicit assignment  
                    END AS Delta_ID --case  
                FROM tree AS parent  
                INNER JOIN #stage AS child ON  
                    parent.ExplicitHierarchy_ID = child.ExplicitHierarchy_ID AND  
                    (  
                        (parent.IsVirtualRoot = 1 AND child.Parent_HP_ID IS NULL) OR --For virtual roots, join on NULL==NULL  
                        (parent.IsVirtualRoot = 0 AND parent.Child_HP_ID = child.Parent_HP_ID) --For non-root members, join on keys  
                    )  
                WHERE child.IsVirtualRoot = 0  
            ),';  
  
        --The closestInPath CTE partitions each member by the hierarchies & roles that it is in. It auto-numbers  
        --each row within a partition such that the row with the smallest delta (distance to an assigned node,  
        --including itself) is first in the partition.  
        --We exclude virtual roots since they were just a computation convenience. We also exclude any member  
        --having neither explicit nor inherited security.  
        SET @SQL = @SQL + N'  
            closestInPath AS  
            (    --Only keep non-virtual rows with explicit assignments in their ancestor path.  
                --Sort each node by the roles it belongs to, with the smallest distance coming first  
                SELECT  
                    ROW_NUMBER() OVER(PARTITION BY ExplicitHierarchy_ID, Child_EN_ID, Child_HP_ID ORDER BY Delta_ID ASC) AS Sequence_ID,  
                    ExplicitHierarchy_ID, Child_EN_ID AS EN_ID, Child_HP_ID AS HP_ID, Delta_ID, Privilege_ID, AccessPermission  
                FROM tree  
                WHERE IsVirtualRoot = 0 AND Delta_ID IS NOT NULL  
            ),';  
  
        --Since we might have multiple explicit hierarchies within this entity, we now need to consolidate the  
        --privileges across them. We do this via a GROUPing clause that finds the MIN (least privilege) across  
        --all the hierarchies and roles that the member participates in. Note that we are still within the context  
        --of a single role.  
        SET @SQL = @SQL + N'  
            leastPrivilege AS  
            (    --If a specific member within a single role belongs to multiple secured explicit hierarchies, then  
                --that member retains the LEAST privilege propagated from within that context.  
                SELECT EN_ID, HP_ID, MIN(Privilege_ID) AS Privilege_ID,  
                       Avg(AccessPermission & 0x1) / 0x1 * 0x1 +  
                       Avg(AccessPermission & 0x2) / 0x2 * 0x2 +  
                       Avg(AccessPermission & 0x4) / 0x4 * 0x4 AS AccessPermission  
                FROM closestInPath  
                WHERE Sequence_ID = 1 --Only keep the most recent (closest) assignment  
                GROUP BY EN_ID, HP_ID  
            )';  
  
        --The final operation inserts into the staging table, ensures that the closest (most recent)  
        --explicitly-assigned permissions trump any inherited permissions.  
        --Swap the Privilege_ID enum back to its original form since we are now done with sorting it  
        SET @SQL = @SQL + N'  
            INSERT INTO #map(SecurityRole_ID, MemberType_ID, ID, Privilege_ID, AccessPermission)  
            SELECT @SecurityRole_ID, CASE WHEN EN_ID IS NOT NULL THEN 1 ELSE 2 END, COALESCE(EN_ID, HP_ID),  
                Privilege_ID, AccessPermission  
            FROM leastPrivilege;';  
  
        --Finally output the number of rows inserted (for debugging & tracing purposes)  
        --then clean up the temp table so it can be recreated in the next iteration  
        SET @SQL = @SQL + N'  
            PRINT CONCAT(SYSDATETIME(), N'': #map : EH (All): '', @@ROWCOUNT);  
            DROP TABLE #stage;  
            ';  
  
        --Loop through each SecurityRole_ID of the explicit hierarchies  
        --The SQL statement that we execute is the same for each role, so this is a small, tight loop  
        WHILE EXISTS(SELECT 1 FROM #assignments WHERE ExplicitHierarchy_ID IS NOT NULL AND IsProcessed = 0) BEGIN  
  
            SELECT TOP 1 @SecurityRole_ID = SecurityRole_ID FROM #assignments WHERE ExplicitHierarchy_ID IS NOT NULL AND IsProcessed = 0 ORDER BY SecurityRole_ID;  
  
            --Execute the dynamic SQL  
            --PRINT @SQL;  
            EXEC sp_executesql @SQL, N'@Entity_ID INT, @Version_ID INT, @SecurityRole_ID INT', @Entity_ID, @Version_ID, @SecurityRole_ID;  
  
            UPDATE #assignments SET IsProcessed = 1 WHERE ExplicitHierarchy_ID IS NOT NULL AND SecurityRole_ID = @SecurityRole_ID;  
  
        END; --while  
  
        PRINT CONCAT(SYSDATETIME(), N': Finished writing Explicit Hierarchy permissions to #map');  
    END; --if  
  
  
    /*=================================================================  
      Derived Hierarchy analysis  
      =================================================================*/  
  
    --Stage the security data from any derived hierarchies associated with the entity's model  
    --Don't do anything if derived hierarchies do not exist for this entity's model, or there are no relevant security assignments  
    IF EXISTS(SELECT 1 FROM #assignments WHERE DerivedHierarchy_ID IS NOT NULL AND IsProcessed = 0)  
    BEGIN  
        PRINT CONCAT(SYSDATETIME(), N': Started loading level info into #dhLevel');  
  
        --Create a table to hold the details of each level of every derived hierarchy in the entity's model  
        CREATE TABLE #dhLevel  
        (  
            ID                  INT IDENTITY(1, 1) NOT NULL PRIMARY KEY CLUSTERED,  
            DerivedHierarchy_ID INT NOT NULL,  
            Level_ID            INT NOT NULL,  
            Entity_ID           INT NOT NULL,  
            EntityTable         SYSNAME,  
            EntityName          NVARCHAR(50) NOT NULL,  
            DbaColumn           SYSNAME NULL,  
            DbaEntity_ID        INT NULL,  
            DbaLevel_ID         INT NULL,  
            IsProcessed         BIT NOT NULL DEFAULT 0  
        ); --table  
  
  
        DECLARE @SecuredHierarchies TABLE  
        (  
            DerivedHierarchy_ID INT PRIMARY KEY  
        );  
        INSERT INTO @SecuredHierarchies  
        SELECT DISTINCT DerivedHierarchy_ID  
        FROM #assignments  
        WHERE DerivedHierarchy_ID IS NOT NULL;  
  
        --Get the details for non-composite hierarchies in the current model that have member permissions.  
        WITH dhLevel AS  
        (  
            SELECT  
                 dhd.DerivedHierarchy_ID  
                ,dhd.Name  
                ,dhd.Level_ID  
                --ForeignType_ID has range [0..4] so ensure CASE statements exclude non-applicable values  
                ,CASE dhd.ForeignType_ID  
                    WHEN @HierarchyItemType_Entity THEN dhd.Foreign_ID  
                    WHEN @HierarchyItemType_DBA    THEN a.DomainEntity_ID  
                    ELSE NULL END AS [Entity_ID]  
                ,a.Entity_ID AS [Parent.Entity.ID]  
                ,a.ID AS [Parent.Attribute.ID]  
                ,a.TableColumn AS [Parent.Attribute.TableColumn]  
            FROM @SecuredHierarchies AS dh  
            INNER JOIN mdm.tblDerivedHierarchyDetail AS dhd  
            ON dh.DerivedHierarchy_ID = dhd.DerivedHierarchy_ID --Ensures that DH has at least one defined level  
            LEFT JOIN mdm.tblAttribute AS a  
            ON      dhd.Foreign_ID = a.ID --Levels join via DBAs  
                AND dhd.ForeignType_ID = @HierarchyItemType_DBA -- Only join level rows that pertain to DBAs.  
        ),  
        exclude AS  
        (    --Exclude specific types of derived hierarchies:  
            SELECT  
                 DerivedHierarchy_ID  
                ,Level_ID  
                ,Entity_ID  
                ,[Parent.Attribute.TableColumn]  
            FROM dhLevel dh  
            WHERE  
                --Only use hierarchies that include a level that uses the specified entity  
                    EXISTS (SELECT 1 FROM dhLevel WHERE Entity_ID = @Entity_ID AND DerivedHierarchy_ID = dh.DerivedHierarchy_ID)  
        )  
        --Insert the details into the #dhLevels table in a shape that will make the @SQL generation simpler  
        INSERT INTO #dhLevel(DerivedHierarchy_ID, Level_ID, Entity_ID, EntityTable, EntityName, DbaColumn, DbaEntity_ID, DbaLevel_ID)  
        SELECT child.DerivedHierarchy_ID, child.Level_ID, child.Entity_ID, en.EntityTable, en.Name, parent.[Parent.Attribute.TableColumn], parent.Entity_ID, parent.Level_ID  
        FROM exclude AS child  
        INNER JOIN mdm.tblEntity AS en  
        ON child.Entity_ID = en.ID  
        LEFT JOIN exclude AS parent  
        ON      child.Level_ID + 1 = parent.Level_ID  
            AND child.DerivedHierarchy_ID = parent.DerivedHierarchy_ID  
        ORDER BY child.Level_ID DESC; --MDS hierarchies are declared upside-down, so we want to reverse the order  
  
        -- all permissions for a specific hierarchy and principal.  
        CREATE TABLE #sram  
        (  
            Entity_ID               INT NOT NULL, --The Entity_ID that is secured.  
            EN_ID                   INT NOT NULL,  
            Privilege_ID            INT NOT NULL, --1=DENY, 4=Access  
            AccessPermission        TINYINT NOT NULL,  
        );  
        CREATE UNIQUE CLUSTERED INDEX #ix_sram_Entity_ID_EN_ID ON #sram(Entity_ID, EN_ID);  
  
        -- Unused (by level) permissions for a specific hierarchy and principal.  
        CREATE TABLE #unusedByLevel  
        (  
             Level_ID            INT NOT NULL PRIMARY KEY -- mdm.tblDerivedHierarchyDetail.Level_ID  
            ,Privilege_ID        TINYINT NOT NULL --1=DENY, 4=Access  
            ,AccessPermission    TINYINT NOT NULL  
        );  
  
        PRINT CONCAT(SYSDATETIME(), N': Started looping through #dhLevel');  
  
       --Don't do anything if there are no defined levels in the derived hierarchies  
        --Loop through each derived hierarchy one at a time, since they each have a different structure  
        WHILE EXISTS(SELECT 1 FROM #dhLevel WHERE IsProcessed = 0)  
        BEGIN  
  
            --There will likely be several rows for each derived hierarchy id, so use TOP 1  
            SELECT TOP 1 @DerivedHierarchy_ID = DerivedHierarchy_ID  
            FROM #dhLevel  
            WHERE IsProcessed = 0  
            ORDER BY DerivedHierarchy_ID;  
  
            -- Determine whether the hierarchy anchors null recursions (relevant for recursive hierarchies).  
            SELECT @AnchorNullRecursions = AnchorNullRecursions  
            FROM mdm.tblDerivedHierarchy  
            WHERE ID = @DerivedHierarchy_ID  
  
            DECLARE @MaxLevel_ID INT; -- The biggest (bottom-most) level number  
            SELECT @MaxLevel_ID = MAX(Level_ID)  
            FROM mdm.tblDerivedHierarchyDetail  
            WHERE DerivedHierarchy_ID = @DerivedHierarchy_ID;  
  
            --Generate the virtual roots for the current derived hierarchy and security role  
            SET @SQL = N'  
DECLARE  
     @RootPrivilege_ID          TINYINT  
    ,@RootAccessPermission      TINYINT;  
  
SELECT  
     @RootPrivilege_ID = Privilege_ID  
    ,@RootAccessPermission = AccessPermission  
FROM #sram  
WHERE EN_ID = 0; -- Root member Id  
  
WITH virtualRoot AS  
(   -- Virtual root (with or without security assignment)  
    SELECT  
         @RootPrivilege_ID Privilege_ID  
        ,@RootAccessPermission AccessPermission  
        ,CASE WHEN @RootPrivilege_ID IS NULL THEN NULL ELSE 0 END AS Delta_ID  
        ,NULL Level_ID  
)';  
  
            --Loop through each level in the current hierarchy, generating the dynamic @SQL clause as a CTE for each level  
            DECLARE  
                 @CurrentID                 INT = NULL  
                ,@NextID                    INT = NULL  
                ,@CurrentLevel_ID           INT = NULL -- 1 at Leaf level, incrementing upwards to top level  
                ,@CurrentLevelAlias         NVARCHAR(50) = NULL  
                ,@PreviousLevelAlias        NVARCHAR(50) = NULL  
                ,@CurrentEntity_ID          INT = 0  
                ,@CurrentEntityName         NVARCHAR(50) = NULL  
                ,@CurrentEntityTableName    SYSNAME = NULL  
                ,@CurrentDbaEntity_ID       INT = NULL  
                ,@CurrentDbaColumnName      SYSNAME = NULL  
                ,@NextDbaColumnName         NVARCHAR(50) = NULL  
                ,@PreviousDbaColumnName     NVARCHAR(50) = NULL  
                ,@IsLevelRecursive          BIT = 0;  
            WHILE EXISTS(SELECT 1  
                         FROM #dhLevel  
                         WHERE  DerivedHierarchy_ID = @DerivedHierarchy_ID  
                            AND Entity_ID = @Entity_ID -- Don't continue traversing down the hierarchy once all the levels that apply to the entity have been processed.  
                            AND IsProcessed = 0)  
            BEGIN  
  
                --Get the topmost unprocessed level in the current hierarchy.  
                WITH cteLevelInfo AS  
                (  
                    SELECT TOP 1  
                         lvl.ID  
                        ,lvl.Level_ID  
                        ,nextLvl.ID NextID  
                        ,nextLvl.Level_ID NextLevel_ID  
                        ,lvl.Entity_ID  
                        ,lvl.EntityName  
                        ,lvl.EntityTable  
                        ,lvl.DbaEntity_ID  
                        ,nextLvl.DbaEntity_ID NextDbaEntity_ID  
                        ,lvl.DbaColumn  
                        ,nextLvl.DbaColumn NextDbaColumn  
                        ,CASE lvl.Entity_ID WHEN nextLvl.Entity_ID THEN 1 ELSE 0 END IsLevelRecursive  
                    FROM #dhLevel lvl  
                    LEFT JOIN #dhLevel nextLvl -- Look at the next level to determine whether the current level is recursive. If so, the two levels will be processed together (a recursive relationship is represented by two level rows).  
                    ON lvl.Level_ID = nextLvl.Level_ID + 1  
                        AND lvl.DerivedHierarchy_ID = nextLvl.DerivedHierarchy_ID  
                    WHERE   lvl.DerivedHierarchy_ID = @DerivedHierarchy_ID  
                        AND lvl.IsProcessed = 0  
                    ORDER BY lvl.Level_ID DESC --MDS derived hierarchies are declared upside-down, so the top level entity is last  
                )  
                SELECT  
                     @CurrentID = ID  
                    ,@NextID = NextID  
                    ,@CurrentLevel_ID = Level_ID  
                    ,@CurrentEntity_ID = Entity_ID  
                    ,@CurrentEntityName = EntityName  
                    ,@CurrentEntityTableName = EntityTable  
                    ,@CurrentDbaEntity_ID  = CASE WHEN IsLevelRecursive = 1 THEN NextDbaEntity_ID ELSE DbaEntity_ID END  
                    ,@CurrentDbaColumnName = DbaColumn  
                    ,@NextDbaColumnName = NextDbaColumn -- If the level is recursive, then this will be the self-referencing DBA.  
                    ,@CurrentLevelAlias = CONCAT(N'L', Level_ID, CASE  
                        WHEN IsLevelRecursive = 1 THEN CONCAT(N'_AND_L', NextLevel_ID, N'_Recursive') -- Set the name of the CTE to reflect that it is handling the two levels that define the recursive relationship.  
                        ELSE N'' END)  
                    ,@IsLevelRecursive = IsLevelRecursive  
                FROM cteLevelInfo  
  
                IF @IsLevelRecursive = 0  
                BEGIN  
                    --Generate the level details and join clause. Joins are different depending  
                    --on whether it is the first, or a subsequent level.  
                    SET @SQL += CONCAT(@TruncationGuard, N'  
,', QUOTENAME(@CurrentLevelAlias), N' AS  
(   --', @CurrentEntityName, N'  
    SELECT  
         child.ID  
        ,CASE --Recursively inherit Privilege_ID following the specified rules  
            WHEN COALESCE(parent.Privilege_ID, unused.Privilege_ID) = ', @Permission_Deny, '/*Deny*/ THEN ', @Permission_Deny, '/*Deny*/ --Inherited explicit DENY trumps any given security on child  
            ELSE COALESCE(sr.Privilege_ID, parent.Privilege_ID, unused.Privilege_ID) --Else use the most recent (closest) assignment  
            END AS Privilege_ID  
        ,CASE  
            WHEN COALESCE(parent.Privilege_ID, unused.Privilege_ID) = ', @Permission_Deny, '/*Deny*/ THEN COALESCE(parent.AccessPermission, unused.AccessPermission) -- None / ReadOnly  
            ELSE COALESCE(sr.AccessPermission, parent.AccessPermission, unused.AccessPermission) --Else use the most recent (closest) assignment  
            END AS AccessPermission  
        ,CASE --Distance to most recently (closest) assigned node (NULL=none, 0=self)  
            WHEN COALESCE(parent.Privilege_ID, unused.Privilege_ID) = ', @Permission_Deny, '/*Deny*/ THEN 0 --Since an inherited explicit DENY trumps all, treat it as a local assignment  
            WHEN sr.Privilege_ID IS NULL THEN  
                CASE WHEN unused.Privilege_ID IS NOT NULL THEN 1 --Permission inherited from unused node  
                    ELSE parent.Delta_ID + 1 --Permission inherited from parent.  
                    END  
            ELSE 0 --Reset distance to 0, since current node has an explicit assignment  
            END AS Delta_ID  
        ,CASE WHEN COALESCE(parent.Privilege_ID, unused.Privilege_ID) = ', @Permission_Deny, ' OR sr.Privilege_ID IS NOT NULL THEN ', @CurrentLevel_ID, N'  
            ELSE parent.Level_ID END Level_ID  
    FROM mdm.', QUOTENAME(@CurrentEntityTableName), N' AS child  
    LEFT JOIN ', QUOTENAME(COALESCE(@PreviousLevelAlias, N'virtualRoot')), N' AS parent  
    ON ', CASE WHEN @PreviousLevelAlias IS NOT NULL THEN N'  
            child.' + QUOTENAME(@CurrentDbaColumnName) + N' = parent.ID  
        AND ' END, N'parent.Privilege_ID IS NOT NULL  
    LEFT JOIN #unusedByLevel unused  
    ON ', CASE WHEN @PreviousLevelAlias IS NOT NULL THEN N'  
            child.' + QUOTENAME(@CurrentDbaColumnName) + N' IS NULL  
        AND ' END, N'unused.Level_ID = ', @CurrentLevel_ID, N'  
    LEFT JOIN #sram sr  
    ON      sr.Entity_ID = ', @CurrentEntity_ID, N'  
        AND child.ID = sr.EN_ID  
    WHERE child.Status_ID = 1  
        AND child.Version_ID = @Version_ID  
)');  
  
                    --Update the loop counter  
                    UPDATE #dhLevel SET IsProcessed = 1 WHERE ID = @CurrentID;  
                END -- IF level is not recursive  
                ELSE  
                BEGIN  
                    -- The level is recursive. Use a recursive CTE to set member permissions.  
                    -- First, the explicit permissions must be loaded into a separate cte, because a LEFT JOIN cannot be done inside the recursive part of a cte.  
                    DECLARE @CurrentLevelAliasHelper NVARCHAR(100) = @CurrentLevelAlias + N'_ExplicitMemberPermissions'  
  
                    SET @SQL += CONCAT(@TruncationGuard, N'  
,', QUOTENAME(@CurrentLevelAliasHelper), N' AS -- Preload member explicit permissions into this helper CTE, since SQL does not allow a LEFT JOIN in the recursive part of a recursive CTE.  
(  
    SELECT  
         en.ID  
        ,sr.Privilege_ID  
        ,sr.AccessPermission  
        ,en.', QUOTENAME(@NextDbaColumnName)/*The next (not the current) DBA is the self referencing recursive one.*/, N' Parent_ID -- recursive parent',  
        CASE WHEN @PreviousLevelAlias IS NOT NULL THEN N'  
        ,en.' + QUOTENAME(@PreviousDbaColumnName) + N' PreviousLevelParent_ID -- Non-recursive parent' END, N'  
    FROM mdm.', QUOTENAME(@CurrentEntityTableName), N' en  
    LEFT JOIN #sram sr  
    ON      sr.Entity_ID = ', @CurrentEntity_ID, N'  
        AND en.ID = sr.EN_ID  
    WHERE   en.Status_ID = 1  
        AND en.Version_ID = @Version_ID  
)  
,', QUOTENAME(@CurrentLevelAlias), N' AS -- Recursive hierarchy levels  
(    --', @CurrentEntityName, N'  
    SELECT  
         child.ID  
        ,CASE --Recursively inherit Privilege_ID following the specified rules  
            WHEN parent.Privilege_ID = ', @Permission_Deny, '/*Deny*/ THEN ', @Permission_Deny, '/*Deny*/ --Inherited explicit DENY trumps any given security on child  
            ELSE COALESCE(sr.Privilege_ID, parent.Privilege_ID) --Else use the most recent (closest) assignment  
            END AS Privilege_ID  
        ,CASE  
            WHEN parent.Privilege_ID = ', @Permission_Deny, '/*Deny*/ THEN parent.AccessPermission  
            WHEN child.Privilege_ID IS NULL THEN parent.AccessPermission  
            ELSE child.AccessPermission  
            END AS AccessPermission  
        ,CASE --Distance to most recently (closest) assigned node (NULL=none, 0=self)  
            WHEN parent.Privilege_ID = ', @Permission_Deny, '/*Deny*/ THEN 0 --Since an inherited explicit DENY trumps all, treat it as a local assignment  
            WHEN sr.Privilege_ID IS NULL THEN parent.Delta_ID + 1 --If no local assignment, get distance to closest inherited assignment  
            ELSE 0 --Reset distance to 0, since current node has an explicit assignment  
            END AS Delta_ID  
        ,0 RecursionLevel  
        ,', CASE WHEN @PreviousLevelAlias IS NULL THEN CONCAT(@CurrentLevel_ID, N' Level_ID') ELSE N'parent.Level_ID' END, N'  
    FROM ', QUOTENAME(@CurrentLevelAliasHelper), N' AS child  
    LEFT JOIN ', COALESCE(@PreviousLevelAlias, N'virtualRoot'), N' AS parent  
    ON ',               CASE WHEN @PreviousLevelAlias IS NOT NULL THEN N'  
                child.PreviousLevelParent_ID = parent.ID  
            AND ' END, N'parent.Privilege_ID IS NOT NULL  
    LEFT JOIN #sram sr  
    ON      sr.Entity_ID = ', @CurrentEntity_ID, N'  
        AND child.ID = sr.EN_ID',  
                    CASE WHEN @AnchorNullRecursions = 1 THEN N'  
    WHERE child.Parent_ID IS NULL -- anchoring null recursions, so only members with NULL DBA values are under ROOT'  
                    ELSE N'  
    -- The hierarchy does not anchor null recursions, so all members appear under ROOT. So, no need to filter on recursive DBA here.' END, N'  
  
    UNION ALL  
  
    SELECT  
         child.ID  
        ,CASE --Recursively inherit Privilege_ID following the specified rules  
            WHEN parent.Privilege_ID = ', @Permission_Deny, '/*Deny*/ THEN ', @Permission_Deny, '/*Deny*/ --Inherited explicit DENY trumps any given security on child  
            ELSE COALESCE(child.Privilege_ID, parent.Privilege_ID) --Else use the most recent (closest) assignment  
            END AS Privilege_ID  
        ,CASE  
            WHEN parent.Privilege_ID = ', @Permission_Deny, '/*Deny*/ THEN parent.AccessPermission  
            WHEN child.Privilege_ID IS NULL THEN parent.AccessPermission  
            ELSE child.AccessPermission  
            END AS AccessPermission  
        ,CASE --Distance to most recently (closest) assigned node (NULL=none, 0=self)  
            WHEN parent.Privilege_ID = ', @Permission_Deny, '/*Deny*/ THEN 0 --Since an inherited explicit DENY trumps all, treat it as a local assignment  
            WHEN child.Privilege_ID IS NULL THEN parent.Delta_ID + 1 --If no local assignment, get distance to closest inherited assignment  
            ELSE 0 --Reset distance to 0, since current node has an explicit assignment  
            END AS Delta_ID  
        ,parent.RecursionLevel + 1  
        ,', @CurrentLevel_ID, N' Level_ID  
    FROM ', QUOTENAME(@CurrentLevelAlias), N' parent -- recursive CTE  
    INNER JOIN ', QUOTENAME(@CurrentLevelAliasHelper), N' child  
    ON      parent.ID = child.Parent_ID  
    WHERE parent.RecursionLevel < 99 -- Protects against "The statement terminated. The maximum recursion 100 has been exhausted before statement completion" error.  
)');  
  
                    --Update the loop counter  
                    UPDATE #dhLevel SET IsProcessed = 1 WHERE ID IN (@CurrentID, @NextID); -- Mark as processed both of the level rows that form the recursive relationship.  
                END; -- IF level is recursive  
  
                SET @PreviousLevelAlias = @CurrentLevelAlias;  
                SET @PreviousDbaColumnName = @NextDbaColumnName;  
            END; --while  
  
            --Since we can exit the inner loop early, make sure all unprocessed rows are deleted else the outer loop will spin  
            --Do NOT delete from #dhLevel since the data is also used in the generated @SQL. Instead flag it as completed.  
            UPDATE #dhLevel SET IsProcessed = 1 WHERE DerivedHierarchy_ID = @DerivedHierarchy_ID;  
  
            --Add the boiler-plate SQL code to navigate the derived hierarchy.  
            SET @SQL += CONCAT(N'  
,closestLeastPriv AS  
(    --Only keep rows with explicit assignments in their ancestor path.  
    --Sort each node by the roles it belongs to, with the smallest distance at the top  
    SELECT  
         ROW_NUMBER() OVER(PARTITION BY ID ORDER BY  
             Delta_ID ASC -- closer permissions take precedence  
            ,Level_ID ASC -- if there is a tie (like if there is a non-recursive level above a recursive level) the lower level wins  
         ) AS Sequence_ID  
        ,ID  
        ,Delta_ID  
        ,Privilege_ID  
        ,AccessPermission  
    FROM ', QUOTENAME(@CurrentLevelAlias), N'  
    WHERE   Delta_ID IS NOT NULL  
        AND Privilege_ID IS NOT NULL  
)  
--Insert into the staging table, ensuring that the closest (most recent)  
--explicitly-assigned permissions trump any inherited permissions.  
INSERT INTO #map(SecurityRole_ID, MemberType_ID, ID, Privilege_ID, AccessPermission)  
SELECT  
     @SecurityRole_ID  
    ,', @MemberType_Leaf, '--Leaf  
    ,ID  
    ,Privilege_ID  
    ,AccessPermission  
FROM closestLeastPriv AS clp  
WHERE Sequence_ID = 1; --Only keep the most recent (closest) assignment  
  
PRINT CONCAT(SYSDATETIME(), N'': #map : DH (#'', @DerivedHierarchy_ID, N''): '', @@ROWCOUNT);  
');  
  
            --Loop through each SecurityRole_ID of the current derived hierarchy  
            --The SQL statement that we execute is the same for each role, so this is a small, tight loop  
            WHILE EXISTS(SELECT 1 FROM #assignments WHERE DerivedHierarchy_ID = @DerivedHierarchy_ID AND IsProcessed = 0)  
            BEGIN  
  
                SELECT TOP 1 @SecurityRole_ID = SecurityRole_ID  
                FROM #assignments  
                WHERE   DerivedHierarchy_ID = @DerivedHierarchy_ID  
                    AND IsProcessed = 0  
                ORDER BY SecurityRole_ID;  
  
                -- Load permissions for the current hierarchy and security role.  
                DELETE FROM #sram;  
                DELETE FROM #unusedByLevel  
  
                INSERT INTO #sram  
                SELECT Entity_ID, COALESCE(EN_ID, 0), Privilege_ID, AccessPermission  
                FROM #assignments  
                WHERE   DerivedHierarchy_ID = @DerivedHierarchy_ID --Only want the current derived hierarchy  
                    AND SecurityRole_ID = @SecurityRole_ID --Only want the current security role  
                    AND IsProcessed = 0;  
  
                DECLARE  
                     @UnusedPrivilege_ID        INT  
                    ,@UnusedAccessPermission    TINYINT;  
                SELECT  
                     @UnusedPrivilege_ID = Privilege_ID  
                    ,@UnusedAccessPermission = AccessPermission  
                FROM #sram  
                WHERE EN_ID = -1; -- Top-level unused member Id  
  
                -- Get per-level unused permissions, by propagating the top-level unused permission down to the children, using the same inheritance rules used for real member inheritance.  
                INSERT INTO #unusedByLevel  
                SELECT  
                     dhd.Level_ID  
                    ,CASE WHEN @UnusedPrivilege_ID = @Permission_Deny THEN @Permission_Deny --Inherited explicit DENY trumps any given security on child  
                        ELSE COALESCE(s.Privilege_ID, @UnusedPrivilege_ID) --Else use the most recent (closest) assignment  
                        END AS Privilege_ID  
                    ,CASE WHEN @UnusedPrivilege_ID = @Permission_Deny THEN @UnusedAccessPermission -- None / ReadOnly  
                        ELSE COALESCE(s.AccessPermission, @UnusedAccessPermission) --Else use the most recent (closest) assignment  
                        END AS AccessPermission  
                FROM mdm.tblDerivedHierarchyDetail dhd  
                LEFT JOIN #sram s  
                ON      dhd.Level_ID = s.EN_ID + 10 + @MaxLevel_ID-- the EN_IDs are negative, in reverse order (top to bottom, ascending) and offset by -10. Adjust to match them to the Level_ID (which are positive and ordered bottom to top, ascending)  
                    AND s.EN_ID < -10  
                WHERE dhd.Level_ID < @MaxLevel_ID  
                    AND dhd.DerivedHierarchy_ID = @DerivedHierarchy_ID  
                    AND COALESCE(s.Privilege_ID, @UnusedPrivilege_ID) IS NOT NULL;-- don't need rows with no permissions  
  
                --Execute the dynamic SQL  
                --PRINT @SQL  
                PRINT CONCAT(SYSDATETIME(), N': Loading permissions into #map for @DerivedHierarchy_ID = ', @DerivedHierarchy_ID, N', @SecurityRole_ID = ', @SecurityRole_ID);  
  
                EXEC sp_executesql @SQL,  
                         N'@Version_ID INT, @Entity_ID INT, @DerivedHierarchy_ID INT, @SecurityRole_ID INT',  
                           @Version_ID,     @Entity_ID,     @DerivedHierarchy_ID,     @SecurityRole_ID;  
  
                UPDATE #assignments  
                SET IsProcessed = 1  
                WHERE   DerivedHierarchy_ID = @DerivedHierarchy_ID  
                    AND SecurityRole_ID = @SecurityRole_ID;  
            END; --while  
  
        END; --while  
  
        PRINT CONCAT(SYSDATETIME(), N': Finished writing Derived Hierarchy permissions to #map');  
    END; --if  
  
  
    /*=================================================================  
      Load _MS tables  
      =================================================================*/  
  
    --DECLARE @MapCount INT = 0;  
    --SELECT @MapCount = COUNT(*) FROM #map;  
    --PRINT CONCAT(N'@#map row count before de-duplication: ', COALESCE(@MapCount, N'NULL'));  
    DECLARE @StartTime DATETIME2(7) = SYSDATETIME();  
  
    --Combine all the role security with the maximum accesspermission unless there is an explicit deny  
    IF @UseUserIds = 0  
    BEGIN  
        ;WITH dedupByRoleCte AS  
        (  
            --Remove any duplicates due to members occurring in multiple hierarchies with the same Delta_ID, in the same role.  
            --In other words, the same member (e.g.) 917 could occur twice but with different Privilege_ID.  
            --Keep the row with the least privilege.  
            SELECT SecurityRole_ID, MemberType_ID, ID, MIN(Privilege_ID) AS Privilege_ID,  
                   -- Average, Divide, and Multiply each access permission type so that the permission will persist only if all roles have that permission on the member.  
                   CONVERT(TINYINT,  
                       AVG(AccessPermission & 0x1) / CAST(0x1 AS TINYINT) * CAST(0x1 AS TINYINT) +  
                       AVG(AccessPermission & 0x2) / CAST(0x2 AS TINYINT) * CAST(0x2 AS TINYINT) +  
                       AVG(AccessPermission & 0x4) / CAST(0x4 AS TINYINT) * CAST(0x4 AS TINYINT)) AS AccessPermission  
            FROM #map  
            GROUP BY SecurityRole_ID, MemberType_ID, ID  
        )  
        INSERT #effectivePermissions (MemberType_ID, [User_ID], ID, AccessPermission)  
        SELECT  
            X.MemberType_ID,  
            R.[User_ID],  
            X.ID,  
            CONVERT(TINYINT,  
                MAX(X.AccessPermission & 0x1) +  
                MAX(X.AccessPermission & 0x2) +  
                MAX(X.AccessPermission & 0x4)) AS AccessPermission  
        FROM dedupByRoleCte X  
        INNER JOIN mdm.[viw_SYSTEM_SECURITY_USER_ROLE] R  
        ON X.SecurityRole_ID = R.Role_ID  
        GROUP BY X.MemberType_ID, R.[User_ID], X.ID  
        HAVING MIN(X.Privilege_ID) <> 1 -- Deny  
    END  
    ELSE  
    BEGIN  
       ;WITH dedupByRoleCte AS  
        (  
            --Remove any duplicates due to members occurring in multiple hierarchies with the same Delta_ID, in the same role.  
            --In other words, the same member (e.g.) 917 could occur twice but with different Privilege_ID.  
            --Keep the row with the least privilege.  
            SELECT SecurityRole_ID, MemberType_ID, ID, MIN(Privilege_ID) AS Privilege_ID,  
                   -- Average, Divide, and Multiply each access permission type so that the permission will persist only if all roles have that permission on the member.  
                   CONVERT(TINYINT,  
                       AVG(AccessPermission & 0x1) / CAST(0x1 AS TINYINT) * CAST(0x1 AS TINYINT) +  
                       AVG(AccessPermission & 0x2) / CAST(0x2 AS TINYINT) * CAST(0x2 AS TINYINT) +  
                       AVG(AccessPermission & 0x4) / CAST(0x4 AS TINYINT) * CAST(0x4 AS TINYINT)) AS AccessPermission  
            FROM #map  
            GROUP BY SecurityRole_ID, MemberType_ID, ID  
        )  
        INSERT #effectivePermissions (MemberType_ID, [User_ID], ID, AccessPermission)  
        SELECT  
            X.MemberType_ID,  
            R.[User_ID],  
            X.ID,  
            CONVERT(TINYINT,  
                MAX(X.AccessPermission & 0x1) +  
                MAX(X.AccessPermission & 0x2) +  
                MAX(X.AccessPermission & 0x4)) AS AccessPermission  
        FROM dedupByRoleCte X  
        INNER JOIN mdm.[viw_SYSTEM_SECURITY_USER_ROLE] R  
        ON X.SecurityRole_ID = R.Role_ID  
        -- Join with #userIds to exclude non-specified users. This was already done above to filter #assignments, but needs to be done again to exclude non-specified users that belong to the same groups as specified users  
        INNER JOIN #userIds AS uids  
        ON uids.ID = R.[User_ID]  
        GROUP BY X.MemberType_ID, R.[User_ID], X.ID  
        HAVING MIN(X.Privilege_ID) <> 1 -- Deny  
    END  
  
    PRINT CONCAT(SYSDATETIME(), N': INSERT INTO #effectivePermissions, elapsed time: ', DATEDIFF(MS, @StartTime, SYSDATETIME()) / 1000.0, N' sec');  
    SET @StartTime = SYSDATETIME()  
  
    DROP TABLE #map;  
  
    PRINT CONCAT(SYSDATETIME(), N': DROP #map, elapsed time: ', DATEDIFF(MS, @StartTime, SYSDATETIME()) / 1000.0, N' sec');  
    SET @StartTime = SYSDATETIME()  
      
    --SELECT @MapCount = COUNT(*) FROM #effectivePermissions;  
    --PRINT CONCAT(N'@#effectivePermissions row count after de-duplication: ', COALESCE(@MapCount, N'NULL'));  
  
    --ALWAYS do the next step, even if #effectivePermissions is empty. An empty #effectivePermissions means that  
    --there is no security anymore, so any existing _MS rows should be deleted.  
    --MERGE the #effectivePermissions table into the final _MS member table. Since the staging table  
    --will contain many duplicate and overlapping hierarchies & members, use a  
    --GROUPing clause to make sure that the maximum permission is granted for  
    --overlapping roles. Use an indexed staging table, else a non-indexed MERGE  
    --is very expensive  
    SET @SQL = CONCAT(@TruncationGuard, N'  
--Ensure we are using the READ COMMITTED level so that we can use SNAPSHOT functionality  
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;  
  
--DECLARE @MapCount INT = 0;  
--SELECT @MapCount = COUNT(*) FROM mdm.', QUOTENAME(@table_EN_MS), N' WHERE Version_ID = @Version_ID;  
--PRINT CONCAT(N''MS table row count: '', COALESCE(@MapCount, N''NULL''));  
  
-- Update the EN_MS table. There are two possible approaches:  
--    1. DELETE all of the existing rows in the MS table for the specified version and INSERT all of the #effectivePermissions rows into the MS table, or  
--    2. MERGE #effectivePermissions with the MS table.  
-- When there are few differences between the MS table and #effectivePermissions, option #2 is *much* faster (5-8 times faster in a test scenario with 3M rows) than #1.  
-- However, on a test run when all 3M rows were different, #2 was about 1.5-2.5 times slower than #1. So measure how different #effectivePermissions is from the MS table  
-- to determine which approach to use.  
DECLARE @DeleteCount    INT,  
        @InsertCount    INT,  
        @UpdateCount    INT,  
        @NoChangeCount  INT;  
  
DECLARE @StartTime DATETIME2(7) = SYSDATETIME();  
WITH targetFilteredByVersion AS -- Get the rows from the MS table that pertain to the specified version  
(  
    SELECT ms.User_ID, ms.ID, ms.AccessPermission  
    FROM mdm.', QUOTENAME(@table_EN_MS), N' ms',  
    CASE @UseUserIds  
    WHEN 1 THEN N'  
    INNER JOIN #userIds userIds ON userIds.ID = ms.User_ID'  
    END, N'  
    WHERE ms.Version_ID = @Version_ID  
),  
sourceByMemberType AS -- Get the rows from the map that pertain to the specified memberType  
(  
    SELECT User_ID, ID, AccessPermission  
    FROM #effectivePermissions  
    WHERE MemberType_ID = ', @MemberType_Leaf, N'  
)  
SELECT  
    @DeleteCount    = COALESCE(SUM(CASE WHEN source.User_ID IS NULL              THEN 1 ELSE 0 END), 0),  
    @InsertCount    = COALESCE(SUM(CASE WHEN target.User_ID IS NULL              THEN 1 ELSE 0 END), 0),  
    @UpdateCount    = COALESCE(SUM(CASE WHEN target.AccessPermission <> source.AccessPermission  
                                                                                         THEN 1 ELSE 0 END), 0),  
    @NoChangeCount  = COALESCE(SUM(CASE WHEN target.AccessPermission = source.AccessPermission  
                                                                                         THEN 1 ELSE 0 END), 0)  
FROM targetFilteredByVersion AS target  
FULL JOIN sourceByMemberType AS source  
ON target.User_ID = source.User_ID  
    AND target.ID = source.ID;  
  
PRINT CONCAT(SYSDATETIME(), N'': Count differences, elapsed time: '', DATEDIFF(MS, @StartTime, SYSDATETIME()) / 1000.0, N'' sec'');  
PRINT CONCAT(SYSDATETIME(), N'': @DeleteCount = '', @DeleteCount);  
PRINT CONCAT(SYSDATETIME(), N'': @InsertCount = '', @InsertCount);  
PRINT CONCAT(SYSDATETIME(), N'': @UpdateCount = '', @UpdateCount);  
PRINT CONCAT(SYSDATETIME(), N'': @NoChangeCount = '', @NoChangeCount);  
  
DECLARE @TotalChangeCount INT = (@DeleteCount + @InsertCount + @UpdateCount);  
SET @StartTime = SYSDATETIME();  
IF @TotalChangeCount > 0 -- If there are no changes, then do nothing.  
BEGIN  
    IF @TotalChangeCount > (@NoChangeCount / 2) -- This heuristic determines which approach to use.  
    BEGIN  
        -- There are at least twice as many changed rows as unchanged rows, so doing DELETE-INSERT will probably be faster than doing MERGE.  
        DELETE ms  
        FROM mdm.', QUOTENAME(@table_EN_MS), N' ms',   
        CASE @UseUserIds  
        WHEN 1 THEN N'  
        INNER JOIN #userIds userIds ON userIds.ID = ms.User_ID'  
        END, N'  
        WHERE Version_ID = @Version_ID;  
  
        INSERT INTO mdm.', QUOTENAME(@table_EN_MS), N'  
               (Version_ID, User_ID, ID, AccessPermission)  
        SELECT @Version_ID, User_ID, ID, AccessPermission  
        FROM #effectivePermissions  
        WHERE MemberType_ID = ', @MemberType_Leaf, N';  
  
        PRINT CONCAT(SYSDATETIME(), N'': DELETE-INSERT elapsed time: '', DATEDIFF(MS, @StartTime, SYSDATETIME())/1000.0, N'' sec'');  
    END  
    ELSE  
    BEGIN  
        -- There are twice as many (or more) unchanged rows as changed rows, so doing MERGE will probably be faster than doing DELETE-INSERT.  
        WITH targetFilteredByVersion AS -- Get the rows from the MS table that pertain to the specified version  
        (  
            SELECT ms.*  
            FROM mdm.', QUOTENAME(@table_EN_MS), N' ms',  
            CASE @UseUserIds  
            WHEN 1 THEN N'  
            INNER JOIN #userIds userIds ON userIds.ID = ms.User_ID'  
            END, N'  
            WHERE ms.Version_ID = @Version_ID  
        ),  
        sourceByMemberType AS -- Get the rows from the map that pertain to the specified memberType  
        (  
            SELECT User_ID, ID, AccessPermission  
            FROM #effectivePermissions  
            WHERE MemberType_ID = ', @MemberType_Leaf, N'  
        )  
        MERGE targetFilteredByVersion AS target  
        USING sourceByMemberType AS source  
        ON target.User_ID = source.User_ID AND  
            -- Note that Version_ID does not need to be included in the matching criteria because two different versions of the same member will  
            -- have different IDs. Thus, it is sufficient to match on ID.  
            target.ID = source.ID  
        WHEN MATCHED AND NOT target.AccessPermission = source.AccessPermission THEN  
            UPDATE SET target.AccessPermission = source.AccessPermission  
        WHEN NOT MATCHED BY TARGET THEN  
            INSERT (Version_ID,  User_ID,        ID,        AccessPermission)  
            VALUES (@Version_ID, source.User_ID, source.ID, source.AccessPermission)  
        WHEN NOT MATCHED BY SOURCE THEN  
            DELETE;  
  
        PRINT CONCAT(SYSDATETIME(), N'': MERGE elapsed time: '', DATEDIFF(MS, @StartTime, SYSDATETIME())/1000.0, N'' sec'');  
    END;  
END  
  
--Output statistics for performance & debugging reasons  
PRINT CONCAT(SYSDATETIME(), N'': ', QUOTENAME(@table_EN_MS), N' rows changed: '', @TotalChangeCount);  
');  
  
    IF @table_HP_MS IS NOT NULL  
    BEGIN  
        SET @SQL = CONCAT(@SQL, N'  
--DECLARE @MapCount INT = 0;  
--SELECT @MapCount = COUNT(*) FROM mdm.', QUOTENAME(@table_HP_MS), N' WHERE Version_ID = @Version_ID;  
--PRINT CONCAT(N''MS table row count: '', COALESCE(@MapCount, N''NULL''));  
  
-- Update the HP_MS table. There are two possible approaches:  
--    1. DELETE all of the existing rows in the MS table for the specified version and INSERT all of the #effectivePermissions rows into the MS table, or  
--    2. MERGE #effectivePermissions with the MS table.  
-- When there are few differences between the MS table and #effectivePermissions, option #2 is *much* faster (5-8 times faster in a test scenario with 3M rows) than #1.  
-- However, on a test run when all 3M rows were different, #2 was about 1.5-2.5 times slower than #1. So measure how different #effectivePermissions is from the MS table  
-- to determine which approach to use.  
  
WITH targetFilteredByVersion AS -- Get the rows from the MS table that pertain to the specified version  
(  
    SELECT ms.User_ID, ms.ID, ms.AccessPermission  
    FROM mdm.', QUOTENAME(@table_HP_MS), N' ms',  
    CASE @UseUserIds  
    WHEN 1 THEN N'  
    INNER JOIN #userIds userIds ON userIds.ID = ms.User_ID'  
    END, N'  
    WHERE ms.Version_ID = @Version_ID  
),  
sourceByMemberType AS -- Get the rows from the map that pertain to the specified memberType  
(  
    SELECT User_ID, ID, AccessPermission  
    FROM #effectivePermissions  
    WHERE MemberType_ID = ', @MemberType_Consolidated, N'  
)  
SELECT  
    @DeleteCount    = COALESCE(SUM(CASE WHEN source.User_ID IS NULL              THEN 1 ELSE 0 END), 0),  
    @InsertCount    = COALESCE(SUM(CASE WHEN target.User_ID IS NULL              THEN 1 ELSE 0 END), 0),  
    @UpdateCount    = COALESCE(SUM(CASE WHEN target.AccessPermission <> source.AccessPermission  
                                                                                         THEN 1 ELSE 0 END), 0),  
    @NoChangeCount  = COALESCE(SUM(CASE WHEN target.AccessPermission = source.AccessPermission  
                                                                                         THEN 1 ELSE 0 END), 0)  
FROM targetFilteredByVersion AS target  
FULL JOIN sourceByMemberType AS source  
ON target.User_ID = source.User_ID  
    AND target.ID = source.ID;  
  
PRINT CONCAT(SYSDATETIME(), N'': Count differences, elapsed time: '', DATEDIFF(MS, @StartTime, SYSDATETIME()) / 1000.0, N'' sec'');  
PRINT CONCAT(SYSDATETIME(), N'': @DeleteCount = '', @DeleteCount);  
PRINT CONCAT(SYSDATETIME(), N'': @InsertCount = '', @InsertCount);  
PRINT CONCAT(SYSDATETIME(), N'': @UpdateCount = '', @UpdateCount);  
PRINT CONCAT(SYSDATETIME(), N'': @NoChangeCount = '', @NoChangeCount);  
  
SET @TotalChangeCount = (@DeleteCount + @InsertCount + @UpdateCount);  
SET @StartTime = SYSDATETIME();  
IF @TotalChangeCount > 0 -- If there are no changes, then do nothing.  
BEGIN  
    IF @TotalChangeCount > (@NoChangeCount / 2) -- This heuristic determines which approach to use.  
    BEGIN  
        -- There are at least twice as many changed rows as unchanged rows, so doing DELETE-INSERT will probably be faster than doing MERGE.  
        DELETE ms  
        FROM mdm.', QUOTENAME(@table_HP_MS), N' ms',   
        CASE @UseUserIds  
        WHEN 1 THEN N'  
        INNER JOIN #userIds userIds ON userIds.ID = ms.User_ID'  
        END, N'  
        WHERE Version_ID = @Version_ID;  
  
        INSERT INTO mdm.', QUOTENAME(@table_HP_MS), N'  
               (Version_ID, User_ID, ID, AccessPermission)  
        SELECT @Version_ID, User_ID, ID, AccessPermission  
        FROM #effectivePermissions  
        WHERE MemberType_ID = ', @MemberType_Consolidated, N';  
  
        PRINT CONCAT(SYSDATETIME(), N'': DELETE-INSERT elapsed time: '', DATEDIFF(MS, @StartTime, SYSDATETIME())/1000.0, N'' sec'');  
    END  
    ELSE  
    BEGIN  
        -- There are twice as many (or more) unchanged rows as changed rows, so doing MERGE will probably be faster than doing DELETE-INSERT.  
        WITH targetFilteredByVersion AS -- Get the rows from the MS table that pertain to the specified version  
        (  
            SELECT ms.*  
            FROM mdm.', QUOTENAME(@table_HP_MS), N' ms',  
            CASE @UseUserIds  
            WHEN 1 THEN N'  
            INNER JOIN #userIds userIds ON userIds.ID = ms.User_ID'  
            END, N'  
            WHERE ms.Version_ID = @Version_ID  
        ),  
        sourceByMemberType AS -- Get the rows from the map that pertain to the specified memberType  
        (  
            SELECT User_ID, ID, AccessPermission  
            FROM #effectivePermissions  
            WHERE MemberType_ID = ', @MemberType_Consolidated, N'  
        )  
        MERGE targetFilteredByVersion AS target  
        USING sourceByMemberType AS source  
        ON target.User_ID = source.User_ID AND  
            -- Note that Version_ID does not need to be included in the matching criteria because two different versions of the same member will  
            -- have different IDs. Thus, it is sufficient to match on ID.  
            target.ID = source.ID  
        WHEN MATCHED AND NOT target.AccessPermission = source.AccessPermission THEN  
            UPDATE SET target.AccessPermission = source.AccessPermission  
        WHEN NOT MATCHED BY TARGET THEN  
            INSERT (Version_ID,  User_ID,        ID,        AccessPermission)  
            VALUES (@Version_ID, source.User_ID, source.ID, source.AccessPermission)  
        WHEN NOT MATCHED BY SOURCE THEN  
            DELETE;  
  
        PRINT CONCAT(SYSDATETIME(), N'': MERGE elapsed time: '', DATEDIFF(MS, @StartTime, SYSDATETIME())/1000.0, N'' sec'');  
    END;  
END  
  
--Output statistics for performance & debugging reasons  
PRINT CONCAT(SYSDATETIME(), N'': ', QUOTENAME(@table_HP_MS), N' rows changed: '', @TotalChangeCount);  
');  
    END  
  
    --PRINT @SQL;  
    EXEC sp_executesql @SQL, N'@Version_ID INT, @Entity_ID INT', @Version_ID, @Entity_ID;  
  
    --Clean up  
    DROP TABLE #effectivePermissions;  
    DROP TABLE #userIds;  
  
    PRINT CONCAT(SYSDATETIME(), N': Finished creating member security items for Entity_ID: ', @Entity_ID, ' and Version_ID: ', @Version_ID, N'  
');  
  
    --Update the status of all the SRAM rows we have used, to flag that they have been used in  
    --at least one processing operation. This flag does not signify that the processing is  
    --complete and/or up to date, it just states that this has happened once.  
    UPDATE sram SET  
        IsInitialized = 1  
    FROM mdm.tblSecurityRoleAccessMember AS sram  
    INNER JOIN #assignments AS asg ON sram.ID = asg.SRAM_ID  
    WHERE asg.IsProcessed = 1;  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpSecurityMemberProcessRebuildEvent]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpSecurityMemberProcessRebuildEvent]  
(  
    @SecurityMemberProcessEvent mdm.SecurityMemberProcessEvent READONLY,  
    @ProcessNow                 BIT = 0,  
    @CorrelationID              UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE @handle     UNIQUEIDENTIFIER,  
            @User_ID    INT,  
            @Version_ID INT,  
            @Entity_ID  INT;  
  
    IF NOT EXISTS (SELECT 1 FROM @SecurityMemberProcessEvent)  
    BEGIN  
        RETURN;  
    END  
  
    DECLARE event_cursor CURSOR  
    FOR SELECT [User_ID],[Entity_ID],Version_ID  
        FROM @SecurityMemberProcessEvent  
    OPEN event_cursor  
        FETCH NEXT FROM event_cursor INTO @User_ID, @Entity_ID, @Version_ID;  
        WHILE @@FETCH_STATUS = 0  
        BEGIN  
            --Put a message onto the SB queue to process member security  
            EXEC mdm.udpSecurityMemberQueueSave   
                @User_ID    = @User_ID, -- update member security for the user(s) that pertain(s) to the specified role.  
                @Version_ID = @Version_ID,   
                @Entity_ID  = @Entity_ID;  
            FETCH NEXT FROM event_cursor INTO @User_ID, @Entity_ID, @Version_ID;  
        END  
    CLOSE event_cursor;  
    DEALLOCATE event_cursor;  
  
    --Insert a msg into the Securitymember timer queue to "kick it off"      
    IF @ProcessNow=1  
    BEGIN  
        --get the existing conversation handle if possible  
        SET @handle = mdm.udfServiceGetConversationHandle(  
            N'microsoft/mdm/service/securitymembertimer',  
            N'microsoft/mdm/service/system');  
  
        IF @handle IS NULL   
            BEGIN DIALOG CONVERSATION @handle    
                FROM SERVICE [microsoft/mdm/service/securitymembertimer]    
                TO SERVICE N'microsoft/mdm/service/system'    
                WITH ENCRYPTION=OFF;  
              
        --set a timer on the handle  
        BEGIN CONVERSATION TIMER (@handle) TIMEOUT = 1;        
    END; --if  
      
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpSecurityMemberProcessRebuildModel]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
--Puts a msg on the qureue for all entities and all versions in the model  
Then inserts a timer msg onto the queue to effectively "kick it off"  
  
--Account  
EXEC mdm.udpSecurityMemberProcessRebuildModel @Model_ID=3  
*/  
CREATE PROCEDURE [mdm].[udpSecurityMemberProcessRebuildModel]  
(  
    @Model_ID       INT, --Required  
    @ProcessNow     BIT = 0  
)  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE @SecurityMemberProcessEvent mdm.SecurityMemberProcessEvent  
  
    INSERT @SecurityMemberProcessEvent([User_ID],[Entity_ID],Version_ID)  
    SELECT NULL, e.ID, v.ID  
    FROM mdm.tblEntity AS e  
    INNER JOIN mdm.tblModelVersion AS v  
    ON v.Model_ID = e.Model_ID  
    WHERE v.Model_ID = @Model_ID;  
  
    EXEC mdm.udpSecurityMemberProcessRebuildEvent @SecurityMemberProcessEvent, @ProcessNow  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpSecurityMemberProcessRebuildModelVersion]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
--Puts a msg on the qureue for all entities in the version.  
Then inserts a timer msg onto the queue to effectively "kick it off"  
  
--Account/Version3  
EXEC mdm.udpSecurityMemberProcessRebuildModelVersion @Version_ID=3  
*/  
CREATE PROCEDURE [mdm].[udpSecurityMemberProcessRebuildModelVersion]  
(  
    @Version_ID     INT, --Required  
    @ProcessNow     BIT = 0,  
    @CorrelationID  UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON;  
      
    DECLARE @SecurityMemberProcessEvent mdm.SecurityMemberProcessEvent  
  
    INSERT @SecurityMemberProcessEvent([User_ID],[Entity_ID],Version_ID)  
    SELECT NULL, e.ID, v.ID  
    FROM mdm.tblEntity AS e  
    INNER JOIN mdm.tblModelVersion AS v  
    ON v.Model_ID = e.Model_ID  
    WHERE v.ID = @Version_ID;  
  
    EXEC mdm.udpSecurityMemberProcessRebuildEvent @SecurityMemberProcessEvent, @ProcessNow  
       
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpSecurityMemberProcessRebuildUser]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
--Puts a msg on the qureue for the user  
Then inserts a timer msg onto the queue to effectively "kick it off"  
  
--Account  
EXEC mdm.udpSecurityMemberProcessRebuildUser @User_ID=3  
*/  
CREATE PROCEDURE [mdm].[udpSecurityMemberProcessRebuildUser]  
(  
    @User_ID        INT, --Required  
    @ProcessNow     BIT = 0,  
    @CorrelationID              UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE @SecurityMemberProcessEvent mdm.SecurityMemberProcessEvent  
  
    INSERT @SecurityMemberProcessEvent ([User_ID], [Entity_ID], Version_ID)  
    SELECT DISTINCT [User_ID], [Entity_ID], Version_ID  
    FROM [mdm].[viw_SYSTEM_SECURITY_ROLE_MEMBER] rm  
    INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_ROLE ur  
    ON rm.Role_ID = ur.Role_ID  
    WHERE ur.[User_ID] = @User_ID;  
  
    EXEC mdm.udpSecurityMemberProcessRebuildEvent @SecurityMemberProcessEvent, @ProcessNow  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpSecurityMemberQueueActivate]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    --Run this the first time to kick off the timer  
    DECLARE @handle UNIQUEIDENTIFIER;  
    BEGIN DIALOG CONVERSATION @handle  
        FROM SERVICE [microsoft/mdm/service/securitymembertimer]  
        TO SERVICE N'microsoft/mdm/service/system'  
        WITH ENCRYPTION=OFF --is by default  
    BEGIN CONVERSATION TIMER (@handle) TIMEOUT = 30;  
  
    --This will disable the activation proc on the queue  
    --ALTER QUEUE [mdm].[microsoft/mdm/queue/securitymember] WITH STATUS = ON , RETENTION = OFF , ACTIVATION (  STATUS = OFF , PROCEDURE_NAME = [mdm].[udpSecurityMemberQueueActivate] , MAX_QUEUE_READERS = 1 , EXECUTE AS OWNER  )  
    --This will Enable the activation proc on the queue  
    --ALTER QUEUE [mdm].[microsoft/mdm/queue/securitymember] WITH STATUS = ON , RETENTION = OFF , ACTIVATION (  STATUS = ON , PROCEDURE_NAME = [mdm].[udpSecurityMemberQueueActivate] , MAX_QUEUE_READERS = 1 , EXECUTE AS OWNER  )  
  
    --truncate table mdm.tblServiceBrokerLog  
    select * FROM mdm.[microsoft/mdm/queue/securitymembertimer]  
    select * FROM mdm.[microsoft/mdm/queue/securitymember]  
  
    --This will generate some actual work msgs  
    Exec mdm.udpSecurityMemberQueueSave 1, 2, 4  
    Exec mdm.udpSecurityMemberQueueSave 1, 2, 4  
    Exec mdm.udpSecurityMemberQueueSave 1, 2, 4  
  
    --Call this if you don't feel like waiting  
    --EXEC mdm.udpSecurityMemberQueueActivate  
  
    --Debug logging  
    --CREATE TABLE tblServiceBrokerLog (Description NVARCHAR(MAX),EnterDTM DATETIME)  
    select count(*) from mdm.tblServiceBrokerLog  
    select top 1000 *,getdate() as CurrentTime from mdm.tblServiceBrokerLog  
  
    --Helpful to figure out whats happening is SSSB  
    select * from sys.dm_broker_activated_tasks  
    select * from sys.dm_broker_connections  
    select * from sys.dm_broker_forwarded_messages  
    select * from sys.dm_broker_queue_monitors  
*/  
CREATE PROCEDURE [mdm].[udpSecurityMemberQueueActivate]  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE  
         @message_type_name SYSNAME  
        ,@handle            UNIQUEIDENTIFIER  
        ,@msghandle         UNIQUEIDENTIFIER  
        ,@msgbody           XML  
        ,@interval          INT  
        ,@need_new          BIT  
        ,@status            NVARCHAR(1000)  
        ,@dialog            UNIQUEIDENTIFIER  
        ,@User_ID           INT  
        ,@TempVersionID     INT  
        ,@TempEntityID      INT  
        ,@UserIdList        mdm.IdList  
          
        ,@Permission_Admin  TINYINT = 5;  
  
    --Initialize variables  
    SELECT @handle = NULL, @need_new = NULL;  
  
    --Load interval setting from config, and check the defaults and ranges  
    SELECT @interval = CAST(SettingValue AS INT) FROM mdm.tblSystemSetting WHERE SettingName = 'SecurityMemberProcessInterval';  
    IF @interval IS NULL SET @interval = 120; --Protect against NULL values  
    ELSE IF @interval < 10 SET @interval = 10; --Prevent negative and 'real-time' settings  
    ELSE IF @interval > 86400 SET @interval = 86400; --Check at least once per day (60 x 60 x 24)  
  
    BEGIN TRANSACTION  
  
    WAITFOR (  
        RECEIVE TOP(1)  
            @handle = [conversation_handle]  
            ,@message_type_name = message_type_name  
  
        FROM mdm.[microsoft/mdm/queue/securitymembertimer]  
    ), TIMEOUT 5000; --Always wait a constant time for any new messages  
  
    --Got a TIMER message  
    IF (@message_type_name = CAST(N'http://schemas.microsoft.com/SQL/ServiceBroker/DialogTimer' AS NVARCHAR(128))) BEGIN  
  
        --Start a new TIMER and COMMIT the transaction before we do the real work, to avoid poisoning  
        BEGIN CONVERSATION TIMER (@handle) TIMEOUT = @interval;  
        COMMIT TRANSACTION;  
  
        --Look into the security member queue to get the work items messages..  
        --gotta do this in a loop as the receive statement will only get one conversation at a time  
        DECLARE @messages TABLE(handle UNIQUEIDENTIFIER,message_type_name NVARCHAR(256),message_body VARBINARY(MAX)) ;  
        WHILE EXISTS(SELECT 1 FROM mdm.[microsoft/mdm/queue/securitymember])  
        BEGIN  
            --INSERT INTO mdm.tblServiceBrokerLog SELECT 'udpSecurityMemberQueueActivate: Getting item from queue',GETDATE();  
            RECEIVE [conversation_handle]  
                ,message_type_name  
                ,message_body  
            FROM mdm.[microsoft/mdm/queue/securitymember]  
            INTO @messages  
        END; --while  
  
        --Loop through the work item messages and create table with all distinct version/entity combinations  
        DECLARE @workitems TABLE([User_ID] INT, VersionID INT,EntityID INT);  
        WITH cte AS (SELECT CONVERT(XML, message_body) AS msg FROM @messages)  
        INSERT INTO @workitems([User_ID], VersionID, EntityID)  
        SELECT DISTINCT  
            msg.value('/SecurityMemberCriteria[1]/User_ID[1]','int') AS [User_ID],  
            msg.value('/SecurityMemberCriteria[1]/Version_ID[1]','int') AS Version_ID,  
            msg.value('/SecurityMemberCriteria[1]/Entity_ID[1]','int') AS Entity_ID  
        FROM cte;  
  
        DELETE FROM @messages; --We are finished working with it  
  
        --Loop through the @workitems table and call the process sproc  
        WHILE EXISTS(SELECT 0 FROM @workitems)  
        BEGIN  
            BEGIN TRANSACTION  
  
            BEGIN TRY  
                SELECT TOP 1  
                     @TempVersionID = VersionID  
                    ,@TempEntityID = EntityID  
                FROM @workitems  
                ORDER BY VersionID, EntityID;  
  
                -- Get all user IDs that apply to the current version and entity.  
                DELETE FROM @UserIdList;  
  
                IF NOT EXISTS(  
                    SELECT 1  
                    FROM @workitems   
                    WHERE VersionID = @TempVersionID  
                        AND EntityID = @TempEntityID  
                        AND [User_ID] = 0 -- All users  
                )  
                BEGIN  
                    INSERT INTO @UserIdList  
                    SELECT DISTINCT w.[User_ID]  
                    FROM @workitems w  
                    LEFT JOIN [mdm].[viw_SYSTEM_SECURITY_USER_ENTITY] s  
                    ON s.[User_ID] = w.[User_ID]  
                        AND s.ID = w.EntityID  
                    WHERE w.VersionID = @TempVersionID  
                        AND w.EntityID = @TempEntityID  
                        AND (s.AccessPermission IS NULL OR s.AccessPermission != @Permission_Admin);  
                END  
  
                --Delete from the temp table  
                DELETE FROM @workitems WHERE VersionID=@TempVersionID AND EntityID=@TempEntityID;  
                --Delete it at top in case of error  
  
PRINT CONCAT(SYSDATETIME(), N': udpSecurityMemberQueueActivate - calling udpSecurityMemberProcess for @Version_ID = ', @TempVersionID, N', @Entity_ID = ', @TempEntityID);  
                EXEC mdm.udpSecurityMemberProcess @Version_ID=@TempVersionID, @Entity_ID=@TempEntityID, @UserIdList=@UserIdList;  
  
                COMMIT TRANSACTION  
            END TRY  
            BEGIN CATCH  
                -- Get error info.  
                DECLARE  
                    @ErrorMessage NVARCHAR(4000),  
                    @ErrorSeverity INT,  
                    @ErrorState INT,  
                    @ErrorNumber INT,  
                    @ErrorLine INT,  
                    @ErrorProcedure NVARCHAR(126);  
                EXEC mdm.udpGetErrorInfo  
                    @ErrorMessage = @ErrorMessage OUTPUT,  
                    @ErrorSeverity = @ErrorSeverity OUTPUT,  
                    @ErrorState = @ErrorState OUTPUT,  
                    @ErrorNumber = @ErrorNumber OUTPUT,  
                    @ErrorLine = @ErrorLine OUTPUT,  
                    @ErrorProcedure = @ErrorProcedure OUTPUT  
  
                SET @ErrorMessage = CONCAT(@ErrorMessage, N', @ErrorNumber = ', @ErrorNumber, N', @ErrorProcedure = "', @ErrorProcedure, N'", line ', @ErrorLine);  
                PRINT @ErrorMessage;  
  
                ROLLBACK TRANSACTION  
  
                RETURN 1;-- Used by test code to indicate an error occurred.  
            END CATCH  
        END; --while  
        --INSERT INTO mdm.tblServiceBrokerLog SELECT 'udpSecurityMemberQueueActivate: Finished processing all security member maps for all the combinations of version/entity',GETDATE()  
  
    --Got an END DIALOG message  
    END ELSE IF (@message_type_name = CAST(N'http://schemas.microsoft.com/SQL/ServiceBroker/EndDialog' AS NVARCHAR(128))) BEGIN  
        --INSERT INTO mdm.tblServiceBrokerLog SELECT  N'udpSecurityMemberQueueActivate: end dialog',GETDATE();  
        SET @need_new = 1;  
  
    --Got ERROR message  
    END ELSE IF (@message_type_name = CAST(N'http://schemas.microsoft.com/SQL/ServiceBroker/Error' AS NVARCHAR(128))) BEGIN  
        --INSERT INTO mdm.tblServiceBrokerLog SELECT 'udpSecurityMemberQueueActivate: Error',GETDATE();  
        SET @need_new = 1;  
  
    --Timeout or unexpected message  
    END ELSE BEGIN  
        --INSERT INTO mdm.tblServiceBrokerLog SELECT 'udpSecurityMemberQueueActivate: Else: ' + CONVERT(NVARCHAR(MAX),ISNULL(@handle,'NULL')) + '-' + ISNULL(@message_type_name,'NULL'),GETDATE();  
        COMMIT TRANSACTION;  
  
    END; --if  
  
    IF (@need_new = 1) BEGIN  
  
        END CONVERSATION @handle;  
  
        BEGIN DIALOG CONVERSATION @handle  
            FROM SERVICE [microsoft/mdm/service/securitymembertimer]  
            TO SERVICE N'microsoft/mdm/service/system'  
            WITH ENCRYPTION = OFF;  
        BEGIN CONVERSATION TIMER (@handle) TIMEOUT = @interval;  
  
        COMMIT TRANSACTION;  
  
    END; --if  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpSecurityMemberQueueSave]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
This proc adds a message to the securitymember queue.  
It is called when ever a change has happened that affects(could) member security  
  
--Version3/Account - Entity example call  
Exec mdm.udpSecurityMemberQueueSave @User_ID=1, @Version_ID=4, @Entity_ID=7  
  
select * FROM mdm.[microsoft/mdm/queue/securitymembertimer]  
select * FROM mdm.[microsoft/mdm/queue/securitymember]  
  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpSecurityMemberQueueSave]  
(  
    @User_ID    INT = NULL, -- Users will have their member count cache cleared when security is processed. Leave NULL to clear the cached counts of all users.  
    @Version_ID INT,  
    @Entity_ID  INT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON  
    DECLARE @messages_conversation_group UNIQUEIDENTIFIER = CONVERT(UNIQUEIDENTIFIER, 0x2) --This is a constant.  Its used is udpSecurityMemberQueueActivate as well  
    --Insert a Message into the Service Broker Queue  
    DECLARE @xml AS XML;  
    SET @xml = (  
        SELECT  
            @User_ID AS [User_ID],  
            @Version_ID AS [Version_ID],  
            @Entity_ID AS [Entity_ID]  
        FOR XML PATH('SecurityMemberCriteria'), ELEMENTS XSINIL --IsNull are really needed but they are there to keep the message the same  
    );  
      
    --INSERT INTO mdm.tblServiceBrokerLog SELECT 'udpSecurityMemberQuestSave: Adding message to queue, @Role_ID=' + CONVERT(NVARCHAR(MAX),@Role_ID) + N', @Version_ID=' + CONVERT(NVARCHAR(MAX),@Version_ID)+ N', @Entity_ID=' + CONVERT(NVARCHAR(MAX),@Entity_ID),GETDATE();  
    --try to get an existing conversation handle  
    DECLARE @conversationHandle UNIQUEIDENTIFIER = mdm.udfServiceGetConversationHandle(  
        N'microsoft/mdm/service/system',  
        N'microsoft/mdm/service/securitymember');  
      
    ----Start a new conversation if necessary  
    IF @conversationHandle IS NULL  
        BEGIN DIALOG CONVERSATION @conversationHandle  
            FROM SERVICE [microsoft/mdm/service/system]   
            TO SERVICE N'microsoft/mdm/service/securitymember'  
            ON CONTRACT [microsoft/mdm/contract/securitymember]   
            WITH ENCRYPTION=OFF; --is by default  
  
    --Send the message  
    SEND ON CONVERSATION @conversationHandle MESSAGE TYPE [microsoft/mdm/message/securitymember](@xml);  
  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpSecurityMemberResolverGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
Gets the privilege for the given member  
  
Procedure  : mdm.udpSecurityMemberResolverGet  
Component  : Security  
Description: mdm.udpSecurityMemberResolverGet returns a list of members and privileges available for a user.  
Parameters : User ID, Version ID, Entity ID, Hierarchy_ID (Optional), HIerarchyType_ID )Optional),Member ID (optional), Member type ID (optional)  
  
Example    : EXEC mdm.udpSecurityMemberResolverGet @User_ID = 1, @Version_ID = 4, @Entity_ID = 7, @Member_ID = 0, @MemberType_ID = 2  
Dependency : NA  
  
  
EXEC mdm.udpSecurityMemberResolverGet @User_ID = 1, @Version_ID = 20, @Entity_ID = 31, @Member_ID = null, @MemberType_ID = null  
*/  
CREATE PROCEDURE [mdm].[udpSecurityMemberResolverGet]  
(  
    @User_ID            INT,  
    @Version_ID         INT,  
    @Hierarchy_ID       INT = NULL,  
    @HierarchyType_ID   TINYINT = NULL,  
    @Entity_ID          INT,  
    @Member_ID          INT,  
    @MemberType_ID      TINYINT,  
    @Privilege_ID       TINYINT = NULL OUTPUT,  
    @AccessPermission   TINYINT = NULL OUTPUT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON  
  
    -- Why?  
    SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED  
  
    DECLARE  
        @ExplicitHierarchyTypeId    TINYINT = 0,  
        @DerivedHierarchyTypeId     TINYINT = 1,  
  
        @Root_ID                    INT = 0,  
        @Unused_ID                  INT = -1,  
  
        @Permission_Deny            TINYINT = 1,  
        @Permission_Access          TINYINT = 4;  
  
    DECLARE @TempCount INT  
    DECLARE @Item_ID INT  
  
    SET @Privilege_ID = @Permission_Deny;  
    SET @AccessPermission = 0;  
        -- Root and used node use hierarchy permission  
    IF COALESCE(NULLIF(@Member_ID, @Unused_ID), @Root_ID) = @Root_ID  
    BEGIN   
        IF @HierarchyType_ID = @ExplicitHierarchyTypeId  
        BEGIN  
            SELECT @Privilege_ID=Privilege_ID, @AccessPermission=AccessPermission FROM mdm.viw_SYSTEM_SECURITY_USER_HIERARCHY WHERE User_ID = @User_ID AND ID = @Hierarchy_ID  
        END  
        ELSE IF @HierarchyType_ID = @DerivedHierarchyTypeId  
        BEGIN  
            SELECT @Privilege_ID=Privilege_ID, @AccessPermission=AccessPermission FROM mdm.viw_SYSTEM_SECURITY_USER_HIERARCHY_DERIVED WHERE User_ID = @User_ID AND ID = @Hierarchy_ID  
        END  
    END  
    -- other nodes use membertype effective permission  
    ELSE  
    BEGIN  
        SELECT @Privilege_ID = Privilege_ID, @AccessPermission = AccessPermission  
        FROM mdm.viw_SYSTEM_SECURITY_USER_MEMBERTYPE  
        WHERE User_ID = @User_ID AND Entity_ID = @Entity_ID AND ID = @MemberType_ID  
    END  
  
    IF COALESCE(NULLIF(@Member_ID, @Unused_ID), @Root_ID) = @Root_ID  
    BEGIN  
        IF EXISTS(  
            SELECT 1  
            FROM mdm.viw_SYSTEM_SECURITY_USER_MEMBER  
            WHERE User_ID=@User_ID  
            AND IsMapped=1  
            AND Hierarchy_ID=@Hierarchy_ID  
            AND HierarchyType_ID=@HierarchyType_ID  
            AND Member_ID=@Member_ID  
        )  
            SELECT @Privilege_ID = Privilege_ID, @Permission_Access = AccessPermission  
            FROM mdm.viw_SYSTEM_SECURITY_USER_MEMBER  
            WHERE User_ID=@User_ID  
                AND IsMapped=1  
                AND Hierarchy_ID=@Hierarchy_ID  
                AND HierarchyType_ID=@HierarchyType_ID  
                AND Member_ID=@Member_ID  
    END ELSE  
    BEGIN  
        -- Overwrite the effective membertype permission with member permission  
        IF mdm.udfUseMemberSecurity(@User_ID, @Entity_ID, @Version_ID, @MemberType_ID) <> 0  
        BEGIN  
            DECLARE @MemberIds mdm.MemberId;  
            INSERT INTO @MemberIds (ID, MemberType_ID) SELECT @Member_ID, @MemberType_ID  
  
            DECLARE @MemberPermissions AS TABLE (ID INT, MemberType_ID TINYINT, Privilege_ID TINYINT, AccessPermission TINYINT);  
            INSERT INTO @MemberPermissions  
            EXEC mdm.udpSecurityMembersResolverGet @User_ID=@User_ID, @Version_ID=@Version_ID, @Entity_ID=@Entity_ID, @MemberIds=@MemberIds;  
  
            SELECT  
                @Privilege_ID = Privilege_ID, @AccessPermission = AccessPermission  
            FROM @MemberPermissions  
        END  
    END  
  
    SET NOCOUNT OFF  
  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpSecurityMembersResolverGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
*** NOTE: ANY CHANGES TO THE COLUMNS RETURNED IN THIS PROCEDURE MUST BE MADE IN THE COMPANION STORED PROCEDURES: udpValidationsGet, udpEntityMembersUpdate, udpHierarchyMembersUpdate.    
  
Procedure  : mdm.udpSecurityMembersResolverGet  
Component  : Security  
Description: mdm.udpSecurityMembersResolverGet returns a list of members and privileges available for a user.  
Parameters : User ID, Version ID, Entity ID, Member Ids, ExplicitHierarchy_ID  
Return     : Table: ID, MemberType_ID, Privilege_ID  
  
Dependency : NA  
Called By  : udpValidationsGet, udpEntityMembersUpdate, udpHierarchyMembersUpdate  
Example    :   
            DECLARE @MemberIDs AS mdm.MemberId  
            INSERT INTO @MemberIDs (ID, MemberType_ID)  
            VALUES (880, 1), (881, 1), (901, 1)  
      
            EXEC mdm.udpSecurityMembersResolverGet @User_ID = 1, @Version_ID = 20, @MemberIds = @MemberIDs, @ExplicitHierarchy_ID = 10  
*/  
CREATE PROCEDURE [mdm].[udpSecurityMembersResolverGet]  
(  
    @User_ID    INT,  
    @Version_ID INT,  
    @Entity_ID  INT,  
    @MemberIds  mdm.MemberId READONLY,  
    @ExplicitHierarchy_ID INT = NULL, -- Pass a non-NULL value when determining a user's permission for changing explicit hierarchy relationships, in which   
                                     -- case special node types (ROOT, MDMUNUSED) are treated differently. That it, the result set of this sproc will indicate  
                                     -- whether the given user has permission to move members to and from ROOT/MDMUNUSED.  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON  
  
    SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED   
  
    DECLARE @EntitySecurityTable            SYSNAME,  
            @HierarchyParentSecurityTable   SYSNAME,  
            @MemberType_Leaf                TINYINT = 1,  
            @MemberType_Consolidated        TINYINT = 2,  
            @SQL                            NVARCHAR(MAX);  
  
    SELECT  
        @EntitySecurityTable = CAST(EntityTable + '_MS' AS SYSNAME),  
        @HierarchyParentSecurityTable = CASE WHEN HierarchyParentTable IS NOT NULL THEN CAST(HierarchyParentTable + '_MS' AS SYSNAME) ELSE NULL END  
    FROM  
        mdm.tblEntity  
    WHERE  
        ID = @Entity_ID;  
  
    -- This pseudo-constant is for use in string concatenation operations to prevent string truncation. When concatenating two or more strings,  
    -- if none of the strings is an NVARCHAR(MAX) or an NVARCHAR constant that is longer than 4,000 characters, then the resulting string   
    -- will be silently truncated to 4,000 characters. Concatenating with this empty NVARCHAR(MAX), is sufficient to prevent truncation.  
    -- See http://connect.microsoft.com/SQLServer/feedback/details/283368/nvarchar-max-concatenation-yields-silent-truncation.  
    DECLARE @TruncationGuard NVARCHAR(MAX) = N'';  
  
    -- Preloading the members into an indexed temp table is better for perf than directly joining with un-indexed @MemberIds. A temp table is  
    -- used instead of a table var so that a multi-column index may be used.  
    CREATE TABLE #MemberIds   
    (  
        Member_ID INT NOT NULL,  
        MemberType_ID INT NOT NULL,  
        Privilege_ID INT,  
        AccessPermission INT  
    );  
    CREATE UNIQUE CLUSTERED INDEX #ix_MemberIds_Member_ID_MemberType_ID ON #MemberIds (Member_ID, MemberType_ID);  
    INSERT INTO #MemberIds (Member_ID, MemberType_ID)  
    SELECT DISTINCT  
         ID  
        ,MemberType_ID  
    FROM @MemberIds  
    WHERE  
            ID IS NOT NULL  
        AND MemberType_ID IS NOT NULL;  
  
        --!!DO NOT CHANGE!! the order or names of columns returned by this without updating udpValidationsGet, udpEntityMembersUpdate, udpHierarchyMembersUpdate  
        SET @SQL = CONCAT(@TruncationGuard, N'  
    -- Preloading the user''s roles into a table var is better for perf than directly joining with viw_SYSTEM_SECURITY_USER_ROLE.   
    -- Testing on large (~1M members) data sets showed that using a table var is slightly (10-20%) faster than using a temp table.  
    DECLARE @SecurityRoles TABLE(Role_ID INT PRIMARY KEY);  
    INSERT INTO @SecurityRoles  
    SELECT Role_ID FROM mdm.[viw_SYSTEM_SECURITY_USER_ROLE] WHERE User_ID = @User_ID;  
      
    DECLARE   
         @Root_ID                   INT = 0  
        ,@Unused_ID                 INT = -1  
        ,@MemberType_Consolidated   TINYINT = 2  
        ,@Permission_Deny           TINYINT = 1  
        ,@Permission_Access         TINYINT = 4  
        ,@Permission_Inferred       TINYINT = 99;  
  
    -- If an Explicit Hierarchy was specified then get permissions to see if nodes can be moved to/from special node types ROOT and   
    -- MDMUNUSED (if those special nodes were included in the input list of members)  
    IF @ExplicitHierarchy_ID IS NOT NULL  
    BEGIN  
        -- See if the user has explicit permission on the ROOT node of the specified hierarchy.  
        -- Note that if it doesn''t, a query further down (the one that handles regular members) will check for inferred permission on ROOT.  
        DECLARE @Root_Permission TINYINT = NULL;  
        DECLARE @Root_AccessPermission TINYINT = 0;  
        SELECT  
            @Root_Permission = MIN(X.Privilege_ID),  
            @Root_AccessPermission =   
                SUM(Distinct(X.AccessPermission & 0x1)) +   
                SUM(Distinct(X.AccessPermission & 0x2)) +   
                SUM(Distinct(X.AccessPermission & 0x4))  
        FROM mdm.tblSecurityRoleAccessMember X  
        INNER JOIN @SecurityRoles R  
            ON X.Role_ID = R.Role_ID  
        WHERE  
                X.Version_ID = @Version_ID  
            AND X.Entity_ID = @Entity_ID  
            AND X.Member_ID = @Root_ID  
            AND X.MemberType_ID = @MemberType_Consolidated  
            AND X.ExplicitHierarchy_ID = @ExplicitHierarchy_ID;  
  
        UPDATE m  
        SET Privilege_ID = @Root_Permission, AccessPermission = @Root_AccessPermission  
        FROM #MemberIds m  
        WHERE  
                m.Member_ID = @Root_ID  
            AND m.MemberType_ID = @MemberType_Consolidated;  
  
        -- Explicit permissions cannot be assigned to MDMUNUSED. It has an assumed Update permission.  
        UPDATE m  
        SET Privilege_ID = @Permission_Access, AccessPermission = 7 --All  
        FROM #MemberIds m  
        WHERE  
                m.Member_ID = @Unused_ID  
            AND m.MemberType_ID = @MemberType_Consolidated;  
    END;  
  
    WITH membersresolved as  
    (  
        SELECT  
            ID AS Member_ID,  
            ', @MemberType_Leaf, N' AS MemberType_ID,  
            AccessPermission  
        FROM  
            mdm.', QUOTENAME(@EntitySecurityTable), N' X  
        WHERE X.User_ID = @User_ID  
            AND X.Version_ID = @Version_ID',  
            CASE  
                WHEN @HierarchyParentSecurityTable IS NOT NULL THEN CONCAT(N'  
        UNION ALL  
        SELECT  
            ID AS Member_ID,  
            ', @MemberType_Consolidated, N' AS MemberType_ID,  
            AccessPermission  
        FROM  
            mdm.', QUOTENAME(@HierarchyParentSecurityTable), N' X  
        WHERE X.User_ID = @User_ID  
            AND X.Version_ID = @Version_ID')  
                ELSE N''  
            END, N'  
    )  
    UPDATE m  
    SET Privilege_ID =  
        CASE  
            WHEN res.AccessPermission IS NULL THEN @Permission_Deny --Absence of record is effective deny  
            ELSE @Permission_Access  
        END  
        , AccessPermission = res.AccessPermission  
    FROM #MemberIds m  
    LEFT JOIN membersresolved res  
    ON      m.Member_ID     = res.Member_ID  
        AND m.MemberType_ID = res.MemberType_ID  
    WHERE m.Privilege_ID IS NULL;  
  
    SELECT  
         Member_ID      AS ID  
        ,MemberType_ID  AS MemberType_ID  
        ,Privilege_ID   AS Privilege_ID  
        ,AccessPermission   AS AccessPermission  
    FROM #MemberIds;  
    ');  
    EXEC sp_executesql @SQL,  
        N'@User_ID INT, @Version_ID INT, @Entity_ID INT, @ExplicitHierarchy_ID INT',  
        @User_ID, @Version_ID, @Entity_ID, @ExplicitHierarchy_ID;  
                      
    SET NOCOUNT OFF  
      
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpSecurityPrivilegesDelete]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
EXEC mdm.udpSecurityPrivilegesDelete 1, 12, 1, 1  
  
--The list of Objects can be found in mdm.tblSecurityObject.  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpSecurityPrivilegesDelete]  
(  
	@Principal_ID		INT = NULL,  
	@PrincipalType_ID	INT = NULL,  
	@Object_ID			INT,  
	@Securable_ID		INT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
	SET NOCOUNT ON  
  
	DECLARE @Role_ID			INT  
  
	IF ISNULL(@Principal_ID, 0) > 0 AND ISNULL(@PrincipalType_ID, 0) > 0 BEGIN  
		SELECT	@Role_ID = Role_ID  
		FROM	mdm.tblSecurityAccessControl  
		WHERE	Principal_ID = @Principal_ID  
		AND		PrincipalType_ID = @PrincipalType_ID  
  
		IF @Role_ID IS NOT NULL BEGIN  
			DELETE FROM mdm.tblSecurityRoleAccess WHERE Role_ID = @Role_ID AND Object_ID = @Object_ID AND Securable_ID = @Securable_ID  
		END  
	END       
    ELSE IF ISNULL(@Principal_ID, 0) = 0 AND ISNULL(@PrincipalType_ID, 0) > 0 BEGIN  
        DELETE FROM mdm.tblSecurityRoleAccess  
        WHERE Object_ID = 5  
        AND Securable_ID = @Securable_ID  
        AND Role_ID IN (  
            SELECT	Role_ID  
            FROM	mdm.tblSecurityAccessControl  
            WHERE	PrincipalType_ID = @PrincipalType_ID  
        )  
    END  
	ELSE BEGIN  
			DELETE   
			FROM	mdm.tblSecurityRoleAccess   
			WHERE	Object_ID = @Object_ID   
			AND		Securable_ID = @Securable_ID  
	END  
  
    -- Send the message  
	EXEC mdm.udpPerformanceQueueSave;  
  
	SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpSecurityPrivilegesDeleteByPrincipalID]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
Deletes all permissions (functional, model, and member) explicitly assigned   
to the given principal.  
EXEC mdm.udpSecurityPrivilegesDeleteByPrincipalID 1,1  
*/  
CREATE PROCEDURE [mdm].[udpSecurityPrivilegesDeleteByPrincipalID]  
(  
    @SystemUser_ID      INT, --Person performing action  
    @Principal_ID       INT,  
    @PrincipalType_ID   TINYINT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON  
  
    DECLARE   
         @FunctionalPrivilege_SuperUser TINYINT = 6  
        ,@PrincipalType_Group           INT = 2  
  
    -- Get the role ID(s) for the given principal.  
    DECLARE @RoleIds TABLE (Role_ID INT PRIMARY KEY);  
    INSERT INTO @RoleIds (Role_ID)  
    SELECT Role_ID  
    FROM mdm.tblSecurityAccessControl  
    WHERE   PrincipalType_ID = @PrincipalType_ID  
        AND Principal_ID = @Principal_ID  
  
    -- Get the role ID(s) that currently have super user functional privilege.  
    DECLARE @SuperUserRoles TABLE(Role_ID INT PRIMARY KEY);  
    INSERT INTO @SuperUserRoles(Role_ID)  
    SELECT DISTINCT Role_ID  
    FROM mdm.tblSecurityRoleAccessFunctional  
    WHERE FunctionalPrivilege_ID = @FunctionalPrivilege_SuperUser;  
  
    -- Determine if the principal is having a SuperUser functional privilege deleted.  
    IF EXISTS (  
        SELECT 1   
        FROM @SuperUserRoles ar  
        INNER JOIN @RoleIds r  
        ON ar.Role_ID = r.Role_ID)  
    BEGIN  
        -- Only SuperUsers can delete a SuperUser permission. Note: That the user performing the operation has at least Security functional privilege should have been verified before calling this sproc.  
        IF NOT EXISTS (  
            SELECT 1   
            FROM mdm.udfSecurityUserFunctionList(@SystemUser_ID)   
            WHERE Function_ID = @FunctionalPrivilege_SuperUser)   
        BEGIN  
            RAISERROR('MDSERR500067|The Super User function can only be granted or revoked by a user that already has that function.', 16, 1);  
            RETURN;  
        END;  
          
        -- Ensure that the principal is not the last super user.  
        IF EXISTS (SELECT 1 FROM @SuperUserRoles) -- This *should* always be true (unless the db has somehow been corrupted), but do the check anyway to prevent the possibility of a misleading error message.  
           AND NOT EXISTS (SELECT 1   
                           FROM @SuperUserRoles ar  
                           LEFT JOIN @RoleIds r  
                           ON ar.Role_ID = r.Role_ID  
                           WHERE r.Role_ID IS NULL)  
        BEGIN  
            IF @PrincipalType_ID = @PrincipalType_Group  
            BEGIN  
                RAISERROR('MDSERR500059|The group cannot be deleted. At least one user or group must have the Super User function.', 16, 1);  
            END ELSE  
            BEGIN  
                RAISERROR('MDSERR500056|The user cannot be deleted. At least one user or group must have the Super User function.', 16, 1);  
            END;  
            RETURN;  
        END;  
    END;  
  
    -- Delete functional permissions  
    DELETE ra  
    FROM mdm.tblSecurityRoleAccessFunctional ra  
    INNER JOIN @RoleIds r  
    ON ra.Role_ID = r.Role_ID  
  
    -- Delete model object permissions  
    DELETE ra  
    FROM mdm.tblSecurityRoleAccess ra  
    INNER JOIN @RoleIds r  
    ON ra.Role_ID = r.Role_ID  
  
    -- Delete member permissions  
    DELETE ra  
    FROM mdm.tblSecurityRoleAccessMember ra  
    INNER JOIN @RoleIds r  
    ON ra.Role_ID = r.Role_ID  
  
    -- Send the message  
	EXEC mdm.udpPerformanceQueueSave;  
  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpSecurityPrivilegesDeleteByRoleAccessMUID]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
Create PROCEDURE [mdm].[udpSecurityPrivilegesDeleteByRoleAccessMUID]  
(  
	@RoleAccess_MUID		UNIQUEIDENTIFIER,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
	SET NOCOUNT ON  
	  
	DELETE FROM mdm.tblSecurityRoleAccess WHERE MUID = @RoleAccess_MUID  
  
    -- Send the message  
	EXEC mdm.udpPerformanceQueueSave;  
  
	SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpSecurityPrivilegesFunctionDelete]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
*/  
CREATE PROCEDURE [mdm].[udpSecurityPrivilegesFunctionDelete]  
(  
    @SystemUser_ID  INT,  
    @Function_MUID  UNIQUEIDENTIFIER,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    -- There must be at least one principal that has Super User functional permission, so  
    -- return an error when trying to delete the last one.  
  
    --Start transaction, being careful to check if we are nested.  
    DECLARE @TranCounter INT = @@TRANCOUNT;  
    IF @TranCounter > 0  
    BEGIN  
        SAVE TRANSACTION TX;  
    END ELSE  
    BEGIN  
        BEGIN TRANSACTION;  
    END;  
  
    BEGIN TRY  
  
        DECLARE   
             @FunctionalPrivilege_SuperUser TINYINT = 6  
            ,@DeletedFunctional_ID          TINYINT;  
          
        SELECT @DeletedFunctional_ID = FunctionalPrivilege_ID   
        FROM mdm.tblSecurityRoleAccessFunctional   
        WHERE MUID = @Function_MUID;  
              
        IF (@DeletedFunctional_ID = @FunctionalPrivilege_SuperUser)  
        BEGIN  
            -- Only SuperUsers can delete a SuperUser permission. Note: That the user performing the operation has at least Security functional privilege should have been verified before calling this sproc.  
            IF NOT EXISTS (  
                SELECT 1   
                FROM mdm.udfSecurityUserFunctionList(@SystemUser_ID)   
                WHERE Function_ID = @FunctionalPrivilege_SuperUser)   
            BEGIN  
                RAISERROR('MDSERR500067|The Super User function can only be granted or revoked by a user that already has that function.', 16, 1);  
                RETURN;  
            END;              
        END;  
  
        -- Delete the specified permission assignment.  
        DELETE  
        FROM mdm.tblSecurityRoleAccessFunctional  
        WHERE MUID = @Function_MUID  
  
        IF (@DeletedFunctional_ID = @FunctionalPrivilege_SuperUser)  
        BEGIN  
            -- A Super User permission was deleted. Ensure it wasn't the last one.  
            IF NOT EXISTS (SELECT 1 FROM mdm.tblSecurityRoleAccessFunctional WHERE FunctionalPrivilege_ID = @FunctionalPrivilege_SuperUser)  
            BEGIN  
                 -- Raise an error.  
                RAISERROR(N'MDSERR500053|The function privilege cannot be deleted. At least one principal must have the Super User function.', 16, 1);  
                RETURN;  
            END;  
        END;  
  
        -- Commit the transaction  
        IF @TranCounter = 0  
        BEGIN  
            COMMIT TRANSACTION;  
        END;  
  
    END TRY  
    --Compensate as necessary  
    BEGIN CATCH  
  
        -- Get error info.  
        DECLARE  
            @ErrorMessage NVARCHAR(4000),  
            @ErrorSeverity INT,  
            @ErrorState INT,  
            @ErrorNumber INT,  
            @ErrorLine INT,  
            @ErrorProcedure NVARCHAR(126);  
        EXEC mdm.udpGetErrorInfo  
            @ErrorMessage = @ErrorMessage OUTPUT,  
            @ErrorSeverity = @ErrorSeverity OUTPUT,  
            @ErrorState = @ErrorState OUTPUT,  
            @ErrorNumber = @ErrorNumber OUTPUT,  
            @ErrorLine = @ErrorLine OUTPUT,  
            @ErrorProcedure = @ErrorProcedure OUTPUT  
  
        SET @ErrorMessage = CONCAT(@ErrorMessage, N', @ErrorNumber = ', @ErrorNumber, N', @ErrorProcedure = "', @ErrorProcedure, N'", line ', @ErrorLine);  
  
        IF @TranCounter = 0 ROLLBACK TRANSACTION;  
        ELSE IF XACT_STATE() <> -1 ROLLBACK TRANSACTION TX;  
  
        RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);  
  
        RETURN;  
  
    END CATCH;  
  
    SET NOCOUNT OFF;  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpSecurityPrivilegesFunctionGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
    Returns function privileges.  
      
    DECLARE @PrivilegeTable mdm.Identifier  
    EXEC mdm.udpSecurityPrivilegesFunctionGet   
         @PrincipalType_ID = NULL  
        ,@Principal_MUID = NULL  
        ,@Principal_ID = NULL  
        ,@Principal_Name = NULL  
        ,@PrivilegeTable = @PrivilegeTable  
*/  
CREATE PROCEDURE [mdm].[udpSecurityPrivilegesFunctionGet]  
(  
     @PrincipalType_ID      INT = NULL  
    ,@Principal_MUID        UNIQUEIDENTIFIER = NULL  
    ,@Principal_ID          INT = NULL  
    ,@Principal_Name        NVARCHAR(355) = NULL  
    ,@PrivilegeTable        mdm.Identifier READONLY -- caller should ensure table does not include rows where both MUID and Name are blank  
    ,@CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    SET @Principal_Name = UPPER(@Principal_Name);  
    IF EXISTS(SELECT 1 FROM @PrivilegeTable)  
    BEGIN  
        SELECT   
             p.RoleAccess_ID  
            ,p.RoleAccess_MUID  
  
            ,p.Principal_ID  
            ,p.Principal_MUID  
            ,p.PrincipalType_ID  
            ,p.Principal_Name  
  
            ,p.Function_ID  
            ,p.Function_Name  
  
            --Auditing  
            ,p.EnterDTM  
            ,p.EnterUserID  
            ,p.EnterUserMUID  
            ,p.EnterUserName  
            ,p.LastChgDTM  
            ,p.LastChgUserID  
            ,p.LastChgUserMUID  
            ,p.LastChgUserName  
        FROM mdm.viw_SYSTEM_SECURITY_ROLE_ACCESSCONTROL_FUNCTIONAL p  
        INNER JOIN @PrivilegeTable crit  
        ON      (@PrincipalType_ID IS NULL OR p.PrincipalType_ID = @PrincipalType_ID)   
            AND (@Principal_MUID IS NULL   OR p.Principal_MUID = @Principal_MUID)   
            AND (@Principal_ID IS NULL     OR p.Principal_ID = @Principal_ID)   
            AND (@Principal_Name IS NULL   OR UPPER(p.Principal_Name) = @Principal_Name)   
            AND (crit.MUID IS NULL OR crit.MUID = p.RoleAccess_MUID)   
            AND (crit.Name IS NULL OR UPPER(crit.Name) = UPPER(p.Function_Name))   
            AND (crit.ID IS NULL OR crit.ID = p.Function_ID)  
    END ELSE  
    BEGIN  
        SELECT   
             p.RoleAccess_ID  
            ,p.RoleAccess_MUID  
  
            ,p.Principal_ID  
            ,p.Principal_MUID  
            ,p.PrincipalType_ID  
            ,p.Principal_Name  
  
            ,p.Function_ID  
            ,p.Function_Name  
  
            --Auditing  
            ,p.EnterDTM  
            ,p.EnterUserID  
            ,p.EnterUserMUID  
            ,p.EnterUserName  
            ,p.LastChgDTM  
            ,p.LastChgUserID  
            ,p.LastChgUserMUID  
            ,p.LastChgUserName  
        FROM mdm.viw_SYSTEM_SECURITY_ROLE_ACCESSCONTROL_FUNCTIONAL p  
        WHERE   (@PrincipalType_ID IS NULL OR p.PrincipalType_ID = @PrincipalType_ID)   
            AND (@Principal_MUID IS NULL   OR p.Principal_MUID = @Principal_MUID)   
            AND (@Principal_ID IS NULL     OR p.Principal_ID = @Principal_ID)   
            AND (@Principal_Name IS NULL   OR UPPER(p.Principal_Name) = @Principal_Name)   
    END  
  
              
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpSecurityPrivilegesFunctionGetEffective]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
Gets the effective (overlapping user and group permissions are combined) permissions   
of the given user.  
  
EXEC mdm.udpSecurityPrivilegesFunctionGetEffective 11  
  
*/  
CREATE PROCEDURE [mdm].[udpSecurityPrivilegesFunctionGetEffective]  
(  
    @User_ID INT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE @PrincipalType_Group TINYINT = 2;  
  
    SELECT DISTINCT   
         RoleAccess_ID  
        ,RoleAccess_MUID  
  
        ,Principal_ID  
        ,Principal_MUID  
        ,PrincipalType_ID  
        ,Principal_Name  
  
        ,Function_ID  
        ,Function_Name + CASE WHEN PrincipalType_ID = @PrincipalType_Group THEN N' *' ELSE N'' END Function_Name  
  
        -- Audit info  
        ,EnterDTM  
        ,EnterUserID  
        ,EnterUserMUID  
        ,EnterUserName  
        ,LastChgDTM  
        ,LastChgUserID  
        ,LastChgUserMUID  
        ,LastChgUserName  
    FROM   
        mdm.udfSecurityUserFunctionList(@User_ID)  
    ORDER BY Function_ID  
  
    SET NOCOUNT OFF;  
END
GO
/****** Object:  StoredProcedure [mdm].[udpSecurityPrivilegesFunctionGetExplicitAndInherited]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
Gets all functional permissions, both explicit and inherited from group,  
of the given user. Overlapping user and group permissions are not combined  
and are listed separately.  
  
EXEC mdm.udpSecurityPrivilegesFunctionGetExplicitAndInherited  @User_ID = 1  
*/  
CREATE PROCEDURE [mdm].[udpSecurityPrivilegesFunctionGetExplicitAndInherited]  
(  
    @User_ID INT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    SELECT  
         RoleAccess_ID  
        ,RoleAccess_MUID  
  
        ,Principal_ID  
        ,Principal_MUID  
        ,PrincipalType_ID  
        ,Principal_Name  
  
        ,Function_ID  
        ,Function_Name  
  
        -- Audit info  
        ,EnterDTM  
        ,EnterUserID  
        ,EnterUserMUID  
        ,EnterUserName  
        ,LastChgDTM  
        ,LastChgUserID  
        ,LastChgUserMUID  
        ,LastChgUserName  
    FROM mdm.viw_SYSTEM_SECURITY_USER_FUNCTION  
    WHERE [User_ID] = @User_ID  
  
    SET NOCOUNT OFF;  
END
GO
/****** Object:  StoredProcedure [mdm].[udpSecurityPrivilegesFunctionSave]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
Saves a functional privilege for a principal (user or group).  
*/  
CREATE PROCEDURE [mdm].[udpSecurityPrivilegesFunctionSave]  
(  
     @SystemUser_ID             INT -- The ID of the user who is executing this action (not to be confused with the principal to which the saved permission applies)  
    ,@Principal_MUID            UNIQUEIDENTIFIER = NULL  
    ,@Principal_Name            NVARCHAR(355) = NULL  
    ,@PrincipalType_ID          TINYINT  
    ,@MUID                      UNIQUEIDENTIFIER = NULL  
    ,@FunctionalPrivilege_ID    TINYINT  
    ,@SaveType                  TINYINT = 0 --default behavior is create.  
    ,@Return_ID                 INT = NULL OUTPUT  
    ,@Return_MUID               UNIQUEIDENTIFIER = NULL OUTPUT  
    ,@CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE   
         @Principal_ID          INT  
        ,@Role_ID               INT  
  
        ,@PrincipalType_User    TINYINT = 1  
        ,@PrincipalType_Group   TINYINT = 2  
  
        ,@SaveType_Create       TINYINT = 0  
        ,@SaveType_Clone        TINYINT = 1  
        ,@SaveType_Update       TINYINT = 2  
        ;  
  
    SET @Principal_MUID = NULLIF(@Principal_MUID, CONVERT(UNIQUEIDENTIFIER, 0x0));  
    SET @Principal_Name = NULLIF(LTRIM(RTRIM(@Principal_Name)), N'');  
    DECLARE @Principal_NameUpper NVARCHAR(355) = UPPER(@Principal_Name);  
    SET @MUID = NULLIF(@MUID, CONVERT(UNIQUEIDENTIFIER, 0x0));  
    SET @Return_ID = NULL;  
    SET @Return_MUID = NULL;  
  
    -- Lookup the Principal ID from the provided Name and/or MUID.  
    IF(@PrincipalType_ID = @PrincipalType_User)  
    BEGIN  
        SELECT   
             @Principal_ID = ID  
            ,@Principal_MUID = MUID  
            ,@Principal_Name = UserName  
        FROM mdm.tblUser  
        WHERE   (@Principal_MUID IS NOT NULL OR @Principal_Name IS NOT NULL)  
            AND (@Principal_MUID IS NULL OR MUID = @Principal_MUID)  
            AND (@Principal_Name IS NULL OR UPPER(UserName) = @Principal_NameUpper);  
    END  
    ELSE IF(@PrincipalType_ID = @PrincipalType_Group)  
    BEGIN  
        SELECT   
             @Principal_ID = ID  
            ,@Principal_MUID = MUID  
            ,@Principal_Name = Name  
        FROM mdm.tblUserGroup  
        WHERE   (@Principal_MUID IS NOT NULL OR @Principal_Name IS NOT NULL)  
            AND (@Principal_MUID IS NULL OR MUID = @Principal_MUID)  
            AND (@Principal_Name IS NULL OR UPPER(Name) = @Principal_NameUpper);  
    END  
      
    IF COALESCE(@Principal_ID, 0) = 0  
    BEGIN  
        RAISERROR('MDSERR500023|The function privilege cannot be saved. The Principal ID is not valid.', 16, 1);  
        RETURN;  
    END;  
  
    -- Lookup/create Role_ID from principal info.  
    SELECT @Role_ID = Role_ID  
    FROM mdm.tblSecurityAccessControl  
    WHERE   Principal_ID = @Principal_ID  
        AND PrincipalType_ID = @PrincipalType_ID  
    IF @Role_ID IS NULL   
    BEGIN  
        DECLARE @PrincipalType_Name NVARCHAR(MAX) = CASE @PrincipalType_ID WHEN @PrincipalType_User THEN N'User' ELSE N'Group' END;  
  
        --Create a new user account role for this user.  
        INSERT INTO mdm.tblSecurityRole  
        (    [Name]  
            ,EnterUserID  
            ,LastChgUserID  
        )  
        VALUES  
        (   N'Role for ' + @PrincipalType_Name + N' ' + COALESCE(@Principal_Name, N'')  
            ,@SystemUser_ID  
            ,@SystemUser_ID  
        );  
        SET @Role_ID = SCOPE_IDENTITY();  
  
        INSERT INTO mdm.tblSecurityAccessControl  
        (    PrincipalType_ID  
            ,Principal_ID  
            ,Role_ID  
            ,[Description]  
            ,EnterUserID  
            ,LastChgUserID  
        )  
        VALUES  
        (    @PrincipalType_ID  
            ,@Principal_ID  
            ,@Role_ID  
            ,CONCAT(LEFT(@Principal_Name, 89), N' ', @PrincipalType_Name)  
            ,@SystemUser_ID  
            ,@SystemUser_ID  
        );  
    END;  
  
  
    -- Check for MUID errors.  
    IF @SaveType = @SaveType_Create  
    BEGIN  
        -- Create.  
        IF @MUID IS NULL -- If a MUID wasn't provided, then create one.  
        BEGIN  
            SET @MUID = NEWID();  
        END;  
          
        IF EXISTS (SELECT 1 FROM mdm.tblSecurityRoleAccessFunctional WHERE MUID = @MUID) -- Ensure the MUID isn't being used by another row.  
        BEGIN  
            RAISERROR('MDSERR500064|The function privilege cannot be created because the GUID already exists.', 16, 1);  
            RETURN;  
        END;  
    END ELSE  
    BEGIN   
        -- Clone or Update.  
  
        -- See if the MUID already exists.  
        SELECT @Return_ID = ID  
        FROM mdm.tblSecurityRoleAccessFunctional  
        WHERE MUID = @MUID;  
  
        IF @SaveType = @SaveType_Clone  
        BEGIN   
            --Clone  
            IF @MUID IS NULL -- Ensure a MUID was provided.  
            BEGIN  
                -- Clone failed. No Muid was supplied.   
                RAISERROR('MDSERR500008|The function privilege cannot be cloned because the GUID is missing or not valid.', 16, 1);  
                RETURN;  
            END;  
  
            SET @SaveType = CASE WHEN @Return_ID IS NULL   
                THEN @SaveType_Create      -- The MUID doesn't already exist, so add a new row  
                ELSE @SaveType_Update END; -- The MUID already exists, so update the existing row.  
        END   
        ELSE IF @SaveType = @SaveType_Update  
        BEGIN  
            -- Update  
            IF @Return_ID IS NULL -- Ensure the MUID already exists  
            BEGIN  
                RAISERROR('MDSERR500009|The function privilege cannot be updated because an existing identifier GUID is missing.', 16, 1);  
                RETURN;  
            END;  
        END;  
    END;  
  
    -- Update the functional permission table.  
    IF @SaveType = @SaveType_Create  
    BEGIN  
        -- Ensure a dupicate permission does not already exist.  
        IF EXISTS (SELECT 1   
                   FROM mdm.tblSecurityRoleAccessFunctional   
                   WHERE    Role_ID = @Role_ID   
                        AND FunctionalPrivilege_ID = @FunctionalPrivilege_ID)  
        BEGIN  
            RAISERROR('MDSERR500003|The function privilege cannot be saved. The permission already exists.', 16, 1);  
            RETURN;  
        END;  
  
        -- Create new row.  
        INSERT INTO mdm.tblSecurityRoleAccessFunctional   
        (  
             MUID  
            ,Role_ID  
            ,FunctionalPrivilege_ID  
            ,EnterUserID  
            ,LastChgUserID  
        )  
        SELECT   
             @MUID  
            ,@Role_ID  
            ,@FunctionalPrivilege_ID  
            ,@SystemUser_ID  
            ,@SystemUser_ID  
    END   
    ELSE IF @SaveType = @SaveType_Update  
    BEGIN  
        -- Update existing row.  
        UPDATE mdm.tblSecurityRoleAccessFunctional   
        SET  Role_ID                = @Role_ID  
            ,FunctionalPrivilege_ID = @FunctionalPrivilege_ID  
            ,LastChgDTM             = GETUTCDATE()  
            ,LastChgUserID          = @SystemUser_ID  
        WHERE MUID = @MUID  
    END;  
  
    SET @Return_ID = SCOPE_IDENTITY();  
    SET @Return_MUID = @MUID;  
  
    -- Send the message  
	EXEC mdm.udpPerformanceQueueSave;  
  
    SET NOCOUNT OFF;  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpSecurityPrivilegesMemberDeleteByRoleAccessID]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
EXEC mdm.udpSecurityPrivilegesMemberDeleteByRoleAccessID 1, 100  
  
*/  
CREATE PROCEDURE [mdm].[udpSecurityPrivilegesMemberDeleteByRoleAccessID]  
(  
    @SystemUser_ID      INT,  
    @RoleAccess_ID      INT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON  
  
    DECLARE @Role_ID            INT,  
            @Version_ID         INT,  
            @Entity_ID          INT,  
            @Hierarchy_ID       INT,  
            @HierarchyType_ID   INT;  
  
    SELECT   
        @Role_ID=Role_ID,  
        @Version_ID=Version_ID,  
        @Entity_ID=[Entity_ID],  
        @Hierarchy_ID=[Hierarchy_ID],  
        @HierarchyType_ID=[HierarchyType_ID]  
    FROM mdm.tblSecurityRoleAccessMember   
    WHERE ID = @RoleAccess_ID;  
  
    DECLARE @SecurityMemberProcessEvent mdm.SecurityMemberProcessEvent  
    INSERT @SecurityMemberProcessEvent ([User_ID], [Entity_ID], Version_ID)  
    SELECT DISTINCT [User_ID], [Entity_ID], [Version_ID]  
    FROM [mdm].[viw_SYSTEM_SECURITY_ROLE_MEMBER] rm  
    INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_ROLE ur  
    ON rm.Role_ID = ur.Role_ID  
    WHERE rm.Role_ID = @Role_ID   
        AND rm.Version_ID = @Version_ID  
        AND Hierarchy_ID = @Hierarchy_ID  
        AND HierarchyType_ID = @HierarchyType_ID  
  
    DELETE FROM mdm.tblSecurityRoleAccessMember WHERE ID = @RoleAccess_ID;  
  
    EXEC mdm.udpSecurityMemberProcessRebuildEvent @SecurityMemberProcessEvent, 1;  
  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpSecurityPrivilegesMemberDeleteByRoleAccessMUID]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpSecurityPrivilegesMemberDeleteByRoleAccessMUID]  
(  
	@SystemUser_ID          INT,  
	@RoleAccess_MUID        UNIQUEIDENTIFIER,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON  
  
    DECLARE @RoleAccess_ID		INT  
  
    SELECT @RoleAccess_ID = (SELECT ID from mdm.tblSecurityRoleAccessMember WHERE MUID = @RoleAccess_MUID)  
  
    EXEC mdm.udpSecurityPrivilegesMemberDeleteByRoleAccessID @SystemUser_ID,@RoleAccess_ID  
  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpSecurityPrivilegesMemberSave]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
  
*/  
CREATE PROCEDURE [mdm].[udpSecurityPrivilegesMemberSave]  
(  
    @SystemUser_ID      INT,  
    @Principal_ID       INT,  
    @PrincipalType_ID   TINYINT,  
    @Principal_Name     NVARCHAR(355) = NULL, -- Max group name length  
    @RoleAccess_ID      INT,  
    @Privilege_ID       TINYINT,  
    @AccessPermission   TINYINT = NULL,  
    @Version_ID         INT,  
    @Entity_ID          INT,  
    @Hierarchy_ID       INT,  
    @HierarchyType_ID   TINYINT,  
    @Member_ID          INT,  
    @MemberType_ID      TINYINT,  
    @Securable_Name     NVARCHAR(100) = NULL,  
    @Return_ID          INT = NULL OUTPUT,  
    @Return_MUID        UNIQUEIDENTIFIER = NULL OUTPUT ,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON  
  
    -- Set AccessPermission as 0 if AccessPermission is null  
    SET @AccessPermission = ISNULL(@AccessPermission, 0);  
  
    DECLARE @Role_ID            INT;  
    DECLARE @Description        NVARCHAR(250);  
  
    SELECT  @Role_ID = Role_ID  
    FROM    mdm.tblSecurityAccessControl  
    WHERE   Principal_ID = @Principal_ID  
    AND     PrincipalType_ID = @PrincipalType_ID  
  
  
    IF @Principal_Name IS NULL BEGIN  
        IF @PrincipalType_ID = 1 BEGIN  
            SELECT @Principal_Name = mdm.udfUserNameGetByUserID(@Principal_ID)  
        END ELSE BEGIN  
            SELECT @Principal_Name = Name FROM mdm.tblUserGroup WHERE ID = @Principal_ID  
        END   
    END  
  
    DECLARE @PrincipalType_Name NVARCHAR(20);  
    IF @PrincipalType_ID = 1 BEGIN  
        SELECT @PrincipalType_Name = N'User'  
    END ELSE BEGIN  
        SELECT @PrincipalType_Name = N'Group'  
    END   
  
    IF @Role_ID IS NULL BEGIN  
        --Create a new user account role for this user.  
        INSERT INTO mdm.tblSecurityRole (Name, EnterUserID, LastChgUserID) VALUES (CONCAT(N'Role for ', @PrincipalType_Name, N' ', @Principal_Name), @SystemUser_ID, @SystemUser_ID)  
        SET @Role_ID = SCOPE_IDENTITY()  
  
        INSERT INTO mdm.tblSecurityAccessControl (PrincipalType_ID, Principal_ID, Role_ID, Description, EnterUserID, LastChgUserID)   
        VALUES (@PrincipalType_ID, @Principal_ID, @Role_ID, LEFT(@Principal_Name, 89) + N' ' + @PrincipalType_Name, @SystemUser_ID, @SystemUser_ID)  
    END   
  
    SELECT    @Description = @Securable_Name + N' ' + o.Name + N' (' + p.Name + N')'  
    FROM    mdm.tblSecurityObject o   
            INNER JOIN mdm.tblSecurityPrivilege p   
                ON p.ID = @Privilege_ID  
  
    -- Ensure the specified hierarchy is valid for member permissions. Recursive derived hierarchies that   
    -- 1. Do not anchor null recursions, or  
    -- 2. Have one or more levels above the recursive level  
    -- are not securable because nodes can appear more than once, resulting in potential security permission conflicts.  
    DECLARE   
         @HierarchyType_Derived         TINYINT = 1  
        ,@HierarchyItemType_ManyToMany  TINYINT = 5  
        ,@HierarchyItemType_Hierararchy                TINYINT = 2;  
  
    IF (@HierarchyType_ID = @HierarchyType_Derived)  
    BEGIN  
        DECLARE   
            @HighestLevel INT,  
            @HasRecursiveLevel BIT = 0,  
            @HasManyToManyLevel BIT = 0,  
            @HasForeignHierarchy BIT = 0;  
        SELECT   
             @HighestLevel = MAX(Level_ID)  
            ,@HasRecursiveLevel = MAX(IsRecursive)  
            ,@HasManyToManyLevel = MAX(CASE WHEN ForeignType_ID = @HierarchyItemType_ManyToMany THEN 1 ELSE 0 END)  
            ,@HasForeignHierarchy = MAX(CASE WHEN ForeignType_ID = @HierarchyItemType_Hierararchy THEN 1 ELSE 0 END)  
        FROM mdm.viw_SYSTEM_SCHEMA_HIERARCHY_DERIVED_LEVELS    
        WHERE Hierarchy_ID = @Hierarchy_ID  
          
        IF (@HasManyToManyLevel = 1)  
        BEGIN  
            RAISERROR('MDSERR500068|A permission cannot be saved on a derived hierarchy that has a many-to-many relationship level.', 16, 1);  
            RETURN;  
        END  
  
        IF (@HasForeignHierarchy = 1)  
        BEGIN  
            RAISERROR('MDSERR500069|A permission cannot be saved on a derived hierarchy that has an explicit hierarchy cap.', 16, 1)  
            RETURN;  
        END  
  
        IF (@HasRecursiveLevel = 1)  
        BEGIN  
  
            DECLARE @LowestRecursiveLevel INT =   
               (SELECT MIN(Level_ID)  
                FROM mdm.viw_SYSTEM_SCHEMA_HIERARCHY_DERIVED_LEVELS    
                WHERE   Hierarchy_ID = @Hierarchy_ID  
                    AND IsRecursive = 1)  
  
            IF (@HighestLevel > @LowestRecursiveLevel)  
            BEGIN  
                RAISERROR('MDSERR500066|A permission cannot be saved on a recursive derived hierarchy that has a level above the recursive level.', 16, 1);  
                RETURN;  
            END  
  
            -- The hierarchy is recursive. Ensure it does not have a level above the recursive level and that it anchors null recursions.  
            IF (EXISTS (SELECT 1 FROM mdm.tblDerivedHierarchy WHERE ID = @Hierarchy_ID AND AnchorNullRecursions = 0))  
            BEGIN  
                RAISERROR('MDSERR500065|A permission cannot be saved on a recursive derived hierarchy that does not anchor null recursions.', 16, 1);  
                RETURN;  
            END  
        END  
    END  
  
    IF IsNull(@RoleAccess_ID, 0) > 0   
    BEGIN  
        IF EXISTS(SELECT 1 FROM mdm.tblSecurityRoleAccessMember WHERE ID = @RoleAccess_ID)   
        BEGIN  
            DECLARE @ExistingUserRoleAccess_ID INT  
            DECLARE @RoleAccessPrincipalType_ID INT  
            SELECT @RoleAccessPrincipalType_ID = PrincipalType_ID FROM mdm.viw_SYSTEM_SECURITY_ROLE_ACCESSCONTROL_MEMBER WHERE RoleAccess_ID = @RoleAccess_ID  
            IF @PrincipalType_ID = 1 AND @RoleAccessPrincipalType_ID = 2   
            BEGIN  
                -- Create a user override of a user group privilege.  First see if the user already has an existing override explicit record.  
                -- If so update it.  If not create a new one.  
                SELECT    @ExistingUserRoleAccess_ID = RoleAccess_ID   
                FROM    mdm.viw_SYSTEM_SECURITY_ROLE_ACCESSCONTROL_MEMBER rac   
                WHERE      rac.Entity_ID        = @Entity_ID  
                and        rac.Hierarchy_ID     = @Hierarchy_ID  
                and        rac.HierarchyType_ID = @HierarchyType_ID  
                and        rac.Member_ID        = @Member_ID  
                and        rac.MemberType_ID    = @MemberType_ID  
                and        rac.Principal_ID      = @Principal_ID  
                AND        rac.PrincipalType_ID  = 1   
  
                IF IsNull(@ExistingUserRoleAccess_ID, 0) = 0  
                BEGIN  
                    INSERT INTO mdm.tblSecurityRoleAccessMember (Role_ID, Privilege_ID, AccessPermission, Version_ID, Entity_ID, ExplicitHierarchy_ID,DerivedHierarchy_ID, HierarchyType_ID, Member_ID, MemberType_ID, Description, EnterUserID, LastChgUserID)  
                        SELECT @Role_ID, @Privilege_ID, @AccessPermission, Version_ID, Entity_ID, CASE @HierarchyType_ID WHEN 0 THEN @Hierarchy_ID ELSE NULL END,CASE @HierarchyType_ID WHEN 1 THEN @Hierarchy_ID ELSE NULL END, HierarchyType_ID, Member_ID, MemberType_ID, Description, @SystemUser_ID, @SystemUser_ID FROM mdm.tblSecurityRoleAccessMember WHERE ID = @RoleAccess_ID  
                END ELSE  
                BEGIN  
                    UPDATE mdm.tblSecurityRoleAccessMember SET Privilege_ID = @Privilege_ID, AccessPermission = @AccessPermission WHERE ID = @RoleAccess_ID   
                END  
            END ELSE   
            BEGIN  
                UPDATE mdm.tblSecurityRoleAccessMember SET Privilege_ID = @Privilege_ID, AccessPermission = @AccessPermission WHERE ID = @RoleAccess_ID   
            END  
        END ELSE  
        BEGIN  
            INSERT INTO mdm.tblSecurityRoleAccessMember (Role_ID, Privilege_ID, AccessPermission, Version_ID, Entity_ID, ExplicitHierarchy_ID,DerivedHierarchy_ID, HierarchyType_ID, Member_ID, MemberType_ID, Description, EnterUserID, LastChgUserID)  
            VALUES(@Role_ID, @Privilege_ID, @AccessPermission, @Version_ID, @Entity_ID, CASE @HierarchyType_ID WHEN 0 THEN @Hierarchy_ID ELSE NULL END,CASE @HierarchyType_ID WHEN 1 THEN @Hierarchy_ID ELSE NULL END, @HierarchyType_ID, @Member_ID, @MemberType_ID, @Description, @SystemUser_ID, @SystemUser_ID)  
            SELECT @RoleAccess_ID = SCOPE_IDENTITY()          
        END  
    END ELSE  
    BEGIN  
        INSERT INTO mdm.tblSecurityRoleAccessMember (Role_ID, Privilege_ID, AccessPermission, Version_ID, Entity_ID, ExplicitHierarchy_ID,DerivedHierarchy_ID, HierarchyType_ID, Member_ID, MemberType_ID, Description, EnterUserID, LastChgUserID)  
            VALUES(@Role_ID, @Privilege_ID, @AccessPermission, @Version_ID, @Entity_ID, CASE @HierarchyType_ID WHEN 0 THEN @Hierarchy_ID ELSE NULL END,CASE @HierarchyType_ID WHEN 1 THEN @Hierarchy_ID ELSE NULL END, @HierarchyType_ID, @Member_ID, @MemberType_ID, @Description, @SystemUser_ID, @SystemUser_ID)  
            SELECT @RoleAccess_ID = SCOPE_IDENTITY()          
    END  
            
    SELECT @Return_ID = @RoleAccess_ID  
    SELECT @Return_MUID = (SELECT MUID FROM mdm.tblSecurityRoleAccessMember WHERE ID = @RoleAccess_ID)  
  
    DECLARE @SecurityMemberProcessEvent mdm.SecurityMemberProcessEvent  
    INSERT @SecurityMemberProcessEvent ([User_ID], [Entity_ID], Version_ID)  
    SELECT DISTINCT [User_ID], [Entity_ID], [Version_ID]  
    FROM [mdm].[viw_SYSTEM_SECURITY_ROLE_MEMBER] rm  
    INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_ROLE ur  
    ON rm.Role_ID = ur.Role_ID  
    WHERE rm.Role_ID = @Role_ID   
        AND rm.Version_ID = @Version_ID  
        AND Hierarchy_ID = @Hierarchy_ID  
        AND HierarchyType_ID = @HierarchyType_ID  
  
    EXEC mdm.udpSecurityMemberProcessRebuildEvent @SecurityMemberProcessEvent, 1;  
  
    -- Send the message  
	EXEC mdm.udpPerformanceQueueSave;  
  
    SET NOCOUNT OFF  
  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpSecurityPrivilegesMemberSaveByMUID]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpSecurityPrivilegesMemberSaveByMUID]  
(  
    @SystemUser_ID			INT,  
    @Principal_MUID			UNIQUEIDENTIFIER=NULL,  
    @PrincipalType_ID		TINYINT,  
    @Principal_Name			NVARCHAR(355) = NULL,-- max group name length  
    @RoleAccess_MUID		UNIQUEIDENTIFIER = NULL,  
    @Privilege_ID			TINYINT,  
    @AccessPermission       TINYINT = NULL,  
    @Model_MUID			    UNIQUEIDENTIFIER = NULL,  
    @Model_Name			    NVARCHAR(50) = NULL,  
    @Version_MUID			UNIQUEIDENTIFIER = NULL,  
    @Version_Name			NVARCHAR(50) = NULL,  
    @Entity_MUID			UNIQUEIDENTIFIER=NULL,  
    @Entity_Name			NVARCHAR(MAX) = NULL,  
    @Hierarchy_MUID			UNIQUEIDENTIFIER = NULL,  
    @Hierarchy_Name			NVARCHAR(50) = NULL,  
    @HierarchyType_ID		TINYINT,  
    @Member_ID				INT,  
    @MemberType_ID			TINYINT,  
    @Member_Code            NVARCHAR(250) = NULL,  
    @Status_ID				TINYINT = 0,  
    @Securable_Name			NVARCHAR(100) = NULL,  
    @Return_ID				INT = NULL OUTPUT,  
    @Return_MUID			UNIQUEIDENTIFIER = NULL OUTPUT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON  
  
    -- Set AccessPermission as 0 if AccessPermission is null  
    SET @AccessPermission = ISNULL(@AccessPermission, 0);  
  
    DECLARE @Role_ID			INT  
    DECLARE @Description		NVARCHAR(250),  
        @Principal_ID			INT,  
        @Principal_NameUpper    NVARCHAR(355) = UPPER(@Principal_Name),  
        @Model_ID               INT,  
        @Version_ID				INT,  
        @Entity_ID				INT,  
        @Hierarchy_ID			INT,  
        @Securable_ID			INT,   
        @RoleAccess_ID			INT,  
        @TempRoleAccess_ID		INT,  
        @NewUser_ID	INT,  
        @GuidEmpty          UNIQUEIDENTIFIER = CAST(0x0 AS UNIQUEIDENTIFIER)  
        ;  
    SELECT  
         @Model_MUID = NULLIF(@Model_MUID, @GuidEmpty)  
        ,@Model_Name = NULLIF(@Model_Name, N'')  
        ,@Version_MUID = NULLIF(@Version_MUID, @GuidEmpty)  
        ,@Version_Name = NULLIF(@Version_Name, N'')  
        ,@RoleAccess_MUID = NULLIF(@RoleAccess_MUID, @GuidEmpty)  
        ,@Entity_MUID = NULLIF(@Entity_MUID, @GuidEmpty)  
        ,@Entity_Name = NULLIF(@Entity_Name, N'')  
        ,@Hierarchy_MUID = NULLIF(@Hierarchy_MUID, @GuidEmpty)  
        ,@Hierarchy_Name = NULLIF(@Hierarchy_Name, N'');  
  
  
    -- Disallow Admin permission for members (only valid for models).  
    DECLARE @PermissionType_Admin TINYINT = 5;  
    IF @Privilege_ID = @PermissionType_Admin  
    BEGIN  
        RAISERROR('MDSERR500054|The permission cannot be saved. Admin permission can only be set on a model.', 16, 1);  
        RETURN;  
    END;  
  
    SET  @Principal_ID = 0   
    --Lookup the integerIDs for the MUIDs  
    IF(@PrincipalType_ID =1)  
    BEGIN  
        IF( @Principal_MUID IS NOT NULL AND CAST(@Principal_MUID  AS BINARY) <> 0x0  
                    AND EXISTS(SELECT ID from mdm.tblUser WHERE MUID=@Principal_MUID))  
        BEGIN  
            SELECT @Principal_ID = (SELECT ID FROM mdm.tblUser WHERE MUID=@Principal_MUID)  
        END  
        ELSE   
        IF( @Principal_Name IS NOT NULL AND EXISTS(SELECT ID from mdm.tblUser WHERE UPPER(UserName) = @Principal_NameUpper))  
        BEGIN  
            SELECT @Principal_ID = (SELECT ID FROM mdm.tblUser WHERE UPPER(UserName) = @Principal_NameUpper)  
        END  
    END  
    ELSE  
    BEGIN  
        IF(@PrincipalType_ID =2 )  
        BEGIN  
            IF( @Principal_MUID IS NOT NULL AND CAST(@Principal_MUID  AS BINARY) <> 0x0  
                    AND EXISTS(SELECT ID from mdm.tblUserGroup WHERE MUID=@Principal_MUID))  
            BEGIN  
                SELECT @Principal_ID = (SELECT ID FROM mdm.tblUserGroup WHERE MUID=@Principal_MUID)  
            END  
            ELSE   
            IF( @Principal_Name IS NOT NULL AND EXISTS(SELECT ID from mdm.tblUserGroup WHERE UPPER(Name) = @Principal_NameUpper))  
            BEGIN  
            SELECT @Principal_ID = (SELECT ID FROM mdm.tblUserGroup WHERE UPPER(Name) = @Principal_NameUpper)  
            END  
        END  
    END  
  
    If @Principal_ID IS NULL OR @Principal_ID = 0   
    BEGIN  
        RAISERROR('MDSERR500025|The principal ID for the user or group is not valid.', 16, 1);  
        RETURN     
    END  
      
    IF (@RoleAccess_MUID IS NOT NULL)    
    BEGIN    
        IF((EXISTS (SELECT ID FROM mdm.tblSecurityRoleAccessMember WHERE MUID = @RoleAccess_MUID)))    
        BEGIN    
            SELECT @RoleAccess_ID = RoleAccess_ID,  
                    @Model_ID = Model_ID,      
                    @Version_ID = Version_ID,  
                    @Entity_ID = Entity_ID,      
                    @Hierarchy_ID = Hierarchy_ID,  
                    @Member_ID = Member_ID,  
                    @HierarchyType_ID = HierarchyType_ID  
            FROM mdm.viw_SYSTEM_SECURITY_ROLE_ACCESSCONTROL_MEMBER   
            WHERE RoleAccess_MUID = @RoleAccess_MUID      
        END     
    END     
  
    --Validate other supplied parameters     
    IF (@Version_ID IS NULL   
        AND (@Version_MUID IS NOT NULL  
               OR (@Version_Name IS NOT NULL  
                 AND (@Model_MUID IS NOT NULL OR @Model_Name IS NOT NULL))))  
    BEGIN  
        SELECT  
             @Version_ID = mv.ID  
            ,@Model_ID = mv.Model_ID  
        FROM mdm.tblModelVersion mv  
        INNER JOIN mdm.tblModel m  
        ON mv.Model_ID = m.ID  
        WHERE  
                (@Model_MUID IS NULL OR @Model_MUID = m.MUID)  
            AND (@Model_Name IS NULL OR @Model_Name = m.Name)  
            AND (@Version_MUID IS NULL OR @Version_MUID = mv.MUID)  
            AND (@Version_Name IS NULL OR @Version_Name = mv.Name);  
    END          
    IF (@Version_ID IS NULL)  
    BEGIN    
        RAISERROR('MDSERR500029|The hierarchy permission cannot be saved. The version ID is not valid.', 16, 1);  
        RETURN       
    END  
      
    IF (@Entity_ID IS NULL   
        AND (@Entity_MUID IS NOT NULL OR @Entity_Name IS NOT NULL))  
    BEGIN  
        SELECT  
            @Entity_ID = ID  
        FROM mdm.tblEntity  
        WHERE  
            Model_ID = @Model_ID  
            AND (@Entity_MUID IS NULL OR @Entity_MUID = MUID)  
            AND (@Entity_Name IS NULL OR @Entity_Name = Name);  
    END          
    IF (@Entity_ID IS NULL)  
    BEGIN    
        RAISERROR('MDSERR500030|The hierarchy permission cannot be saved. The entity ID is not valid.', 16, 1);  
        RETURN       
    END    
        
    -- Check for member Id.   
    IF(@Member_ID = 0 AND @Member_Code IS NOT NULL AND @Member_Code <> '' AND @Member_Code <> 'ROOT')  
    BEGIN  
        EXEC mdm.udpMemberIDGetByCode @Version_ID,@Entity_ID, @Member_Code,@MemberType_ID,@Member_ID OUTPUT  
  
        -- Verify that the member code exists.  
        IF (@Member_ID = 0)   
        BEGIN   
            RAISERROR('MDSERR300002|Error - The member code is not valid.', 16, 1);  
            RETURN;         
        END  
    END  
  
    IF (@Hierarchy_ID IS NULL  
        AND (@Hierarchy_MUID IS NOT NULL OR @Hierarchy_Name IS NOT NULL))  
    BEGIN  
        IF (@HierarchyType_ID = 0)  
        BEGIN  
            SELECT @Hierarchy_ID = ID   
            FROM mdm.tblHierarchy   
            WHERE   
                Entity_ID = @Entity_ID  
                AND (@Hierarchy_MUID IS NULL OR @Hierarchy_MUID = MUID)  
                AND (@Hierarchy_Name IS NULL OR @Hierarchy_Name = Name)  
        END ELSE IF (@HierarchyType_ID = 1)  
        BEGIN  
           SELECT @Hierarchy_ID = ID   
            FROM mdm.tblDerivedHierarchy   
            WHERE   
                Model_ID = @Model_ID  
                AND (@Hierarchy_MUID IS NULL OR @Hierarchy_MUID = MUID)  
                AND (@Hierarchy_Name IS NULL OR @Hierarchy_Name = Name)  
        END  
    END  
    IF (@Hierarchy_ID is NULL)  
    BEGIN    
        RAISERROR('MDSERR500031|The hierarchy permission cannot be saved. The hierarchy ID is not valid.', 16, 1);  
        RETURN       
    END    
          
    SELECT	@TempRoleAccess_ID = RoleAccess_ID  FROM	mdm.viw_SYSTEM_SECURITY_ROLE_ACCESSCONTROL_MEMBER rac     
                    WHERE	rac.Version_ID       = @Version_ID    
                    AND		rac.Entity_ID      = @Entity_ID    
                    AND		rac.Hierarchy_ID   = @Hierarchy_ID    
                    AND		rac.HierarchyType_ID = @HierarchyType_ID    
                    AND		rac.Member_ID        = @Member_ID    
                    AND		rac.MemberType_ID    = @MemberType_ID    
                    AND		rac.Principal_MUID      = @Principal_MUID    
                    AND		rac.PrincipalType_ID  = @PrincipalType_ID    
    
    If ( @TempRoleAccess_ID IS NOT NULL AND @TempRoleAccess_ID <>0)    
    BEGIN     
    --Role exists update the role.    
        UPDATE mdm.tblSecurityRoleAccessMember SET Privilege_ID = @Privilege_ID, AccessPermission = @AccessPermission WHERE ID = @TempRoleAccess_ID     
        SELECT @Hierarchy_ID = Hierarchy_ID ,@HierarchyType_ID = HierarchyType_ID from mdm.tblSecurityRoleAccessMember      
        WHERE ID = @TempRoleAccess_ID     
        Return(1)    
    END    
            
    
    IF(@HierarchyType_ID =0)    
    BEGIN    
        -- Verify that the member is a part of the hierarchy.  
        IF (COALESCE(@Hierarchy_ID, 0) > 0 AND COALESCE(@Member_ID, 0) > 0)  
        BEGIN  
            DECLARE @IsMemberInHierarchy BIT = 0;  
            DECLARE @SQL NVARCHAR(MAX) =  
            N'SET @IsMemberInHierarchy =   
                CASE WHEN EXISTS(  
                            SELECT *  
                            FROM mdm.' + QUOTENAME(mdm.udfTableNameGetByID(@Entity_ID, 4 /*HierarchyTable*/)) + N'  
                            WHERE   
                            Version_ID =    @Version_ID AND  
                            Hierarchy_ID =  @Hierarchy_ID AND  
                            ChildType_ID =  @MemberType_ID AND   
                            @Member_ID =    CASE ChildType_ID   
                                                WHEN 1 /*Leaf*/         THEN Child_EN_ID   
                                                WHEN 2 /*Consolidated*/ THEN Child_HP_ID  
                                                END)  
                    THEN 1 ELSE 0 END;                                          
            ';  
            EXEC sp_executesql @SQL, N'@Version_ID INT, @Hierarchy_ID INT, @MemberType_ID TINYINT, @Member_ID INT, @IsMemberInHierarchy BIT OUTPUT', @Version_ID, @Hierarchy_ID, @MemberType_ID, @Member_ID, @IsMemberInHierarchy OUTPUT;  
            IF (@IsMemberInHierarchy <> 1)  
            BEGIN  
                RAISERROR('MDSERR300002|Error - The member code is not valid.', 16, 1);  
                RETURN;         
            END  
        END  
    END    
  
    
    IF (@RoleAccess_MUID IS NOT NULL)    
        BEGIN    
            IF((EXISTS (SELECT ID FROM mdm.tblSecurityRoleAccessMember WHERE MUID=@RoleAccess_MUID)))    
                BEGIN    
                    SELECT @RoleAccess_ID = (SELECT ID FROM mdm.tblSecurityRoleAccessMember WHERE MUID=@RoleAccess_MUID)    
                    
                    --Print 'update'     
                    IF (@Status_ID = 3)    
                    BEGIN    
                        SET @Status_ID = 1     
    
                    END    
                    IF(@Status_ID = 0)    
                    BEGIN    
                        SET @RoleAccess_ID = 0  -- ignore the role access id     
                    END     
                END    
            ELSE     
            BEGIN    
                IF (@Status_ID = 3)    
                BEGIN    
                    --Print 'Clone' --Clone operation.    
                    print @RoleAccess_ID    
                    SELECT	@Role_ID = Role_ID    
                    FROM	mdm.tblSecurityAccessControl    
                    WHERE	Principal_ID = @Principal_ID    
                    AND		PrincipalType_ID = @PrincipalType_ID    
    
    
                    IF @Principal_Name IS NULL     
                    BEGIN    
                        IF @PrincipalType_ID = 1 BEGIN    
                            SELECT @Principal_Name = mdm.udfUserNameGetByUserID(@Principal_ID)    
                        END ELSE BEGIN    
                            SELECT @Principal_Name = Name FROM mdm.tblUserGroup WHERE ID = @Principal_ID    
                        END     
                    END    
      
                    DECLARE @PrincipalType_Name NVARCHAR(20);  
                    IF @PrincipalType_ID = 1  
                    BEGIN  
                        SELECT @PrincipalType_Name = CAST(N'UserAccount' AS NVARCHAR(20))  
                    END ELSE  
                    BEGIN    
                        SELECT @PrincipalType_Name = CAST(N'Group' AS NVARCHAR(20))  
                    END  
    
                    IF @Role_ID IS NULL BEGIN    
                        --Create a new user account role for this user.    
                        INSERT INTO mdm.tblSecurityRole (Name, EnterUserID, LastChgUserID) VALUES (CAST(N'Role for ' + @PrincipalType_Name + N' ' + @Principal_Name AS NVARCHAR(115)), @SystemUser_ID, @SystemUser_ID)    
                        SET @Role_ID = SCOPE_IDENTITY()    
    
                        INSERT INTO mdm.tblSecurityAccessControl (PrincipalType_ID, Principal_ID, Role_ID, Description, EnterUserID, LastChgUserID)     
                        VALUES (@PrincipalType_ID, @Principal_ID, @Role_ID, CAST(@Principal_Name + N' ' + @PrincipalType_Name AS NVARCHAR(110)), @SystemUser_ID, @SystemUser_ID)    
                    END     
    
                    SELECT	@Description = CONCAT(@Securable_Name, N' ', o.Name, N' (', p.Name, N')')  
                    FROM	mdm.tblSecurityObject o     
                            INNER JOIN mdm.tblSecurityPrivilege p     
                                ON p.ID = @Privilege_ID    
                    --print 'insert'    
                    INSERT INTO mdm.tblSecurityRoleAccessMember (MUID,Role_ID, Privilege_ID, AccessPermission, Version_ID, Entity_ID, ExplicitHierarchy_ID,DerivedHierarchy_ID, HierarchyType_ID, Member_ID, MemberType_ID, Description, EnterUserID, LastChgUserID)    
                    VALUES(@RoleAccess_MUID,@Role_ID, @Privilege_ID, @AccessPermission, @Version_ID, @Entity_ID, CASE @HierarchyType_ID WHEN 0 THEN @Hierarchy_ID ELSE NULL END,CASE @HierarchyType_ID WHEN 1 THEN @Hierarchy_ID ELSE NULL END, @HierarchyType_ID, @Member_ID, @MemberType_ID, @Description, @SystemUser_ID, @SystemUser_ID)    
                    SELECT @NewUser_ID=SCOPE_IDENTITY()		    
                      
                    SELECT @Return_ID = @NewUser_ID    
                    SELECT @Return_MUID = (SELECT MUID FROM mdm.tblSecurityRoleAccessMember WHERE ID = @NewUser_ID)    
                    RETURN(1)     
                END -- Clone    
            END -- ELSE    
        END -- muid Check     
    ELSE    
        BEGIN    
            IF (@Status_ID = 1)    
            BEGIN    
                RAISERROR('MDSERR500037|The hierarchy permission cannot be updated. The ID is not valid.', 16, 1);  
                RETURN      
            END    
            ELSE IF (@Status_ID = 3)    
            BEGIN    
                RAISERROR('MDSERR500038|The hierarchy permission cannot be copied. The ID is not valid.', 16, 1);  
                RETURN      
            END    
        END    
    
        IF (@Status_ID = 0 AND (@RoleAccess_ID IS NOT null AND @RoleAccess_ID > 0) )    
        BEGIN    
            RAISERROR('MDSERR500036|The hierarchy permission cannot be created. The ID is not valid.', 16, 1);  
            RETURN      
        END    
        ELSE IF(@Status_ID = 1 AND (@RoleAccess_ID IS  null OR @RoleAccess_ID = 0 ))    
        BEGIN    
                RAISERROR('MDSERR500037|The hierarchy permission cannot be updated. The ID is not valid.', 16, 1);  
                RETURN      
        END     
        ELSE IF(@Status_ID = 0)    
        BEGIN    
            If(EXISTS (SELECT ID FROM mdm.tblSecurityRoleAccessMember where Role_ID = @Role_ID AND     
                 Privilege_ID = @Privilege_ID AND Hierarchy_ID = @Hierarchy_ID AND Entity_ID=@Entity_ID AND     
                Version_ID = @Version_ID AND Member_ID = @Member_ID))    
            BEGIN    
                RAISERROR('MDSERR500026|The hierarchy permission cannot be created. A hierarchy permission already exists.', 16, 1);  
                RETURN      
            END    
            set @RoleAccess_ID = 0     
        END     
    
    --print @RoleAccess_ID    
    --Execute the save stored procedure.    
    DECLARE	@return_value int    
    
    EXEC    @return_value = [mdm].[udpSecurityPrivilegesMemberSave]    
        @SystemUser_ID,    
        @Principal_ID,    
        @PrincipalType_ID,    
        @Principal_Name,    
        @RoleAccess_ID,    
        @Privilege_ID,  
        @AccessPermission,  
        @Version_ID,    
        @Entity_ID,   
        @Hierarchy_ID,    
        @HierarchyType_ID,    
        @Member_ID,    
        @MemberType_ID,    
        @Securable_Name,    
        @Return_ID = @Return_ID OUTPUT,    
        @Return_MUID = @Return_MUID OUTPUT    
    
        --RETURN(@return_value)    
    
    -- Send the message  
	EXEC mdm.udpPerformanceQueueSave;  
      
    SET NOCOUNT OFF    
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpSecurityPrivilegesMemberSummaryGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
EXEC mdm.udpSecurityPrivilegesMemberSummaryGet 1,27,1,1,0  
EXEC mdm.udpSecurityPrivilegesMemberSummaryGet 1,11,1,1,0,6,10,0  
EXEC mdm.udpSecurityPrivilegesMemberSummaryGet 1,18,1,1,0,Null,Null,Null  
EXEC mdm.udpSecurityPrivilegesMemberSummaryGet 1,118,1,1,0,Null,Null,Null  
*/  
CREATE PROCEDURE [mdm].[udpSecurityPrivilegesMemberSummaryGet]  
(  
     @SystemUser_ID             INT -- The user requesting the permissions  
    ,@Principal_ID              INT  
    ,@PrincipalType_ID          TINYINT  
    ,@ResolutionType            TINYINT  
    ,@Model_ID                  INT = NULL  
    ,@Hierarchy_ID              INT = NULL  
    ,@HierarchyType_ID          INT = NULL  
    ,@CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON  
  
    DECLARE   
         @PrincipalType_Group           TINYINT = 2  
  
        ,@ResolutionType_UserAndGroup   TINYINT = 0  
        ,@ResolutionType_User           TINYINT = 1  
        ,@ResolutionType_Effective      TINYINT = 2;  
  
    IF (@PrincipalType_ID = @PrincipalType_Group AND @ResolutionType = @ResolutionType_Effective)  
    BEGIN  
        SET @ResolutionType = @ResolutionType_User;  
    END;  
  
    DECLARE   
         @IncludeGroupAssignments   BIT = (CASE @ResolutionType WHEN @ResolutionType_User THEN 0 ELSE 1 END)  
        ,@ID                        INT  
        ,@Entity_ID                 INT  
        ,@Version_ID                INT  
        ,@MemberType_ID             INT  
        ,@RootMember_ID             INT = 0  
        ,@TableName                 NVARCHAR(100)  
        ,@SQL                       NVARCHAR(MAX);  
  
  
    CREATE TABLE #tblPrivileges  
    (  
         RoleAccess_ID          INT  
        ,RoleAccess_MUID        UNIQUEIDENTIFIER  
        ,Privilege_ID           TINYINT  
        ,AccessPermission       TINYINT  
        ,Model_ID               INT  
        ,Model_MUID             UNIQUEIDENTIFIER  
        ,Model_Name             NVARCHAR(50) COLLATE DATABASE_DEFAULT  
        ,IsModelAdministrator   BIT  
        ,Version_ID             INT  
        ,Version_MUID           UNIQUEIDENTIFIER  
        ,Version_Name           NVARCHAR(50) COLLATE DATABASE_DEFAULT  
        ,HierarchyType_ID       TINYINT  
        ,Hierarchy_ID           INT  
        ,Hierarchy_MUID         UNIQUEIDENTIFIER  
        ,Hierarchy_Name         NVARCHAR(50) COLLATE DATABASE_DEFAULT  
        ,Entity_ID              INT  
        ,Entity_MUID            UNIQUEIDENTIFIER  
        ,Entity_Name            NVARCHAR(MAX) COLLATE DATABASE_DEFAULT  
        ,MemberType_ID          TINYINT  
        ,Member_ID              INT  
        ,Member_MUID            UNIQUEIDENTIFIER  
        ,Member_Name            NVARCHAR(250) COLLATE DATABASE_DEFAULT NULL  
        ,Member_Code            NVARCHAR(250) COLLATE DATABASE_DEFAULT NULL  
        ,PrincipalType_ID       TINYINT  
        ,Principal_ID           INT  
        ,Principal_MUID         UNIQUEIDENTIFIER  
        ,Principal_Name         NVARCHAR(355) COLLATE DATABASE_DEFAULT  
        ,EnterUserID            INT  
        ,EnterUserMUID          UNIQUEIDENTIFIER  
        ,EnterUser              NVARCHAR(256) COLLATE DATABASE_DEFAULT NULL  
        ,EnterDTM               DATETIME2(3)  
        ,LastChgUserID          INT  
        ,LastChgUserMUID        UNIQUEIDENTIFIER  
        ,LastChgUser            NVARCHAR(256) COLLATE DATABASE_DEFAULT NULL  
        ,LastChgDTM             DATETIME2(3)  
    );  
  
    INSERT INTO #tblPrivileges  
    SELECT   
         xp.RoleAccess_ID  
        ,xp.RoleAccess_MUID  
        ,xp.Privilege_ID  
        ,xp.AccessPermission  
        ,xp.Model_ID  
        ,xp.Model_MUID  
        ,xp.Model_Name  
        ,xp.IsModelAdministrator  
        ,xp.Version_ID  
        ,xp.Version_MUID  
        ,xp.Version_Name  
        ,xp.HierarchyType_ID  
        ,xp.Hierarchy_ID  
        ,xp.Hierarchy_MUID  
        ,xp.Hierarchy_Name  
        ,xp.Entity_ID  
        ,xp.Entity_MUID  
        ,xp.Entity_Name  
        ,xp.MemberType_ID  
        ,xp.Member_ID  
        ,NULL Member_MUID  
        ,NULL Member_Name  
        ,NULL Member_Code  
        ,xp.PrincipalType_ID  
        ,xp.Principal_ID  
        ,xp.Principal_MUID  
        ,xp.Principal_Name  
        ,xp.EnterUserID  
        ,xp.EnterUserMUID  
        ,xp.EnterUser  
        ,xp.EnterDTM  
        ,xp.LastChgUserID  
        ,xp.LastChgUserMUID  
        ,xp.LastChgUser  
        ,xp.LastChgDTM  
    FROM mdm.udfSecurityUserExplicitMemberPermissions(@SystemUser_ID, @Principal_ID, @PrincipalType_ID, @IncludeGroupAssignments) xp  
    WHERE   (@Model_ID IS NULL OR xp.Model_ID = @Model_ID)  
        AND (@Hierarchy_ID IS NULL OR xp.Hierarchy_ID = @Hierarchy_ID)  
        AND (@HierarchyType_ID IS NULL OR xp.HierarchyType_ID = @HierarchyType_ID)  
  
    IF (@ResolutionType = @ResolutionType_Effective)  
    BEGIN  
        DECLARE @MemberPermissions AS TABLE (ID INT PRIMARY KEY, MemberType_ID TINYINT, Privilege_ID TINYINT, AccessPermission TINYINT);  
  
        -- Get a list of distinct entity member types.  
        DECLARE @EntityVersions TABLE  
        (  
             ID         INT IDENTITY (1, 1) NOT NULL  
            ,Entity_ID  INT  
            ,Version_ID INT  
        );  
        INSERT INTO @EntityVersions (Entity_ID, Version_ID)  
        SELECT DISTINCT   
             Entity_ID  
            ,Version_ID  
        FROM #tblPrivileges  
  
        DECLARE @MemberIds  mdm.MemberId;  
  
        -- Get effective permissions for each member, grouped by Entity-Version  
        WHILE EXISTS(SELECT 1 FROM @EntityVersions)  
        BEGIN  
            -- Get the next Entity-Version pair.  
            SELECT TOP 1  
                 @ID = ID  
                ,@Entity_ID = Entity_ID  
                ,@Version_ID = Version_ID  
            FROM @EntityVersions  
            ORDER BY ID;  
  
            DELETE FROM @EntityVersions WHERE ID = @ID;  
  
            -- Get the member ids for the Entity and Version.  
            DELETE FROM @MemberIds  
            INSERT INTO @MemberIds (ID, MemberType_ID)  
            SELECT DISTINCT  
                 Member_ID  
                ,MemberType_ID  
            FROM #tblPrivileges  
            WHERE   Entity_ID = @Entity_ID  
                AND Version_ID = @Version_ID  
                AND Member_ID != @RootMember_ID; -- Omit the ROOT node pseudo-member from the effective permission check. Instead, use it's explicit permission (if any)  
  
            -- Get the member permissions.  
            DELETE FROM @MemberPermissions;  
            INSERT INTO @MemberPermissions  
            EXEC mdm.udpSecurityMembersResolverGet @Principal_ID, @Version_ID, @Entity_ID, @MemberIds;  
  
            -- Since we are getting effective permissions we need to prune the list so that each member appears only once in the result set  
            -- Keep the permission that is effective  
            WITH cteOrderedPermissions AS  
            (  
                SELECT  
                     ROW_NUMBER() OVER (PARTITION BY p.Version_ID, p.Entity_ID, p.MemberType_ID, p.Member_ID  
                                        ORDER BY   
                                            CASE WHEN p.Privilege_ID = mp.Privilege_ID THEN 0 ELSE 1 END -- Permissions that match the effective permission have precedence  
                                            ,p.PrincipalType_ID) RowNumber                               -- Matching user permissions take precedence over matahing group permissions.  
                    ,p.RoleAccess_ID  
                FROM #tblPrivileges p  
                LEFT JOIN @MemberPermissions mp  
                ON      p.Member_ID = mp.ID  
                    AND p.MemberType_ID = mp.MemberType_ID  
                    AND p.Entity_ID = @Entity_ID  
                    AND p.Version_ID = @Version_ID  
                WHERE  p.Member_ID = @RootMember_ID -- Only match the ROOT node, or...  
                    OR mp.ID IS NOT NULL            -- ...members whose effective permissions were just looked up  
            )  
            DELETE p  
            FROM #tblPrivileges p  
            INNER JOIN cteOrderedPermissions op  
            ON p.RoleAccess_ID = op.RoleAccess_ID  
            WHERE op.RowNumber > 1 -- prune all but the best match.  
  
  
            -- Update the member permissions.  
            UPDATE p  
            SET p.Privilege_ID = mp.Privilege_ID, p.AccessPermission = mp.AccessPermission  
            FROM #tblPrivileges p  
            INNER JOIN @MemberPermissions mp  
            ON      p.Member_ID = mp.ID  
                AND p.MemberType_ID = mp.MemberType_ID  
                AND p.Entity_ID = @Entity_ID  
                AND p.Version_ID = @Version_ID;  
        END; -- WHILE  
  
    END; -- If getting effective permissions.  
  
    -- Update the Member name, muid, and code columns.  
  
    -- Get a list of distinct entity member types.  
    DECLARE @EntityMemberTypes TABLE  
    (  
         ID             INT IDENTITY (1, 1) NOT NULL  
        ,Entity_ID      INT  
        ,MemberType_ID  TINYINT  
    );  
    INSERT INTO @EntityMemberTypes (Entity_ID, MemberType_ID)  
    SELECT DISTINCT   
         Entity_ID  
        ,MemberType_ID  
    FROM #tblPrivileges  
    WHERE Member_ID > 0 -- Ignore ROOT and MDMUNUSED (they will be handled later)  
  
    WHILE EXISTS(SELECT 1 FROM @EntityMemberTypes)  
    BEGIN  
        SELECT TOP 1   
             @ID = ID  
            ,@Entity_ID = Entity_ID  
            ,@MemberType_ID = MemberType_ID  
            ,@TableName = mdm.udfTableNameGetByID(Entity_ID, MemberType_ID)  
        FROM @EntityMemberTypes   
        ORDER BY ID;  
         
        DELETE FROM @EntityMemberTypes WHERE ID = @ID;  
  
        SET @SQL= N'  
        UPDATE p  
        SET  Member_MUID       = MUID  
            ,Member_Name       = Name  
            ,Member_Code       = Code  
        FROM mdm.' + QUOTENAME(@TableName) + N' T  
        INNER JOIN #tblPrivileges p  
        ON      T.ID = p.Member_ID  
            AND p.Entity_ID = @Entity_ID  
            AND p.MemberType_ID = @MemberType_ID';  
  
        EXEC sp_executesql @SQL, N'@Entity_ID INT, @MemberType_ID INT', @Entity_ID, @MemberType_ID;  
    END; -- WHILE  
  
    --Update the privileges where id is 0 or less.  
    UPDATE #tblPrivileges  
    SET  Member_Name = N'ROOT'  
        ,Member_Code = N'ROOT'  
    WHERE Member_ID = 0 ;  
    UPDATE #tblPrivileges  
    SET  Member_Name = CASE   
            WHEN Member_ID = -1 THEN NULL -- Top-level unused node  
            ELSE CONVERT(NVARCHAR, ABS(Member_ID) - 10) END -- Level number for level-specific unused node.   
        ,Member_Code = N'MDMUNUSED'  
    WHERE Member_ID < 0;  
  
  
    -- Return the results.  
    SELECT * -- It is generally considered bad practice to do a "SELECT *" because of maintainability issues if the table schema changes. But in this case, it is a temp table that is defined inside of this sproc, so it is okay.  
    FROM #tblPrivileges  
    ORDER BY Model_Name, Version_Name, Member_Name  
  
    SET NOCOUNT OFF  
END
GO
/****** Object:  StoredProcedure [mdm].[udpSecurityPrivilegesModelGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    Returns the specified model privileges.  
  
    DECLARE @RoleAccessTable mdm.Identifier  
    EXEC udpSecurityPrivilegesModelGet  
        @Permission_ID          = NULL,  
        @Model_MUID             = NULL,  
        @Model_Name             = NULL,  
        @Securable_MUID         = NULL,  
        @Securable_Name         = NULL,  
        @Principal_MUID         = NULL,  
        @Principal_Name         = NULL,  
        @PrincipalType_ID       = NULL,  
        @RoleAccessTable        = @RoleAccessTable  
*/  
CREATE PROCEDURE [mdm].[udpSecurityPrivilegesModelGet]  
(  
    @SystemUser_ID          INT, -- The user requesting the permissions  
    @Permission_ID          INT = NULL,  
    @AccessPermission_ID    TINYINT = NULL,  
    @Model_MUID             UNIQUEIDENTIFIER = NULL,  
    @Model_Name             NVARCHAR(100) = NULL,  
    @Securable_MUID         UNIQUEIDENTIFIER = NULL,  
    @Securable_Name         NVARCHAR(355) = NULL, -- Max group name length  
    @Principal_MUID         UNIQUEIDENTIFIER = NULL,  
    @Principal_Name         NVARCHAR(100) = NULL,  
    @PrincipalType_ID       INT = NULL,  
    @RoleAccessTable        mdm.Identifier READONLY,-- caller should ensure table does not include rows where both MUID and Name are blank  
    @CorrelationID          UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE  
         @EmptyMuid             UNIQUEIDENTIFIER = CONVERT(UNIQUEIDENTIFIER, 0x0)  
        ,@PrincipalType_User    TINYINT = 1  
        ,@Permission_Deny       TINYINT = 1;  
  
    SET @Permission_ID      = NULLIF(@Permission_ID, 0);  
    SET @Model_MUID         = NULLIF(@Model_MUID, @EmptyMuid);  
    SET @Model_Name         = NULLIF(@Model_Name, N'');  
    SET @Securable_MUID     = NULLIF(@Securable_MUID, @EmptyMuid);  
    SET @Securable_Name     = NULLIF(@Securable_Name, N'');  
    SET @Principal_MUID     = NULLIF(@Principal_MUID, @EmptyMuid);  
    SET @Principal_Name     = NULLIF(@Principal_Name, N'');  
    DECLARE @Principal_NameUpper NVARCHAR(355) = UPPER(@Principal_Name);  
    SET @PrincipalType_ID   = NULLIF(@PrincipalType_ID, 0);  
  
    IF EXISTS(SELECT 1 FROM @RoleAccessTable)  
    BEGIN  
        SELECT   
             rac.RoleAccess_ID  
            ,rac.RoleAccess_MUID  
            ,rac.Privilege_ID  
            ,rac.AccessPermission  
            ,rac.Object_ID  
            ,rac.Securable_ID  
            ,rac.Securable_MUID  
            ,rac.Securable_Name  
            ,rac.Model_ID  
            ,rac.Model_MUID  
            ,rac.Model_Name  
            ,rac.Principal_ID  
            ,rac.Principal_MUID  
            ,rac.PrincipalType_ID  
            ,rac.Principal_Name  
            ,rac.EnterUserID  
            ,rac.EnterUserMUID  
            ,rac.EnterUserName  
            ,rac.EnterDTM  
            ,rac.LastChgUserID  
            ,rac.LastChgUserMUID  
            ,rac.LastChgUserName  
            ,rac.LastChgDTM  
            ,rac.LastChgDTM  
            ,rac.IsModelAdministrator  
        FROM mdm.viw_SYSTEM_SECURITY_ROLE_ACCESSCONTROL rac  
        INNER JOIN @RoleAccessTable crit  
        ON      (crit.MUID IS NULL OR crit.MUID = rac.RoleAccess_MUID)  
            AND (crit.ID IS NULL OR crit.ID = rac.RoleAccess_ID)  
        INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_MODEL sysUserModel -- The requesting user's model permissions.  
        ON      rac.Model_ID = sysUserModel.ID  
            AND sysUserModel.User_ID = @SystemUser_ID  
        WHERE   (sysUserModel.Privilege_ID = 5 /*Admin*/                -- Requesting user can only see permissions if he is a model admin ...  
                    OR (    rac.Principal_ID = @SystemUser_ID           -- ... or is requesting his own permissions (except for Deny permissions)  
                        AND rac.PrincipalType_ID = @PrincipalType_User  
                        AND rac.Privilege_ID > @Permission_Deny))  
            AND (@Permission_ID IS NULL OR rac.Privilege_ID = @Permission_ID)  
            AND (@AccessPermission_ID IS NULL OR rac.AccessPermission = @AccessPermission_ID)  
            AND (@Model_MUID IS NULL OR rac.Model_MUID = @Model_MUID)  
            AND (@Model_Name IS NULL OR rac.Model_Name = @Model_Name)  
            AND (@Securable_MUID IS NULL OR rac.Securable_MUID = @Securable_MUID)  
            AND (@Securable_Name IS NULL OR rac.Securable_Name = @Securable_Name)  
            AND (@Principal_MUID IS NULL OR rac.Principal_MUID = @Principal_MUID)  
            AND (@Principal_Name IS NULL OR UPPER(rac.Principal_Name) = @Principal_NameUpper)  
            AND (@PrincipalType_ID IS NULL OR rac.PrincipalType_ID = @PrincipalType_ID)  
    END ELSE  
    BEGIN  
        SELECT   
             rac.RoleAccess_ID  
            ,rac.RoleAccess_MUID  
            ,rac.Privilege_ID  
            ,rac.AccessPermission  
            ,rac.Object_ID  
            ,rac.Securable_ID  
            ,rac.Securable_MUID  
            ,rac.Securable_Name  
            ,rac.Model_ID  
            ,rac.Model_MUID  
            ,rac.Model_Name  
            ,rac.Principal_ID  
            ,rac.Principal_MUID  
            ,rac.PrincipalType_ID  
            ,rac.Principal_Name  
            ,rac.EnterUserID  
            ,rac.EnterUserMUID  
            ,rac.EnterUserName  
            ,rac.EnterDTM  
            ,rac.LastChgUserID  
            ,rac.LastChgUserMUID  
            ,rac.LastChgUserName  
            ,rac.LastChgDTM  
            ,rac.LastChgDTM  
            ,rac.IsModelAdministrator  
        FROM mdm.viw_SYSTEM_SECURITY_ROLE_ACCESSCONTROL rac  
        INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_MODEL sysUserModel -- The requesting user's model permissions.  
        ON      rac.Model_ID = sysUserModel.ID  
            AND sysUserModel.User_ID = @SystemUser_ID  
        WHERE   (sysUserModel.Privilege_ID = 5 /*Admin*/                -- Requesting user can only see permissions if he is a model admin ...  
                    OR (    rac.Principal_ID = @SystemUser_ID           -- ... or is requesting his own permissions (except for Deny permissions)  
                        AND rac.PrincipalType_ID = @PrincipalType_User  
                        AND rac.Privilege_ID > @Permission_Deny))  
            AND (@Permission_ID IS NULL OR rac.Privilege_ID = @Permission_ID)  
            AND (@AccessPermission_ID IS NULL OR rac.AccessPermission = @AccessPermission_ID)  
            AND (@Model_MUID IS NULL OR rac.Model_MUID = @Model_MUID)  
            AND (@Model_Name IS NULL OR rac.Model_Name = @Model_Name)  
            AND (@Securable_MUID IS NULL OR rac.Securable_MUID = @Securable_MUID)  
            AND (@Securable_Name IS NULL OR rac.Securable_Name = @Securable_Name)  
            AND (@Principal_MUID IS NULL OR rac.Principal_MUID = @Principal_MUID)  
            AND (@Principal_Name IS NULL OR UPPER(rac.Principal_Name) = @Principal_NameUpper)  
            AND (@PrincipalType_ID IS NULL OR rac.PrincipalType_ID = @PrincipalType_ID)  
    END  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpSecurityPrivilegesSave]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
*/  
CREATE PROCEDURE [mdm].[udpSecurityPrivilegesSave]  
(  
    @SystemUser_ID        INT, -- The user who is making the change.  
    @Principal_ID        INT,  
    @PrincipalType_ID    INT,  
    @Principal_Name        NVARCHAR(355) = NULL, -- max group name length  
    @RoleAccess_ID        INT,  
    @Object_ID            INT,  
    @Privilege_ID        INT,  
    @AccessPermission    TINYINT = NULL,  
    @Model_ID        INT,  
    @Securable_ID        INT,  
    @Securable_Name        NVARCHAR(100),  
    @RoleAccess_MUID    UNIQUEIDENTIFIER = NULL,  
    @Return_ID        INT = NULL OUTPUT,  
    @Return_MUID        UNIQUEIDENTIFIER = NULL OUTPUT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON  
  
    -- Set AccessPermission as 0 if AccessPermission is null  
    SET @AccessPermission = ISNULL(@AccessPermission, 0);  
  
    DECLARE   
         @Role_ID               INT  
        ,@Description           NVARCHAR(250)  
        ,@NewUser_ID            INT  
        ,@PrincipalType_User    TINYINT = 1  
        ,@PrincipalType_Group   TINYINT = 2  
        ;  
  
    SELECT    @Role_ID = Role_ID  
    FROM    mdm.tblSecurityAccessControl  
    WHERE    Principal_ID = @Principal_ID  
    AND        PrincipalType_ID = @PrincipalType_ID  
  
    IF @Principal_Name IS NULL BEGIN  
        IF @PrincipalType_ID = @PrincipalType_User BEGIN  
            SELECT @Principal_Name = mdm.udfUserNameGetByUserID(@Principal_ID)  
        END ELSE BEGIN  
            SELECT @Principal_Name = [Name] FROM mdm.tblUserGroup WHERE ID = @Principal_ID  
        END   
    END  
  
    DECLARE @PrincipalType_Name NVARCHAR(20);  
    IF @PrincipalType_ID = @PrincipalType_User   
    BEGIN  
        SELECT @PrincipalType_Name = N'User'  
    END ELSE   
    BEGIN  
        SELECT @PrincipalType_Name = N'Group'  
    END   
  
    IF @Role_ID IS NULL BEGIN  
        --Create a new user account role for this user.  
        INSERT INTO mdm.tblSecurityRole ([Name], EnterUserID, LastChgUserID) VALUES (CONCAT(N'Role for ', @PrincipalType_Name, N' ', @Principal_Name), @SystemUser_ID, @SystemUser_ID)  
        SET @Role_ID = SCOPE_IDENTITY()  
  
        INSERT INTO mdm.tblSecurityAccessControl (PrincipalType_ID, Principal_ID, Role_ID, Description, EnterUserID, LastChgUserID)   
        VALUES (@PrincipalType_ID, @Principal_ID, @Role_ID, LEFT(@Principal_Name, 89) + N' ' + @PrincipalType_Name, @SystemUser_ID, @SystemUser_ID)  
    END   
  
    IF IsNull(@Object_ID, 0) > 0   
        SELECT    @Description = @Securable_Name + N' ' + o.Name + N' (' + p.Name + N')'  
        FROM    mdm.tblSecurityObject o   
                INNER JOIN mdm.tblSecurityPrivilege p   
                    ON o.ID = @Object_ID AND p.ID = @Privilege_ID  
    ELSE  
        SELECT @Description = N''  
  
    IF IsNull(@RoleAccess_ID, 0) > 0 AND @RoleAccess_MUID IS NULL   
    BEGIN  
        IF EXISTS(SELECT 1 FROM mdm.tblSecurityRoleAccess WHERE ID = @RoleAccess_ID)   
        BEGIN  
            DECLARE @ExistingUserRoleAccess_ID INT  
            DECLARE @RoleAccessPrincipalType_ID INT  
            SELECT @RoleAccessPrincipalType_ID = PrincipalType_ID FROM mdm.viw_SYSTEM_SECURITY_ROLE_ACCESSCONTROL WHERE RoleAccess_ID = @RoleAccess_ID  
            IF @PrincipalType_ID = @PrincipalType_User AND @RoleAccessPrincipalType_ID = @PrincipalType_Group BEGIN  
                -- Create a user override of a user group privilege.  First see if the user already has an existing override explicit record.  
                -- If so update it.  If not create a new one.  
                SELECT @ExistingUserRoleAccess_ID = RoleAccess_ID   
                FROM mdm.viw_SYSTEM_SECURITY_ROLE_ACCESSCONTROL   
                WHERE   
                    Securable_ID = @Securable_ID AND   
                    Object_ID = @Object_ID AND   
                    Principal_ID = @Principal_ID AND   
                    PrincipalType_ID = @PrincipalType_ID  
  
                IF IsNull(@ExistingUserRoleAccess_ID, 0) = 0  
                    INSERT INTO mdm.tblSecurityRoleAccess (Role_ID, Object_ID, Model_ID, Privilege_ID, AccessPermission, Securable_ID, Description, EnterUserID, LastChgUserID)  
                        SELECT @Role_ID, Object_ID, Model_ID, @Privilege_ID, @AccessPermission, Securable_ID, Description, @SystemUser_ID, @SystemUser_ID FROM mdm.tblSecurityRoleAccess WHERE ID = @RoleAccess_ID  
                ELSE  
                    UPDATE mdm.tblSecurityRoleAccess SET Privilege_ID = @Privilege_ID, AccessPermission = @AccessPermission WHERE ID = @ExistingUserRoleAccess_ID   
            END ELSE   
                UPDATE mdm.tblSecurityRoleAccess SET Privilege_ID = @Privilege_ID, AccessPermission = @AccessPermission WHERE ID = @RoleAccess_ID   
        END ELSE  
            BEGIN  
            INSERT INTO mdm.tblSecurityRoleAccess (Role_ID, Object_ID, Model_ID, Privilege_ID, AccessPermission, Securable_ID, Description, EnterUserID, LastChgUserID)  
                                        VALUES(@Role_ID, @Object_ID, @Model_ID, @Privilege_ID, @AccessPermission, @Securable_ID, @Description, @SystemUser_ID, @SystemUser_ID)  
            SELECT @NewUser_ID=SCOPE_IDENTITY()  
            END  
    END ELSE   
        BEGIN  
            SELECT @ExistingUserRoleAccess_ID = RoleAccess_ID   
            FROM mdm.viw_SYSTEM_SECURITY_ROLE_ACCESSCONTROL   
            WHERE   
                Securable_ID = @Securable_ID AND   
                Object_ID = @Object_ID AND   
                Principal_ID = @Principal_ID AND   
                PrincipalType_ID = @PrincipalType_ID;  
  
            IF COALESCE(@ExistingUserRoleAccess_ID, 0) = 0  
            BEGIN  
                IF @RoleAccess_MUID IS NULL   
                BEGIN  
                    INSERT INTO mdm.tblSecurityRoleAccess (Role_ID, Object_ID, Model_ID, Privilege_ID, AccessPermission, Securable_ID, Description, EnterUserID, LastChgUserID)  
                                                    VALUES(@Role_ID, @Object_ID, @Model_ID, @Privilege_ID, @AccessPermission, @Securable_ID, @Description, @SystemUser_ID, @SystemUser_ID)  
                END ELSE  
                BEGIN  
                    INSERT INTO mdm.tblSecurityRoleAccess (Role_ID, MUID, Object_ID, Model_ID, Privilege_ID, AccessPermission, Securable_ID, Description, EnterUserID, LastChgUserID)  
                                                    VALUES(@Role_ID, @RoleAccess_MUID, @Object_ID, @Model_ID, @Privilege_ID, @AccessPermission, @Securable_ID, @Description, @SystemUser_ID, @SystemUser_ID)  
                END;  
            END ELSE   
            BEGIN  
                UPDATE mdm.tblSecurityRoleAccess   
                SET Privilege_ID = @Privilege_ID, AccessPermission = @AccessPermission  
                WHERE ID = @ExistingUserRoleAccess_ID;  
            END;  
                                  
        SELECT @NewUser_ID=SCOPE_IDENTITY()  
        END  
  
            SELECT @Return_ID = @NewUser_ID  
          SELECT @Return_MUID = (SELECT MUID FROM mdm.tblSecurityRoleAccess WHERE ID = @NewUser_ID)  
      
    -- Send the message  
	EXEC mdm.udpPerformanceQueueSave;  
      
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpSecurityPrivilegesSaveByMUID]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpSecurityPrivilegesSaveByMUID]  
(  
    @SystemUser_ID      INT,  
    @Principal_MUID     UNIQUEIDENTIFIER,  
    @PrincipalType_ID   INT,  
    @Principal_Name     NVARCHAR(355) = NULL, -- Max group name length  
    @RoleAccess_MUID    UNIQUEIDENTIFIER = NULL,  
    @Object_ID          INT,  
    @Privilege_ID       INT,  
    @AccessPermission   TINYINT = NULL,  
    @Model_MUID         UNIQUEIDENTIFIER,  
    @Model_Name         NVARCHAR(100) = NULL,  
    @Securable_MUID     UNIQUEIDENTIFIER,  
    @Securable_Name     NVARCHAR(100)=NULL,  
    @Status_ID          INT = 0,  
    @Return_ID          INT = NULL OUTPUT,  
    @Return_MUID        UNIQUEIDENTIFIER = NULL OUTPUT,  
    @CorrelationID      UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON  
  
    DECLARE  
        @Role_ID        INT,  
        @Description    NVARCHAR(100),  
        @Principal_ID   INT,  
        @Principal_NameUpper NVARCHAR(355) = UPPER(@Principal_Name),  
        @Model_ID       INT,  
        @Securable_ID   INT,  
        @RoleAccess_ID  INT,  
        @NewUser_ID     INT,  
        @IsModelAdmin   BIT,  
        @Return_Value   INT,  
  
        --PrincipalTypes  
        @PrincipalType_UserAccount INT = 1,  
        @PrincipalType_Group INT = 2,  
  
        --Statuses  
        @Status_Create INT = 0,  
        @Status_Active INT = 1,  
        @Status_Clone INT = 3,  
  
        --PermissionType  
        @PermissionType_Admin TINYINT = 5,  
  
        --Object type  
        @ObjectType_Model TINYINT = 1,  
        @ObjectType_Entity TINYINT = 3  
    ;  
  
    -- Lookup the principal integer ID from the MUID  
    IF(@PrincipalType_ID = @PrincipalType_UserAccount)  
    BEGIN  
        IF( @Principal_MUID IS NOT NULL AND CAST(@Principal_MUID  AS BINARY) <> 0x0  
                    AND EXISTS(SELECT ID from mdm.tblUser WHERE MUID=@Principal_MUID))  
        BEGIN  
            SELECT @Principal_ID = (SELECT ID FROM mdm.tblUser WHERE MUID=@Principal_MUID)  
        END  
        ELSE  
        IF( @Principal_Name IS NOT NULL AND EXISTS(SELECT ID from mdm.tblUser WHERE UPPER(UserName) = @Principal_NameUpper))  
        BEGIN  
            SELECT @Principal_ID = (SELECT ID FROM mdm.tblUser WHERE UPPER(UserName) = @Principal_NameUpper)  
        END  
    END  
    ELSE IF(@PrincipalType_ID = @PrincipalType_Group)  
    BEGIN  
        IF( @Principal_MUID IS NOT NULL AND CAST(@Principal_MUID  AS BINARY) <> 0x0  
                AND EXISTS(SELECT ID from mdm.tblUserGroup WHERE MUID=@Principal_MUID))  
        BEGIN  
            SELECT @Principal_ID = (SELECT ID FROM mdm.tblUserGroup WHERE MUID=@Principal_MUID)  
        END  
        ELSE IF( @Principal_Name IS NOT NULL AND EXISTS(SELECT ID from mdm.tblUserGroup WHERE UPPER(Name) = @Principal_NameUpper))  
        BEGIN  
            SELECT @Principal_ID = (SELECT ID FROM mdm.tblUserGroup WHERE UPPER(Name) = @Principal_NameUpper)  
        END  
    END  
  
    IF @Principal_ID IS NULL OR @Principal_ID = 0  
    BEGIN  
        RAISERROR('MDSERR500025|The principal ID for the user or group is not valid.', 16, 1);  
        RETURN;  
    END  
  
    -- Find the role id.  
    SELECT  
        @Role_ID = Role_ID  
    FROM  
        mdm.tblSecurityAccessControl  
    WHERE  
        Principal_ID = @Principal_ID  AND  
        PrincipalType_ID = @PrincipalType_ID  
  
    --Check the Role Access MUID  
    IF(@RoleAccess_MUID IS NOT NULL AND CAST(@RoleAccess_MUID  AS BINARY) <> 0x0)  
    BEGIN  
        If( EXISTS(SELECT ID from mdm.tblSecurityRoleAccess WHERE MUID=@RoleAccess_MUID))  
        BEGIN  
            SELECT  
                @RoleAccess_ID = RoleAccess_ID,  
                @Model_MUID = Model_MUID,  
                @Securable_MUID =  Securable_MUID,  
                @Object_ID = Object_ID  
            FROM mdm.viw_SYSTEM_SECURITY_ROLE_ACCESSCONTROL  
            WHERE RoleAccess_MUID = @RoleAccess_MUID  
        END  
    END  
    If( @Model_MUID IS NOT NULL AND CAST(@Model_MUID  AS BINARY) <> 0x0  
            AND EXISTS(SELECT ID from mdm.tblModel WHERE MUID=@Model_MUID))  
    BEGIN  
        SELECT @Model_ID = ID FROM mdm.tblModel WHERE MUID=@Model_MUID  
    END  
    ELSE IF ( @Model_Name IS NOT NULL AND EXISTS(SELECT ID from mdm.tblModel WHERE Name=@Model_Name))  
    BEGIN  
        SELECT @Model_ID = ID, @Model_MUID = MUID FROM mdm.tblModel WHERE  Name=@Model_Name  
    END  
    ELSE  
    BEGIN  
        RAISERROR('MDSERR500027|The model permission cannot be saved. The model GUID is not valid.', 16, 1);  
        RETURN;  
    END  
  
    EXEC mdm.udpUserIsModelAdministrator @User_ID=@SystemUser_ID, @ObjectType_ID=@ObjectType_Model, @Object_MUID=@Model_MUID, @Object_Name=NULL, @ObjectContext_MUID=NULL,  
        @ObjectContext_Name=NULL, @Return_ID=@IsModelAdmin output  
  
    IF @IsModelAdmin = 0  
    BEGIN  
        RAISERROR('MDSERR120002|The user does not have permission to perform this operation.', 16, 1);  
        RETURN;  
    END  
  
    -- Ensure that Admin permission is only being applied to Models  
    IF @Privilege_ID = @PermissionType_Admin  
        AND @Object_ID <> @ObjectType_Model  
        AND @Object_ID <> @ObjectType_Entity  
    BEGIN  
        RAISERROR('MDSERR500054|The permission cannot be saved. Admin permission can only be set on a model.', 16, 1);  
        RETURN;  
    END;  
  
    SELECT @Securable_ID = [mdm].[udfSecurableIDGetByObjectID](@Object_ID, @Securable_MUID, @Securable_Name)  
  
    If(@Securable_ID IS NULL OR @Securable_ID = 0 )  
    BEGIN  
        RAISERROR('MDSERR500028|The model permission cannot be saved. The object GUID is not valid.', 16, 1);  
        RETURN;  
    END  
  
    --Check the Role Access MUID to determine if it is an udpate, clone or a create operation.  
    IF(@RoleAccess_MUID IS NOT NULL AND CAST(@RoleAccess_MUID  AS BINARY) <> 0x0)  
    BEGIN  
        IF( EXISTS(SELECT ID FROM mdm.tblSecurityRoleAccess WHERE MUID=@RoleAccess_MUID))  
        BEGIN  
            --Update operation.  
            SELECT @RoleAccess_ID = (SELECT ID FROM mdm.tblSecurityRoleAccess WHERE MUID=@RoleAccess_MUID)  
            IF (@Status_ID = @Status_Clone)  
            BEGIN  
                SET @Status_ID = @Status_Active  
            END  
        END  
        ELSE IF (@Status_ID = @Status_Clone)  
        BEGIN   --Its a clone operation.  
            EXEC  @Return_Value = [mdm].[udpSecurityPrivilegesSave]  
                @SystemUser_ID,  
                @Principal_ID,  
                @PrincipalType_ID,  
                @Principal_Name,  
                @RoleAccess_ID,  
                @Object_ID,  
                @Privilege_ID,  
                @AccessPermission,  
                @Model_ID,  
                @Securable_ID,  
                @Securable_Name,  
                @RoleAccess_MUID,  
                @Return_ID OUTPUT,  
                @Return_MUID OUTPUT  
  
            RETURN(1)  
        END -- Clone  
  
    END -- MUID Check  
        --Create the new security role.  
    ELSE  
    BEGIN  
        IF (@Status_ID = @Status_Active)  
        BEGIN  
            RAISERROR('MDSERR500033|The model permission cannot be saved. The ID is not valid.', 16, 1);  
            RETURN;  
        END  
        ELSE IF (@Status_ID = @Status_Clone)  
        BEGIN  
            RAISERROR('MDSERR500034|The model permission cannot be copied. The ID is not valid.', 16, 1);  
            RETURN;  
        END  
    END  
  
    IF (@Status_ID = @Status_Create AND @RoleAccess_ID IS NOT NULL AND @RoleAccess_ID > 0 )  
    BEGIN  
        RAISERROR('MDSERR500035|The model permission cannot be created. A model permission already exists.', 16, 1);  
        RETURN;  
    END  
    ELSE IF(@Status_ID = @Status_Active AND @RoleAccess_ID IS NULL OR @RoleAccess_ID = 0 )  
    BEGIN  
        RAISERROR('MDSERR500033|The model permission cannot be saved. The ID is not valid.', 16, 1);  
        RETURN;  
    END  
    ELSE IF(@Status_ID = @Status_Create)  
    BEGIN  
  
        -- IF we can locate a record for the same user, create should result in an error as no new record  
        -- can be added.  
        If(EXISTS (SELECT ID FROM mdm.tblSecurityRoleAccess WHERE Model_ID = @Model_ID AND Role_ID = @Role_ID AND  
            Securable_ID = @Securable_ID AND Object_ID =  @Object_ID ))  
        BEGIN  
            RAISERROR('MDSERR500035|The model permission cannot be created. A model permission already exists.', 16, 1);  
            RETURN;  
        END  
        SET @RoleAccess_ID = 0  
    END  
  
    EXEC    @Return_Value = [mdm].[udpSecurityPrivilegesSave]  
            @SystemUser_ID,  
            @Principal_ID,  
            @PrincipalType_ID,  
            @Principal_Name,  
            @RoleAccess_ID,  
            @Object_ID,  
            @Privilege_ID,  
            @AccessPermission,  
            @Model_ID,  
            @Securable_ID,  
            @Securable_Name,  
            NULL,  
            @Return_ID OUTPUT,  
            @Return_MUID OUTPUT  
  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpSecurityPrivilegesSummaryGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
EXEC mdm.udpSecurityPrivilegesSummaryGet 118,1,1,0  
EXEC mdm.udpSecurityPrivilegesSummaryGet 1,1,2,1  
EXEC mdm.udpSecurityPrivilegesSummaryGet 118,27,1,1  
*/  
CREATE PROCEDURE [mdm].[udpSecurityPrivilegesSummaryGet]  
(  
     @SystemUser_ID     INT  
    ,@Principal_ID      INT  
    ,@PrincipalType_ID  TINYINT  
    ,@ResolutionType    TINYINT  
    ,@CorrelationID     UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON  
  
    DECLARE  
         @PrincipalType_Group           TINYINT = 2  
  
        ,@ResolutionType_UserAndGroup   TINYINT = 0  
        ,@ResolutionType_User           TINYINT = 1  
        ,@ResolutionType_Effective      TINYINT = 2  
  
        ,@MemberType_Leaf               TINYINT = 1  
        ,@MemberType_Consolidated       TINYINT = 2  
        ,@MemberType_Collection         TINYINT = 3  
        ;  
    IF (@PrincipalType_ID = @PrincipalType_Group AND @ResolutionType = @ResolutionType_Effective)  
    BEGIN  
        SET @ResolutionType = @ResolutionType_User;  
    END;  
  
    DECLARE @IncludeGroupAssignments BIT = (CASE @ResolutionType WHEN @ResolutionType_User THEN 0 ELSE 1 END)  
  
    IF (@ResolutionType = @ResolutionType_Effective)  
    BEGIN  
        WITH privileges AS(  
            SELECT  
                modelSec.Privilege_ID,  
                modelSec.AccessPermission,  
                1 /*Model*/ AS Object_ID,  
                model.ID AS Securable_ID,  
                model.MUID AS Securable_MUID,  
                QUOTENAME(model.Name) AS Securable_Name,  
                model.ID AS Model_ID,  
                model.MUID AS Model_MUID,  
                model.Name AS Model_Name,  
                CASE modelSec.Privilege_ID WHEN 5 /*Admin*/ THEN 1 ELSE 0 END AS IsModelAdministrator  
            FROM mdm.viw_SYSTEM_SECURITY_USER_MODEL AS modelSec  
            INNER JOIN mdm.tblModel AS model  
            ON modelSec.ID = model.ID  
            WHERE User_ID = @Principal_ID  
                AND modelSec.Privilege_ID <> 1 /*Deny*/  
            UNION ALL  
            SELECT  
                entitySec.Privilege_ID,  
                entitySec.AccessPermission,  
                3 /*Entity*/ AS Object_ID,  
                entity.ID AS Securable_ID,  
                entity.MUID AS Securable_MUID,  
                CONCAT(QUOTENAME(model.Name), N':', QUOTENAME(entity.Name)) AS Securable_Name,  
                model.ID AS Model_ID,  
                model.MUID AS Model_MUID,  
                model.Name AS Model_Name,  
                CASE entitySec.Privilege_ID WHEN 5 /*Admin*/ THEN 1 ELSE 0 END AS IsModelAdministrator  
            FROM mdm.viw_SYSTEM_SECURITY_USER_ENTITY AS entitySec  
            INNER JOIN mdm.tblEntity AS entity  
            ON entitySec.ID = entity.ID  
            INNER JOIN mdm.tblModel AS model  
            ON entity.Model_ID = model.ID  
            WHERE User_ID = @Principal_ID  
                AND entitySec.Privilege_ID <> 1 /*Deny*/  
            UNION ALL  
            SELECT  
                mtSec.Privilege_ID,  
                mtSec.AccessPermission,  
                mtSec.ID + 7 /*MemberType*/ AS Object_ID,  
                entity.ID AS Securable_ID,  
                entity.MUID AS Securable_MUID,  
                CONCAT(QUOTENAME(model.Name), N':', QUOTENAME(entity.Name), N':', QUOTENAME(  
                CASE mtSec.ID  
                    WHEN @MemberType_Leaf THEN N'Leaf'  
                    WHEN @MemberType_Consolidated THEN N'Consolidated'  
                    WHEN @MemberType_Collection THEN N'Collection'  
                END)) AS Securable_Name,  
                model.ID AS Model_ID,  
                model.MUID AS Model_MUID,  
                model.Name AS Model_Name,  
                mtSec.IsAdmin AS IsModelAdministrator  
            FROM mdm.viw_SYSTEM_SECURITY_USER_MEMBERTYPE AS mtSec  
            INNER JOIN mdm.tblEntity AS entity  
            ON mtSec.Entity_ID = entity.ID  
            INNER JOIN mdm.tblModel AS model  
            ON entity.Model_ID = model.ID  
            WHERE User_ID = @Principal_ID  
                AND mtSec.Privilege_ID <> 1 /*Deny*/  
            UNION ALL  
            SELECT  
                attSec.Privilege_ID,  
                attSec.AccessPermission,  
                4 /*Attribute*/ AS Object_ID,  
                att.ID AS Securable_ID,  
                att.MUID AS Securable_MUID,  
                CONCAT(QUOTENAME(model.Name), N':', QUOTENAME(entity.Name), N':', QUOTENAME(  
                CASE att.MemberType_ID  
                    WHEN @MemberType_Leaf THEN N'Leaf'  
                    WHEN @MemberType_Consolidated THEN N'Consolidated'  
                    WHEN @MemberType_Collection THEN N'Collection'  
                END), N':', QUOTENAME(att.Name))  AS Securable_Name ,  
                model.ID AS Model_ID,  
                model.MUID AS Model_MUID,  
                model.Name AS Model_Name,  
                attSec.IsAdmin AS IsModelAdministrator  
            FROM mdm.viw_SYSTEM_SECURITY_USER_ATTRIBUTE AS attSec  
            INNER JOIN mdm.tblAttribute AS att  
            ON attSec.ID = att.ID  
            INNER JOIN mdm.tblEntity AS entity  
            ON att.Entity_ID = entity.ID  
            INNER JOIN mdm.tblModel AS model  
            ON entity.Model_ID = model.ID  
            WHERE User_ID = @Principal_ID  
        )  
        SELECT  
             NULL AS RoleAccess_ID  
            ,NULL AS RoleAccess_MUID  
            ,Privilege_ID  
            ,AccessPermission  
            ,Object_ID  
            ,Securable_ID  
            ,Securable_MUID  
            ,Securable_Name  
            ,Model_ID  
            ,Model_MUID  
            ,Model_Name  
            ,IsModelAdministrator  
            ,@PrincipalType_ID AS PrincipalType_ID  
            ,@Principal_ID AS Principal_ID  
            ,NULL AS Principal_MUID  
            ,NULL AS Principal_Name  
            ,NULL AS EnterUserID  
            ,NULL AS EnterUserMUID  
            ,NULL AS EnterUserName  
            ,NULL AS EnterDTM  
            ,NULL AS LastChgUserID  
            ,NULL AS LastChgUserMUID  
            ,NULL AS LastChgUserName  
            ,NULL AS LastChgDTM  
    FROM privileges  
    END -- If getting effective permissions.  
    ELSE  
    BEGIN  
        -- Get all permissions assigned to the user.  
       SELECT *  
       FROM mdm.udfSecurityUserExplicitPermissions(@SystemUser_ID, @Principal_ID, @PrincipalType_ID, @IncludeGroupAssignments)  
       ORDER BY Securable_Name  
    END  
  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpSecurityRoleAccessMemberCopy]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    EXEC mdm.udpSecurityRoleAccessMemberCopy 1, 2, 3  
*/  
CREATE PROCEDURE [mdm].[udpSecurityRoleAccessMemberCopy]  
(  
    @User_ID				INT,  
    @SourceVersion_ID		INT,		--Version to copy security assignments from  
    @TargetVersion_ID		INT,		--Version to copy security assignments to  
    @MapMembersByID			BIT = 0,	--Default is to join by [Code], but permit joining on [AsOf_ID] too  
    @DeleteTarget			BIT = 0,	--If true, delete all target rows before copying source rows  
    @IgnoreLeastPrivilege	BIT = 0		--If false, only overwrites if new value is stronger than old value  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
      
    DECLARE   
        @i					INT,  
        @Entity_ID			INT,  
        @MemberType_ID		TINYINT,  
        @Model_ID		    INT,  
        @SQL				NVARCHAR(MAX);  
      
    /*=================================================================    
      Validate parameters  
      =================================================================*/  
        
    IF	@SourceVersion_ID IS NULL   
        OR @TargetVersion_ID IS NULL  
        OR @User_ID IS NULL --Ensure required parameters are provided  
        OR NOT EXISTS  
        (  
            SELECT 1 FROM mdm.tblModelVersion AS v1  
            INNER JOIN mdm.tblModelVersion AS v2 ON (v1.Model_ID = v2.Model_ID) --Ensure both Versions in same Model  
            WHERE v1.ID = @SourceVersion_ID --Ensure Version 1 exists  
            AND v2.ID = @TargetVersion_ID --Ensure Version 2 exists  
            AND v1.ID <> v2.ID --Ensure this is not a self-copy  
        )  
        OR NOT EXISTS  
        (  
            SELECT 1 FROM mdm.tblUser WHERE ID = @User_ID --Ensure User exists  
        )  
    BEGIN  
        RAISERROR('MDSERR100010|The Parameters are not valid.', 16, 1);  
        RETURN(1);  
    END; --if  
  
    SELECT @Model_ID = Model_ID  
    FROM mdm.tblModelVersion  
    WHERE ID = @SourceVersion_ID  
      
    --Set parameter defaults  
    SELECT   
        @DeleteTarget = ISNULL(@DeleteTarget, 0),   
        @IgnoreLeastPrivilege = ISNULL(@IgnoreLeastPrivilege, 0),  
        @MapMembersByID = ISNULL(@MapMembersByID, 0);  
  
  
    /*=================================================================    
      Initialize structures  
      =================================================================*/  
      
    CREATE TABLE #sram  
    (  
           Role_ID                      INT NOT NULL,  
           Privilege_ID					INT NOT NULL,  
           AccessPermission             TINYINT NOT NULL,  
           Entity_ID                    INT NOT NULL,  
           HierarchyType_ID				TINYINT NOT NULL,  
           ExplicitHierarchy_ID			INT NULL,  
           DerivedHierarchy_ID			INT NULL,  
           Hierarchy_ID					INT NOT NULL,  
           MemberType_ID				TINYINT NOT NULL,  
           Member_ID                    INT NOT NULL,  
           [Description]				NVARCHAR(250) NULL,  
           MappedMember_ID				INT NULL --Place holder for mapped member ID  
    );  
  
    --Copy all SRAM rows related to the Source Version into a working table  
    INSERT INTO #sram  
    SELECT  
        ra.Role_ID, Privilege_ID, AccessPermission, Entity_ID,  
        ra.HierarchyType_ID, ExplicitHierarchy_ID, DerivedHierarchy_ID, Hierarchy_ID,  
        ra.MemberType_ID, Member_ID,   
        ra.[Description],   
        CASE WHEN (ra.Member_ID = 0) OR (@Model_ID != e.Model_ID) THEN ra.Member_ID ELSE NULL END --Map virtual roots and external DBA directly (0-->0)  
    FROM mdm.tblSecurityRoleAccessMember ra  
    INNER JOIN mdm.tblEntity e ON ra.Entity_ID = e.ID  
    WHERE Version_ID = @SourceVersion_ID; --We are copying the source Version only  
  
  
    /*=================================================================    
      Map Members across Versions using [Code] or [AsOf_ID]  
      =================================================================*/  
  
    --Declare & populate loop counter  
    DECLARE @loop TABLE(ID INT IDENTITY(1, 1) NOT NULL PRIMARY KEY CLUSTERED, Entity_ID INT NOT NULL, MemberType_ID TINYINT NOT NULL);  
    INSERT INTO @loop(Entity_ID, MemberType_ID)   
    SELECT DISTINCT Entity_ID, MemberType_ID   
    FROM #sram;  
          
    --Map each member in the old Version to the same member in the new Version  
    WHILE EXISTS(SELECT 1 FROM @loop) BEGIN  
        SELECT TOP 1 @i = ID, @Entity_ID = Entity_ID, @MemberType_ID = MemberType_ID FROM @loop ORDER BY ID;  
          
        SET @SQL = N'  
            UPDATE #sram SET   
                MappedMember_ID = en2.ID  
            FROM #sram AS sram  
            INNER JOIN mdm.' + quotename(mdm.udfTableNameGetByID(@Entity_ID, @MemberType_ID)) + N' AS en1 ON  
                sram.Member_ID = en1.ID  
            INNER JOIN mdm.' + quotename(mdm.udfTableNameGetByID(@Entity_ID, @MemberType_ID)) + N' AS en2 ON  
                ' + CASE @MapMembersByID   
                        --Either map members using [Code]-->[Code]		  
                        WHEN 0 THEN 'en1.[Code] = en2.[Code]'  
                        --Else map members using [AsOf_ID]-->[ID]  
                        ELSE '(en1.ID = en2.AsOf_ID) OR (en2.ID = en1.AsOf_ID)'  
                    END + N'  
            WHERE  
                sram.Entity_ID = @Entity_ID AND  
                sram.MemberType_ID = @MemberType_ID AND  
                sram.MappedMember_ID IS NOT NULL AND  
                en1.Version_ID = @SourceVersion_ID AND	--Source Version  
                en2.Version_ID = @TargetVersion_ID AND	--Target Version  
                en1.Status_ID = 1 AND en2.Status_ID = 1	--Non-deleted members  
            ;';  
          
        --PRINT @SQL;		  
        EXEC sp_executesql @SQL, N'@SourceVersion_ID INT, @TargetVersion_ID INT, @Entity_ID INT, @MemberType_ID TINYINT', @SourceVersion_ID, @TargetVersion_ID, @Entity_ID, @MemberType_ID;  
      
        DELETE @loop WHERE ID = @i;  
    END; --while	  
      
          
    /*=================================================================    
      Do the copy operation  
      =================================================================*/  
      
    --Perform a MERGE operation  
    MERGE INTO mdm.tblSecurityRoleAccessMember AS dest	  
    --Only copy rows that we managed to map successfully  
    USING   
    (  
        SELECT   
           Role_ID,  
           Privilege_ID,  
           AccessPermission,  
           Entity_ID,  
           HierarchyType_ID,  
           ExplicitHierarchy_ID,  
           DerivedHierarchy_ID,  
           Hierarchy_ID,  
           MemberType_ID,  
           Member_ID,  
           [Description],  
           MappedMember_ID  
        FROM #sram   
        WHERE MappedMember_ID IS NOT NULL) AS src  
    --Match criteria is a compound key over (Version, Entity, Hierarchy, Role, Mapped/Member)  
    ON   
    (	dest.Version_ID = @TargetVersion_ID AND --Make sure we're updating the target Version only  
        dest.Entity_ID = src.Entity_ID AND  
        dest.HierarchyType_ID = src.HierarchyType_ID AND   
        dest.Hierarchy_ID = src.Hierarchy_ID AND  
        dest.Role_ID = src.Role_ID AND  
        dest.Member_ID = src.MappedMember_ID --Make sure we're joining on the mapped member  
    )  
    --When a row exists in both the source and the target  
    WHEN MATCHED   
        --And the Privilege_ID values do not already match (performance optimization)  
        AND (src.Privilege_ID <> dest.Privilege_ID OR src.AccessPermission <> dest.AccessPermission)  
        --Then UPDATE the destination Privilege_ID as follows:  
        THEN UPDATE SET   
            Privilege_ID = CASE  
                --If DeleteTarget=T then overwrite blindly  
                WHEN @DeleteTarget = 1 THEN src.Privilege_ID  
                --If DeleteTarget=F AND Ignore=T then overwrite blindly				  
                WHEN @DeleteTarget = 0 AND @IgnoreLeastPrivilege = 1 THEN src.Privilege_ID  
                --If DeleteTarget=F AND Ignore=F then...  
                WHEN @DeleteTarget = 0 AND @IgnoreLeastPrivilege = 0 THEN CASE  
                    --Deny always wins  
                    WHEN src.Privilege_ID = 1 OR dest.Privilege_ID = 1 THEN 1  
                    --Else it must be Access  
                    ELSE 4  
                END --case  
            END, --case  
            AccessPermission = dest.AccessPermission | src.AccessPermission,  
            --Reset the Description  
            [Description] = NULL,  
            --Force reprocess to happen later  
            IsInitialized = 0,  
            --Update audit trail  
            LastChgDTM = GETDATE(),  
            LastChgUserID = @User_ID  
    --When a row exists in the source but not the target:  
    WHEN NOT MATCHED BY TARGET  
        --Then INSERT a new row as follows:  
        THEN INSERT  
        (  
            Role_ID, Privilege_ID, AccessPermission,  
            Version_ID, Entity_ID,  
            HierarchyType_ID, ExplicitHierarchy_ID, DerivedHierarchy_ID,   
            [Description],   
            MemberType_ID, Member_ID,  
            EnterUserID, LastChgUserID  
        )  
        VALUES  
        (  
            src.Role_ID, src.Privilege_ID, src.AccessPermission,  
            @TargetVersion_ID, src.Entity_ID,  
            src.HierarchyType_ID, src.ExplicitHierarchy_ID, src.DerivedHierarchy_ID,   
            NULL, --Reset the Description  
            src.MemberType_ID, src.MappedMember_ID,  
            @User_ID, @User_ID  
        )  
    --When a row exists in the target but not the source then:  
    WHEN NOT MATCHED BY SOURCE  
        --If and only if DeleteTarget=T then DELETE the target row  
        AND @DeleteTarget = 1 THEN DELETE  
        --Else leave the target row in place  
    ;  
  
    --Return the number of rows affected	  
    PRINT @@ROWCOUNT;  
      
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpSecurityUserExplicitHierarchy]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
Example  : mdm.[udpSecurityUserExplicitHierarchy](2, 1, 6, 1, , @Privilege_ID OUT) --Returns the default privilege for User ID = 2 and Hierarchy ID = 6  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpSecurityUserExplicitHierarchy]  
(  
    @User_ID            INT,  
    @Hierarchy_ID       INT,  
    @Privilege_ID       INT OUTPUT,  
    @AccessPermission   TINYINT OUTPUT,  
    @CorrelationID      UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
AS  
BEGIN  
    SELECT @Privilege_ID = ssuh.Privilege_ID, @AccessPermission = ssuh.AccessPermission  
    FROM mdm.viw_SYSTEM_SECURITY_USER_HIERARCHY ssuh  
    WHERE ssuh.User_ID = @User_ID  
        AND ssuh.ID = @Hierarchy_ID;  
  
    SET @Privilege_ID = ISNULL(@Privilege_ID, 1 /*Deny*/);  
END
GO
/****** Object:  StoredProcedure [mdm].[udpSecurityUserMemberAttribute]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpSecurityUserMemberAttribute]  
(  
    @User_ID            INT,  
    @Attribute_ID       INT,  
    @Privilege_ID       INT OUTPUT,  
    @AccessPermission   TINYINT OUTPUT,  
    @CorrelationID      UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
AS  
BEGIN  
    SELECT @Privilege_ID = Privilege_ID, @AccessPermission = AccessPermission  
    FROM mdm.viw_SYSTEM_SECURITY_USER_ATTRIBUTE  
    WHERE User_ID = @User_ID AND ID = @Attribute_ID  
  
    SET @Privilege_ID = ISNULL(@Privilege_ID, 1 /*Deny*/);  
END
GO
/****** Object:  StoredProcedure [mdm].[udpSecurityUserMemberDefault]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
Example 1  : SELECT mdm.udfSecurityUserMemberDefault(2, 26, 3, 1) --Returns the default privilege for User ID = 2 and Entity ID = 26 (leaf member)  
Example 2  : SELECT mdm.udfSecurityUserMemberDefault(2, 1020, 4, 1) --Returns the default privilege for User ID = 2 and Attribute ID = 1288 (leaf member)  
Example 3  : SELECT mdm.udfSecurityUserMemberDefault(2, 1, 6, 1) --Returns the default privilege for User ID = 2 and Hierarchy ID = 6  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpSecurityUserMemberDefault]  
(  
    @User_ID INT,  
    @Item_ID INT,  
    @Object_ID INT,  
    @MemberType_ID TINYINT,  
    @Privilege_ID INT OUTPUT,  
    @AccessPermission TINYINT OUTPUT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
AS  
BEGIN  
  
    --consts for the different object types  
    DECLARE @EntityObjectTypeId             INT = 3,  
            @CollectionObjectTypeId         INT = 11,  
            @AttributeObjectTypeId          INT = 4,  
            @ExplicitHierarchyObjectTypeId  INT = 6;  
  
    IF @Object_ID IN (@EntityObjectTypeId, @CollectionObjectTypeId)  
        BEGIN  
        EXEC [mdm].[udpSecurityUserMemberType]  
            @User_ID,  
            @Item_ID,  
            @MemberType_ID,  
            @Privilege_ID OUTPUT,  
            @AccessPermission OUTPUT;  
        END  
    ELSE IF @Object_ID = @AttributeObjectTypeId  
        BEGIN  
        EXEC [mdm].[udpSecurityUserMemberAttribute]  
            @User_ID,  
            @Item_ID,  
            @Privilege_ID OUTPUT,  
            @AccessPermission OUTPUT;  
        END  
    ELSE IF @Object_ID = @ExplicitHierarchyObjectTypeId  
        BEGIN  
        EXEC [mdm].[udpSecurityUserExplicitHierarchy]  
            @User_ID,  
            @Item_ID,  
            @Privilege_ID OUTPUT,  
            @AccessPermission OUTPUT;  
        END  
    ELSE  
        BEGIN  
        SET @Privilege_ID = NULL;  
        SET @AccessPermission = 0;  
        END  
END
GO
/****** Object:  StoredProcedure [mdm].[udpSecurityUserMemberType]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
Example  : mdm.[udpSecurityUserMemberType](2, 1020, 4, 1, @Privilege_ID OUT) --Returns the default privilege for User ID = 2 and Attribute ID = 1288 (leaf member)  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpSecurityUserMemberType]  
(  
    @User_ID INT,  
    @Entity_ID INT,  
    @MemberType_ID TINYINT,  
    @Privilege_ID INT OUTPUT,  
    @AccessPermission TINYINT OUTPUT,  
    @IsAdmin BIT = NULL OUTPUT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
AS  
BEGIN  
    SELECT  
        @Privilege_ID = Privilege_ID,  
        @AccessPermission = AccessPermission,  
        @IsAdmin = IsAdmin  
    FROM mdm.viw_SYSTEM_SECURITY_USER_MEMBERTYPE  
    WHERE User_ID = @User_ID  
        AND Entity_ID = @Entity_ID  
        AND ID = @MemberType_ID  
  
    SET @Privilege_ID = ISNULL(@Privilege_ID, 1 /*Deny*/);  
    SET @AccessPermission = ISNULL(@AccessPermission, NULL /*None*/);  
    SET @IsAdmin = ISNULL(@IsAdmin, 0);  
END
GO
/****** Object:  StoredProcedure [mdm].[udpSecurityUsersGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    Returns the specified users.  
      
    DECLARE @@UserTable mdm.Identifier  
    EXEC udpSecurityUsersGet   
        @@UserTable = @UserTable  
*/  
CREATE PROCEDURE [mdm].[udpSecurityUsersGet]  
(  
    @UserTable mdm.Identifier READONLY,-- caller should ensure table does not include rows where both MUID and Name are blank  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    IF EXISTS(SELECT 1 FROM @UserTable)  
    BEGIN  
        SELECT   
            u.ID,  
            u.MUID,  
            u.SID,  
            u.UserName,  
            u.DisplayName,  
            u.Description,  
            u.EmailAddress,  
            u.LastLoginDTM,  
            COALESCE(u.EnterUserID,0) AS EnterUserID,  
            eu.MUID AS EnterUserMUID,  
            COALESCE(eu.UserName,N'') AS EnterUserName,  
            COALESCE(eu.DisplayName,N'') AS EnterUserDisplayName,  
            u.EnterDTM,  
            COALESCE(u.LastChgUserID,0) AS LastChgUserID,  
            lcu.MUID AS LastChgUserMUID,  
            COALESCE(lcu.UserName,N'') AS LastChgUserName,  
            COALESCE(lcu.DisplayName,N'') AS LastChgUserDisplayName,  
            u.LastChgDTM,  
            pref.PreferenceValue AS EmailType    
        FROM mdm.tblUser u  
        INNER JOIN @UserTable crit  
        ON   
            u.Status_ID <> 2 AND  
            --(crit.MUID IS NOT NULL OR crit.Name IS NOT NULL OR crit.ID IS NOT NULL) AND -- return all when no identifiers are provided. This is inconsistent with udpSecurityGroupsGet??  
            (crit.MUID IS NULL OR crit.MUID = u.MUID) AND  
            (crit.Name IS NULL OR UPPER(crit.Name) = UPPER(u.UserName)) AND  
            (crit.ID IS NULL OR crit.ID = u.ID)  
        LEFT JOIN mdm.tblUser eu   
        ON u.EnterUserID = eu.ID   
        LEFT JOIN mdm.tblUser lcu   
        ON u.LastChgUserID = lcu.ID  
        LEFT JOIN mdm.tblUserPreference pref   
        ON u.ID = pref.User_ID AND   
           PreferenceName='lstEmail'  
        ORDER BY u.ID  
    END ELSE  
    BEGIN  
        SELECT   
            u.ID,  
            u.MUID,  
            u.SID,  
            u.UserName,  
            u.DisplayName,  
            u.Description,  
            u.EmailAddress,  
            u.LastLoginDTM,  
            COALESCE(u.EnterUserID,0) AS EnterUserID,  
            eu.MUID AS EnterUserMUID,  
            COALESCE(eu.UserName,N'') AS EnterUserName,  
            COALESCE(eu.DisplayName,N'') AS EnterUserDisplayName,  
            u.EnterDTM,  
            COALESCE(u.LastChgUserID,0) AS LastChgUserID,  
            lcu.MUID AS LastChgUserMUID,  
            COALESCE(lcu.UserName,N'') AS LastChgUserName,  
            COALESCE(lcu.DisplayName,N'') AS LastChgUserDisplayName,  
            u.LastChgDTM,  
            pref.PreferenceValue AS EmailType    
        FROM mdm.tblUser u  
        LEFT JOIN mdm.tblUser eu   
        ON u.EnterUserID = eu.ID   
        LEFT JOIN mdm.tblUser lcu   
        ON u.LastChgUserID = lcu.ID  
        LEFT JOIN mdm.tblUserPreference pref   
        ON u.ID = pref.User_ID AND   
           PreferenceName='lstEmail'  
        WHERE u.Status_ID <> 2  
        ORDER BY u.ID  
    END  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpStagingBatchQueueActivate]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
	--Run this the first time to kick off the timer  
	DECLARE @handle UNIQUEIDENTIFIER;  
	BEGIN DIALOG CONVERSATION @handle   
		FROM SERVICE [microsoft/mdm/service/stagingbatch]  
		TO SERVICE N'microsoft/mdm/service/system'  
		WITH ENCRYPTION = OFF;  
	BEGIN CONVERSATION TIMER (@handle) TIMEOUT = 1;  
	  
	ALTER QUEUE mdm.[microsoft/mdm/queue/stagingbatch] WITH ACTIVATION (STATUS = ON, PROCEDURE_NAME = mdm.udpStagingBatchQueueActivate, MAX_QUEUE_READERS = 1, EXECUTE AS CALLER);  
			  
	SELECT * FROM mdm.[microsoft/mdm/queue/stagingbatch];  
	  
	UPDATE mdm.tblSystemSetting SET SettingValue = 60 WHERE SettingName = N'StagingBatchInterval';  
*/  
CREATE PROCEDURE [mdm].[udpStagingBatchQueueActivate]  
/*WITH*/  
AS BEGIN  
	SET NOCOUNT ON;  
  
	DECLARE			  
		 @message_type_name	sysname  
		,@handle			UNIQUEIDENTIFIER  
		,@interval			INT  
		,@need_new			BIT  
		,@status			NVARCHAR(1000)  
		,@dialog			UNIQUEIDENTIFIER  
		,@User_ID			INT  
		,@Batch_ID			INT  
		,@Version_ID		INT;  
		  
	--Initialize variables  
	SELECT @handle = NULL, @need_new = NULL;   
	  
	--Load interval setting from config, and check the defaults and ranges  
	SELECT @interval = CAST(SettingValue AS INT) FROM mdm.tblSystemSetting WHERE SettingName = CAST(N'StagingBatchInterval' AS NVARCHAR(100));  
	IF @interval IS NULL SET @interval = 120; --Protect against NULL values  
	ELSE IF @interval < 10 SET @interval = 10; --Prevent negative and 'real-time' settings  
	ELSE IF @interval > 86400 SET @interval = 86400; --Check at least once per day (60 x 60 x 24)  
	  
	BEGIN TRANSACTION   
  
	WAITFOR (  
		RECEIVE TOP(1)  
			@handle = [conversation_handle],  
			@message_type_name = message_type_name  
		FROM mdm.[microsoft/mdm/queue/stagingbatch]		  
	), TIMEOUT 5000; --Always wait a constant time for any new messages  
			  
	--Got a TIMER message  
	IF (@message_type_name = CAST(N'http://schemas.microsoft.com/SQL/ServiceBroker/DialogTimer' AS NVARCHAR(128))) BEGIN  
  
		--Start a new TIMER and COMMIT the transaction before we do the real work, to avoid poisoning  
		BEGIN CONVERSATION TIMER (@handle) TIMEOUT = @interval;  
		COMMIT TRANSACTION;  
			  
		EXEC mdm.udpStagingProcessAllReadyToRun;  
  
	--Got an END DIALOG message  
	END ELSE IF (@message_type_name = CAST(N'http://schemas.microsoft.com/SQL/ServiceBroker/EndDialog' AS NVARCHAR(128))) BEGIN  
		SET @need_new = 1;  
  
	--Got ERROR message  
	END ELSE IF (@message_type_name = CAST(N'http://schemas.microsoft.com/SQL/ServiceBroker/Error' AS NVARCHAR(128))) BEGIN  
		PRINT N'Error in udpStagingBatchQueueActivate error';  
		SET @need_new = 1;  
  
	--Timeout or unexpected message  
	END ELSE BEGIN   
		  
		COMMIT TRANSACTION;  
		  
	END; --if  
	  
	IF (@need_new = 1) BEGIN  
	  
		END CONVERSATION @handle;  
		  
		--DECLARE @handle UNIQUEIDENTIFIER; DECLARE @interval INT; SET @interval = 10;  
		BEGIN DIALOG CONVERSATION @handle  
			FROM SERVICE [microsoft/mdm/service/stagingbatch]  
			TO SERVICE N'microsoft/mdm/service/system'  
			WITH ENCRYPTION = OFF;  
		BEGIN CONVERSATION TIMER (@handle) TIMEOUT = @interval;  
  
		COMMIT TRANSACTION;  
					  
	END; --if  
  
	SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpStagingBatchSave]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
--Status's   
All = 0,  
QueuedToRun = 1,  
NotRunning =2,  
Running=3,  
QueuedToClear=4,  
Cleared=5  
  
--truncate table mdm.tblStgBatch  
--create  
declare @return_id int  
exec mdm.udpStagingBatchSave 1, 1,null, 'Batch1', NULL, 1,null,null,null, @return_id output  
SELECT * FROM mdm.tblStgBatch  
  
--update the name  
exec mdm.udpStagingBatchSave 1, @return_id,null, 'Batch1-1', null,1,null,null,null, @return_id output  
SELECT * FROM mdm.tblStgBatch  
  
--update the status and set to running  
exec mdm.udpStagingBatchSave 1, @return_id,null, 'Batch1-1', null,2,null,null,null, @return_id output  
SELECT * FROM mdm.tblStgBatch  
  
--update the status and set to finished and update counts  
exec mdm.udpStagingBatchSave 1, @return_id,null, 'Batch1-1', null,3,100,1000,200, @return_id output  
SELECT * FROM mdm.tblStgBatch  
  
--Create new one and link to other batch  
exec mdm.udpStagingBatchSave 1, NULL,@return_id, 'Batch1-1-part2', '1', 1, @return_id output  
SELECT * FROM mdm.tblStgBatch  
*/  
  
CREATE PROCEDURE [mdm].[udpStagingBatchSave]  
(  
    @UserID							INT,   
    @VersionID						INT = NULL, -- BatchID or VersionID are required (but both are never required),   
    @BatchID						INT = NULL,   
    @OriginalBatchID				INT = NULL,  
    @Name							NVARCHAR(50) = NULL,   
    @ExternalSystemID				INT = NULL, 	  
    @StatusID						TINYINT,  
    @BatchTag						NVARCHAR(60) = NULL,   
    @EntityID						INT = NULL,  
    @MemberTypeID					TINYINT = NULL,  
    @TotalMemberCount				INT = NULL,  
    @TotalMemberAttributeCount		INT = NULL,  
    @TotalMemberRelationshipCount	INT = NULL,  
    @ErrorMemberCount				INT = NULL,  
    @ErrorMemberAttributeCount		INT = NULL,  
    @ErrorMemberRelationshipCount	INT = NULL,  
    @ReturnID						INT = NULL OUTPUT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
  
    SET NOCOUNT ON  
      
    --Batch or Version are required	  
    IF @VersionID IS NULL AND @BatchID IS NULL BEGIN  
        RAISERROR('MDSERR310050|Specify either a batch ID or a version ID.', 16, 1);  
        RETURN;  
    END;  
      
    IF @BatchID IS NOT NULL BEGIN  
        UPDATE	  
            mdm.tblStgBatch  
        SET		  
            [Name] = ISNULL(@Name,[Name]),  
            ExternalSystem_ID = ISNULL(@ExternalSystemID,ExternalSystem_ID),  
            OriginalBatch_ID = ISNULL(@OriginalBatchID,OriginalBatch_ID),  
            Status_ID = ISNULL(@StatusID,Status_ID),  
            BatchTag = ISNULL(LTRIM(RTRIM(@BatchTag)),BatchTag),  
            Entity_ID = ISNULL(@EntityID,Entity_ID),  
            MemberType_ID = ISNULL(@MemberTypeID,MemberType_ID),  
            LastRunStartUserID = CASE WHEN @StatusID = 2 THEN @UserID ELSE LastRunStartUserID end,  
            LastRunStartDTM = CASE WHEN @StatusID = 2 THEN GETUTCDATE() ELSE LastRunStartDTM end,  
            LastRunEndUserID = CASE WHEN @StatusID IN (3,4) THEN @UserID ELSE LastRunEndUserID end,  
            LastRunEndDTM = CASE WHEN @StatusID IN (3,4) THEN GETUTCDATE() ELSE LastRunEndDTM end,  
            TotalMemberCount = ISNULL(@TotalMemberCount,TotalMemberCount),  
            TotalMemberAttributeCount = ISNULL(@TotalMemberAttributeCount,TotalMemberAttributeCount),  
            TotalMemberRelationshipCount = ISNULL(@TotalMemberRelationshipCount,TotalMemberRelationshipCount),  
            ErrorMemberCount = ISNULL(@ErrorMemberCount,ErrorMemberCount),  
            ErrorMemberAttributeCount = ISNULL(@ErrorMemberAttributeCount,ErrorMemberAttributeCount),  
            ErrorMemberRelationshipCount = ISNULL(@ErrorMemberRelationshipCount,ErrorMemberRelationshipCount)  
        WHERE	  
            ID = @BatchID  
  
        SELECT @ReturnID = @BatchID  
          
        IF @StatusID = 4 BEGIN -- In case when the status is set to "QueuedToClear"  
            -- Clear error detail table records.  
            DELETE FROM mdm.tblStgErrorDetail WHERE Batch_ID = @BatchID;  
        END; -- IF	  
          
    END  
  
    ELSE BEGIN  
        INSERT INTO mdm.tblStgBatch   
        (OriginalBatch_ID  
        ,MUID  
        ,Version_ID  
        ,ExternalSystem_ID  
        ,[Name]  
        ,Status_ID  
        ,BatchTag  
        ,Entity_ID  
        ,MemberType_ID  
        ,TotalMemberCount  
        ,ErrorMemberCount  
        ,TotalMemberAttributeCount  
        ,ErrorMemberAttributeCount  
        ,TotalMemberRelationshipCount  
        ,ErrorMemberRelationshipCount  
        ,LastRunStartDTM  
        ,LastRunStartUserID  
        ,LastRunEndDTM  
        ,LastRunEndUserID  
        ,LastClearedDTM  
        ,LastClearedUserID  
        ,EnterDTM  
        ,EnterUserID)  
        SELECT	  
            @OriginalBatchID,  
            NEWID(),  
            @VersionID,  
            @ExternalSystemID, 			  
            @Name, 		  
            @StatusID,  
            LTRIM(RTRIM(@BatchTag)),  
            @EntityID,  
            @MemberTypeID,  
            NULL,  
            NULL,  
            NULL,  
            NULL,  
            NULL,   
            NULL,  
            NULL,  
            NULL,  
            NULL,  
            NULL,   
            NULL,  
            NULL,  
            GETUTCDATE(),   
            @UserID  
  
        SELECT @ReturnID = SCOPE_IDENTITY()  
          
    END -- IF	  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpStagingProcessAllReadyToRun]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
  
-- =============================================  
-- Author:        <John M. Hall (johnhall)>  
-- Create date: <10-21-09>  
-- Description:    <Process All Ready To Run Batches>  
-- =============================================  
CREATE PROCEDURE [mdm].[udpStagingProcessAllReadyToRun]  
(  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
AS  
BEGIN  
    SET NOCOUNT ON;  
    /* WARNING --- YOU CANNOT INTRODUCE A TRY .. CATCH HERE WITHOUT   
     * SIGNIFICANTLY CHANGING THE BEHAVIOR OF UNDERLYING SPROCS. Contact [johnhall] with questions. */  
       
    DECLARE                
     @User_ID               INT    
    ,@Batch_ID              INT    
    ,@LogFlag               INT = NULL  
    ,@Version_ID            INT  
    ,@BatchTag              NVARCHAR(50)  
    ,@MemberType_ID         TINYINT  
    ,@Entity_ID             INT  
    ,@LeafSproc             SYSNAME  
    ,@ConsolidatedSproc     SYSNAME  
    ,@RelationshipSproc     SYSNAME  
    ,@LeafTable             SYSNAME  
    ,@ConsolidatedTable     SYSNAME  
    ,@RelationshipTable     SYSNAME  
    ,@SQL                   NVARCHAR(MAX)  
    ,@VersionName           NVARCHAR(50)  
  
  
    DECLARE  
        @QueuedToRun                TINYINT = 1,  
        @NotRunning                 TINYINT = 2,             
        @Running                    TINYINT = 3,  
        @QueueToClear               TINYINT = 4,  
        @Cleared                    TINYINT = 5,  
        @AllExceptCleared           TINYINT = 6,  
        @Completed                  TINYINT = 7  
  
    IF EXISTS(SELECT 1 FROM mdm.tblStgBatch WHERE Status_ID = 1)   
    BEGIN    
        -- @LogFlag is OnOff list box which value is On 1, Off 2.  
        SELECT  @LogFlag = CONVERT(INT, SettingValue) FROM mdm.tblSystemSetting WHERE SettingName = 'StagingTransactionLogging';  
        SELECT @LogFlag = CASE @LogFlag WHEN 1 THEN 1 ELSE 0 END;  
          
        WHILE EXISTS(SELECT 1 FROM mdm.tblStgBatch WHERE Status_ID = @QueuedToRun)   
        BEGIN    
   
            SELECT TOP 1    
                @User_ID = EnterUserID,    
                @Batch_ID = ID,    
                @Version_ID = Version_ID,  
                @BatchTag = BatchTag,  
                @MemberType_ID = MemberType_ID,  
                @Entity_ID = Entity_ID     
            FROM mdm.tblStgBatch WHERE Status_ID = @QueuedToRun;  
                
            SELECT            
                @LeafSproc = N'[stg].' + QUOTENAME(N'udp_' + StagingBase + N'_Leaf'),  
                @ConsolidatedSproc = N'[stg].' + QUOTENAME(N'udp_' + StagingBase + N'_Consolidated'),  
                @RelationshipSproc = N'[stg].' + QUOTENAME(N'udp_' + StagingBase + N'_Relationship'),    
                @LeafTable = N'[stg].' + QUOTENAME(StagingBase + N'_Leaf'),     
                @ConsolidatedTable = N'[stg].' + QUOTENAME(StagingBase + N'_Consolidated'),                        
                @RelationshipTable = N'[stg].' + QUOTENAME(StagingBase + N'_Relationship')     
            FROM mdm.tblEntity WHERE ID = @Entity_ID;  
                    
            SELECT   
                @VersionName = [Name]  
            FROM mdm.tblModelVersion WHERE ID = @Version_ID  
                                                          
            --Process EBS  
  
            --Update last run DTM and last run start user ID for the batch      
            UPDATE mdm.tblStgBatch SET LastRunStartDTM=GETUTCDATE(),LastRunStartUserID=@User_ID WHERE ID = @Batch_ID;      
  
            IF @MemberType_ID = 1 -- Leaf  
            BEGIN   
                EXEC @LeafSproc @VersionName = @VersionName, @LogFlag = @LogFlag, @BatchTag = @BatchTag, @User_ID = @User_ID  
            END; --IF  
                
            IF @MemberType_ID = 2 -- Consolidated  
            BEGIN   
                EXEC @ConsolidatedSproc @VersionName = @VersionName, @LogFlag = @LogFlag, @BatchTag = @BatchTag, @User_ID = @User_ID  
            END; --IF  
                
            IF @MemberType_ID = 4 -- Relationship  
            BEGIN   
                EXEC @RelationshipSproc @VersionName = @VersionName, @LogFlag = @LogFlag, @BatchTag = @BatchTag, @User_ID = @User_ID  
            END; --IF                  
                              
            --Update the Status for the batch    
            UPDATE mdm.tblStgBatch   
            SET     
                Status_ID = @Completed,    
                LastRunEndDTM=GETUTCDATE(),    
                LastRunEndUserID=@User_ID  
            WHERE     
                ID = @Batch_ID;    
        END; --while           
    END; --if    
        
    --Checked for Batches that need to be cleared            
    IF EXISTS(SELECT 1 FROM mdm.tblStgBatch WHERE Status_ID = @QueueToClear)   
    BEGIN                      
        WHILE EXISTS(SELECT 1 FROM mdm.tblStgBatch WHERE Status_ID = @QueueToClear)   
        BEGIN    
            SELECT TOP 1    
                @User_ID = EnterUserID,    
                @Batch_ID = ID,  
                @BatchTag = BatchTag,  
                @MemberType_ID = MemberType_ID,  
                @Entity_ID = Entity_ID     
            FROM mdm.tblStgBatch WHERE Status_ID = @QueueToClear;  
                  
            SELECT            
                @LeafTable = N'[stg].' + QUOTENAME(StagingBase + N'_Leaf'),     
                @ConsolidatedTable = N'[stg].' + QUOTENAME(StagingBase + N'_Consolidated'),                        
                @RelationshipTable = N'[stg].' + QUOTENAME(StagingBase + N'_Relationship')     
            FROM       
                mdm.tblEntity WHERE ID = @Entity_ID;    
                                                                        
            --Clear the batch records from the EBS staging tables.    
                  
            IF @MemberType_ID = 1 -- Leaf  
            BEGIN   
                -- Delete records for the batch ID from leaf staging table.  
                SET @SQL = N'DELETE FROM ' + @LeafTable + N' WHERE Batch_ID = @Batch_ID';  
                EXEC sp_executesql @SQL, N'@Batch_ID int', @Batch_ID;                                                                        
            END; --IF  
                
            IF @MemberType_ID = 2 -- Consolidated  
            BEGIN   
                -- Delete records for the batch ID from Consolidated staging table.  
                SET @SQL = N'DELETE FROM ' + @ConsolidatedTable + N' WHERE Batch_ID = @Batch_ID';  
                EXEC sp_executesql @SQL, N'@Batch_ID int', @Batch_ID;                                    
            END; --IF  
                
            IF @MemberType_ID = 4 -- Relationship  
            BEGIN   
                -- Delete records for the batch ID from Relationship staging table.  
                SET @SQL = N'DELETE FROM ' + @RelationshipTable + N' WHERE Batch_ID = @Batch_ID';  
                EXEC sp_executesql @SQL, N'@Batch_ID int', @Batch_ID;  
            END; --IF        
              
            --Update the Status for the batch    
            UPDATE mdm.tblStgBatch   
            SET     
                Status_ID = @Cleared,    
                LastClearedDTM=GETUTCDATE(),    
                LastClearedUserID=@User_ID    
            WHERE     
                ID = @Batch_ID;          
        END; --while          
    END; --if    
  
END -- Proc
GO
/****** Object:  StoredProcedure [mdm].[udpSubscriptionViewCheck]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpSubscriptionViewCheck]  
(  
  
    @SubscriptionView_ID INT = NULL,  
    @Entity_ID  INT = NULL,  
    @Model_ID   INT = NULL,  
    @DerivedHierarchy_ID    INT = NULL,  
    @ModelVersion_ID    INT = NULL,  
    @ModelVersionFlag_ID    INT = NULL,  
    @ViewFormat_ID  INT = NULL,  
    @Levels INT = NULL,  
    @SubscriptionViewName	sysname = NULL,  
    @Return_ID				INT OUTPUT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE @Count INT = 0,  
            @SQL NVARCHAR(MAX),  
            @WhereCriteria NVARCHAR(MAX) = N'',  
            @AndReplace NVARCHAR(17) = N' @AndPlaceHolder ';  
              
    --Build the WHERE clause  
    IF (@SubscriptionView_ID IS NOT NULL)  
    BEGIN  
        SET @WhereCriteria += @AndReplace + N' ID = @SubscriptionView_ID';  
    END  
  
    IF (@Model_ID IS NOT NULL)  
    BEGIN  
        SET @WhereCriteria += @AndReplace + N' Model_ID = @Model_ID';  
    END  
  
    IF (@Entity_ID IS NOT NULL)  
    BEGIN  
        SET @WhereCriteria += @AndReplace + N' Entity_ID = @Entity_ID';  
    END  
  
    IF (@DerivedHierarchy_ID IS NOT NULL)  
    BEGIN  
        SET @WhereCriteria += @AndReplace + N' DerivedHierarchy_ID = @DerivedHierarchy_ID';  
    END  
              
    IF (@ViewFormat_ID IS NOT NULL)  
    BEGIN  
        SET @WhereCriteria += @AndReplace + N' ViewFormat_ID = @ViewFormat_ID';  
    END  
  
    IF (@ModelVersion_ID IS NOT NULL)  
    BEGIN  
        SET @WhereCriteria += @AndReplace + N' ModelVersion_ID = @ModelVersion_ID';  
    END  
          
    IF (@ModelVersionFlag_ID IS NOT NULL)  
    BEGIN  
        SET @WhereCriteria += @AndReplace + N' ModelVersionFlag_ID = @ModelVersionFlag_ID';  
    END  
          
    IF (@SubscriptionViewName IS NOT NULL)  
    BEGIN  
        SET @WhereCriteria += @AndReplace + N' Name = @SubscriptionViewName';  
    END  
                  
    IF (@Levels IS NOT NULL)  
    BEGIN  
        SET @WhereCriteria += @AndReplace + N' Levels = @Levels';  
    END  
  
    /*Now clean up the @MDMPlaceHolders.  First one becomes WHERE the rest are ANDS */  
    IF LEN(@WhereCriteria) <> 0  
    BEGIN  
        DECLARE @Parameters NVARCHAR(MAX) =    
          N'@SubscriptionView_ID INT,  
            @Model_ID INT,  
            @Entity_ID INT,  
            @DerivedHierarchy_ID INT,  
            @ViewFormat_ID INT,  
            @ModelVersion_ID INT,  
            @ModelVersionFlag_ID INT,  
            @SubscriptionViewName sysname,  
            @Levels INT';  
        DECLARE @GetCountParameters NVARCHAR(MAX) = @Parameters + N',  
           @Count INT OUTPUT';  
        SET @WhereCriteria  = N'WHERE ' + SUBSTRING(@WhereCriteria, LEN(@AndReplace)+1, LEN(@WhereCriteria)-LEN(@AndReplace));  
        SET @WhereCriteria  = REPLACE(@WhereCriteria, @AndReplace, N' AND ');  
      
        /* Execute the search if we have a where clause */  
        SET @SQL = N'SELECT	@Count = COUNT(S.ID)  
                FROM mdm.tblSubscriptionView S ' + @WhereCriteria;  
      
        EXEC sp_executesql @SQL, @GetCountParameters,   
            @SubscriptionView_ID, @Model_ID, @Entity_ID, @DerivedHierarchy_ID, @ViewFormat_ID, @ModelVersion_ID, @ModelVersionFlag_ID, @SubscriptionViewName, @Levels, @Count OUTPUT;  
    END  
  
       
    SELECT @Return_ID = @Count;  
          
--    SELECT @Count;  
          
    SET NOCOUNT OFF;  
END;
GO
/****** Object:  StoredProcedure [mdm].[udpSubscriptionViewDeleteByID]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    EXEC mdm.udpSubscriptionViewDeleteByID 1, 0;  
*/  
CREATE PROCEDURE [mdm].[udpSubscriptionViewDeleteByID]  
(  
    @ID	INT,  
    @DeleteView bit = 0,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    ----Test for invalid parameters  
    IF (@ID IS NOT NULL AND NOT EXISTS(SELECT 1 FROM mdm.tblSubscriptionView  WHERE ID = @ID)   
        OR @ID IS NULL ) --Invalid ID  
    BEGIN  
        RAISERROR('MDSERR100010|The Parameters are not valid.', 16, 1);  
        RETURN(1);  
    END; --if  
  
    --Start transaction, being careful to check if we are nested  
    DECLARE @TranCounter INT;   
    SET @TranCounter = @@TRANCOUNT;  
    IF @TranCounter > 0 SAVE TRANSACTION TX;  
    ELSE BEGIN TRANSACTION;  
  
    BEGIN TRY  
          
        DECLARE @ViewName sysname,  
                @SQL	  NVARCHAR(MAX)  
                  
        -- Get the name of the view  
        SELECT @ViewName = V.[Name]  
        FROM mdm.tblSubscriptionView V  
        WHERE V.ID = @ID  
          
        SET @SQL = CAST('' AS NVARCHAR(max));  
  
        IF (@ViewName IS NOT NULL)  
         BEGIN  
            SET @SQL =  N'IF EXISTS(SELECT 1 FROM sys.views WHERE [name] = N' + QUOTENAME(@ViewName, N'''') + N' AND [schema_id] = SCHEMA_ID(''mdm''))   
                DROP VIEW mdm.' + QUOTENAME(@ViewName) + N';';  
              
            --PRINT(@SQL);  
            EXEC sp_executesql @SQL;  
  
        END; --while  
  
        -- Delete view if flag set true  
        IF (@DeleteView = 1)  
            DELETE FROM mdm.tblSubscriptionView  WHERE ID = @ID;  
                  
        --Commit only if we are not nested  
        IF @TranCounter = 0 COMMIT TRANSACTION;  
        RETURN(0);  
  
    END TRY  
    --Compensate as necessary  
    BEGIN CATCH  
  
        -- Get error info.  
        DECLARE  
            @ErrorMessage NVARCHAR(4000),  
            @ErrorSeverity INT,  
            @ErrorState INT,  
            @ErrorNumber INT,  
            @ErrorLine INT,  
            @ErrorProcedure NVARCHAR(126);  
        EXEC mdm.udpGetErrorInfo  
            @ErrorMessage = @ErrorMessage OUTPUT,  
            @ErrorSeverity = @ErrorSeverity OUTPUT,  
            @ErrorState = @ErrorState OUTPUT,  
            @ErrorNumber = @ErrorNumber OUTPUT,  
            @ErrorLine = @ErrorLine OUTPUT,  
            @ErrorProcedure = @ErrorProcedure OUTPUT  
  
        SET @ErrorMessage = CONCAT(@ErrorMessage, N', @ErrorNumber = ', @ErrorNumber, N', @ErrorProcedure = "', @ErrorProcedure, N'", line ', @ErrorLine);  
  
        IF @TranCounter = 0 ROLLBACK TRANSACTION;  
        ELSE IF XACT_STATE() <> -1 ROLLBACK TRANSACTION TX;  
  
        RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);  
  
        RETURN(1);  
  
    END CATCH;  
    SET NOCOUNT OFF;  
END;
GO
/****** Object:  StoredProcedure [mdm].[udpSubscriptionViewGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
select * from mdm.tblSubscriptionView  
EXEC [mdm].[udpSubscriptionViewGet] @User_ID = 1  
*/  
  
CREATE PROCEDURE [mdm].[udpSubscriptionViewGet]  
(  
    @User_ID        INT,  
    @CorrelationID  UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    SET @User_ID = NULLIF(@User_ID, 0);  
  
    SELECT  
        S.ID                AS View_ID  
        ,S.MUID             AS View_Muid  
        ,S.Name             AS View_Name  
        ,S.Levels           AS View_Levels  
        ,S.ViewFormat_ID    AS View_Format  
        ,S.IncludeSoftDeletedMembers    AS View_IncludeSoftDeletedMembers  
        ,M.ID               AS Model_ID  
        ,M.MUID             AS Model_Muid  
        ,M.Name             AS Model_Name  
        ,E.ID               AS [Entity_ID]  
        ,E.MUID             AS Entity_Muid  
        ,E.Name             AS [Entity_Name]  
        ,MV.ID              AS Version_ID  
        ,MV.MUID            AS Version_Muid  
        ,MV.Name            AS Version_Name  
        ,D.ID               AS DerivedHierarchy_ID  
        ,D.MUID             AS DerivedHierarchy_Muid  
        ,D.Name             AS DerivedHierarchy_Name  
        ,S.[Description]    AS [Description]  
        ,UE.DisplayName     AS CreatedBy  
        ,S.EnterDTM         AS DateCreated  
        ,UC.DisplayName     AS UpdatedBy  
        ,S.LastChgDTM       AS DateUpdated  
  
        ,MVF.ID             AS VersionFlag_ID  
        ,MVF.MUID           AS VersionFlag_Muid  
        ,MVF.Name           AS VersionFlag_Name  
    FROM mdm.tblSubscriptionView S  
        INNER JOIN mdm.tblModel M ON S.Model_ID = M.ID  
        LEFT JOIN mdm.viw_SYSTEM_SECURITY_USER_MODEL SSUM ON S.Model_ID = SSUM.ID AND SSUM.[User_ID] = @User_ID  
        LEFT OUTER JOIN mdm.tblEntity E ON S.[Entity_ID] = E.ID  
        LEFT JOIN mdm.tblModelVersion MV ON S.ModelVersion_ID = MV.ID  
        LEFT OUTER JOIN mdm.tblModelVersionFlag MVF ON S.ModelVersionFlag_ID = MVF.ID  
        LEFT OUTER JOIN mdm.tblDerivedHierarchy D ON S.DerivedHierarchy_ID = D.ID  
        LEFT OUTER JOIN mdm.tblUser UE ON S.EnterUserID = UE.ID  
        LEFT OUTER JOIN mdm.tblUser UC ON S.LastChgUserID = UC.ID  
    WHERE @User_ID IS NULL OR SSUM.Privilege_ID = 5 /*Admin*/  
  
    SET NOCOUNT OFF;  
END;
GO
/****** Object:  StoredProcedure [mdm].[udpSubscriptionViewSave]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
EXEC mdm.udpSubscriptionViewSave  
    @SubscriptionView_ID        =  NULL,  
    @Entity_ID                  = 9999999,  
    @Model_ID                   = 9999999,  
    @DerivedHierarchy_ID        = 9999999,  
    @ModelVersion_ID            = 9999999,  
    @ModelVersionFlag_ID        = 9999999,  
    @ViewFormat_ID              = 10,  
    @Levels                     = 1,  
    @SubscriptionViewName       = ''  
    @Description                = 'blah blah',  
    @IncludeSoftDeletedMembers  = 1  
  
  
*/  
CREATE PROCEDURE [mdm].[udpSubscriptionViewSave]  
(  
    @User_ID                    INT,  
    @SubscriptionView_ID        INT = NULL,  
    @Entity_ID                  INT,  
    @Model_ID                   INT,  
    @DerivedHierarchy_ID        INT = NULL,  
    @ModelVersion_ID            INT,  
    @ModelVersionFlag_ID        INT = NULL,  
    @ViewFormat_ID              INT,  
    @Levels                     SMALLINT,  
    @IncludeSoftDeletedMembers  BIT,  
    @SubscriptionViewName       SYSNAME,  
    @Description                NVARCHAR(500) = NULL,  
    @Return_ID                  INT = NULL OUTPUT,  
    @Return_MUID                UNIQUEIDENTIFIER = NULL OUTPUT, --Also an input parameter for clone operations  
    @CorrelationID              UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE @e AS NVARCHAR(200),  
            @MaxLevels INT,  
            @CurrentDTM DATETIME2(3),  
            @IsValidParam INT,  
            @MaxViewFormatID INT = 14;  
  
    --Initialize output parameters and local variables  
    SELECT     @Return_ID = NULL,  
            @Description = NULLIF(LTRIM(RTRIM(@Description)), N''),  
            @CurrentDTM =  GETUTCDATE(),  
            @MaxLevels = 0,  
            @ModelVersion_ID = NULLIF(@ModelVersion_ID, 0),  
            @ModelVersionFlag_ID = NULLIF(@ModelVersionFlag_ID, 0);  
  
  
  
    --Test for invalid parameters  
    SET @IsValidParam = 1;  
  
    --Validate Model_ID  
    EXECUTE @IsValidParam  = mdm.udpIDParameterCheck @Model_ID, 1,NULL,NULL,1  
    IF (@IsValidParam = 0)  
    BEGIN  
        RAISERROR('MDSERR100011|The Model ID is not valid.', 16, 1);  
        RETURN;  
    END;  
  
    --Validate ViewFormat_ID  
    EXECUTE @IsValidParam  = mdm.udpIDParameterCheck @ViewFormat_ID, NULL, 1, @MaxViewFormatID,1  
    IF (@IsValidParam = 0)  
    BEGIN  
        RAISERROR('MDSERR100014|The View Format ID is not valid.', 16, 1);  
        RETURN;  
    END;  
  
    --Must enter @SubscriptionViewName  
    IF  (@SubscriptionViewName IS NULL OR LEN(@SubscriptionViewName) = 0 )  
    BEGIN  
        RAISERROR('MDSERR100021|A subscription view name is required.', 16, 1);  
        RETURN;  
    END;  
  
    --Check for duplicate subscription view name  
    IF (EXISTS (SELECT [Name] FROM mdm.tblSubscriptionView WHERE [Name] = @SubscriptionViewName AND (@SubscriptionView_ID IS NULL OR ID <> @SubscriptionView_ID)))  
    BEGIN  
        RAISERROR('MDSERR100015|The subscription view name already exists.', 16, 1);  
        RETURN;  
    END;  
  
    --Check for subscription view length  
    IF LEN(@SubscriptionViewName) > 128  
    BEGIN  
        RAISERROR('MDSERR100016|The subscription view name must be fewer than 128 characters.', 16, 1);  
        RETURN;  
    END;  
  
    --Business rule checks:  
    --  View can be for either an Entity or Derived Hierarchy  
    IF ((@Entity_ID IS NULL OR @Entity_ID = 0 ) AND (@DerivedHierarchy_ID IS NULL OR @DerivedHierarchy_ID = 0)) OR  
       (@Entity_ID IS NOT NULL AND @DerivedHierarchy_ID IS NOT NULL)  
    BEGIN  
        RAISERROR('MDSERR100017|A subscription view can be generated for either an entity or a derived hierarchy, but not for both.', 16, 1);  
        RETURN;  
    END;  
    ELSE BEGIN  
  
        --Validate @Entity_ID  
        IF (@DerivedHierarchy_ID IS NULL OR @DerivedHierarchy_ID = 0) EXECUTE @IsValidParam = mdm.udpIDParameterCheck @Entity_ID, 5,NULL,NULL,0  
        IF (@IsValidParam = 0)  
        BEGIN  
            RAISERROR('MDSERR100004|The Entity ID is not valid.', 16, 1);  
            RETURN;  
        END;  
  
        --Validate DerivedHierarchy_ID  
        IF (@Entity_ID IS NULL OR @Entity_ID = 0) EXECUTE @IsValidParam  = mdm.udpIDParameterCheck @DerivedHierarchy_ID, 2,NULL,NULL,0  
        IF (@IsValidParam = 0)  
        BEGIN  
            RAISERROR('MDSERR100006|The DerivedHierarchy ID is not valid.', 16, 1);  
            RETURN;  
        END;  
  
    END;  
  
    --Business rule checks:  
    --  View can be based off Version or Version Flag  
    IF (@ModelVersion_ID IS NULL AND @ModelVersionFlag_ID IS NULL) OR  
       (@ModelVersion_ID IS NOT NULL AND @ModelVersionFlag_ID IS NOT NULL)  
    BEGIN  
        RAISERROR('MDSERR100018|A subscription view can be generated for either a version or a version flag, but not for both.', 16, 1);  
        RETURN;  
  
    END;  
    ELSE BEGIN  
        --Validate ModelVersionFlag  
        IF (@ModelVersionFlag_ID IS NULL OR @ModelVersionFlag_ID = 0) EXECUTE @IsValidParam  = mdm.udpIDParameterCheck @ModelVersion_ID, 4,NULL,NULL,0  
        IF (@IsValidParam = 0)  
        BEGIN  
            RAISERROR('MDSERR100013|The Model Version Flag ID is not valid.', 16, 1);  
            RETURN;  
        END;  
  
        --Validate Model Version  
        IF(@ModelVersion_ID IS NULL OR @ModelVersion_ID = 0 ) EXECUTE @IsValidParam  = mdm.udpIDParameterCheck @ModelVersionFlag_ID, 10,NULL,NULL,0  
        IF (@IsValidParam = 0)  
        BEGIN  
            RAISERROR('MDSERR100012|The Model Version ID is not valid.', 16, 1);  
            RETURN;  
        END;  
    END;  
  
  -- Validate level greater than 0 is entered for Entity Levels or Derived Hierarchy Levels views  
   IF ( (@Entity_ID IS NOT NULL AND @ViewFormat_ID = 6 AND @Levels < 0) OR  
        (@DerivedHierarchy_ID IS NOT NULL AND @ViewFormat_ID = 8 AND @Levels < 0 ))  
   BEGIN  
            RAISERROR('MDSERR100019|The levels are not valid for the selected entity or derived hierarchy.', 16, 1);  
            RETURN;  
    END; --if  
  
    --Start transaction, being careful to check if we are nested  
    DECLARE @TranCounter INT;  
    SET @TranCounter = @@TRANCOUNT;  
    IF @TranCounter > 0 SAVE TRANSACTION TX;  
    ELSE BEGIN TRANSACTION;  
  
    BEGIN TRY  
  
        DECLARE @AuditingVersion_ID INT = @ModelVersion_ID;  
        IF (COALESCE(@AuditingVersion_ID, 0) = 0)  
        BEGIN  
            SELECT @AuditingVersion_ID = MAX(ID)  
            FROM mdm.tblModelVersion  
            WHERE Model_ID = @Model_ID;  
        END;  
  
        --Update/Insert SubscriptionView  
        IF (@SubscriptionView_ID IS NOT NULL) BEGIN --Update SubscriptionView  
  
            -- Delete Subscription View  
            EXEC mdm.udpSubscriptionViewDeleteByID @SubscriptionView_ID, 0  
  
            UPDATE mdm.tblSubscriptionView  
                SET Entity_ID = @Entity_ID,  
                    Model_ID = ISNULL(@Model_ID, Model_ID),  
                    DerivedHierarchy_ID = @DerivedHierarchy_ID,  
                    ViewFormat_ID = ISNULL(@ViewFormat_ID, ViewFormat_ID),  
                    ModelVersion_ID = @ModelVersion_ID,  
                    ModelVersionFlag_ID = @ModelVersionFlag_ID,  
                    [Name] = @SubscriptionViewName,  
                    Levels = @Levels,  
                    [Description] = @Description,  
                    [LastChgUserID] = @User_ID,  
                    [LastChgDTM] = @CurrentDTM,  
                    [LastChgVersionID] = @AuditingVersion_ID,  
                    [EnterUserID] = @User_ID,  
                    [EnterDTM] = @CurrentDTM,  
                    [EnterVersionID] = @AuditingVersion_ID,  
                    [IncludeSoftDeletedMembers] = @IncludeSoftDeletedMembers  
            WHERE ID = @SubscriptionView_ID  
  
            --Populate output parameters  
            SELECT @Return_MUID = MUID FROM mdm.tblSubscriptionView WHERE ID = @Entity_ID;  
  
  
        END  
        ELSE BEGIN  -- Insert SubscriptionView  
  
            --Accept an explicit MUID (for clone operations) or generate a new one  
            SET @Return_MUID = ISNULL(@Return_MUID, NEWID());  
  
            INSERT INTO mdm.tblSubscriptionView    (  
                    Entity_ID,  
                    Model_ID,  
                    DerivedHierarchy_ID,  
                    ViewFormat_ID,  
                    ModelVersion_ID,  
                    ModelVersionFlag_ID,  
                    [Name],  
                    Levels,  
                    MUID,  
                    [Description],  
                    [IncludeSoftDeletedMembers],  
                    EnterUserID,  
                    EnterDTM,  
                    EnterVersionID,  
                    LastChgUserID,  
                    LastChgDTM,  
                    LastChgVersionID  
                    )  
            VALUES (  
                    @Entity_ID,  
                    @Model_ID,  
                    @DerivedHierarchy_ID,  
                    @ViewFormat_ID,  
                    @ModelVersion_ID,  
                    @ModelVersionFlag_ID,  
                    @SubscriptionViewName,  
                    @Levels,  
                    @Return_MUID,  
                    @Description,  
                    @IncludeSoftDeletedMembers,  
                    @User_ID,  
                    @CurrentDTM,  
                    @AuditingVersion_ID,  
                    @User_ID,  
                    @CurrentDTM,  
                    @AuditingVersion_ID)  
  
            --Save the identity value  
            SET @SubscriptionView_ID =  SCOPE_IDENTITY();  
        END  
  
  
        --Return values  
        SET @Return_ID = @SubscriptionView_ID;  
  
        -- Regenerate Subscription View  
        EXEC mdm.udpCreateSubscriptionViews @Return_ID, @Entity_ID, @DerivedHierarchy_ID, @ModelVersion_ID,    @ModelVersionFlag_ID, @ViewFormat_ID, @Levels, @SubscriptionViewName, @IncludeSoftDeletedMembers  
  
        --Commit only if we are not nested  
        IF @TranCounter = 0 COMMIT TRANSACTION;  
        RETURN(0);  
  
    END TRY  
    --Compensate as necessary  
    BEGIN CATCH  
  
        -- Get error info.  
        DECLARE  
            @ErrorMessage NVARCHAR(4000),  
            @ErrorSeverity INT,  
            @ErrorState INT,  
            @ErrorNumber INT,  
            @ErrorLine INT,  
            @ErrorProcedure NVARCHAR(126);  
        EXEC mdm.udpGetErrorInfo  
            @ErrorMessage = @ErrorMessage OUTPUT,  
            @ErrorSeverity = @ErrorSeverity OUTPUT,  
            @ErrorState = @ErrorState OUTPUT,  
            @ErrorNumber = @ErrorNumber OUTPUT,  
            @ErrorLine = @ErrorLine OUTPUT,  
            @ErrorProcedure = @ErrorProcedure OUTPUT  
  
        SET @ErrorMessage = CONCAT(@ErrorMessage, N', @ErrorNumber = ', @ErrorNumber, N', @ErrorProcedure = "', @ErrorProcedure, N'", line ', @ErrorLine);  
  
        IF @TranCounter = 0 ROLLBACK TRANSACTION;  
        ELSE IF XACT_STATE() <> -1 ROLLBACK TRANSACTION TX;  
  
        RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);  
  
        SELECT @Return_ID = NULL, @Return_MUID = NULL;  
        RETURN(1);  
  
    END CATCH;  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpSubscriptionViewsDelete]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    Deletes all subscription views that match the given criteria.   
    Parameters that are null or less than 1 are ignored, but at least one   
    of the parameter must have a valid value (i.e. value > 0).   
      
    EXEC mdm.udpSubscriptionViewsDelete 1, 0;  
*/  
CREATE PROCEDURE [mdm].[udpSubscriptionViewsDelete]  
(  
    @Model_ID               INT = NULL,  
    @Version_ID             INT = NULL,  
    @Entity_ID              INT = NULL,  
    @DerivedHierarchy_ID    INT = NULL,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    -- Change invalid input id's to null  
    IF (@Model_ID <= 0)   
    BEGIN  
        SET @Model_ID = NULL;  
    END           
    IF (@Version_ID <= 0)   
    BEGIN  
        SET @Version_ID = NULL;  
    END           
    IF (@Entity_ID <= 0)   
    BEGIN  
        SET @Entity_ID = NULL;  
    END           
    IF (@DerivedHierarchy_ID <= 0)   
    BEGIN  
        SET @DerivedHierarchy_ID = NULL;  
    END   
      
    -- Ensure at least one valid parameter was provided  
    IF (@Model_ID IS NULL AND @Version_ID IS NULL AND @Entity_ID IS NULL AND @DerivedHierarchy_ID IS NULL)  
    BEGIN  
        RAISERROR('MDSERR100010|The Parameters are not valid.', 16, 1);   
        RETURN;  
    END   
      
    -- Get a list of all subscription views that match the given criteria  
    DECLARE @SubscriptionViewIDs mdm.IdList;           
    INSERT INTO @SubscriptionViewIDs (ID)   
    SELECT ID FROM mdm.tblSubscriptionView sv  
    WHERE   
        (@Model_ID IS NULL OR @Model_ID = sv.Model_ID) AND  
        (@Version_ID IS NULL OR @Version_ID = sv.ModelVersion_ID) AND  
        (@Entity_ID IS NULL OR @Entity_ID = sv.Entity_ID) AND  
        (@DerivedHierarchy_ID IS NULL OR @DerivedHierarchy_ID = sv.DerivedHierarchy_ID);  
            
  
    DECLARE @DeleteView BIT = 1; -- constant  
    DECLARE @SubscriptionViewID INT;  
    WHILE EXISTS(SELECT 1 FROM @SubscriptionViewIDs)  
    BEGIN   
        -- Get the next subscription view id  
        SET @SubscriptionViewID = (SELECT TOP 1 ID FROM @SubscriptionViewIDs);  
          
        -- Delete the subscription view  
        EXEC mdm.udpSubscriptionViewDeleteByID @SubscriptionViewID, @DeleteView;  
          
        -- Remove the deleted subscription view from the ID list  
        DELETE FROM @SubscriptionViewIDs WHERE ID = @SubscriptionViewID;  
    END  
          
    SET NOCOUNT OFF;  
END;
GO
/****** Object:  StoredProcedure [mdm].[udpSyncRefresh]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
Syncs the target entity version with its registered source entity version. That is, the target entity version is changed as necessary to make it match the source entity version.   
  
Required user permissions:  
- Sys Admin functional permission  
- Source entity version:  
    -- At least Read permission on the entity and all attributes  
    -- No member permissions (i.e. udfUseMemberSecurity must return 0).  
- Target entity version:   
    -- Model Admin  
    -- Version status must not be Committed.   
  
Possible errors:  
1. The given entity version is not a target in an existing sync relationship.  
2. Conflict in the target entity. E.g. if the source entity has deleted a member that is being referenced as a DBA value in an entity of the target model.   
   In which case, sync will fail until the DBA dependency is removed.  
3. The target version is Committed  
*/  
CREATE PROCEDURE [mdm].[udpSyncRefresh]  
(  
     @User_ID               INT -- Must have admin permission on the target model and Sys Admin functional permission.   
    ,@TargetModel_MUID      UNIQUEIDENTIFIER = NULL  
    ,@TargetModelName       NVARCHAR(50) = NULL  
    ,@TargetModel_ID        INT = NULL -- for internal use only  
    ,@TargetVersion_MUID    UNIQUEIDENTIFIER = NULL -- Sufficient context info must be provided to uniquely identify the target version. If the target version is (or becomes) Committed, the subscription relationship is dormant.  
    ,@TargetVersionName     NVARCHAR(50) = NULL  
    ,@TargetVersion_ID      INT = NULL -- for internal use only  
    ,@TargetEntity_MUID     UNIQUEIDENTIFIER = NULL-- Sufficient context info must be provided to uniquely identify the target entity.  
    ,@TargetEntityName      NVARCHAR(50) = NULL   
    ,@TargetEntity_ID       INT = NULL -- for internal use only  
    ,@CorrelationID         UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS N'mds_schema_user'      
AS  
BEGIN  
    SET NOCOUNT ON;  
  
PRINT CONCAT(SYSDATETIME(), N': Begin udpSyncRefresh')  
    DECLARE   
         @Found_ID    INT  
        ,@TargetVersion_Status_ID       TINYINT  
        ,@TargetEntity_EN_TableName     SYSNAME  
        ,@TargetEntityDataCompression   TINYINT  
        ,@TargetEntityStagingLeafName   SYSNAME  
  
        ,@MemberType_Leaf           TINYINT = 1  
        ,@MemberType_Consolidated   TINYINT = 2  
        ,@MemberType_Collection     TINYINT = 3  
  
        ,@PermissionType_Deny           TINYINT = 1  
        ,@PermissionType_Admin          TINYINT = 5  
  
        ,@FunctionalPrivilege_SysAdmin  TINYINT = 5  
  
        ,@EditMode_Create TINYINT = 0  
        ,@EditMode_Update TINYINT = 1  
  
        ,@VersionStatus_Committed   TINYINT = 3  
  
        ,@AttributeType_Freeform    TINYINT = 1  
        ,@AttributeType_Domain      TINYINT = 2  
        ,@AttributeType_System      TINYINT = 3  
        ,@AttributeType_File        TINYINT = 4  
  
        ,@SyncStatus_InProgress     TINYINT = 1  
        ,@SyncStatus_Success        TINYINT = 2  
        ,@SyncStatus_Failed         TINYINT = 3  
  
        -- Member status  
        ,@Status_Active                 TINYINT = 1  
        ,@Status_Deactivated            TINYINT = 2  
  
        ,@TransactionLogType_None       TINYINT = 3  
          
        ,@ErrorMessage NVARCHAR(4000)  
        ;  
  
    -- Lookup target model ID  
    SET @Found_ID = NULL;  
    DECLARE @TargetModelPrivilege_ID TINYINT  
    EXEC mdm.udpInformationLookupModel @User_ID = @User_ID, @Model_MUID = @TargetModel_MUID, @Model_Name = @TargetModelName, @Model_ID = @TargetModel_ID, @ID = @Found_ID OUTPUT, @Privilege_ID = @TargetModelPrivilege_ID OUTPUT;  
    SET @TargetModel_ID = @Found_ID;  
  
    -- Lookup target version ID. Note: not using udpInformationLookupVersion to avoid needlessly querying the model security view again.  
    SET @Found_ID = NULL;  
    SELECT   
         @Found_ID = ID  
        ,@TargetVersion_Status_ID = Status_ID  
    FROM mdm.tblModelVersion   
    WHERE  
            (@TargetVersion_MUID IS NOT NULL OR @TargetVersionName IS NOT NULL OR @TargetVersion_ID IS NOT NULL)   
        AND (@TargetVersion_MUID IS NULL OR MUID = @TargetVersion_MUID)   
        AND (@TargetVersionName IS NULL OR Name = @TargetVersionName)  
        AND (@TargetVersion_ID IS NULL OR ID = @TargetVersion_ID)  
        AND Model_ID = @TargetModel_ID;  
    SET @TargetVersion_ID = @Found_ID;  
  
    -- Lookup target entity ID. Note: not using udpInformationLookupEntity to avoid needlessly querying the model security view again. If the user isn't a model admin, the sproc would have returned with an error already.  
    SET @Found_ID = NULL;  
    DECLARE @TargetEntitySupportsNonLeafMembers BIT = 0;  
    SELECT   
         @Found_ID = ID  
        ,@TargetEntityName = Name -- needed in case the name is aliased (i.e. is different from source)  
        ,@TargetEntity_EN_TableName = EntityTable  
        ,@TargetEntitySupportsNonLeafMembers = CASE WHEN COALESCE(HierarchyParentTable, CollectionTable) IS NULL THEN 0 ELSE 1 END  
        ,@TargetEntityDataCompression = DataCompression  
        ,@TargetEntityStagingLeafName = StagingLeafName  
    FROM mdm.tblEntity e  
    WHERE  
            (@TargetEntity_MUID IS NOT NULL OR @TargetEntityName IS NOT NULL OR @TargetEntity_ID IS NOT NULL)   
        AND (@TargetEntity_MUID IS NULL OR MUID = @TargetEntity_MUID)   
        AND (@TargetEntityName IS NULL OR Name = @TargetEntityName)  
        AND (@TargetEntity_ID IS NULL OR ID = @TargetEntity_ID)  
        AND Model_ID = @TargetModel_ID;  
    SET @TargetEntity_ID = @Found_ID;  
  
    DECLARE   
         @TargetEntityNameIsAliased     BIT  
        ,@LastSyncTimestamp             VARBINARY(8)  
        ,@LastSyncAttemptStatus         TINYINT  
        ,@SourceEntity_ID               INT  
        ,@SourceEntity_EN_TableName     SYSNAME  
        ,@SourceVersion_ID              INT  
        ,@SourceEntityName              NVARCHAR(50)  
        ,@SourceEntityDescription       NVARCHAR(500)  
        ,@SourceEntityTimestamp         VARBINARY(8)  
        ,@SourceEntityDataCompression   TINYINT  
        ,@SourceEntityIsBase            BIT  
        ;  
  
    SELECT  
         @TargetEntityNameIsAliased = sr.TargetEntityNameIsAliased  
        ,@LastSyncTimestamp         = sr.LastSuccessfulSyncTimestamp  
        ,@LastSyncAttemptStatus     = sr.LastSyncAttemptStatus  
        ,@SourceEntity_ID           = sr.SourceEntity_ID  
        ,@SourceEntity_EN_TableName = se.EntityTable  
        ,@SourceVersion_ID          = sr.SourceVersion_ID  
        ,@SourceEntityName          = se.Name  
        ,@SourceEntityDescription   = se.[Description]  
        ,@SourceEntityTimestamp     = CONVERT(VARBINARY(8), se.LastChgTS)  
        ,@SourceEntityDataCompression   = se.DataCompression  
        ,@SourceEntityIsBase        = se.IsBase  
    FROM mdm.tblSyncRelationship sr  
    INNER JOIN mdm.tblEntity se  
    ON sr.SourceEntity_ID = se.ID  
    WHERE   sr.TargetEntity_ID = @TargetEntity_ID  
        AND sr.TargetVersion_ID = @TargetVersion_ID  
    ;  
  
    DECLARE @IsFirstSyncAttempt BIT = CASE WHEN @LastSyncTimestamp IS NULL THEN 1 ELSE 0 END;  
    DECLARE @NeedToRefreshStagingSproc BIT = @IsFirstSyncAttempt;  
    IF @LastSyncAttemptStatus = @SyncStatus_InProgress  
    BEGIN  
PRINT CONCAT(SYSDATETIME(), N': The target entity version is already being sync''ed. Aborting...')  
        RETURN;  
    END  
  
    -- update the status and timestamp in the sync table  
    UPDATE mdm.tblSyncRelationship  
    SET    
         LastSyncAttemptDTM = GETUTCDATE()  
        ,LastSyncAttemptStatus = @SyncStatus_InProgress  
        ,LastSyncAttemptErrorInfo = NULL  
    WHERE   TargetEntity_ID = @TargetEntity_ID  
        AND TargetVersion_ID = @TargetVersion_ID  
  
    --Start transaction, being careful to check if we are nested  
    DECLARE @TranCounter INT = @@TRANCOUNT;  
    IF @TranCounter > 0 SAVE TRANSACTION TX;  
    ELSE BEGIN TRANSACTION;  
  
    BEGIN TRY -- Note: the TRY block begins near the top of the sproc so that any raised error will be written to the sync relationship table.  
  
        -- Ensure the user has Sys Admin functional permissions (can modify metadata)  
        IF mdm.udfSecurityUserFunctionIsAllowed(@User_ID, @FunctionalPrivilege_SysAdmin) = 0  
        BEGIN   
            RAISERROR('MDSERR120002|The user does not have permission to perform this operation.', 16, 1);  
            RETURN;  
        END  
  
        -- Verify user is model admin  
        IF @TargetModel_ID IS NULL OR COALESCE(@TargetModelPrivilege_ID, @PermissionType_Deny) <> @PermissionType_Admin  
        BEGIN  
            -- Either the model doesn't exist, or the user doesn't have permission to see it.  
            RAISERROR('MDSERR200204|Sync target model ID is not valid or the user does not have sufficient permission.', 16, 1);  
            RETURN;  
        END;  
  
        IF @TargetVersion_ID IS NULL  
        BEGIN  
            RAISERROR('MDSERR200205|Sync target version ID is not valid.', 16, 1);  
            RETURN;  
        END;  
  
        IF @TargetVersion_Status_ID = @VersionStatus_Committed  
        BEGIN  
            RAISERROR('MDSERR200208|Cannot sync to the target entity. The target version is committed.', 16, 1);  
            RETURN;  
        END;  
  
        IF @TargetEntity_ID IS NULL  
        BEGIN  
            RAISERROR('MDSERR200209|Sync target entity ID is not valid.', 16, 1);  
            RETURN;  
        END;  
  
        IF EXISTS (SELECT 1 FROM mdm.tblBRBusinessRule WHERE Entity_ID = @TargetEntity_ID)  
        BEGIN  
            RAISERROR('MDSERR200218|The sync relationship is not valid. A target entity may not contain business rules.', 16, 1);  
            RETURN;  
        END;  
  
        IF @TargetEntitySupportsNonLeafMembers = 1  
        BEGIN  
            RAISERROR('MDSERR200222|The sync relationship is not valid. A target entity may only contain Leaf members.', 16, 1);  
            RETURN;  
        END;  
  
        IF EXISTS (SELECT 1 FROM mdm.tblIndex WHERE Entity_ID = @TargetEntity_ID)  
        BEGIN  
            RAISERROR('MDSERR200224|The sync relationship is not valid. A target entity may not contain Indexes.', 16, 1);  
            RETURN;  
        END;  
  
        -- Verify the user has permission to see all members and attributes within the source entity. Note: lack of attribute group permission does not prevent creation of a sync relationship.  
        DECLARE @UseMemberSecurity BIT;  
        SET @UseMemberSecurity = mdm.udfUseMemberSecurity(@User_ID, @SourceEntity_ID, @SourceVersion_ID, @MemberType_Leaf)  
        IF @UseMemberSecurity <> 0  
           OR EXISTS(SELECT 1  
                  FROM mdm.tblAttribute a  
                  LEFT JOIN mdm.viw_SYSTEM_SECURITY_USER_ATTRIBUTE sa  
                  ON    a.ID = sa.ID  
                    AND sa.User_ID = @User_ID  
                  WHERE  
                        a.Entity_ID = @SourceEntity_ID  
                    AND a.MemberType_ID = @MemberType_Leaf  
                    AND (a.IsSystem = 0 OR a.IsCode = 1 OR a.IsName = 1)  
                    AND sa.Privilege_ID IS NULL)  
        BEGIN  
            RAISERROR('MDSERR200210|Insufficient permission on source entity.', 16, 1);  
            RETURN;  
        END;  
  
        -- Sync entity metadata  
        IF  @IsFirstSyncAttempt = 1 OR  
            @SourceEntityTimestamp <> @LastSyncTimestamp   
        BEGIN  
            -- The source entity has changed since the last sync. Update it  
            SET @NeedToRefreshStagingSproc = 1  
  
            IF @TargetEntityNameIsAliased = 0  
            BEGIN  
                SET @TargetEntityName = @SourceEntityName;  
            END  
  
PRINT CONCAT(SYSDATETIME(), N': Updating target entity ''', @TargetEntityName,''' (ID = ', @TargetEntity_ID, N')')  
            EXEC mdm.udpEntitySave   
                 @User_ID = @User_ID  
                ,@Model_ID = @TargetModel_ID  
                ,@Entity_ID = @TargetEntity_ID  
                ,@EntityName = @TargetEntityName  
                ,@Description = @SourceEntityDescription  
                ,@IsBase = @SourceEntityIsBase  
                ,@EditMode = @EditMode_Update -- The entity must have already been created at this point, so always doing update  
                ,@DataCompression = @SourceEntityDataCompression  
                ,@TransactionLogType = @TransactionLogType_None  
                ,@IsSync = 1  
                ,@RecreateStagingProc = 0 -- For efficiency, will update the sproc only after all entity and attribute metadata changes have been made  
  
            -- update the target entity audit info to match the source  
            UPDATE te  
            SET    
                 EnterDTM = se.EnterDTM  
                ,EnterUserID = se.EnterUserID  
                ,LastChgDTM = se.LastChgDTM  
                ,LastChgUserID = se.LastChgUserID  
            FROM mdm.tblEntity te  
            INNER JOIN mdm.tblEntity se  
            ON      se.ID = @SourceEntity_ID  
                AND te.ID = @TargetEntity_ID;  
        END;  
  
  
  
        -- Sync attribute metadata  
  
        DECLARE @SourceAttributes TABLE  
        (  
             ID                     INT PRIMARY KEY  
            ,Name                   NVARCHAR(100) NULL  
            ,DataType_ID            TINYINT NULL  
            ,AttributeType_ID       TINYINT NULL  
            ,ChangeTrackingGroup    INT NULL  
            ,DataTypeInformation    INT NULL  
            ,Description            NVARCHAR(500) NULL  
            ,DisplayName            NVARCHAR(250) NULL  
            ,DisplayWidth           INT NULL  
            ,DomainEntity_ID        INT NULL -- TODO: Add support for reflexive DBAs  
            ,InputMask_ID           INT NULL  
            ,SortOrder              INT NULL  
            ,TableColumn            SYSNAME  
            ,EnterDTM               DATETIME2(3)  
            ,EnterUserID            INT  
            ,LastChgDTM             DATETIME2(3)  
            ,LastChgUserID          INT  
            ,LastChgTS              VARBINARY(8) NULL  
        )  
  
        INSERT INTO @SourceAttributes  
        SELECT  
             ID  
            ,Name  
            ,DataType_ID  
            ,AttributeType_ID  
            ,ChangeTrackingGroup  
            ,DataTypeInformation  
            ,Description  
            ,DisplayName  
            ,DisplayWidth  
            ,DomainEntity_ID  
            ,InputMask_ID  
            ,SortOrder  
            ,TableColumn  
            ,EnterDTM  
            ,EnterUserID  
            ,LastChgDTM  
            ,LastChgUserID  
            ,CAST(LastChgTS AS VARBINARY(8))  
        FROM mdm.tblAttribute  
        WHERE   Entity_ID = @SourceEntity_ID  
            AND MemberType_ID = @MemberType_Leaf  
            AND (IsSystem = 0 OR IsName = 1 OR IsCode = 1)  
            AND (DomainEntity_ID IS NULL   
                --OR DomainEntity_ID = @SourceEntity_ID -- TODO: Add support for reflexive DBAs  
                )  
  
        DECLARE @AttributeChanges TABLE  
        (  
             RowID                  INT IDENTITY(1, 1) PRIMARY KEY  
            ,SourceAttribute_ID     INT NULL  
            ,TargetAttribute_ID     INT NULL  
            ,TargetAttributeName    NVARCHAR(100) NULL  
            ,TargetAttributeDataType_ID TINYINT  
  
            -- source attribute values  
            ,AttributeType_ID       TINYINT NULL  
            ,ChangeTrackingGroup    INT NULL  
            ,DataType_ID            TINYINT NULL  
            ,DataTypeInformation    INT NULL  
            ,Description            NVARCHAR(500) NULL  
            ,DisplayName            NVARCHAR(250) NULL  
            ,DisplayWidth           INT NULL  
            ,DomainEntity_ID        INT NULL -- TODO: Add support for reflexive-DBAs  
            ,InputMask_ID           INT NULL  
            ,Name                   NVARCHAR(100) NULL  
            ,SortOrder              INT NULL  
            ,EnterDTM               DATETIME2(3)  
            ,EnterUserID            INT  
            ,LastChgDTM             DATETIME2(3)  
            ,LastChgUserID          INT  
            ,LastChgTS              VARBINARY(8) NULL  
        );  
  
        IF @IsFirstSyncAttempt = 1  
        BEGIN  
            -- This is the first sync attempt. Attributes are matched by name (subsequent syncs will use Source_ID). Attributes that  
            -- already exist in the target Entity must *exactly* match those in the source Entity, or sync will fail. Because initial sync   
            -- must not cause data loss on the target Entity. It can add, but not modify or delete existing data.  
PRINT CONCAT(SYSDATETIME(), N': Matching source and target attributes for initial sync')  
  
            UPDATE tgt   
            SET  
                 Source_ID = src.ID  
                ,Source_LastChgTS = src.LastChgTS  
                ,EnterDTM = src.EnterDTM  
                ,EnterUserID = src.EnterUserID  
                ,LastChgDTM = src.LastChgDTM  
                ,LastChgUserID = src.LastChgUserID  
            FROM mdm.tblAttribute tgt  
            INNER JOIN @SourceAttributes src  
            ON      src.AttributeType_ID = tgt.AttributeType_ID -- not nullable  
                AND src.ChangeTrackingGroup = tgt.ChangeTrackingGroup -- not nullable  
                AND src.DataType_ID = tgt.DataType_ID -- not nullable  
                AND ((src.DataTypeInformation IS NULL AND tgt.DataTypeInformation IS NULL) OR src.DataTypeInformation = tgt.DataTypeInformation)  
                AND ((src.DisplayName IS NULL AND tgt.DisplayName IS NULL) OR src.DisplayName = tgt.DisplayName)  
                AND ((src.Description IS NULL AND tgt.Description IS NULL) OR src.Description = tgt.Description)  
                AND src.DisplayWidth = tgt.DisplayWidth -- not nullable  
                AND (  (src.DomainEntity_ID IS NULL AND tgt.DomainEntity_ID IS NULL) -- not a DBA  
                    OR (src.DomainEntity_ID = @SourceEntity_ID AND tgt.DomainEntity_ID = @TargetEntity_ID)) -- reflexive DBA  
                AND src.InputMask_ID = src.InputMask_ID -- not nullable  
                AND src.Name = tgt.Name -- not nullable  
                AND src.SortOrder = tgt.SortOrder -- not nullable  
            WHERE   tgt.Entity_ID = @TargetEntity_ID  
                AND tgt.MemberType_ID = @MemberType_Leaf  
                AND (tgt.IsSystem = 0 OR tgt.IsName = 1 OR tgt.IsCode = 1)  
  
  
            DECLARE @FirstNonMatchedAttributeName NVARCHAR(100)  
            SELECT TOP 1  
                @FirstNonMatchedAttributeName = Name  
            FROM mdm.tblAttribute  
            WHERE   Entity_ID = @TargetEntity_ID  
                AND MemberType_ID = @MemberType_Leaf  
                AND (IsSystem = 0 OR IsName = 1 OR IsCode = 1)  
                AND Source_ID IS NULL;  
  
            IF @FirstNonMatchedAttributeName IS NOT NULL  
            BEGIN  
                DECLARE @ErrorMsg NVARCHAR(MAX) = CONCAT('MDSERR200211|Initial sync of entity has failed. Target entity contains at least one attribute that does not match a source entity attribute. First attribute name: "{0}"|', @FirstNonMatchedAttributeName, N'|') -- Adding a trailing "|" char to separate the attribute name from any error context info added to the error message by the catch block.  
                SET @ErrorMsg = REPLACE(@ErrorMsg, '%', '%%')-- escape out format specifier  
                RAISERROR (@ErrorMsg, 16, 1);   
                RETURN;  
            END  
  
        END -- initial sync  
  
PRINT CONCAT(SYSDATETIME(), N': Getting attribute changes')  
        ;WITH targetAttributesCte AS  
        (  
            SELECT  
                 ID  
                ,Name  
                ,DataType_ID  
                ,Source_ID  
                ,Source_LastChgTS  
            FROM mdm.tblAttribute  
            WHERE   
                    Entity_ID = @TargetEntity_ID  
                AND MemberType_ID = @MemberType_Leaf  
                AND (IsSystem = 0 OR IsName = 1 OR IsCode = 1)  
        )              
        INSERT INTO @AttributeChanges  
        SELECT  
             src.ID SourceAttribute_ID  
            ,tgt.ID TargetAttribute_ID  
            ,tgt.Name TargetAttributeName  
            ,tgt.DataType_ID TargetAttributeDataType_ID  
            ,src.AttributeType_ID  
            ,src.ChangeTrackingGroup  
            ,src.DataType_ID  
            ,src.DataTypeInformation  
            ,src.Description  
            ,src.DisplayName  
            ,src.DisplayWidth  
            ,CASE WHEN src.DomainEntity_ID IS NULL THEN NULL ELSE @TargetEntity_ID END DomainEntity_ID  
            ,src.InputMask_ID  
            ,src.Name  
            ,src.SortOrder  
            ,src.EnterDTM  
            ,src.EnterUserID  
            ,src.LastChgDTM  
            ,src.LastChgUserID  
            ,src.LastChgTS  
        FROM @SourceAttributes src  
        FULL JOIN targetAttributesCte tgt  
        ON src.ID = tgt.Source_ID  
        WHERE  src.ID IS NULL -- attribute was deleted from source and needs to be deleted from target entity  
            OR tgt.ID IS NULL -- attribute was added to source entity since last sync and needs to be added to target entity  
            OR (src.LastChgTS IS NULL OR tgt.Source_LastChgTS IS NULL OR src.LastChgTS <> tgt.Source_LastChgTS) -- attribute has changed in source and needs to be updated in target entity  
  
  
        DECLARE   
             @RowID                 INT = 0  
            ,@SourceAttribute_ID    INT  
            ,@TargetAttribute_ID    INT  
            ,@TargetAttributeName   NVARCHAR(100)  
            ,@TargetAttributeDataType_ID TINYINT  
            ,@AttributeType_ID      TINYINT  
            ,@ChangeTrackingGroup   INT  
            ,@DataType_ID           TINYINT  
            ,@DataTypeInformation   INT  
            ,@Description           NVARCHAR(500)  
            ,@DisplayName           NVARCHAR(250)  
            ,@DisplayWidth          INT  
            ,@DomainEntity_ID       INT  
            ,@InputMask_ID          INT  
            ,@AttributeName         NVARCHAR(100)  
            ,@SortOrder             INT  
            ,@EnterDTM              DATETIME2(3)  
            ,@EnterUserID           INT  
            ,@LastChgDTM            DATETIME2(3)  
            ,@LastChgUserID         INT  
            ,@LastChgTS             VARBINARY(8)  
            ;  
  
        SET @NeedToRefreshStagingSproc = CASE WHEN EXISTS (SELECT 1 FROM @AttributeChanges)   
            THEN 1   
            ELSE @NeedToRefreshStagingSproc -- leave original value   
            END  
  
        WHILE EXISTS (SELECT 1 FROM @AttributeChanges WHERE RowID > @RowID)  
        BEGIN  
            SELECT TOP 1  
                 @RowID = RowID  
                ,@SourceAttribute_ID = SourceAttribute_ID  
                ,@TargetAttribute_ID = TargetAttribute_ID   
                ,@TargetAttributeName = TargetAttributeName  
                ,@TargetAttributeDataType_ID = TargetAttributeDataType_ID  
  
                -- source attribute values  
                ,@AttributeType_ID = AttributeType_ID  
                ,@ChangeTrackingGroup = ChangeTrackingGroup  
                ,@DataType_ID = DataType_ID  
                ,@DataTypeInformation = DataTypeInformation  
                ,@Description = Description   
                ,@DisplayName = DisplayName  
                ,@DisplayWidth = DisplayWidth  
                ,@DomainEntity_ID = DomainEntity_ID   
                ,@InputMask_ID = InputMask_ID  
                ,@AttributeName = Name  
                ,@SortOrder = SortOrder  
                ,@EnterDTM = EnterDTM  
                ,@EnterUserID = EnterUserID  
                ,@LastChgDTM = LastChgDTM  
                ,@LastChgUserID = LastChgUserID  
                ,@LastChgTS = LastChgTS  
            FROM @AttributeChanges  
            WHERE RowID > @RowID  
            ORDER BY RowID;  
            IF @SourceAttribute_ID IS NULL  
            BEGIN  
PRINT CONCAT(SYSDATETIME(), N': Deleting target attribute ''', @TargetAttributeName, N''' (ID = ', @TargetAttribute_ID, N')');  
                -- Delete the attribute  
                EXEC mdm.udpAttributeDelete   
                     @Attribute_ID = @TargetAttribute_ID  
                    ,@IsSync = 1  
            END   
            ELSE BEGIN  
                DECLARE @EditMode TINYINT = CASE WHEN @TargetAttribute_ID IS NULL THEN @EditMode_Create ELSE @EditMode_Update END  
  
                IF @EditMode = @EditMode_Create  
                BEGIN  
PRINT CONCAT(SYSDATETIME(), N': Creating new target attribute, copy of source attribute ''', @AttributeName, N''' (ID = ', @SourceAttribute_ID, N')');  
                END ELSE  
                BEGIN  
PRINT CONCAT(SYSDATETIME(), N': Updating target attribute ''', @TargetAttributeName,N''' (ID = ', @TargetAttribute_ID, N'), copy of source attribute ID = ', @SourceAttribute_ID);  
                END  
  
                IF @EditMode = @EditMode_Update AND COALESCE(@TargetAttributeDataType_ID, -1) <> COALESCE(@DataType_ID, -1)  
                BEGIN  
                    -- The attribute's type has changed.  
  
PRINT CONCAT(SYSDATETIME(), N': Changing attribute data type')              
                    -- TODO: add special handling for failure cases. Like should attribute values be changed before changing the type? Or simply delete and re-add the attribute?  
                    DECLARE   
                         @TargetAttribute_MUID UNIQUEIDENTIFIER = (SELECT MUID FROM mdm.tblAttribute WHERE ID = @TargetAttribute_ID)  
                        ,@DomainEntity_MUID UNIQUEIDENTIFIER = (SELECT MUID FROM mdm.tblEntity WHERE ID = @DomainEntity_ID);  
  
                    EXEC mdm.udpAttributeChange  
                         @User_ID = @User_ID  
                        ,@Attribute_MUID = @TargetAttribute_MUID  
                        ,@AttributeNewName = @AttributeName  
                        ,@AttributeType_ID = @AttributeType_ID  
                        ,@ChangeTrackingGroup = ChangeTrackingGroup  
                        ,@DataType_ID = DataType_ID  
                        ,@DataTypeInformation = DataTypeInformation  
                        ,@Description = @Description  
                        ,@DisplayName = @DisplayName  
                        ,@DisplayWidth = @DisplayWidth  
                        ,@DomainEntity_MUID = @DomainEntity_MUID   
                        ,@IsSync = 1  
                END   
  
                -- Add/update the attribute  
                EXEC mdm.udpAttributeSave   
                     @User_ID = @User_ID  
                    ,@Model_ID = @TargetModel_ID  
                    ,@Entity_ID = @TargetEntity_ID  
                    ,@IsHierarchyEnabled = 0  
                    ,@IsCollectionEnabled = 0  
                    ,@DataCompression = @TargetEntityDataCompression  
                    ,@TableName = @TargetEntity_EN_TableName  
                    ,@StagingTableName = @TargetEntityStagingLeafName  
                    ,@MemberType_ID = @MemberType_Leaf  
                    ,@Attribute_ID = @TargetAttribute_ID  
                    ,@AttributeName = @AttributeName  
                    ,@AttributeType_ID = @AttributeType_ID  
                    ,@ChangeTrackingGroup = @ChangeTrackingGroup  
                    ,@DataType_ID = @DataType_ID  
                    ,@DataTypeInformation = @DataTypeInformation  
                    ,@Description = @Description  
                    ,@DisplayName = @DisplayName  
                    ,@DisplayWidth = @DisplayWidth  
                    ,@DomainEntity_ID = @DomainEntity_ID   
                    ,@InputMask_ID = @InputMask_ID  
                    ,@SortOrder = @SortOrder  
                    ,@EditMode = @EditMode  
                    ,@IsSync = 1  
                    ,@RecreateStagingProc = 0 -- For efficiency, will update the sproc only after all entity and attribute metadata changes have been made  
                    ,@Return_ID = @TargetAttribute_ID OUTPUT  
                    ;  
  
                UPDATE mdm.tblAttribute  
                SET  
                     Source_ID = @SourceAttribute_ID   
                    ,Source_LastChgTS = @LastChgTS  
                    ,EnterDTM = CASE WHEN @EditMode = @EditMode_Create OR IsSystem = 1 THEN @EnterDTM ELSE EnterDTM END  
                    ,EnterUserID = CASE WHEN @EditMode = @EditMode_Create OR IsSystem = 1 THEN @EnterUserID ELSE EnterUserID END  
                    ,LastChgDTM = @LastChgDTM  
                    ,LastChgUserID = @LastChgUserID  
                WHERE ID = @TargetAttribute_ID  
            END  
        END -- WHILE  
  
        IF @NeedToRefreshStagingSproc = 1  
        BEGIN  
            EXEC mdm.udpEntityStagingCreateLeafStoredProcedure @TargetEntity_ID  
        END  
  
  
        -- Sync master data  
        CREATE TABLE #FileAttributeValueMapping  
        (  
             TargetMember_ID    INT NOT NULL  
            ,TargetMemberCode   NVARCHAR(250) NOT NULL  
            ,TargetAttribute_ID INT NOT NULL  
            ,TargetColumnName   SYSNAME NOT NULL  
            ,TargetFile_ID      INT NULL  
            ,SourceMember_ID    INT NULL  
            ,SourceFile_ID      INT NULL  
            ,MatchedOnInitialSync BIT NOT NULL  
        );  
        CREATE INDEX #ix_FileAttributeValueMapping_TargetFile_ID ON #FileAttributeValueMapping(TargetFile_ID);  
        CREATE INDEX #ix_FileAttributeValueMapping_SourceFile_ID ON #FileAttributeValueMapping(SourceFile_ID);  
  
        CREATE TABLE #AttributeMapping  
        (  
             SourceAttribute_ID         INT NOT NULL  
            ,SourceAttribute_ColumnName SYSNAME NOT NULL  
            ,TargetAttribute_ID         INT NOT NULL  
            ,TargetAttribute_ColumnName SYSNAME NOT NULL  
            ,AttributeType_ID           INT NOT NULL  
        );  
        CREATE UNIQUE CLUSTERED INDEX #ix_AttributeMapping_SourceAttribute_ID_TargetAttribute_ID ON #AttributeMapping(SourceAttribute_ID, TargetAttribute_ID);  
  
        INSERT INTO #AttributeMapping  
        SELECT  
             src.ID             SourceAttribute_ID  
            ,src.TableColumn    SourceAttribute_ColumnName  
            ,tgt.ID             TargetAttribute_ID  
            ,tgt.TableColumn    TargetAttribute_ColumnName  
            ,src.AttributeType_ID  
        FROM @SourceAttributes src  
        INNER JOIN mdm.tblAttribute tgt  
        ON src.ID = tgt.Source_ID  
        WHERE   tgt.Entity_ID = @TargetEntity_ID  
            AND tgt.MemberType_ID = @MemberType_Leaf  
  
        DECLARE   
             @AttributeValueMatchClause     NVARCHAR(MAX) = N''  
            ,@AttributeValueSetClause       NVARCHAR(MAX) = N''  
            ,@SourceAttributesSelectClause  NVARCHAR(MAX) = N''  
            ,@TargetAttributesSelectClause  NVARCHAR(MAX) = N''  
            ,@HasFileAttribute  BIT = CASE WHEN EXISTS (SELECT 1 FROM #AttributeMapping WHERE AttributeType_ID = @AttributeType_File) THEN 1 ELSE 0 END  
            --,@SourceDBALookupFromClause NVARCHAR(MAX) = N''  
            --,@TargetDBALookupFromClause NVARCHAR(MAX) = N''  
            ;  
        SELECT   
             @AttributeValueMatchClause += CONCAT(N'  
        AND ', CASE AttributeType_ID  
              
                -- TODO: Add JOIN clauses to lookup referenced member ID  
                WHEN @AttributeType_Domain THEN N'' --CONCAT(N'srcDBA', @SourceAttribute_ID, N'.Code = tgtDBA', @TargetAttribute_ID, N'.Code') -- Compare on Code (rather than attribute value) for self-referencing DBAs  
                   
                 -- For File attributes, only need to ensure both are null or not null at this point. File content is compared later.  
                WHEN @AttributeType_File THEN CONCAT(N'(  
                   (   tgt.', QUOTENAME(TargetAttribute_ColumnName), N' IS NOT NULL   
                    AND src.', QUOTENAME(SourceAttribute_ColumnName), N' IS NOT NULL)  
                OR ISNULL(tgt.', QUOTENAME(TargetAttribute_ColumnName),', src.', QUOTENAME(SourceAttribute_ColumnName), N') IS NULL)' )  
                   
                 -- For Freeform attributes, compare values directly  
                ELSE CONCAT(N'(tgt.', QUOTENAME(TargetAttribute_ColumnName), N' = src.', QUOTENAME(SourceAttribute_ColumnName), CASE WHEN TargetAttribute_ColumnName <> N'Code' -- Code is not nullable  
                    THEN CONCAT(N' OR ISNULL(tgt.', QUOTENAME(TargetAttribute_ColumnName),', src.', QUOTENAME(SourceAttribute_ColumnName), N') IS NULL') END, N')')  
                END)  
        FROM #AttributeMapping  
  
        SELECT   
             @AttributeValueSetClause += CONCAT(N'  
            ,', QUOTENAME(TargetAttribute_ColumnName), N' = src.', QUOTENAME(SourceAttribute_ColumnName))  
  
            ,@SourceAttributesSelectClause += CONCAT(N'  
            ,', SourceAttribute_ColumnName)  
  
            ,@TargetAttributesSelectClause += CONCAT(N'  
            ,', TargetAttribute_ColumnName)  
        FROM #AttributeMapping  
        WHERE AttributeType_ID = @AttributeType_Freeform  
  
        DECLARE @SQL NVARCHAR(MAX);  
  
        IF @IsFirstSyncAttempt = 1  
        BEGIN  
            -- This is the first sync attempt. Members are matched by Code (subsequent syncs will use Source_ID). Members that  
            -- already exist in the target Entity must *exactly* match those in the source Entity, or sync will fail. Because initial sync   
            -- must not cause data loss on the target Entity. It can add, but not modify or delete, existing data.  
            SET @SQL = CONCAT(N'  
PRINT CONCAT(SYSDATETIME(), N'': Initial sync, purging soft-deleted target members'');  
    DELETE mdm.', QUOTENAME(@TargetEntity_EN_TableName), N'  
    WHERE   Version_ID = @TargetVersion_ID  
        AND Status_ID = ', @Status_Deactivated, N' -- Soft-deleted  
  
PRINT CONCAT(SYSDATETIME(), N'': Initial sync, checking for member mismatches'');  
    UPDATE tgt  
    SET  Source_ID = src.ID  
        ,ValidationStatus_ID = src.ValidationStatus_ID  
        ,EnterDTM = src.EnterDTM  
        ,EnterUserID = src.EnterUserID  
        ,LastChgDTM = src.LastChgDTM  
        ,LastChgUserID = src.LastChgUserID  
        ,Source_LastChgTS = src.LastChgTS  
    FROM mdm.', QUOTENAME(@TargetEntity_EN_TableName), N' tgt  
    INNER JOIN mdm.', QUOTENAME(@SourceEntity_EN_TableName), N' src  
    ON      src.Status_ID = ', @Status_Active, N' -- Active',  
        @AttributeValueMatchClause, N'  
    WHERE   tgt.Version_ID = @TargetVersion_ID  
        AND src.Version_ID = @SourceVersion_ID;  
  
    DECLARE @FirstNonmatchedMemberCode NVARCHAR(250) = NULL;  
    SELECT TOP 1   
        @FirstNonmatchedMemberCode = Code  
    FROM mdm.', QUOTENAME(@TargetEntity_EN_TableName), N'  
    WHERE   Version_ID = @TargetVersion_ID  
        AND Source_ID IS NULL;  
          
    IF @FirstNonmatchedMemberCode IS NOT NULL  
    BEGIN   
        DECLARE @ErrorMessage NVARCHAR(MAX) = CONCAT(N''MDSERR200212|Initial sync of entity has failed. Target entity contains at least one member that does not match a source entity member. First member code: "{0}"|'', @FirstNonmatchedMemberCode, N''|''); -- Adding a trailing "|" char to separate the member Code from any error context info added to the error message by the catch block.  
        SET @ErrorMessage = REPLACE(@ErrorMessage, ''%'', ''%%'')-- escape out format specifier  
        RAISERROR(@ErrorMessage, 16, 1);  
    END  
            ');  
  
            --PRINT @SQL  
            EXEC sp_executesql @SQL, N'@SourceVersion_ID INT, @TargetVersion_ID INT', @SourceVersion_ID, @TargetVersion_ID;  
  
            -- Compare file attribute values  
            IF @HasFileAttribute = 1  
            BEGIN  
PRINT CONCAT(SYSDATETIME(), N': Comparing file attribute values');  
  
                SET @SQL = N'';  
                SELECT @SQL += CONCAT(N'  
    ', CASE WHEN LEN(@SQL) = 0 THEN N'INSERT INTO #FileAttributeValueMapping' ELSE N'UNION ALL' END, N'  
    SELECT  
         tgt.ID     TargetMember_ID  
        ,tgt.Code   TargetMemberCode  
        ,', TargetAttribute_ID, N'     TargetAttribute_ID  
        ,', QUOTENAME(TargetAttribute_ColumnName, N''''), N' TargetColumnName  
        ,tgt.', QUOTENAME(TargetAttribute_ColumnName), N' TargetFile_ID  
        ,src.ID     SourceMember_ID  
        ,src.', QUOTENAME(SourceAttribute_ColumnName), N' SourceFile_ID  
        ,1          MatchedOnInitialSync  
    FROM mdm.', QUOTENAME(@TargetEntity_EN_TableName), N' tgt  
    INNER JOIN mdm.', QUOTENAME(@SourceEntity_EN_TableName), N' src  
    ON      tgt.Version_ID = @TargetVersion_ID  
        AND tgt.Source_ID = src.ID  
        AND src.Version_ID = @SourceVersion_ID  
    WHERE tgt.', QUOTENAME(TargetAttribute_ColumnName), N' IS NOT NULL  
                ')  
                FROM #AttributeMapping  
                WHERE AttributeType_ID = @AttributeType_File  
  
                --PRINT @SQL;  
                EXEC sp_executesql @SQL, N'@SourceVersion_ID INT, @TargetVersion_ID INT', @SourceVersion_ID, @TargetVersion_ID;  
  
PRINT CONCAT(SYSDATETIME(), N': Updating tblFile.Source_ID');  
                UPDATE tgtFile  
                SET   
                     Source_ID = srcFile.ID  
                    ,Source_LastChgTS = CAST(srcFile.LastChgTS AS VARBINARY(8))  
                    ,EnterUserID = srcFile.EnterUserID  
                    ,EnterDTM = srcFile.EnterDTM  
                    ,LastChgUserID = srcFile.LastChgUserID  
                    ,LastChgDTM = srcFile.LastChgDTM  
                FROM #FileAttributeValueMapping map  
                INNER JOIN mdm.tblFile tgtFile  
                ON map.TargetFile_ID = tgtFile.ID  
                INNER JOIN mdm.tblFile srcFile  
                ON map.SourceFile_ID = srcFile.ID  
                WHERE   tgtFile.[FileName]      = srcFile.[FileName] -- column not nullable  
                    AND tgtFile.FileContentType = srcFile.FileContentType -- column not nullable  
                    AND (tgtFile.FileContent    = srcFile.FileContent OR ISNULL(tgtFile.FileContent, srcFile.FileContent) IS NULL) -- column nullable  
  
PRINT CONCAT(SYSDATETIME(), N': Checking if a target member has a file attribute mismatch.');  
                DECLARE @FirstNonmatchedMemberCode NVARCHAR(250) = NULL;  
                SELECT TOP 1   
                    @FirstNonmatchedMemberCode = map.TargetMemberCode  
                FROM #FileAttributeValueMapping map  
                INNER JOIN mdm.tblFile tgtFile  
                ON map.TargetFile_ID = tgtFile.ID  
                WHERE tgtFile.Source_ID IS NULL;  
          
                IF @FirstNonmatchedMemberCode IS NOT NULL  
                BEGIN   
                    SET @ErrorMessage = CONCAT(N'MDSERR200212|Initial sync of entity has failed. Target entity contains at least one member that does not match a source entity member. First member code: "{0}"|', @FirstNonmatchedMemberCode, N'|');-- Adding a trailing "|" char to separate the member Code from any error context info added to the error message by the catch block.  
                    SET @ErrorMessage = REPLACE(@ErrorMessage, '%', '%%')-- escape out format specifier  
                    RAISERROR(@ErrorMessage, 16, 1);  
                END  
  
            END -- compare file attribute values  
  
        END; -- initial sync  
  
PRINT CONCAT(SYSDATETIME(), N': Updating target entity members (freeform attributes only)');  
        SET @SQL = CONCAT(N'  
    MERGE mdm.', QUOTENAME(@TargetEntity_EN_TableName), N' tgt  
    USING  
    (  
        SELECT  
             ID  
            ,ValidationStatus_ID  
            ,EnterDTM  
            ,EnterUserID  
            ,LastChgDTM  
            ,LastChgUserID  
            ,LastChgTS',  
            @SourceAttributesSelectClause, N'  
        FROM mdm.', QUOTENAME(@SourceEntity_EN_TableName), N'  
        WHERE   Version_ID = @SourceVersion_ID  
            AND Status_ID = ', @Status_Active, N' -- Active  
    ) src  
    ON      tgt.Version_ID = @TargetVersion_ID  
        AND tgt.Source_ID = src.ID  
  
    -- Update existing member   
    WHEN MATCHED AND tgt.Source_LastChgTS <> src.LastChgTS THEN  
        UPDATE SET  
             ValidationStatus_ID = src.ValidationStatus_ID  
            ,Source_LastChgTS = src.LastChgTS  
            ,EnterDTM = src.EnterDTM  
            ,EnterUserID = src.EnterUserID  
            ,LastChgDTM = src.LastChgDTM  
            ,LastChgUserID = src.LastChgUserID',  
            @AttributeValueSetClause, N'  
  
    -- Add new member  
    WHEN NOT MATCHED BY TARGET THEN  
        INSERT  
        (  
             Source_ID  
            ,Source_LastChgTS  
            ,Version_ID  
            ,Status_ID  
            ,ValidationStatus_ID  
            ,EnterDTM  
            ,EnterUserID  
            ,EnterVersionID  
            ,LastChgDTM  
            ,LastChgUserID  
            ,LastChgVersionID',  
            @TargetAttributesSelectClause, N'  
        )  
        VALUES  
        (  
             src.ID  
            ,src.LastChgTS  
            ,@TargetVersion_ID  
            ,', @Status_Active, N' -- Active  
            ,src.ValidationStatus_ID  
            ,src.EnterDTM  
            ,src.EnterUserID  
            ,@TargetVersion_ID  
            ,src.LastChgDTM  
            ,src.LastChgUserID  
            ,@TargetVersion_ID',  
            @SourceAttributesSelectClause, N'  
        )  
  
    -- Flag for hard-deletion  
    WHEN NOT MATCHED BY SOURCE AND tgt.Version_ID = @TargetVersion_ID THEN  
        UPDATE SET Source_ID = NULL -- Will hard-delete these later  
    ;  
  
PRINT CONCAT(SYSDATETIME(), N'': changed rows: '', @@ROWCOUNT);  
  
PRINT CONCAT(SYSDATETIME(), N'': Updating file attribute values'');  
  
            ');  
  
        --PRINT @SQL  
        EXEC sp_executesql @SQL, N'@SourceVersion_ID INT, @TargetVersion_ID INT', @SourceVersion_ID, @TargetVersion_ID;  
  
        IF @HasFileAttribute = 1  
        BEGIN  
PRINT CONCAT(SYSDATETIME(), N': Updating file attributes.');  
                SET @SQL = N'';  
                SELECT @SQL += CONCAT(N'  
    ', CASE WHEN LEN(@SQL) = 0 THEN N'INSERT INTO #FileAttributeValueMapping' ELSE N'UNION ALL' END, N'  
    SELECT  
         tgt.ID     TargetMember_ID  
        ,tgt.Code   TargetMemberCode  
        ,', TargetAttribute_ID, N' TargetAttribute_ID  
        ,N', QUOTENAME(TargetAttribute_ColumnName, N''''), N' TargetColumnName  
        ,tgt.', QUOTENAME(TargetAttribute_ColumnName), N' TargetFile_ID  
        ,src.ID     SourceMember_ID  
        ,src.', QUOTENAME(SourceAttribute_ColumnName), N' SourceFile_ID  
        ,0 MatchedOnInitialSync  
    FROM mdm.', QUOTENAME(@TargetEntity_EN_TableName), N' tgt  
    LEFT JOIN mdm.', QUOTENAME(@SourceEntity_EN_TableName), N' src  
    ON      tgt.Source_ID = src.ID  
        AND src.Version_ID = @SourceVersion_ID',   
                CASE WHEN @IsFirstSyncAttempt = 1 THEN CONCAT(N'  
    LEFT JOIN #FileAttributeValueMapping map  
    ON      tgt.ID = map.TargetMember_ID  
        AND map.TargetColumnName = N', QUOTENAME(TargetAttribute_ColumnName, N'''')) END, N'  
    WHERE   tgt.Version_ID = @TargetVersion_ID  
        AND (   tgt.', QUOTENAME(TargetAttribute_ColumnName), N' IS NOT NULL   
             OR src.', QUOTENAME(SourceAttribute_ColumnName), N' IS NOT NULL)',   
                CASE WHEN @IsFirstSyncAttempt = 1 THEN N'  
        AND map.TargetMember_ID IS NULL -- on initial sync, ignore attributes that have already been matched  
                ' END)  
                FROM #AttributeMapping   
                WHERE AttributeType_ID = @AttributeType_File  
            --PRINT @SQL  
            EXEC sp_executesql @SQL, N'@SourceVersion_ID INT, @TargetVersion_ID INT', @SourceVersion_ID, @TargetVersion_ID;  
  
            IF @IsFirstSyncAttempt = 1  
            BEGIN  
PRINT CONCAT(SYSDATETIME(), N': Deleting #FileAttributeValueMapping rows that were already matched.');  
                DELETE FROM #FileAttributeValueMapping  
                WHERE MatchedOnInitialSync = 1  
            END  
  
PRINT CONCAT(SYSDATETIME(), N': Checking for target entity files to delete.');  
            CREATE TABLE #FilesToDelete  
            (  
                 TargetMember_ID    INT NOT NULL  
                ,TargetAttribute_ID INT NOT NULL  
                ,TargetColumnName   SYSNAME NOT NULL  
                ,TargetFile_ID      INT NOT NULL  
            );  
            CREATE UNIQUE INDEX #ix_FilesToDelete_TargetMember_ID_TargetAttribute_ID ON #FilesToDelete(TargetMember_ID, TargetAttribute_ID);  
            CREATE INDEX #ix_FilesToDelete_TargetFile_ID ON #FilesToDelete(TargetFile_ID);  
            INSERT INTO #FilesToDelete  
            SELECT   
                 map.TargetMember_ID  
                ,map.TargetAttribute_ID  
                ,map.TargetColumnName  
                ,map.TargetFile_ID  
            FROM #FileAttributeValueMapping map  
            LEFT JOIN mdm.tblFile tgtFile  
            ON map.TargetFile_ID = tgtFile.ID  
            LEFT JOIN mdm.tblFile srcFile  
            ON map.SourceFile_ID = srcFile.ID  
            WHERE   map.TargetFile_ID IS NOT NULL   
                AND (map.SourceFile_ID IS NULL   
                    OR tgtFile.Source_ID <> srcFile.ID)  
              
            SET @TargetAttribute_ID = 0;  
            WHILE EXISTS (SELECT 1 FROM #FilesToDelete WHERE TargetAttribute_ID > @TargetAttribute_ID)  
            BEGIN  
                SET @SQL = N'';  
                SELECT TOP 1  
                    @TargetAttribute_ID = TargetAttribute_ID  
                    ,@SQL = CONCAT(N'  
        UPDATE tgt  
        SET ', QUOTENAME(TargetColumnName) ,N' = NULL  
        FROM mdm.', QUOTENAME(@TargetEntity_EN_TableName), N' tgt  
        INNER JOIN #FilesToDelete f  
        ON      tgt.ID = f.TargetMember_ID  
            AND tgt.Version_ID = @TargetVersion_ID  
            AND f.TargetAttribute_ID = @TargetAttribute_ID  
        ')  
                FROM #FilesToDelete  
                WHERE TargetAttribute_ID > @TargetAttribute_ID  
                ORDER BY TargetAttribute_ID ASC  
              
PRINT CONCAT(SYSDATETIME(), N': Setting to null values for attribute ID = ', @TargetAttribute_ID);  
                --PRINT @SQL  
                EXEC sp_executesql @SQL, N'@TargetVersion_ID INT, @TargetAttribute_ID INT', @TargetVersion_ID, @TargetAttribute_ID;  
PRINT CONCAT(SYSDATETIME(), N': ', @@ROWCOUNT, N' row(s) updated in table ', @TargetEntity_EN_TableName);  
  
            END  
  
PRINT CONCAT(SYSDATETIME(), N': Deleting rows from tblFile.');  
            DECLARE @File_ID mdm.IdList;  
            INSERT INTO @File_ID (ID)  
            SELECT TargetFile_ID  
            FROM #FilesToDelete   
  
            EXEC mdm.udpFilesDelete @File_ID = @File_ID, @CorrelationID = @CorrelationID;  
  
PRINT CONCAT(SYSDATETIME(), N': Deleting rows from #FileAttributeValueMapping for deleted file attributes.');  
            DELETE map  
            FROM #FileAttributeValueMapping map   
            INNER JOIN #FilesToDelete f  
            ON      map.TargetMember_ID = f.TargetMember_ID  
                AND map.TargetAttribute_ID = f.TargetAttribute_ID  
                AND map.SourceFile_ID IS NULL  
PRINT CONCAT(SYSDATETIME(), N': ', @@ROWCOUNT, N' rows deleted.');  
  
PRINT CONCAT(SYSDATETIME(), N': Clearing old TargetFIle_ID from #FileAttributeValueMapping for deleted file attributes (where there is a non-null source).');  
            UPDATE map  
            SET TargetFile_ID = NULL  
            FROM #FileAttributeValueMapping map   
            INNER JOIN #FilesToDelete f  
            ON      map.TargetMember_ID = f.TargetMember_ID  
                AND map.TargetAttribute_ID = f.TargetAttribute_ID  
                AND map.SourceFile_ID IS NOT NULL  
PRINT CONCAT(SYSDATETIME(), N': ', @@ROWCOUNT, N' rows updated.');  
  
PRINT CONCAT(SYSDATETIME(), N': Copying rows in mdm.tblFile.');  
            CREATE TABLE #NewFiles  
            (  
                 TargetMember_ID    INT NOT NULL  
                ,TargetAttribute_ID INT NOT NULL  
                ,TargetColumnName   SYSNAME NOT NULL  
                ,TargetFile_ID      INT NOT NULL  
            )  
            CREATE UNIQUE INDEX #ix_NewFiles_TargetMember_ID_TargetAttribute_ID ON #NewFiles(TargetMember_ID, TargetAttribute_ID);  
            -- Copy file attributes  
            MERGE mdm.tblFile tgtFile  
            USING  
            (  
                SELECT  
                     f.ID  
                    ,f.LastChgTS  
                    ,f.EnterUserID  
                    ,f.EnterDTM  
                    ,f.LastChgUserID  
                    ,f.LastChgDTM  
                    ,f.FileName  
                    ,f.FileContentType  
                    ,f.FileContent  
                    ,map.TargetMember_ID  
                    ,map.TargetAttribute_ID  
                    ,map.TargetColumnName  
                    ,map.TargetFile_ID  
                FROM mdm.tblFile f  
                INNER JOIN #FileAttributeValueMapping map  
                ON f.ID = map.SourceFile_ID  
            ) srcFile  
            ON tgtFile.ID = srcFile.TargetFile_ID  
  
            WHEN NOT MATCHED THEN  
                INSERT  
                (  
                     Source_ID  
                    ,Source_LastChgTS  
                    ,EnterUserID  
                    ,EnterDTM  
                    ,LastChgUserID  
                    ,LastChgDTM  
                    ,FileName  
                    ,FileContentType  
                    ,FileContent  
                )  
                VALUES  
                (  
                     srcFile.ID  
                    ,srcFile.LastChgTS  
                    ,srcFile.EnterUserID  
                    ,srcFile.EnterDTM  
                    ,srcFile.LastChgUserID  
                    ,srcFile.LastChgDTM  
                    ,srcFile.FileName  
                    ,srcFile.FileContentType  
                    ,srcFile.FileContent  
                )  
  
            WHEN MATCHED AND (ISNULL(tgtFile.Source_ID, 0) <> srcFile.ID OR tgtFile.Source_LastChgTS <> CAST(srcFile.LastChgTS AS VARBINARY(8))) THEN  
                UPDATE SET  
                     Source_ID = srcFile.ID  
                    ,Source_LastChgTS = srcFile.LastChgTS  
                    ,EnterUserID = srcFile.EnterUserID  
                    ,EnterDTM = srcFile.EnterDTM  
                    ,LastChgUserID = srcFile.LastChgUserID  
                    ,LastChgDTM = srcFile.LastChgDTM  
                    ,FileName = srcFile.FileName  
                    ,FileContentType = srcFile.FileContentType  
                    ,FileContent = srcFile.FileContent  
            OUTPUT srcFile.TargetMember_ID, srcFile.TargetAttribute_ID, srcFile.TargetColumnName, inserted.ID  
            INTO #NewFiles(TargetMember_ID, TargetAttribute_ID, TargetColumnName, TargetFile_ID)  
            ;  
  
PRINT CONCAT(SYSDATETIME(), N': ', @@ROWCOUNT, N' rows created.');  
  
            SET @TargetAttribute_ID = 0;  
            WHILE EXISTS (SELECT 1 FROM #NewFiles WHERE TargetAttribute_ID > @TargetAttribute_ID)  
            BEGIN  
PRINT CONCAT(SYSDATETIME(), N': Setting to new values for attribute ID = ', @TargetAttribute_ID);  
                SET @SQL = N'';  
                SELECT TOP 1  
                    @TargetAttribute_ID = TargetAttribute_ID  
                    ,@SQL = CONCAT(N'  
        UPDATE tgt  
        SET ', QUOTENAME(TargetColumnName) ,N' = f.TargetFile_ID  
        FROM mdm.', QUOTENAME(@TargetEntity_EN_TableName), N' tgt  
        INNER JOIN #NewFiles f  
        ON      tgt.ID = f.TargetMember_ID  
            AND tgt.Version_ID = @TargetVersion_ID  
            AND f.TargetAttribute_ID = @TargetAttribute_ID  
            AND ISNULL(', QUOTENAME(TargetColumnName) ,N', 0) <> f.TargetFile_ID -- ignore updates, only do new rows  
        ')  
                FROM #NewFiles  
                WHERE TargetAttribute_ID > @TargetAttribute_ID  
                ORDER BY TargetAttribute_ID ASC  
              
            --PRINT @SQL  
            EXEC sp_executesql @SQL, N'@TargetVersion_ID INT, @TargetAttribute_ID INT', @TargetVersion_ID, @TargetAttribute_ID;  
PRINT CONCAT(SYSDATETIME(), N': ', @@ROWCOUNT, N' rows updated in table ', @TargetEntity_EN_TableName);  
  
            END  
  
  
            -- Update file attributes (N/A?)  
  
  
        END -- update File attribute values  
  
PRINT CONCAT(SYSDATETIME(), N': Getting DBA dependencies on the target entity, to check for broken DBA relationships.');  
        CREATE TABLE #targetConsumers  
        (  
             DBA_ID     INT PRIMARY KEY  
            ,EntityName NVARCHAR(50)  
            ,TableName  SYSNAME NOT NULL  
            ,ColumnName SYSNAME NOT NULL  
        )  
        INSERT INTO #targetConsumers  
        SELECT  
             a.ID           AS DBA_ID  
            ,e.Name         AS EntityName  
            ,CASE a.MemberType_ID  
                WHEN @MemberType_Leaf THEN e.EntityTable  
                WHEN @MemberType_Consolidated THEN e.HierarchyParentTable  
                WHEN @MemberType_Collection THEN e.CollectionTable  
            END             AS TableName  
            ,a.TableColumn  AS ColumnName  
        FROM mdm.tblAttribute a  
        INNER JOIN mdm.tblEntity e  
        ON a.Entity_ID = e.ID  
        WHERE   a.DomainEntity_ID = @TargetEntity_ID   
            AND a.Entity_ID != @TargetEntity_ID -- ignore self-references  
  
        DECLARE   
             @DBA_ID        INT = 0  
            ,@EntityName    NVARCHAR(50)  
            ,@TableName     SYSNAME  
            ,@ColumnName    SYSNAME;  
        WHILE EXISTS (SELECT 1 FROM #targetConsumers WHERE DBA_ID > @DBA_ID)  
        BEGIN  
            SELECT TOP 1  
                 @DBA_ID =  DBA_ID  
                ,@EntityName = EntityName  
                ,@TableName = TableName  
                ,@ColumnName = ColumnName  
            FROM #targetConsumers   
            WHERE DBA_ID > @DBA_ID  
            ORDER BY DBA_ID;  
  
            SET @SQL = CONCAT(N'  
    DECLARE @ErrorMessage NVARCHAR(MAX) = NULL  
    SELECT TOP 1  
        @ErrorMessage = CONCAT(N''MDSERR300004|The member with code "{0}" cannot be deleted. It is currently used by entity "{1}", member code "{2}"|'', tgt.Code, N''|', @EntityName, '|'', ref.Code, N''|'') -- Adding a trailing "|" char to separate the member Code from any error context info added to the error message by the catch block.  
    FROM mdm.', QUOTENAME(@TableName), N' ref  
    INNER JOIN mdm.', QUOTENAME(@TargetEntity_EN_TableName), N' tgt  
    ON      ref.Version_ID = tgt.Version_ID  
        AND ref.', QUOTENAME(@ColumnName), N' = tgt.ID  
    WHERE   tgt.Version_ID = @TargetVersion_ID  
        AND tgt.Source_ID IS NULL;  
  
    IF @ErrorMessage IS NOT NULL  
    BEGIN  
        SET @ErrorMessage = REPLACE(@ErrorMessage, ''%'', ''%%'')-- escape out format specifier  
        RAISERROR (@ErrorMessage, 16, 1);  
    END  
    ');  
PRINT CONCAT(SYSDATETIME(), N': Looking for consuming members in Entity ''', @EntityName, ''', DBA_ID = ', @DBA_ID);  
            EXEC sp_executesql @SQL, N'@TargetVersion_ID INT', @TargetVersion_ID;  
  
        END  
  
  
        SET @SQL = CONCAT(N'  
    DELETE mdm.', QUOTENAME(@TargetEntity_EN_TableName), N'  
    WHERE   Version_ID = @TargetVersion_ID  
        AND Source_ID IS NULL;')  
        --PRINT @SQL  
PRINT CONCAT(SYSDATETIME(), N': Deleting target members');  
        EXEC sp_executesql @SQL, N'@TargetVersion_ID INT', @TargetVersion_ID;  
  
PRINT CONCAT(SYSDATETIME(), N': Deleted rows: ', @@ROWCOUNT);  
  
  
        PRINT CONCAT(SYSDATETIME(), N': Sync successful. Updating tblSyncRelationship.');  
  
        DECLARE @Now DATETIME2(7) = GETUTCDATE();  
  
        -- update the entity timestamp in the sync table  
        UPDATE mdm.tblSyncRelationship  
        SET  LastSuccessfulSyncTimestamp = @SourceEntityTimestamp  
            ,LastSuccessfulSyncDTM = @Now  
            ,LastSyncAttemptDTM = @Now  
            ,LastSyncAttemptStatus = @SyncStatus_Success  
            ,LastSyncAttemptErrorInfo = NULL  
        WHERE   TargetEntity_ID = @TargetEntity_ID  
            AND TargetVersion_ID = @TargetVersion_ID  
  
        --Commit only if we are not nested  
        IF @TranCounter = 0 COMMIT TRANSACTION;  
  
    END TRY  
    --Compensate as necessary  
    BEGIN CATCH  
  
        -- Get error info.  
        DECLARE  
            @ErrorSeverity INT,  
            @ErrorState INT,  
            @ErrorNumber INT,  
            @ErrorLine INT,  
            @ErrorProcedure NVARCHAR(126);  
        EXEC mdm.udpGetErrorInfo  
            @ErrorMessage = @ErrorMessage OUTPUT,  
            @ErrorSeverity = @ErrorSeverity OUTPUT,  
            @ErrorState = @ErrorState OUTPUT,  
            @ErrorNumber = @ErrorNumber OUTPUT,  
            @ErrorLine = @ErrorLine OUTPUT,  
            @ErrorProcedure = @ErrorProcedure OUTPUT  
  
        IF @TranCounter = 0 ROLLBACK TRANSACTION;  
        ELSE IF XACT_STATE() <> -1 ROLLBACK TRANSACTION TX;  
  
PRINT CONCAT(SYSDATETIME(), N': Sync failed. Updating tblSyncRelationship.');  
        -- update the entity timestamp in the sync table  
        UPDATE mdm.tblSyncRelationship  
        SET    
             LastSyncAttemptDTM = GETUTCDATE()  
            ,LastSyncAttemptStatus = @SyncStatus_Failed  
            ,LastSyncAttemptErrorInfo = @ErrorMessage  
        WHERE   TargetEntity_ID = @TargetEntity_ID  
            AND TargetVersion_ID = @TargetVersion_ID  
  
        SET @ErrorMessage = CONCAT(@ErrorMessage, N', @ErrorNumber = ', @ErrorNumber, N', @ErrorProcedure = "', @ErrorProcedure, N'", line ', @ErrorLine);  
  
        RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);  
  
    END CATCH;  
  
    -- Send the message  
	EXEC mdm.udpPerformanceQueueSave;  
      
    SET NOCOUNT OFF;  
END -- Proc
GO
/****** Object:  StoredProcedure [mdm].[udpSyncRefreshJob]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
Executed by SQL Agent, refreshes any sync relationships that are due.  
*/  
CREATE PROCEDURE [mdm].[udpSyncRefreshJob]  
WITH EXECUTE AS N'mds_schema_user'      
AS  
BEGIN  
    SET NOCOUNT ON;  
  
PRINT CONCAT(SYSDATETIME(), N': Sync Job- Started.');  
  
    -- Set a MUTEX?  
  
    DECLARE   
         @TargetModel_ID    INT = 0 -- Set to non-null value to enter the below loop  
        ,@TargetVersion_ID  INT  
        ,@TargetEntity_ID   INT  
        ,@User_ID           INT  
        ,@OverdueHours      DECIMAL  
  
    -- Loop through overdue sync relationships  
    WHILE @TargetModel_ID IS NOT NULL  
    BEGIN  
  
        SET @TargetModel_ID = NULL;  
  
        ;WITH syncRelationshipsCte AS  
        (  
            SELECT   
                 LastChgUserID -- Execute the refresh using the credentials of the user who last changed the sync relationship  
                ,TargetVersion_ID  
                ,TargetEntity_ID  
                ,(DATEDIFF(MINUTE, LastSyncAttemptDTM, GETUTCDATE()) / 60.0) --HoursSinceLastRefreshAttempt  
                    - CONVERT(DECIMAL(38,1), RefreshFrequencyInHours) AS OverdueHours  
                ,RefreshFrequencyInHours   
            FROM mdm.tblSyncRelationship  
            WHERE   RefreshFrequencyInHours IS NOT NULL -- Ignore sync relationships that refresh on-demand only   
                AND RefreshFrequencyInHours > 0  
        )  
        SELECT TOP 1  
             @User_ID = sync.LastChgUserID  
            ,@TargetModel_ID = v.Model_ID  
            ,@TargetVersion_ID = sync.TargetVersion_ID  
            ,@TargetEntity_ID = sync.TargetEntity_ID  
            ,@OverdueHours = OverdueHours  
        FROM syncRelationshipsCte sync  
        INNER JOIN mdm.tblModelVersion v  
        ON sync.TargetVersion_ID = v.ID  
        WHERE sync.OverdueHours >= 0  
        ORDER BY sync.OverdueHours DESC -- prioritize the most overdue  
  
        IF @TargetModel_ID IS NOT NULL  
        BEGIN  
  
PRINT CONCAT(SYSDATETIME(), N': Sync Job- Attempting sync refresh. @User_ID = ', @User_ID, N', @TargetModel_ID = ', @TargetModel_ID, N', @TargetVersion_ID = ', @TargetVersion_ID, N', @TargetEntity_ID = ', @TargetEntity_ID, N', @OverdueHours = ', @OverdueHours);  
            BEGIN TRY  
                EXEC mdm.udpSyncRefresh @User_ID = @User_ID, @TargetModel_ID = @TargetModel_ID, @TargetVersion_ID = @TargetVersion_ID, @TargetEntity_ID = @TargetEntity_ID  
            END TRY  
            BEGIN CATCH  
  
                -- Get error info.  
                DECLARE  
                    @ErrorMessage NVARCHAR(4000),  
                    @ErrorSeverity INT,  
                    @ErrorState INT,  
                    @ErrorNumber INT,  
                    @ErrorLine INT,  
                    @ErrorProcedure NVARCHAR(126);  
                EXEC mdm.udpGetErrorInfo  
                    @ErrorMessage = @ErrorMessage OUTPUT,  
                    @ErrorSeverity = @ErrorSeverity OUTPUT,  
                    @ErrorState = @ErrorState OUTPUT,  
                    @ErrorNumber = @ErrorNumber OUTPUT,  
                    @ErrorLine = @ErrorLine OUTPUT,  
                    @ErrorProcedure = @ErrorProcedure OUTPUT  
  
PRINT CONCAT(SYSDATETIME(), N': Sync Job- Sync refresh failed with error: ', @ErrorMessage);  
  
                -- update the status and timestamp in the sync table  
                DECLARE @SyncStatus_Failed         TINYINT = 3  
                UPDATE mdm.tblSyncRelationship  
                SET    
                     LastSyncAttemptDTM = GETUTCDATE()-- Use end time, rather than start time  
                    ,LastSyncAttemptStatus = @SyncStatus_Failed  
                    ,LastSyncAttemptErrorInfo = @ErrorMessage  
                WHERE   TargetEntity_ID = @TargetEntity_ID  
                    AND TargetVersion_ID = @TargetVersion_ID  
  
            END CATCH;  
  
        END;  
  
    END; -- WHILE  
  
PRINT CONCAT(SYSDATETIME(), N': Sync Job- Finished.');  
    SET NOCOUNT OFF;  
  
END -- Proc
GO
/****** Object:  StoredProcedure [mdm].[udpSyncRelationshipDelete]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
Removes a sync relationship that targets the given entity version. This makes the master data of that version writable.   
The entity metadata is also becomes writable if there are no other sync relationships pertaining to other versions   
of the target entity.  
*/  
CREATE PROCEDURE [mdm].[udpSyncRelationshipDelete]  
(  
     @User_ID               INT -- Must have admin permission on the target model and Sys Admin functional permission.  
    ,@TargetModel_MUID      UNIQUEIDENTIFIER = NULL -- Target Model name and/or muid is required.  
    ,@TargetModelName       NVARCHAR(50) = NULL  
    ,@TargetVersion_MUID    UNIQUEIDENTIFIER = NULL -- Target Version name and/or muid is required.  
    ,@TargetVersionName     NVARCHAR(50) = NULL  
    ,@TargetVersion_ID      INT = NULL -- for internal use only  
    ,@TargetEntity_MUID     UNIQUEIDENTIFIER = NULL -- when NULL, a random MUID will be generated  
    ,@TargetEntityName      NVARCHAR(50) = NULL -- when NULL, the target entity will have the same name as the source entity.  
    ,@TargetEntity_ID       INT = NULL -- for internal use only  
    ,@IsVersionOrEntityDelete  BIT = 0 -- Should only be set to 1 when being called from udpVersionDelete or udpEntityDelete. Causes the sproc to skip target entity permission checks.  
    ,@CorrelationID         UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS  
BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE   
         @TargetModel_ID    INT  
        ,@TargetEntity_EN_TableName sysname  
  
        ,@PermissionType_Deny           TINYINT = 1  
        ,@PermissionType_Admin          TINYINT = 5  
  
        ,@FunctionalPrivilege_SysAdmin  TINYINT = 5  
    ;  
    -- Ensure the user has Sys Admin functional permissions (can modify metadata)  
    IF @IsVersionOrEntityDelete = 0 -- when deleting the source/target entity or version, the appropriate permissions will have already been checked at this point.  
    BEGIN  
        SET @TargetVersion_ID = NULL;  
        SET @TargetEntity_ID = NULL;  
  
        IF mdm.udfSecurityUserFunctionIsAllowed(@User_ID, @FunctionalPrivilege_SysAdmin) = 0  
        BEGIN   
            RAISERROR('MDSERR120002|The user does not have permission to perform this operation.', 16, 1);  
            RETURN;  
        END  
  
        -- Lookup target model ID and verify user is model admin  
        DECLARE @TargetModelPrivilege_ID TINYINT  
        EXEC mdm.udpInformationLookupModel @User_ID = @User_ID, @Model_MUID = @TargetModel_MUID, @Model_Name = @TargetModelName, @ID = @TargetModel_ID OUTPUT, @Privilege_ID = @TargetModelPrivilege_ID OUTPUT;  
        IF COALESCE(@TargetModelPrivilege_ID, @PermissionType_Deny) <> @PermissionType_Admin  
        BEGIN  
            SET @TargetModel_ID = NULL;  
        END  
  
        IF @TargetModel_ID IS NULL   
        BEGIN  
            -- Either the model doesn't exist, or the user doesn't have permission to see it.  
            RAISERROR('MDSERR200204|Sync target model ID is not valid or the user does not have sufficient permission.', 16, 1);  
            RETURN;  
        END;  
  
        -- Lookup target version ID. Note: not using udpInformationLookupVersion to avoid needlessly querying the model security view again.  
        SELECT @TargetVersion_ID = ID  
        FROM mdm.tblModelVersion   
        WHERE  
                (@TargetVersion_MUID IS NOT NULL OR @TargetVersionName IS NOT NULL)   
            AND (@TargetVersion_MUID IS NULL OR MUID = @TargetVersion_MUID)   
            AND (@TargetVersionName IS NULL OR Name = @TargetVersionName)  
            AND Model_ID = @TargetModel_ID;  
  
        -- Lookup target entity ID. Note: not using udpInformationLookupEntity to avoid needlessly querying the model security view again.  
        SELECT   
             @TargetEntity_ID = ID  
            ,@TargetEntity_EN_TableName = e.EntityTable  
        FROM mdm.tblEntity e  
        WHERE  
                (@TargetEntity_MUID IS NOT NULL OR @TargetEntityName IS NOT NULL)   
            AND (@TargetEntity_MUID IS NULL OR MUID = @TargetEntity_MUID)   
            AND (@TargetEntityName IS NULL OR Name = @TargetEntityName)  
            AND Model_ID = @TargetModel_ID;  
    END ELSE  
    BEGIN  
        -- When deleting a version or entity, the entity ID will be passed in directly. Use it to look up the entity table name.  
        SELECT @TargetEntity_EN_TableName = EntityTable  
        FROM mdm.tblEntity  
        WHERE ID = @TargetEntity_ID;  
    END  
  
    IF @TargetVersion_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR200205|Sync target version ID is not valid.', 16, 1);  
        RETURN;  
    END;  
    IF @TargetEntity_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR200209|Sync target entity ID is not valid.', 16, 1);  
        RETURN;  
    END;  
  
PRINT CONCAT(SYSDATETIME(), N': Deleting sync relationship @TargetVersion_ID = ', @TargetVersion_ID, N', @TargetEntity_ID = ', @TargetEntity_ID);  
  
  
    --Start transaction, being careful to check if we are nested  
    DECLARE @TranCounter INT = @@TRANCOUNT;  
    IF @TranCounter > 0 SAVE TRANSACTION TX;  
    ELSE BEGIN TRANSACTION;  
  
    BEGIN TRY  
  
        DELETE FROM mdm.tblSyncRelationship  
        WHERE   TargetVersion_ID = @TargetVersion_ID  
            AND TargetEntity_ID  = @TargetEntity_ID  
  
        DECLARE   
             @Source_IDColumnName SYSNAME = N'Source_ID'  
            ,@Source_LastChgTSColumnName SYSNAME = N'Source_LastChgTS'  
            ,@SQL NVARCHAR(MAX);  
  
        IF EXISTS (SELECT 1 FROM mdm.tblSyncRelationship WHERE TargetEntity_ID  = @TargetEntity_ID)  
        BEGIN  
            -- At least one other version of the entity is a sync target.  
  
            -- Clear out the Source_ID column for the specified target version (EN table only. Leave the metadata tables)  
            SET @SQL = CONCAT(N'  
UPDATE mdm.', QUOTENAME(@TargetEntity_EN_TableName), N'  
SET ', QUOTENAME(@Source_IDColumnName), ' = NULL  
    ,', QUOTENAME(@Source_LastChgTSColumnName), N' = NULL  
WHERE Version_ID = @TargetVersion_ID');  
            EXEC sp_executesql @SQL, N'@TargetVersion_ID INT', @TargetVersion_ID;;  
        END ELSE  
        BEGIN  
            -- No other versions of the entity is a sync target.  
  
            -- Clear the metadata tables' Source_ID columns  
            UPDATE mdm.tblAttribute  
            SET  Source_ID = NULL  
                ,Source_LastChgTS = NULL  
            WHERE Entity_ID = @TargetEntity_ID  
  
            --UPDATE agd  
            --SET agd.Source_ID = NULL  
            --FROM mdm.tblAttributeGroupDetail agd  
            --INNER JOIN mdm.tblAttributeGroup ag  
            --ON agd.AttributeGroup_ID = ag.ID  
            --WHERE ag.Entity_ID = @TargetEntity_ID  
  
            --UPDATE mdm.tblAttributeGroup  
            --SET Source_ID = NULL  
            --FROM mdm.tblAttributeGroup  
            --WHERE Entity_ID = @TargetEntity_ID  
  
            -- Drop the Source_ID column from the EN table if it exists (idempotency means the column might have already been deleted)  
            DECLARE @Table_ID INT = (SELECT object_id FROM sys.tables WHERE name = @TargetEntity_EN_TableName and schema_id = schema_id('mdm'))  
            IF EXISTS(  SELECT 1 FROM sys.columns c  
                        WHERE name = @Source_IDColumnName  
                        AND c.object_id = @Table_ID)  
            BEGIN  
                DECLARE @Source_IDIndexName sysname = CONCAT('ix_', @TargetEntity_EN_TableName, N'_Version_ID_', @Source_IDColumnName, N'_', @Source_LastChgTSColumnName);  
                SET @SQL = CONCAT(N'  
DROP INDEX ', QUOTENAME(@Source_IDIndexName), N' ON mdm.', QUOTENAME(@TargetEntity_EN_TableName), N';  
ALTER TABLE mdm.', QUOTENAME(@TargetEntity_EN_TableName), N' DROP COLUMN ', QUOTENAME(@Source_IDColumnName), N';  
ALTER TABLE mdm.', QUOTENAME(@TargetEntity_EN_TableName), N' DROP COLUMN ', QUOTENAME(@Source_LastChgTSColumnName), N';'  
);  
  
                EXEC sp_executesql @SQL;  
            END;  
  
        END;  
  
        --Commit only if we are not nested  
        IF @TranCounter = 0 COMMIT TRANSACTION;  
  
    END TRY  
    --Compensate as necessary  
    BEGIN CATCH  
  
        -- Get error info.  
        DECLARE  
            @ErrorMessage NVARCHAR(4000),  
            @ErrorSeverity INT,  
            @ErrorState INT,  
            @ErrorNumber INT,  
            @ErrorLine INT,  
            @ErrorProcedure NVARCHAR(126);  
        EXEC mdm.udpGetErrorInfo  
            @ErrorMessage = @ErrorMessage OUTPUT,  
            @ErrorSeverity = @ErrorSeverity OUTPUT,  
            @ErrorState = @ErrorState OUTPUT,  
            @ErrorNumber = @ErrorNumber OUTPUT,  
            @ErrorLine = @ErrorLine OUTPUT,  
            @ErrorProcedure = @ErrorProcedure OUTPUT  
  
        SET @ErrorMessage = CONCAT(@ErrorMessage, N', @ErrorNumber = ', @ErrorNumber, N', @ErrorProcedure = "', @ErrorProcedure, N'", line ', @ErrorLine);  
  
        IF @TranCounter = 0 ROLLBACK TRANSACTION;  
        ELSE IF XACT_STATE() <> -1 ROLLBACK TRANSACTION TX;  
  
        RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);  
    END CATCH;  
  
    -- Send the message  
	EXEC mdm.udpPerformanceQueueSave;  
  
    SET NOCOUNT OFF;  
END -- Proc
GO
/****** Object:  StoredProcedure [mdm].[udpSyncRelationshipSave]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
Creates or updates a sync relationship between the given source and target entity versions.  
  
Required user permissions:  
- Sys Admin functional permission  
- Source entity version:  
    -- At least Read permission on the entity and all attributes  
    -- No member permissions (i.e. udfUseMemberSecurity must return 0).  
- Target entity version:   
    -- Model Admin  
    -- Version status must not be Committed.   
  
*/  
CREATE PROCEDURE [mdm].[udpSyncRelationshipSave]  
(  
     @User_ID               INT -- Must have permission to create an entity on the target model and at least read permission on all source entity objects (metadata and master data)  
    ,@SourceModel_MUID      UNIQUEIDENTIFIER = NULL -- Source Model name and/or muid is required.  
    ,@SourceModelName       NVARCHAR(50) = NULL  
    ,@SourceVersion_MUID    UNIQUEIDENTIFIER = NULL -- Source Version name and/or muid is required.  
    ,@SourceVersionName     NVARCHAR(50) = NULL  
    ,@SourceEntity_MUID     UNIQUEIDENTIFIER = NULL -- Source Entity name and/or muid is required.  
    ,@SourceEntityName      NVARCHAR(50) = NULL  
    ,@TargetModel_MUID      UNIQUEIDENTIFIER = NULL -- Target Model name and/or muid is required.  
    ,@TargetModelName       NVARCHAR(50) = NULL  
    ,@TargetVersion_MUID    UNIQUEIDENTIFIER = NULL -- Target Version name and/or muid is required.  
    ,@TargetVersionName     NVARCHAR(50) = NULL  
    ,@TargetEntity_MUID     UNIQUEIDENTIFIER = NULL -- when NULL, a random MUID will be generated  
    ,@TargetEntityName      NVARCHAR(50) = NULL -- when NULL, the target entity will have the same name as the source entity.  
    ,@FrequencyInHours      INT = NULL -- If NULL, syncs will only happen on-demand rather than automatically on at a regular interval.  
    ,@CorrelationID         UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS N'mds_schema_user'      
AS  
BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE   
         @SourceModel_ID    INT  
        ,@SourceVersion_ID  INT  
        ,@SourceEntity_ID   INT  
        ,@TargetModel_ID    INT  
        ,@TargetVersion_ID  INT  
        ,@TargetEntity_ID   INT  
  
        ,@MemberType_Leaf   TINYINT  = 1  
  
        ,@PermissionType_Deny           TINYINT = 1  
        ,@PermissionType_Admin          TINYINT = 5  
  
        ,@FunctionalPrivilege_SysAdmin  TINYINT = 5  
  
        ,@TransactionLogType_None       TINYINT = 3  
  
    ;  
  
    SET @TargetEntity_MUID = NULLIF(@TargetEntity_MUID, 0x0);  
    IF @FrequencyInHours <= 0  
    BEGIN  
        SET @FrequencyInHours = NULL;  
    END  
  
    -- Lookup source model ID  
    EXEC mdm.udpInformationLookupModel @User_ID = @User_ID, @Model_MUID = @SourceModel_MUID, @Model_Name = @SourceModelName, @ID = @SourceModel_ID OUTPUT ;  
    IF @SourceModel_ID IS NULL  
    BEGIN  
        -- Either the model doesn't exist, or the user doesn't have permission to see it.  
        RAISERROR('MDSERR200200|Sync source model ID is not valid', 16, 1);  
        RETURN;  
    END;  
  
    -- Lookup source version ID. Note: not using udpInformationLookupVersion to avoid needlessly querying the model security view again.  
    SELECT @SourceVersion_ID = ID  
    FROM mdm.tblModelVersion   
    WHERE  
            (@SourceVersion_MUID IS NOT NULL OR @SourceVersionName IS NOT NULL)   
        AND (@SourceVersion_MUID IS NULL OR MUID = @SourceVersion_MUID)   
        AND (@SourceVersionName IS NULL OR Name = @SourceVersionName)  
        AND Model_ID = @SourceModel_ID;  
    IF @SourceVersion_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR200201|Sync source version ID is not valid', 16, 1);  
        RETURN;  
    END;  
  
    -- Lookup source entity ID  
    EXEC mdm.udpInformationLookupEntity @User_ID = @User_ID, @Model_ID = @SourceModel_ID, @Entity_MUID = @SourceEntity_MUID, @Entity_Name = @SourceEntityName, @ID = @SourceEntity_ID OUTPUT, @Name = @SourceEntityName OUTPUT, @MUID = @SourceEntity_MUID OUTPUT;  
    IF @SourceEntity_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR200202|Sync source entity ID is not valid', 16, 1);  
        RETURN;  
    END;  
  
    -- Ensure the source entity version is not the target of another sync relationship (the user should copy the original source entity, not try to copy the copy).   
    IF EXISTS(SELECT 1  
              FROM mdm.tblSyncRelationship  
              WHERE TargetEntity_ID = @SourceEntity_ID  
                AND TargetVersion_ID = @SourceVersion_ID)  
    BEGIN  
        RAISERROR('MDSERR200203|Sync source entity is not valid. It is a target entity in another sync relationship.', 16, 1);  
        RETURN;  
    END  
  
    -- Lookup target model ID and verify user is model admin  
    DECLARE @TargetModelPrivilege_ID TINYINT  
    EXEC mdm.udpInformationLookupModel @User_ID = @User_ID, @Model_MUID = @TargetModel_MUID, @Model_Name = @TargetModelName, @ID = @TargetModel_ID OUTPUT, @Privilege_ID = @TargetModelPrivilege_ID OUTPUT;  
    IF @TargetModel_ID IS NULL OR COALESCE(@TargetModelPrivilege_ID, @PermissionType_Deny) <> @PermissionType_Admin  
    BEGIN  
        -- Either the model doesn't exist, or the user doesn't have permission to see it.  
        RAISERROR('MDSERR200204|Sync target model ID is not valid or the user does not have sufficient permission.', 16, 1);  
        RETURN;  
    END;  
  
    -- Lookup target version ID. Note: not using udpInformationLookupVersion to avoid needlessly querying the model security view again.  
    SELECT @TargetVersion_ID = ID  
    FROM mdm.tblModelVersion   
    WHERE  
            (@TargetVersion_MUID IS NOT NULL OR @TargetVersionName IS NOT NULL)   
        AND (@TargetVersion_MUID IS NULL OR MUID = @TargetVersion_MUID)   
        AND (@TargetVersionName IS NULL OR Name = @TargetVersionName)  
        AND Model_ID = @TargetModel_ID;  
    IF @TargetVersion_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR200205|Sync target version ID is not valid.', 16, 1);  
        RETURN;  
    END;  
  
    -- Ensure source and target models are different.  
    IF @SourceModel_ID = @TargetModel_ID  
    BEGIN  
        RAISERROR('MDSERR200206|Sync source and target models must be different.', 16, 1);  
        RETURN;  
    END  
  
    -- Lookup target entity ID, if provided  
    IF (@TargetEntity_MUID IS NOT NULL OR @TargetEntityName IS NOT NULL)  
    BEGIN  
        EXEC mdm.udpInformationLookupEntity @User_ID = @User_ID, @Model_ID = @TargetModel_ID, @Entity_MUID = @TargetEntity_MUID, @Entity_Name = @TargetEntityName, @ID = @TargetEntity_ID OUTPUT--, @Name = @TargetEntityName OUTPUT, @MUID = @TargetEntity_MUID OUTPUT;  
        IF @TargetEntity_ID IS NULL  
        BEGIN  
            IF (@TargetEntityName IS NULL)  
            BEGIN  
                -- Create new entity with specified MUID and source's name  
                SET @TargetEntityName = @SourceEntityName;  
            END ELSE  
            BEGIN  
                -- Create new entity with specified Name and random MUID  
                SET @TargetEntity_MUID = NEWID();  
            END  
        END;  
    END ELSE  
    BEGIN  
        -- No target entity id or name provided. Use the source entity's name.  
  
        -- See if the target model already has an entity with that name  
        SET @TargetEntityName = @SourceEntityName;  
        EXEC mdm.udpInformationLookupEntity @User_ID = @User_ID, @Model_ID = @TargetModel_ID, @Entity_Name = @TargetEntityName, @ID = @TargetEntity_ID OUTPUT, @MUID = @TargetEntity_MUID OUTPUT;  
        IF @TargetEntity_ID IS NULL  
        BEGIN  
            -- Create new entity with random MUID  
            SET @TargetEntity_MUID = NEWID();  
        END;  
    END;  
  
    -- If other version(s) of the target entity is/are the target(s) other sync relationship(s), verify the new source entity is the same as the other source entities (can be same or different versions of the source entities)  
    IF @TargetEntity_ID IS NOT NULL AND  
        EXISTS (SELECT 1   
                FROM mdm.tblSyncRelationship  
                WHERE   TargetEntity_ID = @TargetEntity_ID  
                    AND SourceEntity_ID <> @SourceEntity_ID  
               )  
    BEGIN  
        RAISERROR('MDSERR200207|The target entity already has a sync relationship with a different source entity.', 16, 1);  
        RETURN;  
    END;  
  
    DECLARE @TargetEntityNameIsAliased BIT = CASE WHEN @SourceEntityName = @TargetEntityName THEN 0 ELSE 1 END;  
  
    --Start transaction, being careful to check if we are nested  
    DECLARE @TranCounter INT = @@TRANCOUNT;  
    IF @TranCounter > 0 SAVE TRANSACTION TX;  
    ELSE BEGIN TRANSACTION;  
  
    BEGIN TRY  
  
        DECLARE   
             @OldSourceEntity_ID INT  
            ,@OldSourceVersion_ID INT;  
  
        -- Create the entity, if it doesn't already exist. Note: the sync process will ensure the target entity matches the source (including creating attributes). But the entity  
        -- must be added here because of the FK relationship (tblSyncRelationship.TargetEntity_ID => tblEntity.ID)  
        IF @TargetEntity_ID IS NULL  
        BEGIN  
            -- Get source entity properties to be copied  
            DECLARE   
                 @Description       NVARCHAR(500)  
                ,@IsBase            BIT  
                ,@DataCompression   TINYINT  
                ,@EditMode_Create   TINYINT = 0  
                ,@EnterDTM          DATETIME2(3)  
                ,@EnterUserID       INT  
                ;  
  
            SELECT  
                 @Description = [Description]  
                ,@IsBase = IsBase  
                ,@DataCompression = DataCompression  
                ,@EnterDTM = EnterDTM  
                ,@EnterUserID  = EnterUserID  
            FROM mdm.tblEntity  
            WHERE ID = @SourceEntity_ID  
  
PRINT CONCAT(SYSDATETIME(), N': Creating TargetEntity ''', @TargetEntityName, N'''');  
            EXEC mdm.udpEntitySave   
                 @User_ID = @User_ID  
                ,@Model_ID = @TargetModel_ID  
                ,@Entity_MUID = @TargetEntity_MUID  
                ,@EntityName = @TargetEntityName  
                ,@Description = @Description  
                ,@IsBase = @IsBase  
                ,@StagingBase = NULL -- Let a unique StagingBase be auto-generated  
                ,@CodeGenSeed = NULL -- Do not copy source entity CodeGenSeed. Only sync will be adding members to this entity, so automatic member code generation is N/A  
                ,@EditMode = @EditMode_Create  
                ,@DataCompression = @DataCompression  
                ,@TransactionLogType = @TransactionLogType_None  
                ,@IsSync = 1  
                ,@RecreateStagingProc = 0 -- For efficiency, will update the sproc only after all entity and attribute metadata changes have been made  
                ,@Return_ID = @TargetEntity_ID OUTPUT  
                ;  
PRINT CONCAT(SYSDATETIME(), N': Created TargetEntity ''', @TargetEntityName, N''' (ID = ', @TargetEntity_ID, N')');  
  
            -- Update created entity's audit info to match source entity  
            UPDATE mdm.tblEntity  
            SET  EnterDTM = @EnterDTM  
                ,EnterUserID  = @EnterUserID  
            WHERE ID = @TargetEntity_ID  
  
			-- Update the system Attributes properties  
			UPDATE tgt  
			SET ChangeTrackingGroup = src.ChangeTrackingGroup  
			,DisplayName = src.DisplayName  
			,Description = src.Description  
			,SortOrder = src.SortOrder  
			FROM mdm.tblAttribute src  
			INNER JOIN mdm.tblAttribute tgt  
			ON src.Entity_ID = @SourceEntity_ID  
			AND tgt.Entity_ID = @TargetEntity_ID  
			AND src.MemberType_ID = tgt.MemberType_ID  
			AND src.Name = tgt.Name  
			AND src.Name IN (N'Name', N'Code')  
  
        END ELSE -- create entity  
        BEGIN  
  
            -- The target entity already exists. It may-or-may-not be a target in an existing relationship. If so, update the sync table.  
            DECLARE @OldSource TABLE  
            (  
                 SourceEntity_ID INT  
                ,SourceVersion_ID INT  
            );  
  
            -- update the sync table  
            UPDATE mdm.tblSyncRelationship  
            SET  
                 SourceEntity_ID = @SourceEntity_ID  
                ,SourceVersion_ID = @SourceVersion_ID  
                ,TargetEntityNameIsAliased = @TargetEntityNameIsAliased  
                ,RefreshFrequencyInHours = @FrequencyInHours  
                ,LastChgDTM = GETUTCDATE()  
                ,LastChgUserID = @User_ID  
  
                -- If changing the target's source, clear out the last sync columns, otherwise leave unchanged.  
                ,LastSuccessfulSyncTimestamp = CASE WHEN SourceVersion_ID <> @SourceVersion_ID OR SourceEntity_ID <> @SourceEntity_ID THEN NULL ELSE LastSuccessfulSyncTimestamp END  
                ,LastSuccessfulSyncDTM = CASE WHEN SourceVersion_ID <> @SourceVersion_ID OR SourceEntity_ID <> @SourceEntity_ID THEN NULL ELSE LastSuccessfulSyncDTM END  
            OUTPUT   
                 deleted.SourceEntity_ID, deleted.SourceVersion_ID INTO @OldSource  
            WHERE   TargetEntity_ID = @TargetEntity_ID  
                AND TargetVersion_ID = @TargetVersion_ID  
  
            SELECT TOP 1 -- there should never be more than one row in the table  
                 @OldSourceEntity_ID = SourceEntity_ID  
                ,@OldSourceVersion_ID = SourceVersion_ID  
            FROM @OldSource;  
  
        END; -- update sync table  
  
        IF @OldSourceEntity_ID IS NULL  
        BEGIN  
            -- Existing row wasn't found, insert new row  
            INSERT INTO mdm.tblSyncRelationship  
            (  
                 SourceEntity_ID  
                ,SourceVersion_ID  
                ,TargetEntity_ID  
                ,TargetVersion_ID  
                ,TargetEntityNameIsAliased  
                ,RefreshFrequencyInHours  
                ,EnterUserID  
                ,LastChgUserID  
            )  
            VALUES  
            (  
                 @SourceEntity_ID  
                ,@SourceVersion_ID  
                ,@TargetEntity_ID  
                ,@TargetVersion_ID  
                ,@TargetEntityNameIsAliased  
                ,@FrequencyInHours  
                ,@User_ID  
                ,@User_ID  
            );  
        END;  
  
        IF     @OldSourceEntity_ID IS NULL   
            OR @OldSourceEntity_ID <> @SourceEntity_ID   
            OR @OldSourceVersion_ID <> @SourceVersion_ID  
        BEGIN  
            -- A new source was added (either changing an existing sync relationship or adding a new one). The EN table needs to be changed  
            -- Add/clear Source_ID column  
            DECLARE   
                 @TargetEntity_EN_TableName SYSNAME  
                ,@TargetEntity_DataCompression TINYINT  
                ,@Source_IDColumnName SYSNAME = N'Source_ID'  
                ,@Source_LastChgTSColumnName sysname = N'Source_LastChgTS'  
                ,@SQL NVARCHAR(MAX);  
  
            SELECT   
                 @TargetEntity_EN_TableName = EntityTable  
                ,@TargetEntity_DataCompression = DataCompression  
            FROM mdm.tblEntity   
            WHERE ID = @TargetEntity_ID;  
  
            DECLARE @Table_ID INT = (SELECT object_id FROM sys.tables WHERE name = @TargetEntity_EN_TableName and schema_id = schema_id('mdm'));  
            IF EXISTS(SELECT 1 FROM sys.columns c  
                          WHERE name = @Source_IDColumnName  
                            AND c.object_id = @Table_ID)  
            BEGIN  
                -- The Source_ID column already exists, so just clear it out (but only for the specified target version).  
PRINT CONCAT(SYSDATETIME(), N': Clearing sync columns in table ', @TargetEntity_EN_TableName)  
                SET @SQL = CONCAT(N'  
UPDATE mdm.', QUOTENAME(@TargetEntity_EN_TableName), N'  
SET ', QUOTENAME(@Source_IDColumnName), N' = NULL  
    ,', QUOTENAME(@Source_LastChgTSColumnName), N' = NULL  
WHERE Version_ID = @TargetVersion_ID');  
            END ELSE  
            BEGIN  
                -- The Source_ID column does not exist, so create it.  
PRINT CONCAT(SYSDATETIME(), N': Adding sync columns to table mdm.', @TargetEntity_EN_TableName)  
                DECLARE   
                     @Source_IDIndexName sysname = CONCAT('ix_', @TargetEntity_EN_TableName, N'_Version_ID_', @Source_IDColumnName, N'_', @Source_LastChgTSColumnName)  
                    ,@IndexOptions NVARCHAR(MAX) = mdm.udfGetIndexOptions(@TargetEntity_DataCompression, @TargetModel_ID);  
  
                SET @SQL = CONCAT(N'  
ALTER TABLE mdm.', QUOTENAME(@TargetEntity_EN_TableName), N' ADD ', QUOTENAME(@Source_IDColumnName), N' INT NULL;  
ALTER TABLE mdm.', QUOTENAME(@TargetEntity_EN_TableName), N' ADD ', QUOTENAME(@Source_LastChgTSColumnName), N' VARBINARY(8) NULL;  
CREATE NONCLUSTERED INDEX ', QUOTENAME(@Source_IDIndexName), N' ON mdm.', QUOTENAME(@TargetEntity_EN_TableName), N'(Version_ID, ', QUOTENAME(@Source_IDColumnName), N', ', QUOTENAME(@Source_LastChgTSColumnName), N')  
' + @IndexOptions + N';');  
            END;  
            EXEC sp_executesql @SQL, N'@TargetVersion_ID INT', @TargetVersion_ID;  
PRINT CONCAT(SYSDATETIME(), N': Done altering table mdm.', @TargetEntity_EN_TableName)  
  
            -- Copy from source to target entity version. This is inside the IF block because merely updating the sync interval of an existing sync relationship shouldn't trigger a new sync.  
            EXEC mdm.udpSyncRefresh @User_ID = @User_ID, @TargetModel_ID = @TargetModel_ID, @TargetVersion_ID = @TargetVersion_ID, @TargetEntity_ID = @TargetEntity_ID, @CorrelationID = @CorrelationID;  
        END;  
  
  
        --Commit only if we are not nested  
        IF @TranCounter = 0 COMMIT TRANSACTION;  
  
    END TRY  
    --Compensate as necessary  
    BEGIN CATCH  
  
        -- Get error info.  
        DECLARE  
            @ErrorMessage NVARCHAR(4000),  
            @ErrorSeverity INT,  
            @ErrorState INT,  
            @ErrorNumber INT,  
            @ErrorLine INT,  
            @ErrorProcedure NVARCHAR(126);  
        EXEC mdm.udpGetErrorInfo  
            @ErrorMessage = @ErrorMessage OUTPUT,  
            @ErrorSeverity = @ErrorSeverity OUTPUT,  
            @ErrorState = @ErrorState OUTPUT,  
            @ErrorNumber = @ErrorNumber OUTPUT,  
            @ErrorLine = @ErrorLine OUTPUT,  
            @ErrorProcedure = @ErrorProcedure OUTPUT  
  
        SET @ErrorMessage = CONCAT(@ErrorMessage, N', @ErrorNumber = ', @ErrorNumber, N', @ErrorProcedure = "', @ErrorProcedure, N'", line ', @ErrorLine);  
  
        IF @TranCounter = 0 ROLLBACK TRANSACTION;  
        ELSE IF XACT_STATE() <> -1 ROLLBACK TRANSACTION TX;  
  
        RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);  
    END CATCH;  
  
    -- Send the message  
	EXEC mdm.udpPerformanceQueueSave;  
  
    SET NOCOUNT OFF;  
END -- Proc
GO
/****** Object:  StoredProcedure [mdm].[udpSyncRelationshipsGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
Returns all sync relationships, filtered by the given user's permissions.  
*/  
CREATE PROCEDURE [mdm].[udpSyncRelationshipsGet]  
(  
     @User_ID           INT -- -- Must have permission to see source and target entities  
    ,@CorrelationID     UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS  
BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE @PermissionType_Deny TINYINT = 1;  
  
    SELECT  
         sm.ID SourceModel_ID  
        ,sm.MUID SourceModel_MUID  
        ,sm.Name SourceModelName  
  
        ,sr.SourceVersion_ID  
        ,sv.MUID SourceVersion_MUID  
        ,sv.Name SourceVersionName  
  
        ,sr.SourceEntity_ID  
        ,se.MUID SourceEntity_MUID  
        ,se.Name SourceEntity_Name  
      
        ,tm.ID TargetModel_ID  
        ,tm.MUID TargetModel_MUID  
        ,tm.Name TargetModelName  
  
        ,sr.TargetVersion_ID  
        ,tv.MUID TargetVersion_MUID  
        ,tv.Name TargetVersionName  
  
        ,sr.TargetEntity_ID  
        ,te.MUID TargetEntity_MUID  
        ,te.Name TargetEntityName  
  
        --,sr.TargetEntityNameIsAliased  
        ,sr.RefreshFrequencyInHours  
  
        ,sr.LastSuccessfulSyncDTM  
        ,sr.LastSyncAttemptDTM  
        ,sr.LastSyncAttemptStatus  
        ,sr.LastSyncAttemptErrorInfo  
  
        ,sr.EnterDTM  
        ,sr.EnterUserID  
        ,eu.MUID EnterUserMUID  
        ,eu.UserName EnterUserName  
        ,sr.LastChgDTM  
        ,sr.LastChgUserID  
        ,lcu.MUID LastChgUserMUID  
        ,lcu.UserName LastChgUserName  
        --,LastChgTS  
  
    FROM mdm.tblSyncRelationship sr  
    INNER JOIN mdm.tblModelVersion sv  
    ON sr.SourceVersion_ID = sv.ID  
    INNER JOIN mdm.tblModel sm  
    ON sv.Model_ID = sm.ID  
    INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_ENTITY ses  
    ON      sr.SourceEntity_ID = ses.ID  
        AND ses.User_ID = @User_ID  
        AND ses.Privilege_ID > @PermissionType_Deny  
    INNER JOIN mdm.tblEntity se  
    ON sr.SourceEntity_ID = se.ID  
    INNER JOIN mdm.tblModelVersion tv  
    ON sr.TargetVersion_ID = tv.ID  
    INNER JOIN mdm.tblModel tm  
    ON tv.Model_ID = tm.ID  
    INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_ENTITY tes  
    ON  sr.TargetEntity_ID = tes.ID  
        AND tes.User_ID = @User_ID  
        AND tes.Privilege_ID > @PermissionType_Deny  
    INNER JOIN mdm.tblEntity te  
    ON sr.TargetEntity_ID = te.ID  
    LEFT JOIN mdm.tblUser eu  
    ON sr.EnterUserID = eu.ID  
    LEFT JOIN mdm.tblUser lcu  
    ON sr.LastChgUserID = lcu.ID  
  
  
    SET NOCOUNT OFF;  
END -- Proc
GO
/****** Object:  StoredProcedure [mdm].[udpSystemDomainListGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
    EXEC mdm.udpSystemDomainListGet NULL, NULL, NULL  
    EXEC mdm.udpSystemDomainListGet 'lstBRItemTypeSubCategory'  
    EXEC mdm.udpSystemDomainListGet 'lstInputMask', null  
    EXEC mdm.udpSystemDomainListGet 'lstInputMask', 1  
    EXEC mdm.udpSystemDomainListGet '',null  
  
   SELECT * FROM mdm.tblList  
*/  
CREATE PROCEDURE [mdm].[udpSystemDomainListGet]   
(  
    @ListCode       NVARCHAR(50) = NULL,  
    @ListGroup_ID   INT = NULL,  
    @ListOption     NVARCHAR(250) = NULL,  
    @ListItem       mdm.MemberCodes READONLY,  
    @CorrelationID  UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
  
    SET NOCOUNT ON  
  
    SELECT   
         @ListCode = NULLIF(@ListCode, N'')  
        ,@ListOption = NULLIF(@ListOption, N'')  
  
    -- If the temp table is already defined, then the caller has specified in a temp table which items to return (and @ListCode will be ignored)  
    -- Otherwise, create the table and use @ListCode to populate it.  
  
    DECLARE @ListItem2 TABLE   
    (  
        Code   NVARCHAR(50) COLLATE DATABASE_DEFAULT PRIMARY KEY  
        ,Name   NVARCHAR(50) COLLATE DATABASE_DEFAULT  
    )  
  
    IF NOT EXISTS (SELECT 1 FROM @ListItem)  
    BEGIN  
        INSERT INTO @ListItem2  
        SELECT DISTINCT  
             ListCode AS Code  
            ,ListName AS Name  
        FROM mdm.tblList  
        WHERE ListCode = ISNULL(@ListCode, ListCode)  
    END  
    ELSE  
    BEGIN  
        INSERT INTO @ListItem2  
        SELECT DISTINCT  
             CONVERT(NVARCHAR(50), MemberCode) AS Code  
            ,CONVERT(NVARCHAR(50),MemberName) AS Name  
        FROM @ListItem  
    END  
  
    -- Return Code and Name  
    SELECT  
         Code  
        ,Name  
    FROM @ListItem2  
  
    -- Return item values  
    SELECT  
         sl.Code -- maps to the parent row of the previous result set  
        ,l.Group_ID     AS ListGroup  
        ,l.ListOption   AS Name  
        ,l.OptionID     AS Value  
    FROM @ListItem2 sl  
    INNER JOIN mdm.tblList l  
    ON sl.Code = l.ListCode  
    WHERE   l.Group_ID = ISNULL(@ListGroup_ID, l.Group_ID)  
        AND l.ListOption = ISNULL(@ListOption, l.ListOption)  
        AND IsVisible = 1  
    ORDER BY sl.Code, l.Seq  
  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpSystemEventSave]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    EXEC mdm.udpSystemEventSave 2, 1, N'ValidateModel', 2;  
    SELECT * FROM mdm.tblEvent;  
*/  
CREATE PROCEDURE [mdm].[udpSystemEventSave]  
(  
     @User_ID           INT    
    ,@Version_ID        INT    
    ,@Entity_ID         INT = NULL    
    ,@EventName         NVARCHAR(100)    
    ,@EventStatus_ID    TINYINT    
    ,@ErrorMsg         NVARCHAR(MAX) = NULL  
    ,@CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability    
)    
/*WITH*/    
AS BEGIN    
    SET NOCOUNT ON;    
    DECLARE @GuidEmpty                 UNIQUEIDENTIFIER = CAST(0x0 AS UNIQUEIDENTIFIER);    
    DECLARE @SQL                       NVARCHAR(MAX);    
    DECLARE @Permission_Deny		   INT = 1;    
    
    --Start transaction, being careful to check if we are nested    
    DECLARE @TranCounter INT;     
    SET @TranCounter = @@TRANCOUNT;    
    IF @TranCounter > 0 SAVE TRANSACTION TX;    
    ELSE BEGIN TRANSACTION;    
    
    BEGIN TRY    
  
        DECLARE @UpdateCount INT; --Instead of doing a complex IF EXISTS(), just try UPDATE and check if any rows were affected    
        UPDATE mdm.tblEvent SET    
            EventStatus_ID = ISNULL(@EventStatus_ID, EventStatus_ID),    
            LastChgUserID = @User_ID,    
            LastChgDTM = GETUTCDATE(),  
            ErrorMsg = @ErrorMsg   
        WHERE     
            EventName = @EventName     
            AND     
            (    
                (@Version_ID IS NULL) --Show all rows    
                OR (@Version_ID = 0 AND Version_ID IS NULL) --Show just the rows with NULL Version_ID    
                OR (Version_ID = @Version_ID) --Show just the rows with the specified Version_ID    
            )     
            AND    
            (    
                (@Entity_ID IS NULL) --Show all rows    
                OR (@Entity_ID = 0 AND Entity_ID IS NULL) --Show just the rows with NULL Entity_ID    
                OR (@Entity_ID = Entity_ID) --Show just the rows with the specified Entity_ID    
            );    
    
    
        SET @UpdateCount = @@ROWCOUNT; --This statement must be IMMEDIATELY after UPDATE clause    
                    
        IF @UpdateCount = 0 BEGIN --If no rows were updated, INSERT the value instead    
    
            INSERT INTO mdm.tblEvent    
            (    
                Version_ID,    
                Entity_ID,    
                EventName,    
                EventStatus_ID,    
                EnterUserID,    
                LastChgUserID,  
                ErrorMsg   
            )    
            VALUES    
            (    
                NULLIF(@Version_ID, 0), --0 is used as a magic token to represent 'row has no Version context'    
                NULLIF(@Entity_ID, 0), --0 is used as a magic token to represent 'row has no Entity context'    
                @EventName,    
                @EventStatus_ID,    
                @User_ID,    
                @User_ID,  
                @ErrorMsg		    
            );    
                
        END; --if    
    
        --Commit only if we are not nested    
        IF @TranCounter = 0 COMMIT TRANSACTION;    
        RETURN(0);    
    
    END TRY    
    --Compensate as necessary    
    BEGIN CATCH    
    
        -- Get error info.    
        DECLARE    
            @ErrorMessage NVARCHAR(4000),    
            @ErrorSeverity INT,    
            @ErrorState INT,    
            @ErrorNumber INT,    
            @ErrorLine INT,    
            @ErrorProcedure NVARCHAR(126);    
        EXEC mdm.udpGetErrorInfo    
            @ErrorMessage = @ErrorMessage OUTPUT,    
            @ErrorSeverity = @ErrorSeverity OUTPUT,    
            @ErrorState = @ErrorState OUTPUT,    
            @ErrorNumber = @ErrorNumber OUTPUT,    
            @ErrorLine = @ErrorLine OUTPUT,    
            @ErrorProcedure = @ErrorProcedure OUTPUT    
    
        SET @ErrorMessage = CONCAT(@ErrorMessage, N', @ErrorNumber = ', @ErrorNumber, N', @ErrorProcedure = "', @ErrorProcedure, N'", line ', @ErrorLine);    
    
        IF @TranCounter = 0 ROLLBACK TRANSACTION;    
        ELSE IF XACT_STATE() <> -1 ROLLBACK TRANSACTION TX;    
    
        RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);    
    
        --On error, return NULL results    
        --SELECT @Return_ID = NULL, @Return_MUID = NULL;    
        RETURN(1);    
    
    END CATCH;    
    
    SET NOCOUNT OFF;    
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpSystemGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
    Gets the record from tblSystem  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpSystemGet]  
(  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON  
  
    DECLARE @NeedsRepair    BIT = 1,  
            @DbName         NVARCHAR(MAX)  
  
    SET @DbName = DB_NAME()  
  
    -- A DB does not need repair if has both the broker enabled and trustworthy on  
    SELECT @NeedsRepair = 0 from sys.databases where name=@DbName AND is_broker_enabled=1 and is_trustworthy_on=1  
  
    SELECT TOP 1 [ID]  
      ,[SchemaVersion]  
      ,@@VERSION as [SQLServerVersion]  
      ,[EnterDTM]  
      ,[EnterUserID]  
      ,[LastChgUserID]  
      ,[LastChgDTM]  
      ,@NeedsRepair AS NeedsRepair  
       ,(select  
            compatibility_level  
         from sys.databases  
            where name = @DbName) as [CompatibilityLevel]  
      ,SERVERPROPERTY('Edition') AS Edition  
      ,SERVERPROPERTY('EngineEdition') AS EngineEdition  
    FROM [mdm].[tblSystem]  
    ORDER BY [ID]  
  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpSystemSave]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    The procedure assumes 1 and only 1 record should exists in the table.  
  
    exec mdm.udpSystemSave @SchemaVersion = '10.50.166.1234'  
*/  
CREATE PROCEDURE [mdm].[udpSystemSave]  
    @SchemaVersion NVARCHAR(250)=NULL,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
AS  
/*WITH*/  
BEGIN  
    SET NOCOUNT ON;  
  
    --Initialize output parameters and local variables  
    SELECT  
        @SchemaVersion = NULLIF(LTRIM(RTRIM(@SchemaVersion)), N'')  
  
    IF EXISTS(SELECT 1 FROM mdm.tblSystem)  
    BEGIN  
        BEGIN TRY  
  
                UPDATE mdm.tblSystem  
                 SET [SchemaVersion] = ISNULL(@SchemaVersion,[SchemaVersion])  
                  ,[LastChgUserID] = SYSTEM_USER  
                  ,[LastChgDTM] = GETUTCDATE()  
                 WHERE [ID] = (SELECT MAX([ID]) FROM mdm.tblSystem)  
  
            RETURN(0);  
  
        END TRY  
        --Compensate as necessary  
        BEGIN CATCH  
  
            -- Get error info.  
            DECLARE  
                @ErrorMessage NVARCHAR(4000),  
                @ErrorSeverity INT,  
                @ErrorState INT,  
                @ErrorNumber INT,  
                @ErrorLine INT,  
                @ErrorProcedure NVARCHAR(126);  
            EXEC mdm.udpGetErrorInfo  
                @ErrorMessage = @ErrorMessage OUTPUT,  
                @ErrorSeverity = @ErrorSeverity OUTPUT,  
                @ErrorState = @ErrorState OUTPUT,  
                @ErrorNumber = @ErrorNumber OUTPUT,  
                @ErrorLine = @ErrorLine OUTPUT,  
                @ErrorProcedure = @ErrorProcedure OUTPUT  
  
            SET @ErrorMessage = CONCAT(@ErrorMessage, N', @ErrorNumber = ', @ErrorNumber, N', @ErrorProcedure = "', @ErrorProcedure, N'", line ', @ErrorLine);  
  
            RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);  
  
            RETURN(1);  
  
        END CATCH;  
    END  
    SET NOCOUNT OFF;  
END;
GO
/****** Object:  StoredProcedure [mdm].[udpSystemSettingGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
declare @ret as NVARCHAR(500)  
exec mdm.udpSystemSettingGet 'BuiltInAdministrator',@ret OUTPUT  
select @ret  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpSystemSettingGet]  
(  
	@SettingName 	NVARCHAR(100),  
	@SettingValue 	NVARCHAR(max) = NULL OUTPUT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
	SET NOCOUNT ON  
  
	SELECT	@SettingValue = SettingValue  
	FROM	mdm.tblSystemSetting  
	WHERE	SettingName = @SettingName  
  
	SET @SettingValue = ISNULL(@SettingValue, CAST(N'' AS NVARCHAR(max)) )  
  
	SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpSystemSettingGroupGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
EXEC mdm.udpSystemSettingGroupGet   
EXEC mdm.udpSystemSettingGroupGet @Group_Name = 'Email'  
exec mdm.udpSystemSettingGroupGet @Group_ID=NULL,@Group_MUID=0x0,@Group_Name=N'Email'  
  
*/  
CREATE PROCEDURE [mdm].[udpSystemSettingGroupGet]   
(  
     @Group_MUID UNIQUEIDENTIFIER = NULL  
    ,@Group_Name NVARCHAR(50) = NULL  
    ,@CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS N'mds_schema_user'   
AS BEGIN  
  
    SET NOCOUNT ON  
  
    SET @Group_MUID = NULLIF(@Group_MUID, 0x0);  
    SET @Group_Name = NULLIF(@Group_Name, N'');   
  
    DECLARE @SelectedGroup TABLE   
    (  
        ID  INT PRIMARY KEY  
    )  
    INSERT INTO @SelectedGroup  
    SELECT ID  
    FROM mdm.tblSystemSettingGroup g  
    WHERE   MUID = ISNULL(@Group_MUID, MUID)  
        AND GroupName = ISNULL(@Group_Name, GroupName)  
  
    SELECT  
         g.MUID         AS Group_MUID  
        ,g.GroupName    AS Group_Name  
        ,sg.ID          AS Group_ID  
          
        ,g.Description  
        ,g.DisplayName  
        ,g.DisplaySequence  
    FROM @SelectedGroup sg  
    INNER JOIN mdm.tblSystemSettingGroup g  
    ON sg.ID = g.ID  
    ORDER BY g.DisplaySequence  
  
  
    SELECT  
         s.MUID           AS Setting_MUID  
        ,s.SettingName    AS Setting_Name  
        ,s.ID             AS Setting_ID  
  
        ,s.SystemSettingGroup_ID  AS Group_ID  
              
        ,s.DataType_ID   
        ,s.Description  
        ,s.DisplayName  
        ,s.DisplaySequence  
        ,s.IsVisible  
        ,s.MaxValue  
        ,s.MinValue  
        ,s.SettingType_ID  
        ,s.SettingValue  
        ,s.SettingValueDomainName  
    FROM @SelectedGroup sg  
    INNER JOIN mdm.viw_SYSTEM_SCHEMA_SYSTEMSETTINGS s  
    ON sg.ID = s.SystemSettingGroup_ID  
    ORDER BY s.SystemSettingGroup_ID, s.DisplaySequence  
  
  
    -- load a temp table with the list codes to get  
    DECLARE @ListItem mdm.MemberCodes;  
  
    INSERT INTO @ListItem (MemberCode, MemberName)  
    SELECT DISTINCT  
         s.SettingValueDomainName   AS MemberCode  
        ,l.ListName                 AS MemberName  
    FROM @SelectedGroup sg  
    INNER JOIN mdm.viw_SYSTEM_SCHEMA_SYSTEMSETTINGS s  
    ON sg.ID = s.SystemSettingGroup_ID  
    INNER JOIN mdm.tblList l  
    ON s.SettingValueDomainName = l.ListCode  
    WHERE s.SettingValueDomainName IS NOT NULL  
  
  
    EXEC mdm.udpSystemDomainListGet @ListItem = @ListItem, @CorrelationID = @CorrelationID  
  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpSystemSettingSave]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    EXEC mdm.udpSystemSettingSave 1,'SiteTitle','MDS (Master Data Services)',1,'Site Title','The title of the application that shows up in the title bar of browser';  
    EXEC mdm.udpSystemSettingSave 1,'eDMAdminEmailAddress','test1@mdm.com',null,null,null;  
  
    select * from mdm.tblSystemSetting;  
    SELECT * FROM msdb.dbo.sysmail_account WHERE [name] = N'MDM_Email_Account';  
*/  
CREATE PROCEDURE [mdm].[udpSystemSettingSave]  
(  
    @User_ID            INT,  
    @SettingName		NVARCHAR(100),  
    @SettingValue		NVARCHAR(max),  
    @IsVisible			BIT = NULL,  
    @DisplayName		NVARCHAR(100) = NULL,  
    @Description		NVARCHAR(250) = NULL,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE  
        @ID INT,  
        @SettingType_ID TINYINT,  
        @DataType_ID TINYINT,  
        @MinValue NVARCHAR(200),  
        @MaxValue NVARCHAR(200),  
        @ListCode NVARCHAR(50),  
        @ExistingSettingValue NVARCHAR(max),  
        @NumericSettingValue FLOAT  
          
    SELECT  
        @ID = ID,  
        @ExistingSettingValue = SettingValue,  
        @SettingType_ID = SettingType_ID,  
        @DataType_ID = DataType_ID,  
        @MinValue = MinValue,  
        @MaxValue = MaxValue,  
        @ListCode = ListCode  
    FROM mdm.tblSystemSetting  
    WHERE SettingName = @SettingName  
  
    DECLARE @SettingValueHasReservedCharacters BIT;  
    EXEC mdm.udpMetadataItemReservedCharactersCheck @SettingValue, @SettingValueHasReservedCharacters OUTPUT;  
  
    DECLARE @DisplayNameHasReservedCharacters BIT;  
    EXEC mdm.udpMetadataItemReservedCharactersCheck @DisplayName, @DisplayNameHasReservedCharacters OUTPUT;  
  
    DECLARE @DescriptionHasReservedCharacters BIT;  
    EXEC mdm.udpMetadataItemReservedCharactersCheck @Description, @DescriptionHasReservedCharacters OUTPUT;  
  
    IF @SettingValueHasReservedCharacters = 1 OR @DisplayNameHasReservedCharacters = 1 OR @DescriptionHasReservedCharacters = 1  
    BEGIN  
        RAISERROR('MDSERR100057|The system setting cannot be updated because it contains characters that are not valid.', 16, 1);  
        RETURN;  
    END; --if  
  
    IF @ID IS NOT NULL BEGIN  
        --Start transaction, being careful to check if we are nested  
        DECLARE @TranCounter INT;   
        SET @TranCounter = @@TRANCOUNT;  
        IF @TranCounter > 0 SAVE TRANSACTION TX;  
        ELSE BEGIN TRANSACTION;  
  
        BEGIN TRY		  
  
            --Validate setting value.  
            IF @SettingType_ID = 2   
            BEGIN  
                IF ISNUMERIC(@SettingValue) = 0   
                    RAISERROR('MDSERR200043|The system setting cannot be saved. The setting value must be a number.', 16, 1);  
                ELSE  
                    IF mdm.udfIsValidListOptionID(@ListCode, CAST(@SettingValue AS INT), NULL) = 0   
                    BEGIN  
                        RAISERROR('MDSERR200042|The system setting cannot be saved. The setting is not a valid value.', 16, 1);  
                    END; --if					  
            END   
            ELSE BEGIN  
                IF @DataType_ID = 2 BEGIN  
                    IF @SettingValue IS NOT NULL BEGIN  
                        IF ISNUMERIC(@SettingValue) = 0 BEGIN  
                            RAISERROR('MDSERR200043|The system setting cannot be saved. The setting value must be a number.', 16, 1);  
                        END ELSE BEGIN  
                            SET @NumericSettingValue = CAST(@SettingValue AS FLOAT)  
                            IF ISNUMERIC(@MinValue) = 1 AND @NumericSettingValue < CAST(@MinValue AS FLOAT) BEGIN  
                                    RAISERROR('MDSERR200044|The system setting cannot be saved. The setting value cannot be less than the minimum value allowed.', 16, 1);  
                            END; --if  
  
                            IF ISNUMERIC(@MaxValue) = 1 AND @NumericSettingValue > CAST(@MaxValue AS FLOAT) BEGIN  
                                    RAISERROR('MDSERR200045|The system setting cannot be saved. The setting value cannot be greater than the maximum value allowed.', 16, 1);  
                            END; --if  
                        END; --if  
                    END; --if  
                END; --if  
            END; --if  
          
            --Update the value  
            UPDATE mdm.tblSystemSetting SET   
                SettingValue = ISNULL(@SettingValue, N''),  
  
                IsVisible = ISNULL(@IsVisible, IsVisible),  
                DisplayName = ISNULL(@DisplayName, DisplayName),  
                [Description] = ISNULL(@Description, [Description]),  
  
                LastChgUserID = @User_ID,  
                LastChgDTM = GETUTCDATE()  
            WHERE   
                SettingName = @SettingName;  
  
            --Commit only if we are not nested  
            IF @TranCounter = 0 COMMIT TRANSACTION;  
  
        END TRY  
  
        BEGIN CATCH  
            IF @TranCounter = 0 ROLLBACK TRANSACTION;  
            ELSE IF XACT_STATE() <> -1 ROLLBACK TRANSACTION TX;  
  
            DECLARE @ErrorNumber INT;  
  
            SELECT   
                @ErrorNumber = ERROR_NUMBER();  
  
            IF (@ErrorNumber = 200042)  
                RAISERROR('MDSERR200042|The system setting cannot be saved. The setting is not a valid value.', 16, 1);  
            ELSE IF (@ErrorNumber = 200043)  
                RAISERROR('MDSERR200043|The system setting cannot be saved. The setting value must be a number.', 16, 1);  
            ELSE IF (@ErrorNumber = 200044)  
                RAISERROR('MDSERR200044|The system setting cannot be saved. The setting value cannot be less than the minimum value allowed.', 16, 1);  
            ELSE IF (@ErrorNumber = 200045)  
                RAISERROR('MDSERR200045|The system setting cannot be saved. The setting value cannot be greater than the maximum value allowed.', 16, 1);  
            ELSE  
                RAISERROR('MDSERR200046|The system setting cannot be saved.', 16, 1);  
  
            RETURN  
  
        END CATCH;  
                          
    END ELSE BEGIN  
        RAISERROR('MDSERR200041|The system setting cannot be saved. The setting name is not valid.', 16, 1);  
        RETURN		  
    END; --if  
  
    RETURN(0);  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpTablePartitionCheck]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
/*  
EXEC udpTablePartitionCheck  
*/  
CREATE PROCEDURE [mdm].[udpTablePartitionCheck]  
/*WITH*/  
AS BEGIN  
    IF mdm.udfIsEnterpriseEdition() = 1  
    BEGIN  
        DECLARE @ModelID INT,  
                @VersionID INT;  
        DECLARE versionID_cursor CURSOR  
        FOR SELECT ID, Model_ID  
            FROM [mdm].[tblModelVersion];  
  
        OPEN versionID_cursor  
        FETCH NEXT FROM versionID_cursor INTO @VersionID, @ModelID  
  
        WHILE @@FETCH_STATUS = 0  
        BEGIN  
            EXEC mdm.udpTablePartitionSplit @ModelID, @VersionID;  
            FETCH NEXT FROM versionID_cursor INTO @VersionID, @ModelID  
        END  
  
        CLOSE versionID_cursor;  
        DEALLOCATE versionID_cursor;  
    END  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpTablePartitionQueueActivate]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
--Create SSB items  
CREATE QUEUE [mdm].[microsoft/mdm/queue/tablepartition] WITH STATUS = ON , RETENTION = OFF  ON [PRIMARY]  
CREATE SERVICE [microsoft/mdm/service/tablepartition]  AUTHORIZATION [dbo]  ON QUEUE [mdm].[microsoft/mdm/queue/tablepartition] ([microsoft/mdm/contract/tablepartition])  
CREATE MESSAGE TYPE [microsoft/mdm/message/tablepartition] AUTHORIZATION [dbo] VALIDATION = WELL_FORMED_XML  
CREATE CONTRACT [microsoft/mdm/contract/tablepartition] AUTHORIZATION [dbo] ([microsoft/mdm/message/tablepartition] SENT BY INITIATOR)  
  
  
--Alter the queue to use the SP we just created in an activated manner  
ALTER QUEUE mdm.[microsoft/mdm/queue/tablepartition]  
WITH STATUS = ON , RETENTION = OFF , ACTIVATION (  STATUS = ON , PROCEDURE_NAME = [mdm].[udpTablePartitionQueueActivate] , MAX_QUEUE_READERS = 1 , EXECUTE AS CALLER  )  
  
*/  
CREATE PROCEDURE [mdm].[udpTablePartitionQueueActivate]  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE  
         @message_type_name sysname  
        ,@handle            UNIQUEIDENTIFIER  
        ,@interval          INT  
        ,@body              XML;  
  
    --Initialize variables  
    SELECT @handle = NULL;  
  
    --Load interval setting from config, and check the defaults and ranges  
    SET @interval = 1800; --Protect against NULL values  
  
    BEGIN TRANSACTION  
  
    WAITFOR (  
        RECEIVE TOP(1)  
            @handle = [conversation_handle],  
            @message_type_name = message_type_name,  
            @body = CONVERT(XML,message_body)  
        FROM mdm.[microsoft/mdm/queue/tablepartition]  
    ), TIMEOUT 5000; --Always wait a constant time for any new messages  
  
    --Got a TIMER message  
    IF (@message_type_name = N'microsoft/mdm/message/tablepartition') BEGIN  
  
        --Start a new TIMER and COMMIT the transaction before we do the real work, to avoid poisoning  
        BEGIN CONVERSATION TIMER (@handle) TIMEOUT = @interval;  
        COMMIT TRANSACTION;  
        PRINT 'TablePartition received message';  
        --Do the real work here  
        DECLARE  
                @Model_ID       INT,  
                @Version_ID     INT;  
  
        SET @Model_ID = @body.value('/TablePartition[1]/Model_ID[1]','int');  
        SET @Version_ID = @body.value('/TablePartition[1]/Version_ID[1]','int');  
  
        BEGIN TRANSACTION  
        BEGIN TRY  
            EXEC mdm.udpTablePartitionSplit @Model_ID, @Version_ID;  
            COMMIT TRANSACTION  
        END TRY  
        BEGIN CATCH  
            ROLLBACK TRANSACTION  
        END CATCH  
    --Got an END DIALOG message  
    END ELSE IF (@message_type_name = N'http://schemas.microsoft.com/SQL/ServiceBroker/EndDialog') BEGIN  
  
        PRINT 'TablePartition EndDialog'  
  
    --Got ERROR message  
    END ELSE IF (@message_type_name = N'http://schemas.microsoft.com/SQL/ServiceBroker/Error') BEGIN  
  
        PRINT 'TablePartition Error'  
  
    --Timeout or unexpected message  
    END ELSE BEGIN  
  
        COMMIT TRANSACTION;  
  
    END; --if  
  
    SET NOCOUNT OFF;  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpTablePartitionQueueSave]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
  
CREATE PROCEDURE [mdm].[udpTablePartitionQueueSave]  
(  
    @Model_ID       INT,  
    @Version_ID     INT  
)  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON  
    --Insert a Message into the Service Broker Queue  
    DECLARE @xml AS XML;  
    SET @xml = (  
        SELECT  
            @Model_ID AS [Model_ID],  
            @Version_ID AS [Version_ID]  
        FOR XML PATH('TablePartition'), ELEMENTS  
    );  
  
    --try to get an existing conversation handle  
    DECLARE @conversationHandle UNIQUEIDENTIFIER = mdm.udfServiceGetConversationHandle(  
        N'microsoft/mdm/service/system',  
        N'microsoft/mdm/service/tablepartition');  
  
    --Start a new conversation if necessary  
    IF @conversationHandle IS NULL  
        BEGIN DIALOG @conversationHandle  
            FROM SERVICE [microsoft/mdm/service/system]   
            TO SERVICE N'microsoft/mdm/service/tablepartition'  
            ON CONTRACT [microsoft/mdm/contract/tablepartition]   
            WITH ENCRYPTION = OFF;  
  
    --Send a sample message  
    SEND ON CONVERSATION @conversationHandle MESSAGE TYPE [microsoft/mdm/message/tablepartition](@xml);  
  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpTablePartitionSplit]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpTablePartitionSplit]  
(  
    @Model_ID       INT,  
    @Version_ID     INT  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    IF mdm.udfIsEnterpriseEdition() = 1  
    BEGIN  
        DECLARE @SQL NVARCHAR(MAX),  
                @PartitionSchema SYSNAME,  
                @PartitionFunction SYSNAME,  
                @PartitionId INT,  
                @TotalFileGroup INT,  
                @FileGroupName SYSNAME;  
        SET @PartitionSchema = CONCAT(N'udpsModel_', @Model_ID);  
        SET @PartitionFunction= CONCAT(N'udpfModel_', @Model_ID);  
  
        IF NOT EXISTS (  
            SELECT TOP 1 * FROM sys.partition_functions f  
            INNER JOIN sys.partition_range_values r ON f.function_id = r.function_id  
            WHERE f.name = @PartitionFunction AND r.value = @Version_ID  
        )  
        BEGIN  
  
            SET DEADLOCK_PRIORITY 10;  
  
            SELECT @PartitionId = MAX(boundary_id) FROM sys.partition_functions f  
            INNER JOIN sys.partition_range_values r ON f.function_id = r.function_id  
            WHERE f.name = @PartitionFunction  
            SET @PartitionId = ISNULL(@PartitionId, 0)  
  
            SELECT @TotalFileGroup = COUNT(name)  
            FROM sys.filegroups  
            WHERE is_read_only = 0  
  
            SELECT @FileGroupName = fgs.Name  
            FROM (  
                SELECT ROW_NUMBER() OVER (ORDER BY name ASC) AS ID,  
                       name as Name  
                FROM sys.filegroups  
                WHERE is_read_only = 0  
                ) fgs  
            WHERE fgs.ID = (@PartitionId % @TotalFileGroup) + 1  
  
            SET @SQL = CONCAT(N'ALTER PARTITION SCHEME ' , @PartitionSchema, N' NEXT USED ' , QUOTENAME(@FileGroupName));  
            EXEC sp_executesql @SQL;  
  
            SET @SQL = CONCAT(N'ALTER PARTITION FUNCTION ', @PartitionFunction, N'() SPLIT RANGE(', @Version_ID, N');');  
            EXEC sp_executesql @SQL;  
        END  
    END  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpTransactionAnnotationSave]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpTransactionAnnotationSave]  
(  
    @User_ID            INT,  
    @Model_ID           INT,  
    @Version_ID         INT,  
    @Transaction_ID     INT,  
    @Comment            NVARCHAR(500),  
    @Return_ID          INT = NULL OUTPUT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE @ID AS INT,  
            @CurrentDTM AS DATETIME2(3),  
            @AnnotationTableName sysname = NULL,  
            @SQL NVARCHAR(MAX);  
  
    --Initialize local variables  
    SELECT  
        @CurrentDTM = GETUTCDATE();  
  
    --Start transaction, being careful to check if we are nested  
    DECLARE @TranCounter INT;  
    SET @TranCounter = @@TRANCOUNT;  
    IF @TranCounter > 0 SAVE TRANSACTION TX;  
    ELSE BEGIN TRANSACTION AnnotationSave;  
  
    BEGIN TRY  
  
    --Test for invalid parameters  
        IF NOT EXISTS(SELECT ID FROM mdm.tblUser WHERE ID = @User_ID) --Invalid @User_ID  
        BEGIN  
            RAISERROR('MDSERR100010|The Parameters are not valid.', 16, 1);  
            RETURN(1);  
        END; --if  
  
        --Validate model  
        IF NOT EXISTS(SELECT ID FROM mdm.tblModel WHERE ID = @Model_ID)  
        BEGIN  
            RAISERROR('MDSERR100010|The Parameters are not valid.', 16, 1);  
            RETURN(1);  
        END  
  
        SET @AnnotationTableName = mdm.udfGetTransactionAnnotationTableName(@Model_ID);  
  
        BEGIN  
            --Insert the Annotation comment  
            SET @SQL = N'  
            INSERT INTO [mdm].' + QUOTENAME(@AnnotationTableName) + N'  
            (  
                 [Version_ID]  
                ,[Transaction_ID]  
                ,[EnterDTM]  
                ,[EnterUserID]  
                ,[LastChgDTM]  
                ,[LastChgUserID]  
                ,[Comment]  
            ) SELECT  
                @Version_ID,  
                @Transaction_ID,  
                @CurrentDTM,  
                @User_ID,  
                @CurrentDTM,  
                @User_ID,  
                @Comment  
            ';  
            EXEC sp_executesql @SQL, N'@Version_ID INT, @Transaction_ID INT, @CurrentDTM DATETIME2(3), @User_ID INT, @Comment NVARCHAR(500)',  
                                       @Version_ID,     @Transaction_ID,     @CurrentDTM,              @User_ID,     @Comment;  
  
            --Save the identity value  
            SET @ID = SCOPE_IDENTITY();  
  
            --Return values  
            SET @Return_ID = @ID;  
  
            --Commit only if we are not nested  
            IF @TranCounter = 0 COMMIT TRANSACTION AnnotationSave;  
            RETURN(0);  
        END;  
  
    END TRY  
    --Handle exceptions  
    BEGIN CATCH  
  
        -- Get error info.  
        DECLARE  
            @ErrorMessage NVARCHAR(4000),  
            @ErrorSeverity INT,  
            @ErrorState INT,  
            @ErrorNumber INT,  
            @ErrorLine INT,  
            @ErrorProcedure NVARCHAR(126);  
        EXEC mdm.udpGetErrorInfo  
            @ErrorMessage = @ErrorMessage OUTPUT,  
            @ErrorSeverity = @ErrorSeverity OUTPUT,  
            @ErrorState = @ErrorState OUTPUT,  
            @ErrorNumber = @ErrorNumber OUTPUT,  
            @ErrorLine = @ErrorLine OUTPUT,  
            @ErrorProcedure = @ErrorProcedure OUTPUT  
  
        SET @ErrorMessage = CONCAT(@ErrorMessage, N', @ErrorNumber = ', @ErrorNumber, N', @ErrorProcedure = "', @ErrorProcedure, N'", line ', @ErrorLine);  
  
        --Rollback appropriate transaction  
        IF @TranCounter = 0 ROLLBACK TRANSACTION AnnotationSave;  
        ELSE IF XACT_STATE() <> -1 ROLLBACK TRANSACTION TX;  
  
        RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);  
  
        --On error, return NULL results  
        SELECT @Return_ID = NULL;  
        RETURN(1);  
  
    END CATCH;  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpTransactionLogGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
EXEC  
    mdm.udpTransactionLogGet  
        @Model_MUID             = NULL,  
        @Model_Name             = NULL,  
        @Version_MUID            = NULL,  
        @Version_Name            = NULL,  
        @Entity_MUID            = NULL,  
        @Entity_Name            = NULL,  
        @MemberType_ID                = NULL,  
        @Attribute_MUID            = NULL,  
        @Attribute_Name            = NULL,  
        @ExplicitHierarchy_MUID = NULL,  
        @ExplicitHierarchy_Name = NULL,  
        @User_MUID                = NULL,  
        @User_Name                = NULL,  
        @MemberCode                = NULL,  
        @MemberMuid                = NULL,  
        @Transaction_ID            = NULL,  
        @TransactionType_ID        = NULL,  
        @NewValue                = NULL,  
        @PriorValue                = NULL,  
        @DateTimeBeginRange        = '2008-07-28 12:51:55.999',  
        @DateTimeEndRange        = NULL,  
        @PageNumber                = NULL,  
        @PageSize                = NULL,  
        @SortColumn                = NULL,  
        @SortDirection            = NULL,  
        @CountOnly                = 0,  
  
*/  
CREATE PROCEDURE [mdm].[udpTransactionLogGet]  
(  
     @SystemUser_ID          INT  
    ,@Model_MUID             UNIQUEIDENTIFIER = NULL  
    ,@Model_Name             NVARCHAR(MAX) = NULL  
    ,@Version_MUID           UNIQUEIDENTIFIER = NULL  
    ,@Version_Name           NVARCHAR(MAX) = NULL  
    ,@Entity_MUID            UNIQUEIDENTIFIER = NULL  
    ,@Entity_Name            NVARCHAR(MAX) = NULL  
    ,@MemberType_ID          TINYINT = NULL  
    ,@Attribute_MUID         UNIQUEIDENTIFIER = NULL  
    ,@Attribute_Name         NVARCHAR(MAX) = NULL  
    ,@ExplicitHierarchy_MUID UNIQUEIDENTIFIER = NULL  
    ,@ExplicitHierarchy_Name NVARCHAR(MAX) = NULL  
    ,@User_MUID              UNIQUEIDENTIFIER = NULL  
    ,@User_Name              NVARCHAR(MAX) = NULL  
    ,@MemberCode             NVARCHAR(MAX) = NULL  
    ,@Member_MUID            UNIQUEIDENTIFIER = NULL  
    ,@Transaction_ID         INT = NULL  
    ,@TransactionType_ID     INT = NULL  
    ,@NewValue               NVARCHAR(MAX) = NULL  
    ,@PriorValue             NVARCHAR(MAX) = NULL  
    ,@DateTimeBeginRange     DATETIME2(3) = NULL  
    ,@DateTimeEndRange       DATETIME2(3) = NULL  
    ,@PageNumber             INT = NULL  
    ,@PageSize               INT = NULL  
    ,@SortColumn             NVARCHAR(500) = NULL  
    ,@SortDirection          NVARCHAR(5) = NULL  
    ,@CountOnly              BIT = 0  
    ,@CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON  
    DECLARE  
         @SQL                   NVARCHAR(MAX)  
        ,@NoMatches             BIT = 0 -- This flag is used to skip doing additional filtering once a filter has been found that results in no matches.  
        ,@FilterByVersion       BIT = 0  
        ,@FilterByEntity        BIT = 0  
        ,@FilterByMemberType    BIT = 0  
        ,@FilterByAttribute     BIT = 0  
        ,@FilterByHierarchy     BIT = 0  
        ,@FilterByUser          BIT = 0  
        ,@FilterByMemberCode    BIT = 0  
        ,@FilterByMemberId      BIT = 0  
        ,@FilterByMemberMuid    BIT = 0  
  
        --Member Types  
        ,@MemberType_Unknown            TINYINT = 0  
        ,@MemberType_Leaf               TINYINT = 1  
        ,@MemberType_Consolidated       TINYINT = 2  
        ,@MemberType_Collection         TINYINT = 3  
  
        ,@StartRow    INT  
        ,@EndRow      INT  
  
        ,@CurrentRow_ID              INT  
        ,@CurrentEntity_ID           INT  
        ,@CurrentMemberTableName     NVARCHAR(258)  
        ,@CurrentSecurityTableName   SYSNAME  
        ,@CurrentMemberSecurity      BIT  
        ,@CurrentMemberType_ID       TINYINT  
        ,@AttributeExplorerMode      INT = 1  
        ,@IsFirstCTE                 BIT = 1  
        ,@IsModelAdmin               BIT  
        ,@CurrentCTE                 NVARCHAR(MAX)  
        ,@CurrentAcl                 NVARCHAR(MAX)  
  
        ,@Permission_Deny            TINYINT = 4  
  
        ,@WhereCriteria NVARCHAR(MAX) = N''  
        ,@From          NVARCHAR(MAX) = N''  
        ,@Join          NVARCHAR(MAX) = N''  
  
        --Transaction view name  
        ,@TransactionViewName NVARCHAR(258)  
  
        ,@Model_ID               INT = NULL  
        ,@Version_ID             INT = NULL  
        ,@Entity_ID              INT = NULL  
        ,@Attribute_ID           INT = NULL  
        ,@User_ID                INT = NULL  
  
        -- This pseudo-constant is for use in string concatenation operations to prevent string truncation. When concatenating two or more strings,  
        -- if none of the strings is an NVARCHAR(MAX) or an NVARCHAR constant that is longer than 4,000 characters, then the resulting string  
        -- will be silently truncated to 4,000 characters. Concatenating with this empty NVARCHAR(MAX), is sufficient to prevent truncation.  
        -- See http://connect.microsoft.com/SQLServer/feedback/details/283368/nvarchar-max-concatenation-yields-silent-truncation.  
        ,@TruncationGuard        NVARCHAR(MAX) = N''  
        ;  
  
    IF (@SortDirection IS NOT NULL AND UPPER(@SortDirection) <> N'ASC' AND UPPER(@SortDirection) <> N'DESC')  
    BEGIN  
        RAISERROR('MDSERR200086|Invalid Sort Direction.  Supported Values are ''ASC'' and ''DESC''.', 16, 1);  
        RETURN;  
    END;  
  
    SET @SortDirection = COALESCE(@SortDirection, N'ASC');  
    SET @PageNumber = COALESCE(@PageNumber, 1);  
    SET @Model_Name = NULLIF(@Model_Name, N'');  
    SET @Model_MUID = NULLIF(@Model_MUID, 0x0);  
    SET @Version_Name = NULLIF(@Version_Name, N'');  
    SET @Version_MUID = NULLIF(@Version_MUID, 0x0);  
    SET @Entity_Name = NULLIF(@Entity_Name, N'');  
    SET @Entity_MUID = NULLIF(@Entity_MUID, 0x0);  
    SET @Attribute_Name = NULLIF(@Attribute_Name, N'');  
    SET @Attribute_MUID = NULLIF(@Attribute_MUID, 0x0);  
    SET @ExplicitHierarchy_Name = NULLIF(@ExplicitHierarchy_Name, N'');  
    SET @ExplicitHierarchy_MUID = NULLIF(@ExplicitHierarchy_MUID, 0x0);  
    SET @User_Name = NULLIF(@User_Name, N'');  
    DECLARE @User_NameUpper NVARCHAR(MAX) = UPPER(@User_Name);  
    SET @User_MUID = NULLIF(@User_MUID, 0x0);  
    SET @MemberCode = NULLIF(@MemberCode, N'');  
    SET @Member_MUID = NULLIF(@Member_MUID, 0x0);  
  
    -- Replace null page size with default.  
    IF @PageSize IS NULL  
    BEGIN  
        SELECT @PageSize = CAST(SettingValue AS INT)  
        FROM mdm.tblSystemSetting  
        WHERE SettingName = N'RowsPerBatch';  
    END  
    SET @PageSize = COALESCE(@PageSize, 50);  
  
    -- Get start row.  
    IF @PageNumber <= 1  
    BEGIN  
        SET @PageNumber = 1;  
    END  
    SET @StartRow = ((@PageNumber - 1) * @PageSize) + 1;  
  
    -- Get the end row.  
    SET @EndRow = @PageNumber * @PageSize;  
  
    -- Prefilter various items (Models, Versions, Entities, Users, etc) on the table in which they are defined to get  
    -- a list of matching ID values. This is much less expensive that doing the same search directly against the transaction  
    -- view, which is typically much larger. For example, doing a LIKE comparison on tblModel.Name is much cheaper than doing it on system_transaction_viw.Model_Name  
    -- because tblModel typically won't have more than dozens (or even hundreds, in an extreme case) of rows, while the transaction  
    -- view could easily have millions of rows.  
  
    -- Find all models that match the provided criteria.  
    CREATE TABLE #ModelIds (ID INT PRIMARY KEY, IsAdministrator BIT);  
    INSERT INTO #ModelIds(ID, IsAdministrator)  
    SELECT DISTINCT m.ID, CASE acl.Privilege_ID WHEN 5 /*Admin*/ THEN 1 ELSE 0 END  
    FROM mdm.tblModel m  
    INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_MODEL acl  
    ON m.ID = acl.ID  
        AND acl.User_ID = @SystemUser_ID  
        AND acl.Privilege_ID <> 1 /*Deny*/  
    WHERE   (@Model_MUID IS NULL OR m.MUID    = @Model_MUID)  
        AND (@Model_Name IS NULL OR m.Name    = @Model_Name);  
  
    IF NOT EXISTS(SELECT 1 FROM #ModelIds)  
    BEGIN  
        --A valid model must be supplied  
        RAISERROR('MDSERR300005|The supplied model is not valid.', 16, 1);  
        RETURN;  
    END;  
  
        --Load the model ID we found  
    SELECT TOP 1  
        @Model_ID = ID,  
        @IsModelAdmin = IsAdministrator  
    FROM #ModelIds;  
  
        SET @TransactionViewName = mdm.udfGetTransactionViewName(@Model_ID);  
  
    IF @SortColumn IS NOT NULL  
    BEGIN  
        IF NOT EXISTS(  
            SELECT 1  
            FROM sys.columns c  
            INNER JOIN sys.views v  
            ON c.object_id = v.object_id  
            INNER JOIN sys.schemas s  
            ON v.schema_id = s.schema_id  
            WHERE   v.name =  @TransactionViewName  
                AND s.name = N'mdm'  
                AND c.name = @SortColumn)  
        BEGIN  
            RAISERROR('MDSERR200087|Sort Column not found in target table.', 16, 1);  
            RETURN;  
        END  
    END  
    ELSE  
    BEGIN  
        -- Sort by ID by default.  
        SET @SortColumn = CAST(N'ID' AS NVARCHAR(500))  
        -- Sort by Date Time by default.  
    END  
  
    -- Find all versions that match the provided criteria.  
    IF  @NoMatches = 0  
        AND(   @Version_MUID IS NOT NULL  
            OR @Version_Name IS NOT NULL)  
    BEGIN  
        SET @FilterByVersion = 1;  
  
        CREATE TABLE #VersionIds (ID INT PRIMARY KEY);  
        INSERT INTO #VersionIds(ID)  
        SELECT DISTINCT v.ID  
        FROM mdm.tblModelVersion v  
        INNER JOIN #ModelIds m  
        ON v.Model_ID = m.ID  
        WHERE   (@Version_MUID IS NULL OR v.MUID    = @Version_MUID)  
            AND (@Version_Name IS NULL OR v.Name LIKE @Version_Name);  
  
        IF NOT EXISTS(SELECT 1 FROM #VersionIds)  
        BEGIN  
            SET @NoMatches = 1;  
        END;  
    END;  
  
    -- Find all entities that match the provided criteria.  
    IF  @NoMatches = 0  
        AND(   @Entity_MUID IS NOT NULL  
            OR @Entity_Name IS NOT NULL)  
    BEGIN  
        SET @FilterByEntity = 1;  
  
        CREATE TABLE #EntityIds  
        (  
             Row_ID                         INT IDENTITY(1,1)  
            ,ID                             INT PRIMARY KEY  
            ,LeafMemberTableName            NVARCHAR(258) NULL  
            ,ConsolidatedMemberTableName    NVARCHAR(258) NULL  
            ,CollectionMemberTableName      NVARCHAR(258) NULL  
        );  
        INSERT INTO #EntityIds  
        (  
             ID  
            ,LeafMemberTableName  
            ,ConsolidatedMemberTableName  
            ,CollectionMemberTableName  
        )  
        SELECT DISTINCT  
             e.ID  
            ,e.EntityTable  
            ,e.HierarchyParentTable  
            ,e.CollectionTable  
        FROM mdm.tblEntity e  
        INNER JOIN #ModelIds m  
        ON e.Model_ID = m.ID  
  
        WHERE   (@Entity_MUID IS NULL OR e.MUID    = @Entity_MUID)  
            AND (@Entity_Name IS NULL OR e.Name    = @Entity_Name);  
  
        IF NOT EXISTS(SELECT 1 FROM #EntityIds)  
        BEGIN  
            SET @NoMatches = 1;  
        END ELSE  
        BEGIN  
            -- select the entity ID we just found  
            SELECT TOP 1  
                @Entity_ID = ID  
            FROM #EntityIds;  
        END;  
    END;  
  
    -- Set a flag indicating whether filtering should be done on member type. This is necessary so that the flag can be switched off, even  
    -- when a member type is specified, if a subsequent filter makes this one redundant.  
    IF @NoMatches = 0 AND @MemberType_ID IS NOT NULL  
    BEGIN  
        SET @FilterByMemberType = 1;  
    END;  
  
    -- Find all attributes that match the provided criteria.  
    IF  @NoMatches = 0  
        AND(   @Attribute_MUID IS NOT NULL  
            OR @Attribute_Name IS NOT NULL)  
    BEGIN  
        SET @FilterByAttribute = 1;  
  
        CREATE TABLE #AttributeIds (ID INT PRIMARY KEY);  
        SET @SQL = @TruncationGuard + N'  
        INSERT INTO #AttributeIds(ID)  
        SELECT DISTINCT a.ID  
        FROM mdm.tblAttribute a' +  
  
        -- If an entity filter also exists, then use it to further constrain the results.  
        CASE WHEN @FilterByEntity = 1 THEN N'  
        INNER JOIN #EntityIds e  
        ON a.Entity_ID = e.ID'  
  
        -- Or if there is no entity filter  
        ELSE N'  
        INNER JOIN mdm.tblEntity e  
        ON a.Entity_ID = e.ID  
        INNER JOIN mdm.tblModel m  
        ON e.Model_ID = m.ID'  
  
        END + N'  
        WHERE   (@Attribute_MUID IS NULL OR a.MUID             = @Attribute_MUID)  
            AND (@Attribute_Name IS NULL OR a.Name             = @Attribute_Name)  
            AND (@MemberType_ID  IS NULL OR a.MemberType_ID    = @MemberType_ID);';  
        -- PRINT @SQL  
        EXEC sp_executesql @SQL, N'@Attribute_MUID UNIQUEIDENTIFIER, @Attribute_Name NVARCHAR(100), @MemberType_ID TINYINT', @Attribute_MUID, @Attribute_Name, @MemberType_ID;  
  
        IF NOT EXISTS(SELECT 1 FROM #AttributeIds)  
        BEGIN  
            SET @NoMatches = 1;  
        END;  
    END;  
  
    -- Find all explicit hierarchies that match the provided criteria.  
    IF  @NoMatches = 0  
        AND(   @ExplicitHierarchy_MUID IS NOT NULL  
            OR @ExplicitHierarchy_Name IS NOT NULL)  
    BEGIN  
        SET @FilterByHierarchy = 1;  
  
        CREATE TABLE #HierarchyIds (ID INT PRIMARY KEY);  
        SET @SQL = @TruncationGuard + N'  
        INSERT INTO #HierarchyIds(ID)  
        SELECT DISTINCT h.ID  
        FROM mdm.tblHierarchy h' +  
  
        -- If an entity filter also exists, then use it to further constrain the results.  
        CASE WHEN @FilterByEntity = 1 THEN N'  
        INNER JOIN #EntityIds e  
        ON h.Entity_ID = e.ID'  
  
        -- Or if there is no entity filter  
        ELSE N'  
        INNER JOIN mdm.tblEntity e  
        ON h.Entity_ID = e.ID  
        INNER JOIN mdm.tblModel m  
        ON e.Model_ID = m.ID'  
  
        END + N'  
        WHERE   (@ExplicitHierarchy_MUID IS NULL OR h.MUID    = @ExplicitHierarchy_MUID)  
            AND (@ExplicitHierarchy_Name IS NULL OR h.Name    = @ExplicitHierarchy_Name);';  
        -- PRINT @SQL  
        EXEC sp_executesql @SQL, N'@ExplicitHierarchy_MUID UNIQUEIDENTIFIER, @ExplicitHierarchy_Name NVARCHAR(50)', @ExplicitHierarchy_MUID, @ExplicitHierarchy_Name;  
  
        IF NOT EXISTS(SELECT 1 FROM #HierarchyIds)  
        BEGIN  
            SET @NoMatches = 1;  
        END;  
    END;  
  
    -- Find all users that match the provided criteria.  
    IF  @NoMatches = 0  
        AND(   @User_MUID IS NOT NULL  
            OR @User_Name IS NOT NULL)  
    BEGIN  
        SET @FilterByUser = 1;  
  
        CREATE TABLE #UserIds (ID INT PRIMARY KEY);  
        INSERT INTO #UserIds(ID)  
        SELECT DISTINCT ID  
        FROM mdm.tblUser  
        WHERE   (@User_MUID IS NULL OR MUID        = @User_MUID)  
            AND (@User_Name IS NULL OR UPPER(UserName) LIKE @User_NameUpper);  
  
        IF NOT EXISTS(SELECT 1 FROM #UserIds)  
        BEGIN  
            SET @NoMatches = 1;  
        END;  
    END;  
  
    -- If a member MUID is provided, set FilterByMemberMuid flag  
    IF @Member_MUID IS NOT NULL  
    BEGIN  
        SET @FilterByMemberMuid = 1;  
    END  
  
    -- Find all members that match the provided criteria. We can skip this step if member muid is already provided.  
    IF @NoMatches = 0 AND @FilterByMemberMuid = 0 AND @MemberCode IS NOT NULL  
    BEGIN  
        -- See if we can take the shortcut of filtering on MemberID rather than MemberCode (comparing INTs is cheaper than doing a LIKE on NVARCHARs)  
        IF      @FilterByEntity = 1  
            AND COALESCE(@MemberType_ID, @MemberType_Unknown) IN (@MemberType_Leaf, @MemberType_Consolidated, @MemberType_Collection)  
        BEGIN  
            -- Lookup member id(s) from the provided member code. This will be faster than scanning through the view, doing a LIKE on member code.  
            SET @FilterByMemberId = 1;  
  
            CREATE TABLE #MemberIds  
            (  
                 Entity_ID      INT  
                ,MemberType_ID  TINYINT  
                ,Member_ID             INT  
            );  
            CREATE CLUSTERED INDEX #ix_MemberIds_Entity_ID ON #MemberIds(Entity_ID);  
            CREATE NONCLUSTERED INDEX #ix_MemberIds_MemberType_ID ON #MemberIds(MemberType_ID);  
            CREATE NONCLUSTERED INDEX #ix_MemberIds_Member_ID ON #MemberIds(Member_ID);  
  
            SET @CurrentRow_ID = 1;  
            WHILE EXISTS(SELECT 1 FROM #EntityIds WHERE Row_ID = @CurrentRow_ID)  
            BEGIN  
                SELECT  
                     @CurrentEntity_ID = ID  
                    ,@CurrentMemberTableName = CASE @MemberType_ID  
                        WHEN @MemberType_Leaf THEN LeafMemberTableName  
                        WHEN @MemberType_Consolidated THEN ConsolidatedMemberTableName  
                        WHEN @MemberType_Collection THEN CollectionMemberTableName  
                        END  
                FROM #EntityIds  
                WHERE Row_ID = @CurrentRow_ID;  
                SET @SQL = @TruncationGuard + N'  
                INSERT INTO #MemberIds  
                (  
                     Entity_ID  
                    ,MemberType_ID  
                    ,Member_ID  
                )  
                SELECT  
                     @CurrentEntity_ID  
                    ,@MemberType_ID  
                    ,m.ID  
                FROM mdm.' + @CurrentMemberTableName + N' m' +  
  
                -- If a verion filter also exists, then use it to further constrain the results.  
                CASE WHEN @FilterByVersion = 1 THEN N'  
                INNER JOIN #VersionIds v  
                ON m.Version_ID = v.ID'  
  
                ELSE N'' END + N'  
                WHERE m.Code LIKE @MemberCode  
                ';  
                -- PRINT @SQL  
                EXEC sp_executesql @SQL, N'@MemberCode NVARCHAR(250), @CurrentEntity_ID INT, @MemberType_ID TINYINT', @MemberCode, @CurrentEntity_ID, @MemberType_ID;  
  
                SET @CurrentRow_ID += 1;  
            END; -- WHILE  
  
            IF NOT EXISTS(SELECT 1 FROM #MemberIds)  
            BEGIN  
                SET @NoMatches = 1;  
            END;  
        END ELSE  
        BEGIN  
            -- Not enough info was provided to filter by member ID, so just filter by member code (this will be slower).  
            SET @FilterByMemberCode = 1;  
        END;  
    END;  
  
    -- See if the filters can be simplified.  
    IF @FilterByMemberMuid = 1  
    BEGIN  
            -- We do not need to filter by member code if a member muid is supplied  
        SET @FilterByMemberCode = 0;  
    END  
  
    IF @FilterByMemberId = 1 OR @FilterByMemberMuid = 1  
    BEGIN  
        -- Filtering by MemberId or MemberMuid includes model, version, entity, and member type, so no need to explicitly filter on those.  
        SET @FilterByVersion = 0;  
        SET @FilterByEntity = 0;  
        SET @FilterByMemberType = 0;  
    END  
    ELSE IF @FilterByAttribute = 1  
    BEGIN  
        -- Filtering by attribute includes model, entity, and member type, so no need to explicitly filter on those.  
        SET @FilterByEntity = 0;  
        SET @FilterByMemberType = 0;  
    END  
  
    -- reset the var to build query  
    SET @SQL = N'';  
  
    DECLARE @UseEntitiesToCheckSecurity BIT = 0;  
    IF @IsModelAdmin = 0  
    BEGIN  
        -- Find entity member types that need security check  
        -- and store only the entities that need it  
        CREATE TABLE #EntitiesToCheckSecurity  
        (  
             Row_ID INT PRIMARY KEY IDENTITY  
            ,Entity_ID INT NOT NULL  
            ,MemberType_ID TINYINT NOT NULL  
            ,UseMemberSecurity BIT NOT NULL  
            ,SecurityTableName SYSNAME NULL  
  
        );  
        CREATE NONCLUSTERED INDEX #ix_EntitiesToCheckSecurity_Entity_ID ON #EntitiesToCheckSecurity(Entity_ID);  
  
        -- Find entities that need security check  
        -- and store only the ones that need it  
        WITH cteEntityMemberTypesToCheckSecurity AS  
        (  
            SELECT  
                 memberType.Entity_ID  
                ,memberType.ID AS MemberType_ID  
                ,mdm.udfUseMemberSecurity(@SystemUser_ID, memberType.Entity_ID, @Version_ID, memberType.ID) AS UseMemberSecurity  
                ,CASE memberType.ID  
                    WHEN @MemberType_Leaf THEN CAST(entity.EntityTable + '_MS' AS SYSNAME)  
                    WHEN @MemberType_Consolidated THEN CASE WHEN HierarchyParentTable IS NOT NULL THEN CAST(entity.HierarchyParentTable + '_MS' AS SYSNAME) ELSE NULL END  
                 END AS SecurityTable  
            FROM mdm.viw_SYSTEM_SECURITY_USER_MEMBERTYPE memberType  
            INNER JOIN mdm.tblEntity entity  
            ON entity.ID = memberType.Entity_ID  
            INNER JOIN mdm.tblModel model  
            ON model.ID = entity.Model_ID  
            WHERE model.ID = @Model_ID  
                AND (@Entity_ID IS NULL OR entity.ID = @Entity_ID)  
                AND (@MemberType_ID IS NULL OR memberType.ID = @MemberType_ID)  
                AND (Privilege_ID <> @Permission_Deny)  
        )  
        INSERT INTO #EntitiesToCheckSecurity  
        SELECT DISTINCT  
             Entity_ID  
            ,MemberType_ID  
            ,UseMemberSecurity  
            ,SecurityTable  
        FROM cteEntityMemberTypesToCheckSecurity  
        WHERE UseMemberSecurity <> 0;  
  
        -- begin building the where clause for CTEs  
        IF EXISTS(SELECT 1 FROM #EntitiesToCheckSecurity)  
        BEGIN  
            SET @UseEntitiesToCheckSecurity = 1;  
            SET @WhereCriteria += @TruncationGuard + N'    AND (t.Member_ID IS NULL OR sec.UseMemberSecurity = 0)';  
        END  
  
        -- begin a loop that generates CTEs to look up member level security  
        -- the CTEs will be named based on their member security tables, e.g. cte_tbl_1_1_MS  
        SET @CurrentRow_ID = 1;  
        WHILE EXISTS(SELECT 1 FROM #EntitiesToCheckSecurity WHERE Row_ID = @CurrentRow_ID)  
        BEGIN  
            SELECT  
                 @CurrentEntity_ID = Entity_ID  
                ,@CurrentSecurityTableName = SecurityTableName  
                ,@CurrentMemberSecurity = UseMemberSecurity  
                ,@CurrentMemberType_ID = MemberType_ID  
            FROM #EntitiesToCheckSecurity  
            WHERE Row_ID = @CurrentRow_ID  
  
            IF @CurrentMemberSecurity = 1  
            BEGIN  
                -- begin generating CTEs  
                IF @IsFirstCTE = 1  
                BEGIN  
                    SET @SQL += @TruncationGuard + N'  
        ;WITH'  
                    SET @IsFirstCTE = 0;  
                END  
                ELSE  
                BEGIN  
                    SET @SQL += @TruncationGuard + N'  
        ,';  
                END  
  
                SET @CurrentCTE = N' cte_' + @CurrentSecurityTableName;  
  
                -- the CTE will contain Member_ID column that is either EN_ID or HP_ID depending on the member type  
                SET @SQL += CONCAT(@TruncationGuard + @CurrentCTE + N' AS  
        (  
            SELECT  
                ID AS Member_ID,  
                ', @CurrentMemberType_ID, N' AS MemberType_ID,  
                ', @CurrentEntity_ID,'AS Entity_ID  
            FROM  
                mdm.', QUOTENAME(@CurrentSecurityTableName), N' X  
            WHERE X.User_ID = @SystemUser_ID  
                AND X.Version_ID = @Version_ID  
        )');  
  
                -- build the join clause to join on entity, entity member type, and member id  
                SET @Join += @TruncationGuard + N'  
        LEFT JOIN ' + @CurrentCTE + N' ' + @CurrentCTE + N'  
        ON t.Entity_ID = ' + @CurrentCTE + N'.Entity_ID AND t.MemberType_ID = ' + @CurrentCTE + N'.MemberType_ID AND t.Member_ID = ' + @CurrentCTE + N'.Member_ID';  
  
                -- build the where clause to exclude members that need to evaluate member security  
                SET @WhereCriteria += @TruncationGuard + N' OR ' + @CurrentCTE + N'.Member_ID IS NOT NULL';  
            END  
            SET @CurrentRow_ID += 1;  
        END -- while  
  
        -- wrap up building the where clause for CTEs  
        IF EXISTS(SELECT 1 FROM #EntitiesToCheckSecurity)  
        BEGIN  
            SET @WhereCriteria += @TruncationGuard + N')';  
        END  
  
    END -- if  
  
    -- Create the FROM clause, using INNER JOINs to filter on various ID columns (most of which have FK relationships, so they are indexed).  
    SET @From = @TruncationGuard + N'  
        FROM [mdm].' + QUOTENAME(@TransactionViewName) + N' AS t ' +  
    CASE WHEN @FilterByVersion = 1 THEN N'  
        INNER JOIN #VersionIds v  
        ON t.Version_ID = v.ID' ELSE N'' END +  
    CASE WHEN @FilterByEntity = 1 THEN N'  
        INNER JOIN #EntityIds e  
        ON t.Entity_ID = e.ID' ELSE N'' END +  
    CASE WHEN @FilterByHierarchy = 1 THEN N'  
        INNER JOIN #HierarchyIds h  
        ON t.ExplicitHierarchy_ID = h.ID' ELSE N'' END +  
    CASE WHEN @FilterByAttribute = 1 THEN N'  
        INNER JOIN #AttributeIds a  
        ON t.Attribute_ID = a.ID' ELSE N'' END +  
    CASE WHEN @FilterByUser = 1 THEN N'  
        INNER JOIN #UserIds u  
        ON t.[User ID] = u.ID' ELSE N'' END +  
    CASE WHEN @FilterByMemberId = 1 THEN N'  
        INNER JOIN #MemberIds mem  
        ON      t.Entity_ID = mem.Entity_ID  
            AND t.MemberType_ID = mem.MemberType_ID  
            AND t.Member_ID = mem.Member_ID' ELSE N'' END +  
    CASE WHEN @IsModelAdmin = 0 THEN N'  
        LEFT JOIN mdm.viw_SYSTEM_SECURITY_USER_ENTITY eAcl  
        ON t.Entity_ID = eAcl.ID AND eAcl.User_ID = @SystemUser_ID AND eAcl.Privilege_ID <> 1  
        LEFT JOIN mdm.viw_SYSTEM_SECURITY_USER_ATTRIBUTE aAcl  
        ON  t.Attribute_ID = aAcl.ID AND aAcl.User_ID = @SystemUser_ID'  
        + CASE @UseEntitiesToCheckSecurity WHEN 1 THEN N'  
        LEFT JOIN #EntitiesToCheckSecurity sec  
        ON t.Entity_ID = sec.Entity_ID AND t.MemberType_ID = sec.MemberType_ID' ELSE N'' END  
        ELSE N'' END;  
  
    -- Create the WHERE clause to filter on additional values.  
  
    IF @IsModelAdmin = 0  
    BEGIN  
        -- build the where clause to ensure user has privileges on attribute and entity  
        SET @WhereCriteria += @TruncationGuard + N'  
            AND (t.Entity_ID IS NULL OR t.Entity_ID = eAcl.ID)  
            AND (t.Attribute_ID IS NULL OR t.Attribute_ID = aAcl.ID)'  
    END  
  
    IF @FilterByMemberType = 1  
    BEGIN  
        SET @WhereCriteria += @TruncationGuard + N'  
            AND t.MemberType_ID = @MemberType_ID';  
    END;  
  
    IF @Transaction_ID IS NOT NULL  
    BEGIN  
        SET @WhereCriteria += @TruncationGuard + N'  
            AND t.ID = @Transaction_ID';  
    END  
  
    IF @TransactionType_ID IS NOT NULL  
    BEGIN  
        SET @WhereCriteria += @TruncationGuard + N'  
            AND t.TransactionType_ID = @TransactionType_ID';  
    END  
  
    IF @FilterByMemberMuid = 1  
    BEGIN  
        SET @WhereCriteria += @TruncationGuard + N'  
                AND t.[Member_MUID] = @Member_MUID';  
    END  
  
    IF @NewValue IS NOT NULL  
    BEGIN  
        SET @WhereCriteria += @TruncationGuard + N'  
            AND t.[New Value] LIKE @NewValue';  
    END  
  
    IF @PriorValue IS NOT NULL  
    BEGIN  
        SET @WhereCriteria += @TruncationGuard + N'  
            AND t.[Prior Value] LIKE @PriorValue';  
    END  
  
    IF @FilterByMemberCode = 1  
    BEGIN  
        SET @WhereCriteria += @TruncationGuard + N'  
            AND t.[Member Code] LIKE @MemberCode';  
    END  
  
    IF @DateTimeBeginRange IS NOT NULL  
    BEGIN  
        SET @WhereCriteria += @TruncationGuard + N'  
            AND t.[Date Time] >= @DateTimeBeginRange';  
    END  
  
    IF @DateTimeEndRange IS NOT NULL  
    BEGIN  
        SET @WhereCriteria += @TruncationGuard + N'  
            AND t.[Date Time] <= @DateTimeEndRange';  
    END  
  
    -- Remove the leading 'AND' and prepend 'WHERE'.  
    IF LEN(@WhereCriteria) > 0  
    BEGIN  
        SET @WhereCriteria = SUBSTRING(@WhereCriteria, CHARINDEX(N'AND ', @WhereCriteria) + 4, LEN(@WhereCriteria));-- Remove leading AND  
        SET @WhereCriteria = @TruncationGuard + N'  
        WHERE   ' + @WhereCriteria;  
    END  
  
    IF @CountOnly = 1  
    BEGIN  
        SET @SQL += @TruncationGuard + N'  
        SELECT COUNT(t.ID) AS MemberRowCount'  
        + @From  
        + @Join  
        + @WhereCriteria;  
    END ELSE  
    BEGIN  
        -- The returned columns must be in the correct order (see http://msdn.microsoft.com/en-us/library/ms729813.aspx) or DataContractSerializer  
         -- may fail (sometimes silently) to deserialize out-of-order columns.  
         -- Core.BusinessEntities.Transaction members  
  
        IF @IsFirstCTE = 1  
        BEGIN  
            SET @SQL += @TruncationGuard + N'  
    ;WITH'  
            SET @IsFirstCTE = 0;  
        END  
        ELSE  
        BEGIN  
            SET @SQL += @TruncationGuard + N'  
    ,';  
        END  
        SET @SQL += @TruncationGuard + N' ctePaging AS  
    (  
        SELECT  
            t.*,  
            ROW_NUMBER() OVER(ORDER BY t.' + QUOTENAME(@SortColumn) + N' ' + CASE @SortDirection WHEN N'ASC' THEN N'ASC' ELSE N'DESC' END + N') AS Row'  
        + @From  
        + @Join  
        + @WhereCriteria + N'  
    )  
    SELECT  
         [Attribute_ID]  
        ,[Attribute_MUID]  
        ,[Attribute] AS [Attribute_Name]  
        ,[Date Time] AS [Date]  
        ,[Entity_ID]  
        ,[Entity_MUID]  
        ,[Entity] AS [Entity_Name]  
        ,[ExplicitHierarchy_ID]  
        ,[ExplicitHierarchy_MUID]  
        ,[Explicit Hierarchy] AS [ExplicitHierarchy_Name]  
        ,[ID]  
        ,[Member_ID]  
        ,[Member_MUID]  
        ,[Member Code] AS [Member_Code]  
        ,[MemberType_ID] AS [Member_Type]  
        ,[Model_ID]  
        ,[Model_MUID]  
        ,[Model_Name]  
        ,[New Value] AS [New_Value]  
        ,[Prior Value] AS [Prior_Value]  
        ,[TransactionType_ID] AS [TransactionType]  
        ,[User ID] AS [User_ID]  
        ,[User_MUID]  
        ,[User Name] AS [User_Name]  
        ,[Version_ID]  
        ,[Version_MUID]  
        ,[Version_Name]  
    FROM ctePaging AS t  
    WHERE t.Row BETWEEN @StartRow AND @EndRow  
    ;';  
    END;  
  
    -- PRINT @SQL  
  
    EXEC sp_executesql @SQL,  
            N' @SystemUser_ID                 INT  
              ,@Model_ID                INT  
              ,@MemberType_ID           TINYINT  
              ,@NewValue                NVARCHAR(MAX)  
              ,@PriorValue              NVARCHAR(MAX)  
              ,@MemberCode              NVARCHAR(250)  
              ,@Member_MUID             UNIQUEIDENTIFIER  
              ,@Transaction_ID          INT  
              ,@TransactionType_ID      INT  
              ,@DateTimeBeginRange      DATETIME2(3)  
              ,@DateTimeEndRange        DATETIME2(3)  
              ,@StartRow                INT  
              ,@EndRow                  INT  
              ,@MemberType_Leaf         TINYINT  
              ,@MemberType_Consolidated TINYINT',  
  
               @SystemUser_ID  
              ,@Model_ID  
              ,@MemberType_ID  
              ,@NewValue  
              ,@PriorValue  
              ,@MemberCode  
              ,@Member_MUID  
              ,@Transaction_ID  
              ,@TransactionType_ID  
              ,@DateTimeBeginRange  
              ,@DateTimeEndRange  
              ,@StartRow  
              ,@EndRow  
              ,@MemberType_Leaf  
              ,@MemberType_Consolidated;  
  
    SET NOCOUNT OFF  
  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpTransactionReverse]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
exec mdm.udpTransactionReverse @User_ID = 1, @Model_ID = 7, @Transaction_ID = 41  
  
select * from mdm.tbl1HPAccount where version_ID = 3  
*/  
CREATE PROCEDURE [mdm].[udpTransactionReverse]  
(  
    @User_ID	    INT,  
	@Model_ID       INT,  
    @Transaction_ID INT,  
    @Return_ID		INT = NULL OUTPUT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON  
  
    DECLARE @TempStatus_ID TINYINT  
    DECLARE @OriginalVersion_ID AS INT  
    DECLARE @OriginalTransactionType_ID AS INT  
    DECLARE @OriginalHierarchy_ID  AS INT  
    DECLARE @OriginalEntity_ID  AS INT  
    DECLARE @OriginalMember_ID  AS INT  
    DECLARE @OriginalMemberMUID  AS UNIQUEIDENTIFIER  
    DECLARE @OriginalMemberType_ID  AS TINYINT  
    DECLARE @OriginalMemberCode AS NVARCHAR(250)  
    DECLARE @OriginalAttribute_ID  AS INT  
    DECLARE @OriginalAttributeName AS NVARCHAR(100)  
    DECLARE @OriginalOldValue AS NVARCHAR(max)  
    DECLARE @OriginalOldCode AS NVARCHAR(max)  
    DECLARE @OriginalNewValue AS NVARCHAR(max)  
    DECLARE @OriginalNewCode AS NVARCHAR(max)  
    DECLARE @OriginalTargetMemberType_ID TINYINT  
    DECLARE @TransactionTableName sysname;  
    DECLARE @SQL NVARCHAR(MAX);  
    DECLARE @TransactionType_CreateMember INT = 1;  
    DECLARE @TransactionType_ChangeMemberStatus INT = 2;  
    DECLARE @TransactionType_SetAttributeValue INT = 3;  
    DECLARE @TransactionType_MoveToParent INT = 4;  
    DECLARE @TransactionType_MoveToSibling INT = 5;  
    DECLARE @TransactionType_MemberAnnotate INT = 6;  
  
    DECLARE  
         @MemberStatus_Active           TINYINT = 1  
        ,@MemberStatus_Deactivated      TINYINT = 2  
        ,@MemberIds                     mdm.MemberId;  
  
    --Validate model id  
    IF NOT EXISTS(SELECT 1 FROM mdm.tblModel WHERE ID = @Model_ID)  
    BEGIN  
        RAISERROR('MDSERR100010|The Parameters are not valid.', 16, 1);  
        RETURN(1);  
    END  
  
    SET @TransactionTableName = mdm.udfGetTransactionTableName(@Model_ID);      
	      
    --Create a constant like value for the logging flag to pass  
    --into the procedures that will actually be doing the reversing.  
    --We do NOT want those procedures to create a transaction log entry,  
    --for the reversal, as this procedure will do that. Otherwise 2 entries  
    --will be added to the transaction table.  
    DECLARE @LoggingFlag BIT = 0;  
      
    --As an alternative to returning an error when the transaction type isn't supported for reversal,  
    --the @RunTransactionSave is checked to see if a transaction reversal save should be run. Default  
    --to "no".   
    DECLARE @RunTransactionSave INT  
    SELECT @RunTransactionSave = 0  
  
    --Get the Original Transaction Information  
    SET @SQL = N'  
    SELECT   
        @OriginalVersion_ID = T.Version_ID,  
        @OriginalTransactionType_ID = T.TransactionType_ID,  
        @OriginalHierarchy_ID = T.Hierarchy_ID,  
        @OriginalEntity_ID = T.Entity_ID,  
        @OriginalAttribute_ID = T.Attribute_ID,  
        @OriginalMember_ID = T.Member_ID,  
        @OriginalMemberMUID = T.Member_MUID,  
        @OriginalMemberType_ID = T.MemberType_ID,  
        @OriginalMemberCode = T.MemberCode,  
        @OriginalOldValue = T.OldValue,  
        @OriginalOldCode = T.OldCode,  
        @OriginalNewValue = T.NewValue,  
        @OriginalNewCode = T.NewCode  
  
	FROM  
        [mdm].' + QUOTENAME(@TransactionTableName) + N' T  
    WHERE  
        ID = @Transaction_ID;  
    ';  
    EXEC sp_executesql @SQL, N'@OriginalVersion_ID INT OUTPUT, @OriginalTransactionType_ID INT OUTPUT, @OriginalHierarchy_ID INT OUTPUT, @OriginalEntity_ID INT OUTPUT, @OriginalAttribute_ID INT OUTPUT, @OriginalMember_ID INT OUTPUT, @OriginalMemberMUID UNIQUEIDENTIFIER OUTPUT, @OriginalMemberType_ID TINYINT OUTPUT, @OriginalMemberCode NVARCHAR(250) OUTPUT, @OriginalOldValue NVARCHAR(MAX) OUTPUT, @OriginalOldCode NVARCHAR(MAX) OUTPUT, @OriginalNewValue NVARCHAR(MAX) OUTPUT, @OriginalNewCode NVARCHAR(MAX) OUTPUT, @Transaction_ID INT',  
                               @OriginalVersion_ID OUTPUT,     @OriginalTransactionType_ID OUTPUT,     @OriginalHierarchy_ID OUTPUT,     @OriginalEntity_ID OUTPUT,     @OriginalAttribute_ID OUTPUT,     @OriginalMember_ID OUTPUT,     @OriginalMemberMUID OUTPUT,                  @OriginalMemberType_ID OUTPUT,         @OriginalMemberCode OUTPUT,               @OriginalOldValue OUTPUT,               @OriginalOldCode OUTPUT,               @OriginalNewValue OUTPUT,               @OriginalNewCode OUTPUT,               @Transaction_ID;  
  
    --Figure out whether we are looking at a reversible transaction type  
    --Member annotation transactions cannot be reversed at all  
    IF @OriginalTransactionType_ID  = @TransactionType_MemberAnnotate  
    BEGIN  
        RAISERROR('MDSERR310059|Transaction of this type cannot be reversed.', 16, 1);  
        RETURN(1);  
    END  
  
    --Start transaction, being careful to check if we are nested  
    DECLARE @TranCounter INT = @@TRANCOUNT;  
    IF @TranCounter > 0   
    BEGIN  
        SAVE TRANSACTION TX;  
    END ELSE   
    BEGIN  
        BEGIN TRANSACTION;  
    END;  
  
    BEGIN TRY  
        --Member Create  
        IF @OriginalTransactionType_ID = @TransactionType_CreateMember  
        BEGIN  
            INSERT INTO @MemberIds(ID, MemberType_ID)  
            VALUES (@OriginalMember_ID, @OriginalMemberType_ID)  
          
            -- Deactivate (soft-delete) the member.  
            EXEC mdm.udpMembersStatusSet   
                 @User_ID = @User_ID  
                ,@Model_ID = @Model_ID  
                ,@Version_ID = @OriginalVersion_ID  
                ,@Entity_ID = @OriginalEntity_ID  
                ,@MemberIds = @MemberIds  
                ,@MemberType_ID = @OriginalMemberType_ID  
                ,@Status_ID = @MemberStatus_Deactivated  
                ,@LogFlag = @LoggingFlag  
                ,@RaiseFirstError = 1  
  
            SET @RunTransactionSave = 1;  
  
            -- Undoing a Create transaction means soft-deleting (deactivating) the created member. So change the old value fields to look like reverting a transaction that activated the member.  
            SET @OriginalTransactionType_ID = @TransactionType_ChangeMemberStatus;  
            SET @OriginalNewValue = @MemberStatus_Active;  
            SET @OriginalOldValue = @MemberStatus_Deactivated;  
        END  
        --Member Status Set  
        ELSE IF @OriginalTransactionType_ID = @TransactionType_ChangeMemberStatus  
        BEGIN  
            INSERT INTO @MemberIds(ID, MemberType_ID)  
            VALUES (@OriginalMember_ID, @OriginalMemberType_ID)  
  
            DECLARE @OriginalStatus TINYINT = CONVERT(TINYINT, @OriginalOldValue);  
            EXEC mdm.udpMembersStatusSet   
                 @User_ID = @User_ID  
                ,@Model_ID = @Model_ID  
                ,@Version_ID = @OriginalVersion_ID  
                ,@Entity_ID = @OriginalEntity_ID  
                ,@MemberIds = @MemberIds  
                ,@MemberType_ID = @OriginalMemberType_ID  
                ,@Status_ID = @OriginalStatus  
                ,@LogFlag = @LoggingFlag  
                ,@RaiseFirstError = 1  
            SELECT @RunTransactionSave = 1  
        END  
        --Set Attribute Value  
        ELSE IF @OriginalTransactionType_ID = @TransactionType_SetAttributeValue  
        BEGIN  
            DECLARE  
                 @Members           mdm.MemberSaveList  
                ,@MemberAttributes  mdm.MemberAttributeValues;  
  
            INSERT INTO @Members(RowID, MemberMUID)  
            VALUES (1, @OriginalMemberMUID);  
  
            INSERT INTO @MemberAttributes(MemberRowID, AttributeID, AttributeValue)  
            VALUES (1, @OriginalAttribute_ID, @OriginalOldValue)  
  
            EXEC mdm.udpEntityMembersSave  
                 @User_ID = @User_ID  
                ,@Model_ID = @Model_ID  
                ,@Version_ID = @OriginalVersion_ID  
                ,@Entity_ID = @OriginalEntity_ID  
                ,@MemberType_ID = @OriginalMemberType_ID  
                ,@Members = @Members  
                ,@MemberAttributes = @MemberAttributes  
                ,@SaveMode = 3 -- Update  
                ,@LogFlag = @LoggingFlag  
                ,@ValidateDataTypes = 0 -- Shouldn't be necessary to revalidate the old value, since it would have been validated when originally set.  
                ,@ErrorReportingType = 4 -- Raise first error  
            SELECT @RunTransactionSave = 1  
        END  
        --Move Member to Parent AND Move Member to Sibling  
        --The reason why this is used for both is because we don't store the SortOrder of the original location  
        --Also, we store the original parent NOT the closest sibling of the original location  
        --So there is currently no way to navigate back to the exact location  
        ELSE IF @OriginalTransactionType_ID IN (@TransactionType_MoveToParent, @TransactionType_MoveToSibling)  
        BEGIN  
            DECLARE @OriginalOldValueInt INT = CONVERT(INT, @OriginalOldValue);  
            EXEC mdm.udpMemberTypeIDAndIDGetByCode @OriginalVersion_ID, @OriginalEntity_ID, @OriginalMemberCode, @OriginalTargetMemberType_ID OUTPUT  
            EXEC mdm.udpMemberStatusIDGetByMemberID @OriginalVersion_ID, @OriginalEntity_ID, @OriginalOldValueInt, 2, @TempStatus_ID OUTPUT  
            --Check to see if Target is Disabled, if so goto Root  
            DECLARE @HierarchyMembers AS mdm.HierarchyMembers    
            INSERT INTO @HierarchyMembers   
                (Hierarchy_ID,          Child_ID,           ChildCode,          ChildMemberType_ID,     TargetType_ID) VALUES   
                (@OriginalHierarchy_ID, @OriginalMember_ID, @OriginalMemberCode, @OriginalMemberType_ID, 1/*Parent*/);  
            IF @TempStatus_ID = (SELECT OptionID FROM mdm.tblList where ListCode = CAST(N'lstStatus' AS NVARCHAR(50)) AND ListOption = CAST(N'Deleted' AS NVARCHAR(250)))  
            BEGIN  
                UPDATE @HierarchyMembers  
                SET TargetMemberType_ID = 2/*Consolidated*/;  
            END  
            ELSE  
            BEGIN  
                UPDATE @HierarchyMembers  
                SET  
                    Target_ID = CONVERT(INT, @OriginalOldValue),  
                    TargetCode = CONVERT(NVARCHAR(250), @OriginalOldCode),  
                    TargetMemberType_ID = @OriginalTargetMemberType_ID;  
            END; --if  
          
            SET @LoggingFlag = 1;-- Have the below sproc update the transaction log (note that @RunTransactionSave is being left zero)  
            EXECUTE mdm.udpHierarchyMembersUpdate @User_ID=@User_ID, @Version_ID=@OriginalVersion_ID, @Entity_ID=@OriginalEntity_ID, @HierarchyMembers=@HierarchyMembers, @OriginalTransaction_ID=@Transaction_ID, @LogFlag=@LoggingFlag;   
      
        END; --if  
      
        --Only log a transaction record if something was actually reversed.  
        IF @RunTransactionSave = 1  
        BEGIN    
            -- log this transaction reverse. Since this is logging the reversal,  
            -- the oldvalue is stored in the new value column, and the New value is stored  
            -- in the old value column.  
            EXEC mdm.udpTransactionSave   
                @User_ID = @User_ID,  
                @Version_ID	= @OriginalVersion_ID,  
                @TransactionType_ID = @OriginalTransactionType_ID,  
                @OriginalTransaction_ID  = @Transaction_ID,  
                @Hierarchy_ID = @OriginalHierarchy_ID,  
                @Entity_ID = @OriginalEntity_ID,  
                @Member_ID = @OriginalMember_ID,  
                @MemberType_ID = @OriginalMemberType_ID,  
                @Attribute_ID = @OriginalAttribute_ID,  
                @OldValue = @OriginalNewValue,  
                @NewValue = @OriginalOldValue,  
                @Return_ID = @Return_ID OUTPUT;  
        END  
  
        --Commit only if we are not nested.  
        IF @TranCounter = 0   
        BEGIN  
            COMMIT TRANSACTION;  
        END;  
  
    END TRY  
    --Compensate as necessary  
    BEGIN CATCH  
  
        -- Get error info.  
        DECLARE  
            @ErrorMessage NVARCHAR(4000),  
            @ErrorSeverity INT,  
            @ErrorState INT,  
            @ErrorNumber INT,  
            @ErrorLine INT,  
            @ErrorProcedure NVARCHAR(126);  
        EXEC mdm.udpGetErrorInfo  
            @ErrorMessage = @ErrorMessage OUTPUT,  
            @ErrorSeverity = @ErrorSeverity OUTPUT,  
            @ErrorState = @ErrorState OUTPUT,  
            @ErrorNumber = @ErrorNumber OUTPUT,  
            @ErrorLine = @ErrorLine OUTPUT,  
            @ErrorProcedure = @ErrorProcedure OUTPUT  
  
        SET @ErrorMessage = CONCAT(@ErrorMessage, N', @ErrorNumber = ', @ErrorNumber, N', @ErrorProcedure = "', @ErrorProcedure, N'", line ', @ErrorLine);  
                  
        IF @TranCounter = 0   
        BEGIN  
            ROLLBACK TRANSACTION;  
        END ELSE IF XACT_STATE() <> -1   
        BEGIN  
            ROLLBACK TRANSACTION TX;  
        END;  
  
        RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);  
    END CATCH;  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpTransactionSave]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
EXEC mdm.udpTransactionSave 1,'34',3,NULL,NULL,40,12,2,517,'2','2'  
EXEC mdm.udpTransactionSave 1,2,3,NULL,NULL,1,1,5,20,'1.000','1.00'  
  
select * from mdm.tbl_7_TR order by EnterDTM desc  
*/  
CREATE PROCEDURE [mdm].[udpTransactionSave]  
(  
    @User_ID                    INT,  
    @Version_ID                 INT,  
    @TransactionType_ID         INT,  
    @OriginalTransaction_ID     INT = NULL,  
    @Hierarchy_ID               INT = NULL,  
    @Entity_ID                  INT = NULL,  
    @Member_ID                  INT = NULL,  
    @MemberType_ID              TINYINT = NULL,  
    @Attribute_ID               INT = NULL,  
    @OldValue                   NVARCHAR(max) = NULL,  
    @NewValue                   NVARCHAR(max) = NULL,  
    @Comment                    NVARCHAR(500) = NULL,  
    @Return_ID                  INT = NULL OUTPUT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON  
    DECLARE @ID INT  
    DECLARE @Annotation_ID INT  
    DECLARE @TempDomainEntity_ID INT  
    DECLARE @TempAttributeType_ID INT  
    DECLARE @OldCode NVARCHAR(250)  
    DECLARE @NewCode NVARCHAR(250)  
    DECLARE @MemberCode NVARCHAR(250)  
    DECLARE @TempMember_ID INT;  
    DECLARE @Member_MUID UNIQUEIDENTIFIER;  
    DECLARE @TableName sysname;  
    DECLARE @Model_ID INT;  
    DECLARE @TransactionTableName sysname;  
    DECLARE @SQL NVARCHAR(MAX);  
  
    --Read before making edits to this SPROC  
    --This SPROC only deals with a member at a time. When updating it, also  
    --remember to update other SPROCs such as udpEntityMembersCreate/Update that work with  
    --multiple members and also write to the transaction table  
  
    -- Parameter validation  
    IF ((@Member_ID IS NULL) OR (@Member_ID <= 0)  
        OR (@MemberType_ID IS NULL) OR (@MemberType_ID < 1 AND @MemberType_ID > 5)  
        OR (@TransactionType_ID IS NULL) OR (@TransactionType_ID < 1 AND @TransactionType_ID > 6)  
        OR (@Version_ID IS NULL) OR (NOT EXISTS(SELECT * FROM mdm.tblModelVersion WHERE ID = @Version_ID)))  
    BEGIN  
        RAISERROR('MDSERR100010|The Parameters are not valid.', 16, 1);  
        RETURN(1);  
    END  
  
    -- Get the transaction table name  
    SELECT  
        @Model_ID = Model_ID  
    FROM mdm.tblModelVersion  
    WHERE ID = @Version_ID;  
  
    SET @TransactionTableName = mdm.udfGetTransactionTableName(@Model_ID);  
  
    --Get the Member MUID  
    SET @TableName = mdm.udfTableNameGetByID(@Entity_ID, @MemberType_ID);  
  
    SET @SQL = N'SELECT @Member_MUID = MUID  
        FROM mdm.' + quotename(@TableName) + N'  
        WHERE ID = @Member_ID;';  
  
    EXEC sp_executesql @SQL, N'@Member_ID INT, @Member_MUID UNIQUEIDENTIFIER OUTPUT', @Member_ID, @Member_MUID OUTPUT;  
  
    --Get the MemberCode  
    if @MemberType_ID BETWEEN 1 AND 3  
        BEGIN  
            EXEC mdm.udpMemberCodeGetByID @Version_ID = @Version_ID, @Entity_ID = @Entity_ID, @Member_ID = @Member_ID, @MemberType_ID = @MemberType_ID, @ReturnCode = @MemberCode OUTPUT  
        END; --if  
  
    --Check to see if it is a Domain Attribute  
    --If so get the Codes  
    SELECT @TempDomainEntity_ID = (SELECT DomainEntity_ID FROM mdm.tblAttribute where Entity_ID = @Entity_ID AND ID = @Attribute_ID)  
    SELECT @TempAttributeType_ID = (SELECT AttributeType_ID FROM mdm.tblAttribute where Entity_ID = @Entity_ID AND ID = @Attribute_ID)  
    IF @TempAttributeType_ID = 2 --DBA  
        BEGIN  
            SET @TempMember_ID = CONVERT(INT, @OldValue)  
            EXEC mdm.udpMemberCodeGetByID @Version_ID = @Version_ID, @Entity_ID = @TempDomainEntity_ID, @Member_ID = @TempMember_ID, @MemberType_ID = 1, @ReturnCode = @OldCode OUTPUT  
            IF @OldCode = N'0'  
                BEGIN  
                    SELECT @OldCode = N''  
                END  
            SET @TempMember_ID = CONVERT(INT, @NewValue)  
            EXEC mdm.udpMemberCodeGetByID @Version_ID = @Version_ID, @Entity_ID = @TempDomainEntity_ID, @Member_ID = @TempMember_ID, @MemberType_ID = 1, @ReturnCode = @NewCode OUTPUT  
            IF @NewCode = N'0'  
                BEGIN  
                    SELECT @NewCode = N''  
                END  
        END  
    ELSE IF @TempAttributeType_ID = 4 --File  
        BEGIN  
            IF NOT EXISTS(SELECT 1 FROM mdm.tblFile WHERE ID = CAST(@OldValue AS INT))  
                BEGIN  
                    SELECT @OldCode = N''  
                END  
            ELSE  
                BEGIN  
                    SELECT @OldCode = (SELECT [FileName] FROM mdm.tblFile WHERE ID = CAST(@OldValue AS INT))  
                END  
            SELECT @NewCode = (SELECT [FileName] FROM mdm.tblFile WHERE ID = CAST(@NewValue AS INT))  
        END  
    ELSE IF @TempAttributeType_ID = 1 --FFA  
        BEGIN  
            IF (SELECT DataType_ID FROM mdm.tblAttribute WHERE ID = @Attribute_ID) = 3  
                BEGIN  
                    /*  
                        while the datatype is NCHAR in [sys].[syslanguages] the SET DATEFORMAT won't allow trailing spaces.  
                    */  
                    DECLARE @Dateformat NVARCHAR(6)  
                    DECLARE @TempOldValue DATETIME2(3)  
                    DECLARE @TempNewValue DATETIME2(3)  
                    SELECT @Dateformat = CAST([dateformat] AS NVARCHAR(6)) FROM master.sys.syslanguages where langid = @@langid  
                    SET DATEFORMAT @Dateformat  
                    SET @TempOldValue = CONVERT(DATETIME2(3),@OldValue)  
                    SET @TempNewValue = CONVERT(DATETIME2(3),@NewValue)  
                    IF @Dateformat = CAST(N'mdy' AS NVARCHAR(6))  
                        BEGIN  
                            SELECT @OldCode = CONVERT(NVARCHAR(10),MONTH(@TempOldValue)) + N'/' + CONVERT(NVARCHAR(10),DAY(@TempOldValue)) + N'/' + CONVERT(NVARCHAR(10),YEAR(@TempOldValue))  
                            SELECT @NewCode = CONVERT(NVARCHAR(10),MONTH(@TempNewValue)) + N'/' + CONVERT(NVARCHAR(10),DAY(@TempNewValue)) + N'/' + CONVERT(NVARCHAR(10),YEAR(@TempNewValue))  
                        END  
                    IF @Dateformat = CAST(N'dmy'  AS NVARCHAR(6))  
                        BEGIN  
                            SELECT @OldCode = CONVERT(NVARCHAR(10),DAY(@TempOldValue)) + N'/' + CONVERT(NVARCHAR(10),MONTH(@TempOldValue)) + N'/' + CONVERT(NVARCHAR(10),YEAR(@TempOldValue))  
                            SELECT @NewCode = CONVERT(NVARCHAR(10),DAY(@TempNewValue)) + N'/' + CONVERT(NVARCHAR(10),MONTH(@TempNewValue)) + N'/' + CONVERT(NVARCHAR(10),YEAR(@TempNewValue))  
                        END  
                    IF @Dateformat = CAST(N'ymd'  AS NVARCHAR(6))  
                        BEGIN  
                            SELECT @OldCode = CONVERT(NVARCHAR(10),YEAR(@TempOldValue)) + N'/' + CONVERT(NVARCHAR(10),MONTH(@TempOldValue)) + N'/' + CONVERT(NVARCHAR(10),DAY(@TempOldValue))  
                            SELECT @NewCode = CONVERT(NVARCHAR(10),YEAR(@TempNewValue)) + N'/' + CONVERT(NVARCHAR(10),MONTH(@TempNewValue)) + N'/' + CONVERT(NVARCHAR(10),DAY(@TempNewValue))  
                        END  
  
                END  
            ELSE  
                BEGIN  
                    SELECT @OldCode = CONVERT(NVARCHAR(250), @OldValue)  
                    SELECT @NewCode = CONVERT(NVARCHAR(250), @NewValue)  
                END  
        END  
  
    --Start transaction, being careful to check if we are nested  
    DECLARE @TranCounter INT;  
    SET @TranCounter = @@TRANCOUNT;  
    IF @TranCounter > 0 SAVE TRANSACTION TX;  
    ELSE BEGIN TRANSACTION;  
  
    BEGIN TRY  
        IF @TransactionType_ID = 2 --Status_Set  
            BEGIN  
                IF @OldValue = CAST(N'1' AS NVARCHAR(max))  
                    BEGIN  
                        SELECT @OldCode = N'Active'  
                    END  
                ELSE IF @OldValue = CAST(N'2' AS NVARCHAR(max))  
                    BEGIN  
                        SELECT @OldCode = N'De-Activated'  
                    END  
                ELSE  
                    BEGIN  
                        SET @OldValue = NULL  
                        SET @OldCode = NULL  
                    END  
  
                IF @NewValue = CAST(N'1' AS NVARCHAR(max))  
                    BEGIN  
                        SELECT @NewCode = N'Active'  
                    END  
                ELSE IF @NewValue = CAST(N'2' AS NVARCHAR(max))  
                    BEGIN  
                        SELECT @NewCode = N'De-Activated'  
                    END  
                ELSE  
                    BEGIN  
                        SET @NewValue = NULL  
                        SET @NewCode = NULL  
                    END  
            END  
  
        ELSE IF @TransactionType_ID = 4 --Hierarchy Parent Set  
            BEGIN  
                SET @TempMember_ID = CONVERT(INT, @OldValue)  
                EXEC mdm.udpMemberCodeGetByID @Version_ID = @Version_ID, @Entity_ID = @Entity_ID, @Member_ID = @TempMember_ID, @MemberType_ID = 2, @ReturnCode = @OldCode OUTPUT  
                IF @OldCode = CAST(N'0' AS NVARCHAR(max))  
                    BEGIN  
                        IF @OldValue = CAST(N'-1'  AS NVARCHAR(max))  
                            BEGIN  
                                SELECT @OldCode = N'MDMUNUSED'  
                            END  
                        ELSE  
                            BEGIN  
                                SELECT @OldCode = N'ROOT'  
                            END  
                    END  
                SET @TempMember_ID = CONVERT(INT, @NewValue)  
                EXEC mdm.udpMemberCodeGetByID @Version_ID = @Version_ID, @Entity_ID = @Entity_ID, @Member_ID = @TempMember_ID, @MemberType_ID = 2, @ReturnCode = @NewCode OUTPUT  
                IF @NewCode = N'0'  
                    BEGIN  
                        IF @NewValue = CAST(N'-1'  AS NVARCHAR(max))  
                            BEGIN  
                                SELECT @NewCode = N'MDMUNUSED'  
                            END  
                        ELSE  
                            BEGIN  
                                SELECT @NewCode = N'ROOT'  
                            END  
                    END  
            END  
  
        ELSE IF @TransactionType_ID = 5 --Hierarchy Sibling Set  
            BEGIN  
                SET @TempMember_ID = CONVERT(INT, @OldValue)  
                EXEC mdm.udpMemberCodeGetByID @Version_ID = @Version_ID, @Entity_ID = @Entity_ID, @Member_ID = @TempMember_ID, @MemberType_ID = 2, @ReturnCode = @OldCode OUTPUT  
                IF @OldCode = N'0'  
                    BEGIN  
                        IF @OldValue = CAST(N'-1'  AS NVARCHAR(max))  
                            BEGIN  
                                SELECT @OldCode = N'MDMUNUSED'  
                            END  
                        ELSE  
                            BEGIN  
                                SELECT @OldCode = N'ROOT'  
                            END  
                    END  
                SET @TempMember_ID = CONVERT(INT, @NewValue)  
                EXEC mdm.udpMemberCodeGetByID @Version_ID = @Version_ID, @Entity_ID = @Entity_ID, @Member_ID = @TempMember_ID, @MemberType_ID = 2, @ReturnCode = @NewCode OUTPUT  
                IF @NewCode = N'0'  
                    BEGIN  
                        IF @NewValue = CAST(N'-1'  AS NVARCHAR(max))  
                            BEGIN  
                                SELECT @NewCode = N'MDMUNUSED'  
                            END  
                        ELSE  
                            BEGIN  
                                SELECT @NewCode = N'ROOT'  
                            END  
                    END  
            END  
  
            SET @SQL = N'  
            INSERT INTO [mdm].' + QUOTENAME(@TransactionTableName) + N'  
                (  
                Version_ID,  
                TransactionType_ID,  
                OriginalTransaction_ID,  
                Hierarchy_ID,  
                Entity_ID,  
                Attribute_ID,  
                Member_ID,  
                MemberType_ID,  
                MemberCode,  
                Member_MUID,  
                OldValue,  
                OldCode,  
                NewValue,  
                NewCode,  
                EnterDTM,  
                EnterUserID,  
                LastChgDTM,  
                LastChgUserID  
                )  
            VALUES  
                (  
                @Version_ID,  
                @TransactionType_ID,  
                ISNULL(@OriginalTransaction_ID,0),  
                NULLIF(@Hierarchy_ID,0),  
                @Entity_ID,  
                @Attribute_ID,  
                @Member_ID,  
                @MemberType_ID,  
                @MemberCode,  
                @Member_MUID,  
                @OldValue, --ISNULL(@OldValue,''''),  
                @OldCode, --ISNULL(@OldCode,''''),  
                @NewValue, --ISNULL(@NewValue,''''),  
                @NewCode, --ISNULL(@NewCode,''''),  
                GETUTCDATE(),  
                @User_ID,  
                GETUTCDATE(),  
                @User_ID  
                )  
  
                --Save the identity value  
                SET @ID = SCOPE_IDENTITY();  
            ';  
  
            EXEC sp_executesql @SQL, N'@Version_ID INT, @TransactionType_ID INT, @OriginalTransaction_ID INT, @Hierarchy_ID INT, @Entity_ID INT, @Attribute_ID INT, @Member_ID INT, @Member_MUID UNIQUEIDENTIFIER, @MemberType_ID TINYINT, @MemberCode NVARCHAR(250), @OldValue NVARCHAR(MAX), @OldCode NVARCHAR(250), @NewValue NVARCHAR(MAX), @NewCode NVARCHAR(250), @User_ID INT, @ID INT OUTPUT',  
                                       @Version_ID,     @TransactionType_ID,     @OriginalTransaction_ID,     @Hierarchy_ID,     @Entity_ID,     @Attribute_ID,     @Member_ID,     @Member_MUID,                  @MemberType_ID,         @MemberCode,               @OldValue,               @OldCode,               @NewValue,               @NewCode,               @User_ID,     @ID OUTPUT;  
  
            IF (@@ERROR <> 0)  
                BEGIN  
                    RAISERROR('MDSERR500061|The transaction could not be saved. A database error occurred.', 16, 1);  
  
                    ROLLBACK TRAN  
                    RETURN(1)  
                END  
  
        ELSE IF @TransactionType_ID = 6  
            BEGIN  
                EXEC [mdm].[udpTransactionAnnotationSave] @User_ID, @Model_ID, @Version_ID, @ID, @Comment, @Annotation_ID OUTPUT  
            END  
  
        --Return values  
        SET @Return_ID = @ID;  
        IF @TranCounter = 0 COMMIT TRAN  
  
        SET NOCOUNT OFF  
        RETURN(0);  
    END TRY  
    BEGIN CATCH  
        IF @TranCounter = 0 ROLLBACK TRANSACTION;  
        ELSE IF XACT_STATE() <> -1 ROLLBACK TRANSACTION TX;  
  
        SET NOCOUNT OFF;  
  
        RAISERROR('MDSERR500061|The transaction could not be saved. A database error occurred.', 16, 1);  
  
        SET NOCOUNT OFF  
        RETURN(1);  
    END CATCH  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpTransactionsCleanup]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
    SELECT * FROM mdm.tbl_7_TR where LastChgDTM < '2014-10-22';  
    EXEC mdm.udpLogCLeanup 7, '2014-10-22';  
    SELECT * FROM mdm.tbl_7_TR where LastChgDTM < '2014-10-22';  
*/  
CREATE PROCEDURE [mdm].[udpTransactionsCleanup]  
(  
    @Model_ID    INT,  
    @CleanupOlderThanDate  DATE,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS N'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON  
  
    DECLARE  
        @SQL                            NVARCHAR(MAX),  
         --Annotation table names  
        @TableName                      SYSNAME,  
        @TransactionTableName           SYSNAME,  
        @AnnotationTableName            SYSNAME,  
        @ValidationLogHistoryTableName  SYSNAME;  
  
  
    SET @TransactionTableName = mdm.udfGetTransactionTableName(@Model_ID);  
    SET @AnnotationTableName = mdm.udfGetTransactionAnnotationTableName(@Model_ID);  
  
    BEGIN TRY  
  
        --Delete all Annotations on transactions being deleted issues  
        SET @SQL = CONCAT(N'  
        DELETE an  
        FROM [mdm].', QUOTENAME(@AnnotationTableName), N' an  
        INNER JOIN[mdm].', QUOTENAME(@TransactionTableName), N' tr  
        ON an.Transaction_ID = tr.ID AND an.Version_ID = tr.Version_ID  
        WHERE tr.LastChgDTM <= @CleanupOlderThanDate');  
        EXEC sp_executesql @SQL, N'@CleanupOlderThanDate DATE', @CleanupOlderThanDate;  
  
  
        --Delete all transactions older than the specified date  
        SET @SQL = CONCAT(N'  
        DELETE FROM [mdm].' , QUOTENAME(@TransactionTableName) , N'  
        WHERE LastChgDTM <= @CleanupOlderThanDate');  
  
        EXEC sp_executesql @SQL, N'@CleanupOlderThanDate DATE', @CleanupOlderThanDate;  
  
        DECLARE entity_cursor CURSOR  
            FOR  
                SELECT EntityTable AS TableName  
                FROM mdm.tblEntity  
                WHERE Model_ID = @Model_ID AND EntityTable IS NOT NULL  
                UNION ALL  
                SELECT HierarchyParentTable AS TableName  
                FROM mdm.tblEntity  
                WHERE Model_ID = @Model_ID AND HierarchyParentTable IS NOT NULL  
                UNION ALL  
                SELECT CollectionTable AS TableName  
                FROM mdm.tblEntity  
                WHERE Model_ID = @Model_ID AND CollectionTable IS NOT NULL  
                UNION ALL  
                SELECT HierarchyTable AS TableName  
                FROM mdm.tblEntity  
                WHERE Model_ID = @Model_ID AND HierarchyTable IS NOT NULL  
                UNION ALL  
                SELECT CollectionMemberTable AS TableName  
                FROM mdm.tblEntity  
                WHERE Model_ID = @Model_ID AND CollectionMemberTable IS NOT NULL  
        OPEN entity_cursor  
        FETCH NEXT FROM entity_cursor INTO @TableName  
  
        WHILE @@FETCH_STATUS = 0  
        BEGIN  
            SET @TransactionTableName = CONVERT(SYSNAME, CONCAT(@TableName, '_HS'));  
            SET @AnnotationTableName = CONVERT(SYSNAME, CONCAT(@TableName, '_AN'));  
  
            SET @SQL = CONCAT(N'  
            DELETE an  
            FROM [mdm].', QUOTENAME(@AnnotationTableName), N' an  
            INNER JOIN[mdm].', QUOTENAME(@TransactionTableName), N' tr  
            ON an.Revision_ID = tr.ID AND an.Version_ID = tr.Version_ID  
            WHERE tr.LastChgDTM <= @CleanupOlderThanDate;');  
            EXEC sp_executesql @SQL, N'@CleanupOlderThanDate DATE', @CleanupOlderThanDate;  
  
            SET @SQL = CONCAT(N'  
            DELETE FROM [mdm].' , QUOTENAME(@TransactionTableName) , N'  
            WHERE LastChgDTM <= @CleanupOlderThanDate;');  
  
            EXEC sp_executesql @SQL, N'@CleanupOlderThanDate DATE', @CleanupOlderThanDate;  
            FETCH NEXT FROM entity_cursor INTO @TableName  
        END  
  
        CLOSE entity_cursor;  
        DEALLOCATE entity_cursor;  
  
        RETURN(0);  
    END TRY  
    --Compensate as necessary  
    BEGIN CATCH  
  
        -- Get error info.  
        DECLARE  
            @ErrorMessage NVARCHAR(4000),  
            @ErrorSeverity INT,  
            @ErrorState INT,  
            @ErrorNumber INT,  
            @ErrorLine INT,  
            @ErrorProcedure NVARCHAR(126);  
        EXEC mdm.udpGetErrorInfo  
            @ErrorMessage = @ErrorMessage OUTPUT,  
            @ErrorSeverity = @ErrorSeverity OUTPUT,  
            @ErrorState = @ErrorState OUTPUT,  
            @ErrorNumber = @ErrorNumber OUTPUT,  
            @ErrorLine = @ErrorLine OUTPUT,  
            @ErrorProcedure = @ErrorProcedure OUTPUT  
  
        SET @ErrorMessage = CONCAT(@ErrorMessage, N', @ErrorNumber = ', @ErrorNumber, N', @ErrorProcedure = "', @ErrorProcedure, N'", line ', @ErrorLine);  
  
        RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);  
  
        --On error, return NULL results  
        --SELECT @Return_ID = NULL;  
        RETURN(1);  
  
    END CATCH;  
  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpUniqueStagingBaseCheck]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpUniqueStagingBaseCheck]  
(  
	@StagingBase			NVARCHAR(60),  
	@IsUnique				BIT OUTPUT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
	SET NOCOUNT ON  
	  
	-- If the StagingBase is unique return 1. Otherwise return 0.   
	Set @StagingBase = LTRIM(RTRIM(@StagingBase));  
		  
	IF EXISTS (SELECT 1 FROM mdm.tblEntity WHERE StagingBase = @StagingBase) BEGIN  
		SET @IsUnique = 0;  
	END;   
	ELSE BEGIN  
		SET @IsUnique = 1;  
	END; -- IF  
  
	SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpUserDelete]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
mdm.udpUserDelete 'admin','jsmith'  
select * from mdm.tblUser  
*/  
CREATE PROCEDURE [mdm].[udpUserDelete]  
(  
    @SystemUser_ID  INT, --Person performing save  
    @User_MUID      UNIQUEIDENTIFIER,  
    @SID            NVARCHAR(250) = NULL OUTPUT,  
    @CorrelationID  UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON  
  
    DECLARE @GuidEmpty  UNIQUEIDENTIFIER = CAST(0x0 AS UNIQUEIDENTIFIER),  
            @User_ID    INT;  
  
    SET @User_MUID = NULLIF(@User_MUID, @GuidEmpty);  
  
    SELECT @User_ID = ID, @SID = [SID] FROM mdm.tblUser WHERE MUID = @User_MUID  
    IF @User_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR500043|The user cannot be deleted. The ID is not valid.', 16, 1);  
        RETURN;  
    END  
  
    IF @SystemUser_ID = @User_ID  
    BEGIN  
        RAISERROR('MDSERR500019|The logged-in user cannot be deleted.', 16, 1);  
        RETURN;   
    END  
  
    IF NOT EXISTS (  
        SELECT 1  
        FROM [mdm].[viw_SYSTEM_SECURITY_USER_FUNCTION]  
        WHERE [User_ID] != @User_ID AND Function_ID = 6 /*Super User*/  
    )  
    BEGIN  
        RAISERROR('MDSERR500047|The administrator cannot be deleted.', 16, 1);  
        RETURN;  
    END  
  
    --Start transaction, being careful to check if we are nested  
    DECLARE @TranCounter INT = @@TRANCOUNT;  
    IF @TranCounter > 0   
    BEGIN  
        SAVE TRANSACTION TX;  
    END ELSE   
    BEGIN  
        BEGIN TRANSACTION;  
    END;  
  
    BEGIN TRY  
        DECLARE   
             @PrincipalType_User TINYINT = 1  
            ,@Status_Inactive    TINYINT = 2;  
  
        -- Save all the users we need renbuild the member security  
        DECLARE @SecurityMemberProcessEvent mdm.SecurityMemberProcessEvent  
  
        INSERT @SecurityMemberProcessEvent ([User_ID], [Entity_ID], Version_ID)  
        SELECT DISTINCT [User_ID], [Entity_ID], Version_ID  
        FROM [mdm].[viw_SYSTEM_SECURITY_ROLE_MEMBER] rm  
        INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_ROLE ur  
        ON rm.Role_ID = ur.Role_ID  
        WHERE ur.[User_ID] = @User_ID;  
  
        EXEC mdm.udpSecurityPrivilegesDeleteByPrincipalID @SystemUser_ID, @User_ID, @PrincipalType_User  
  
        UPDATE  
            mdm.tblUser  
        SET  
            Status_ID = @Status_Inactive,  
            LastChgUserID = @SystemUser_ID,  
            LastChgDTM = GETUTCDATE()  
        FROM  
            mdm.tblUser  
        WHERE  
            ID = @User_ID  
  
        EXEC mdm.udpUserGroupAssignmentDelete @SystemUser_ID, @User_ID, NULL, 0;  
  
        -- Queue a event to immediate recompute affected user  
        EXEC mdm.udpSecurityMemberProcessRebuildEvent @SecurityMemberProcessEvent, 1;  
  
        -- Commit transaction only if not nested.  
        IF @TranCounter = 0  
        BEGIN  
            COMMIT TRANSACTION;  
        END;  
    END TRY  
    BEGIN CATCH  
  
        -- Get error info.  
        DECLARE  
            @ErrorMessage NVARCHAR(4000),  
            @ErrorSeverity INT,  
            @ErrorState INT,  
            @ErrorNumber INT,  
            @ErrorLine INT,  
            @ErrorProcedure NVARCHAR(126);  
        EXEC mdm.udpGetErrorInfo  
            @ErrorMessage = @ErrorMessage OUTPUT,  
            @ErrorSeverity = @ErrorSeverity OUTPUT,  
            @ErrorState = @ErrorState OUTPUT,  
            @ErrorNumber = @ErrorNumber OUTPUT,  
            @ErrorLine = @ErrorLine OUTPUT,  
            @ErrorProcedure = @ErrorProcedure OUTPUT  
  
        SET @ErrorMessage = CONCAT(@ErrorMessage, N', @ErrorNumber = ', @ErrorNumber, N', @ErrorProcedure = "', @ErrorProcedure, N'", line ', @ErrorLine);  
  
        -- Roll back the transaction.  
        IF @TranCounter = 0 ROLLBACK TRANSACTION;  
        ELSE IF XACT_STATE() <> -1 ROLLBACK TRANSACTION TX;  
  
        RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);  
  
    END CATCH;  
  
    -- Send the message  
	EXEC mdm.udpPerformanceQueueSave;  
  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpUserGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
Gets information about the given user.  
  
EXEC mdm.udpUserGet 5  
EXEC mdm.udpUserGet 11  
*/  
CREATE PROCEDURE [mdm].[udpUserGet]  
(  
    @User_ID INT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON  
  
    SELECT  
        u.ID,  
        u.MUID,  
        u.SID,  
        u.UserName,  
        u.DisplayName,  
        u.Description,  
        u.EmailAddress,  
        u.LastLoginDTM,  
-       u.EnterUserID,  
        eu.MUID AS EnterUserMUID,  
        COALESCE(eu.UserName,N'') AS EnterUserName,  
        COALESCE(eu.DisplayName,N'') AS EnterUserDisplayName,  
        u.EnterDTM,  
        u.LastChgUserID,  
        eu.MUID AS LastChgUserMUID,  
        COALESCE(lcu.UserName,N'') AS LastChgUserName,  
        COALESCE(lcu.DisplayName,N'') AS LastChgUserDisplayName,  
        u.LastChgDTM,  
        pref.PreferenceValue AS EmailType    
    FROM  
        mdm.tblUser u  
        LEFT OUTER JOIN mdm.tblUser eu ON u.EnterUserID = eu.ID   
        LEFT OUTER JOIN mdm.tblUser lcu ON u.LastChgUserID = lcu.ID  
        LEFT OUTER JOIN mdm.tblUserPreference pref on u.ID = pref.User_ID AND PreferenceName='lstEmail'  
    WHERE  
        u.ID = @User_ID   
        AND u.Status_ID <> 2  
  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpUserGetByMUID]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
EXEC mdm.udpUserGetByMuid 3F07AFF7-9557-4D7E-AFEA-A8E2AFA6F90E  
*/  
CREATE PROCEDURE [mdm].[udpUserGetByMUID]  
(  
    @User_MUID UNIQUEIDENTIFIER,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON  
    DECLARE @USER_ID int,  
            @return_value int  
  
    IF (@User_MUID IS NULL OR CAST(@User_MUID  AS BINARY) = 0x0 OR (NOT EXISTS (SELECT MUID FROM mdm.tblUser WHERE MUID = @User_MUID)))  
    BEGIN  
        RAISERROR('MDSERR500001|The user GUID is not valid.', 16, 1);  
        RETURN;  
    END  
  
    SELECT @USER_ID = (SELECT ID FROM mdm.tblUser where MUID=@User_MUID)  
  
    EXEC [mdm].[udpUserGet] @USER_ID  
  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpUserGroupAssignmentDelete]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
exec mdm.udpUserGroupAssignmentDelete 'jhills', NULL    -- Deletes all group assignments for user_id 'jhills'  
exec mdm.udpUserGroupAssignmentDelete NULL, 8           -- Deletes all group assignments for usergroup_id 8   
exec mdm.udpUserGroupAssignmentDelete 'bbarnett', 9     -- Deletes group assignment for user_id 'bbarnett' and usergroup_id 9  
exec mdm.udpUserGroupAssignmentDelete NULL, NULL        -- Deletes all group assignments  
  
select u.UserName, ga.* from mdm.tblUserGroupAssignment ga inner join mdm.tblUser u on u.id = ga.User_ID order by usergroup_id, user_id  
select u.UserName, ga.* from mdm.tblUserGroupAssignment ga inner join mdm.tblUser u on u.id = ga.User_ID order by user_id, usergroup_id   
  
*/  
CREATE PROCEDURE [mdm].[udpUserGroupAssignmentDelete]  
(  
    @SystemUser_ID  INT, --Person performing save  
    @User_ID        INT = NULL, -- NULL to deactive all user  
    @UserGroup_ID   INT = NULL, -- NULL to deactive all group  
    @ProcessSecurityMember  BIT = 1,  
    @CorrelationID  UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON  
  
    DECLARE @Status_Deactive        TINYINT = 2,  
            @PrincipalType_Group    TINYINT = 2,  
            @securityMemberEvent    mdm.SecurityMemberProcessEvent  
  
    IF @ProcessSecurityMember = 1  
    BEGIN  
        IF @User_ID IS NOT NULL  
        BEGIN  
            INSERT @securityMemberEvent ([User_ID], [Entity_ID], Version_ID)  
            SELECT DISTINCT [User_ID], [Entity_ID], Version_ID  
            FROM [mdm].[viw_SYSTEM_SECURITY_ROLE_MEMBER] rm  
            INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_ROLE ur  
            ON rm.Role_ID = ur.Role_ID  
            WHERE ur.[User_ID] = @User_ID;  
        END  
        ELSE IF @UserGroup_ID IS NOT NULL  
        BEGIN  
            INSERT @securityMemberEvent ([User_ID], [Entity_ID], Version_ID)  
            SELECT DISTINCT [User_ID], [Entity_ID], Version_ID  
            FROM [mdm].[viw_SYSTEM_SECURITY_ROLE_MEMBER] rm  
            INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_ROLE ur  
            ON rm.Role_ID = ur.Role_ID  
            INNER JOIN [mdm].[tblSecurityAccessControl] sa  
            ON  rm.Role_ID = sa.Role_ID  
            WHERE PrincipalType_ID = @PrincipalType_Group  
            AND Principal_ID = @UserGroup_ID  
        END  
    END  
  
    DELETE mdm.tblUserGroupAssignment  
    WHERE (@UserGroup_ID IS NOT NULL OR @User_ID IS NOT NULL)  
        AND (@UserGroup_ID IS NULL OR UserGroup_ID = @UserGroup_ID)  
        AND (@User_ID IS NULL OR [User_ID] = @User_ID)  
  
    -- Queue a async event to recompute affected user  
    EXEC mdm.udpSecurityMemberProcessRebuildEvent @securityMemberEvent, 0;  
  
    -- Send the message  
	EXEC mdm.udpPerformanceQueueSave;  
  
    SET NOCOUNT OFF  
END
GO
/****** Object:  StoredProcedure [mdm].[udpUserGroupAssignmentSave]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
mdm.udpUserGroupAssignmentSave 1,1,1  
select * from mdm.tblUserGroupAssignment  
*/  
CREATE PROCEDURE [mdm].[udpUserGroupAssignmentSave]  
(  
    @SystemUser_ID      INT, --Person performing save  
    @User_ID            INT,  
    @UserGroup_MUID     UNIQUEIDENTIFIER,  
    @CorrelationID      UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
    DECLARE @GuidEmpty              UNIQUEIDENTIFIER = CAST(0x0 AS UNIQUEIDENTIFIER),  
            @UserGroup_ID           INT,  
            @securityMemberEvent    mdm.SecurityMemberProcessEvent;  
  
    INSERT @securityMemberEvent ([User_ID], [Entity_ID], Version_ID)  
    SELECT DISTINCT [User_ID], [Entity_ID], Version_ID  
    FROM [mdm].[viw_SYSTEM_SECURITY_ROLE_MEMBER] rm  
    INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_ROLE ur  
    ON rm.Role_ID = ur.Role_ID  
    WHERE ur.[User_ID] = @User_ID;  
  
    SET @UserGroup_MUID = NULLIF(@UserGroup_MUID, @GuidEmpty);  
  
    SELECT @UserGroup_ID  = (SELECT ID FROM mdm.tblUserGroup WHERE MUID = @UserGroup_MUID)  
    IF @UserGroup_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR500022|The group assignment cannot be updated. The group ID is not valid.', 16, 1);  
        RETURN;  
    END  
  
    IF NOT EXISTS(  
        SELECT 1 FROM mdm.tblUserGroupAssignment  
        WHERE UserGroup_ID = @UserGroup_ID  
            AND User_ID = @User_ID)  
    BEGIN  
        INSERT INTO mdm.tblUserGroupAssignment(UserGroup_ID, User_ID, EnterUserID, LastChgUserID)  
        SELECT @UserGroup_ID, @User_ID, @SystemUser_ID, @SystemUser_ID;  
    END  
  
    -- Queue a async event to recompute affected user  
    EXEC mdm.udpSecurityMemberProcessRebuildEvent @securityMemberEvent, 0;  
  
    -- Send the message  
	EXEC mdm.udpPerformanceQueueSave;  
  
    SET NOCOUNT OFF;  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpUserGroupDelete]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
mdm.udpUserGroupDelete 1,1  
select * from mdm.tblUserGroup  
*/  
CREATE PROCEDURE [mdm].[udpUserGroupDelete]  
(  
    @SystemUser_ID  INT,  
    @UserGroup_MUID UNIQUEIDENTIFIER,  
    @SID            NVARCHAR(250) = NULL OUTPUT,  
    @CorrelationID  UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON  
  
    DECLARE @GuidEmpty      UNIQUEIDENTIFIER = CAST(0x0 AS UNIQUEIDENTIFIER),  
            @UserGroup_ID   INT;  
  
    SET @UserGroup_MUID = NULLIF(@UserGroup_MUID, @GuidEmpty);  
  
    SELECT @UserGroup_ID = ID , @SID = [SID] FROM mdm.tblUserGroup WHERE MUID = @UserGroup_MUID  
    IF @UserGroup_ID IS NULL  
    BEGIN  
        RAISERROR('MDSERR500044|The group cannot be deleted. The ID is not valid.', 16, 1);  
        RETURN;  
    END  
  
    --Start transaction, being careful to check if we are nested  
    DECLARE @TranCounter INT = @@TRANCOUNT;  
    IF @TranCounter > 0   
    BEGIN  
        SAVE TRANSACTION TX;  
    END ELSE   
    BEGIN  
        BEGIN TRANSACTION;  
    END;  
  
    BEGIN TRY  
        DECLARE @PrincipalType_Group    TINYINT = 2,  
                @Status_Inactive        TINYINT = 2;  
  
        -- Save all the users we need renbuild the member security  
        DECLARE @securityMemberEvent mdm.SecurityMemberProcessEvent  
  
        INSERT @securityMemberEvent ([User_ID], [Entity_ID], Version_ID)  
        SELECT DISTINCT [User_ID], [Entity_ID], Version_ID  
        FROM [mdm].[viw_SYSTEM_SECURITY_ROLE_MEMBER] rm  
        INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_ROLE ur  
        ON rm.Role_ID = ur.Role_ID  
        INNER JOIN [mdm].[tblSecurityAccessControl] sa  
        ON  rm.Role_ID = sa.Role_ID  
        WHERE PrincipalType_ID = @PrincipalType_Group  
        AND Principal_ID = @UserGroup_ID  
  
        EXEC mdm.udpSecurityPrivilegesDeleteByPrincipalID @SystemUser_ID, @UserGroup_ID, @PrincipalType_Group  
  
        UPDATE  
            tblUserGroup  
        SET  
            Status_ID = @Status_Inactive,  
            LastChgUserID = @SystemUser_ID,  
            LastChgDTM = GETUTCDATE()  
        FROM  
            mdm.tblUserGroup  
        WHERE  
            ID = @UserGroup_ID  
  
        EXEC mdm.udpUserGroupAssignmentDelete @SystemUser_ID, NULL, @UserGroup_ID, 0;  
  
        -- Queue a event to immediate recompute affected user  
        EXEC mdm.udpSecurityMemberProcessRebuildEvent @securityMemberEvent, 1;  
  
        -- Commit transaction only if not nested.  
        IF @TranCounter = 0  
        BEGIN  
            COMMIT TRANSACTION;  
        END;  
    END TRY  
    BEGIN CATCH  
  
        -- Get error info.  
        DECLARE  
            @ErrorMessage NVARCHAR(4000),  
            @ErrorSeverity INT,  
            @ErrorState INT,  
            @ErrorNumber INT,  
            @ErrorLine INT,  
            @ErrorProcedure NVARCHAR(126);  
        EXEC mdm.udpGetErrorInfo  
            @ErrorMessage = @ErrorMessage OUTPUT,  
            @ErrorSeverity = @ErrorSeverity OUTPUT,  
            @ErrorState = @ErrorState OUTPUT,  
            @ErrorNumber = @ErrorNumber OUTPUT,  
            @ErrorLine = @ErrorLine OUTPUT,  
            @ErrorProcedure = @ErrorProcedure OUTPUT  
  
        SET @ErrorMessage = CONCAT(@ErrorMessage, N', @ErrorNumber = ', @ErrorNumber, N', @ErrorProcedure = "', @ErrorProcedure, N'", line ', @ErrorLine);  
  
        -- Roll back the transaction.  
        IF @TranCounter = 0 ROLLBACK TRANSACTION;  
        ELSE IF XACT_STATE() <> -1 ROLLBACK TRANSACTION TX;  
  
        RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);  
  
    END CATCH;  
  
    -- Send the message  
	EXEC mdm.udpPerformanceQueueSave;  
  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpUserGroupListGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
Gets all user groups.  
  
EXEC mdm.udpUserGroupListGet  
*/  
CREATE PROCEDURE [mdm].[udpUserGroupListGet]  
(  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON  
    SELECT  
        g.ID,  
        g.MUID,  
        g.UserGroupType_ID,  
        g.SID,  
        g.Name,  
        g.Description,  
        COALESCE(g.EnterUserID, 0) AS EnterUserID,  
        eu.MUID AS EnterUserMUID,  
        COALESCE(eu.UserName, N'') AS EnterUserName,  
        COALESCE(eu.DisplayName, N'') AS EnterUserDisplayName,  
        g.EnterDTM,  
        COALESCE(g.LastChgUserID, 0) AS LastChgUserID,  
        lcu.MUID AS LastChgUserMUID,  
        COALESCE(lcu.UserName, N'') AS LastChgUserName,  
        COALESCE(lcu.DisplayName, N'') AS LastChgUserDisplayName,  
        g.LastChgDTM  
    FROM mdm.tblUserGroup g  
    LEFT JOIN mdm.tblUser eu   
    ON g.EnterUserID = eu.ID   
    LEFT JOIN mdm.tblUser lcu   
    ON g.LastChgUserID = lcu.ID  
    WHERE g.Status_ID = 1--Active  
    ORDER BY Name  
  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpUserGroupSave]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpUserGroupSave]  
(  
    @SystemUser_ID      INT,  
    @UserGroup_ID       INT = NULL OUTPUT,  
    @UserGroup_MUID     UNIQUEIDENTIFIER = NULL OUTPUT, -- \  
    @SID                NVARCHAR(250) = NULL OUTPUT,    -- / One of these is required  
    @Name               NVARCHAR(355) = NULL,  
    @UserGroupType_ID   TINYINT = NULL,  
    @Status_ID          TINYINT,  
    @Description        NVARCHAR(256) = NULL,  
    @CorrelationID      UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
AS  
BEGIN  
    SET NOCOUNT ON  
  
    DECLARE @GuidEmpty              UNIQUEIDENTIFIER = CAST(0x0 AS UNIQUEIDENTIFIER),  
  
            @Status_Create          INT = 0,  
            @Status_Activate        INT = 1,  
            @Status_Deactive        INT = 2,  
            @Status_Clone           INT = 3,  
  
            @GroupStatus_ID         TINYINT,  
            @GroupStatus_Active     TINYINT = 1,  
            @GroupStatus_Deactive   TINYINT = 2,  
              
            @OldUserGroup_MUID      UNIQUEIDENTIFIER,  
            @OldUserGroup_SID       NVARCHAR(250),  
            @ErrorMessage           NVARCHAR(4000);  
  
    SELECT   
        @UserGroup_MUID = NULLIF(@UserGroup_MUID, @GuidEmpty),  
        @SID = NULLIF(LTRIM(RTRIM(@SID)), N''),  
        @Name = NULLIF(LTRIM(RTRIM(@Name)), N''),  
        @UserGroupType_ID = NULLIF(@UserGroupType_ID, 0),  
        @Description = NULLIF(LTRIM(RTRIM(@Description)), N'');  
  
    SELECT @UserGroup_ID = ID, @OldUserGroup_MUID = MUID, @OldUserGroup_SID = [SID]  
    FROM mdm.tblUserGroup  
    WHERE  
        (@UserGroup_MUID IS NOT NULL OR @SID IS NOT NULL)  
        AND (@Status_ID = @Status_Clone OR @UserGroup_MUID  IS NULL OR MUID = @UserGroup_MUID)  
        AND (@SID IS NULL OR [SID] = @SID);  
  
    -- New group  
    IF @UserGroup_ID IS NULL  
    BEGIN  
        IF @Status_ID = @Status_Activate OR @Status_ID = @Status_Deactive  
        BEGIN  
            RAISERROR('MDSERR500004|The principal cannot be updated because the principal identifier is not valid. The identifier must have an existing GUID, name, or both.', 16, 1);  
            RETURN  
        END  
  
        -- For new group, the name and sid should be unique  
        IF EXISTS(  
            SELECT 1  
            FROM mdm.tblUserGroup  
            WHERE  
                (@SID IS NOT NULL OR @Name IS NOT NULL)  
                AND ((@SID IS NOT NULL AND [SID] = @SID)  
                    OR (@Name IS NOT NULL AND Name = @Name))  
        )  
        BEGIN  
            SELECT  @ErrorMessage = N'MDSERR500015|Name and Security Identifier (SID) combination must be unique for group update, create, and copy operations. Name: {0}, Security Identifier: {1}.|' + REPLACE(@Name, N'|', N'') + '|' + @SID;  
            SET @ErrorMessage = REPLACE(@ErrorMessage, '%', '%%')-- escape out format specifier  
            RAISERROR(@ErrorMessage, 16, 1, @Name, @SID);  
        END  
  
        IF @UserGroup_MUID IS NULL  
        BEGIN  
            IF @Status_ID = @Status_Clone  
            BEGIN  
                RAISERROR('MDSERR500004|The principal cannot be updated because the principal identifier is not valid. The identifier must have an existing GUID, name, or both.', 16, 1);  
                RETURN  
            END  
            ELSE  
            BEGIN  
                SET @UserGroup_MUID = NEWID();  
            END  
        END  
  
        INSERT INTO mdm.tblUserGroup  
        (  
            [UserGroupType_ID],  
            [Status_ID],  
            [Name],  
            [SID],  
            [Description],  
            [EnterUserID],  
            [LastChgUserID],  
            [MUID]  
        )  
        SELECT  
            @UserGroupType_ID,  
            @GroupStatus_Active,  
            @Name,  
            @SID,  
            @Description,  
            @SystemUser_ID,  
            @SystemUser_ID,  
            @UserGroup_MUID  
  
        SET @UserGroup_ID = SCOPE_IDENTITY();  
    END  
    ELSE  
    BEGIN  
        SET @GroupStatus_ID = CASE @Status_ID WHEN @Status_Deactive THEN @GroupStatus_Deactive ELSE @GroupStatus_Active END;  
  
        IF @Status_ID != @Status_Clone OR @UserGroup_MUID IS NULL  
        BEGIN  
            UPDATE tblUserGroup  
            SET Status_ID = @GroupStatus_ID,  
                Name = COALESCE(@Name, Name),  
                UserGroupType_ID = COALESCE(@UserGroupType_ID, UserGroupType_ID),  
                [Description] = COALESCE(@Description,[Description]),  
                LastChgUserID = @SystemUser_ID,  
                LastChgDTM = GETUTCDATE()  
            WHERE ID = @UserGroup_ID  
            SET @UserGroup_MUID = @OldUserGroup_MUID;  
        END  
        ELSE  
        BEGIN  
            UPDATE tblUserGroup  
            SET MUID = @UserGroup_MUID,  
                Status_ID = @GroupStatus_ID,  
                Name = COALESCE(@Name, Name),  
                UserGroupType_ID = COALESCE(@UserGroupType_ID, UserGroupType_ID),  
                [Description] = COALESCE(@Description,[Description]),  
                LastChgUserID = @SystemUser_ID,  
                LastChgDTM = GETUTCDATE()  
            WHERE ID = @UserGroup_ID  
        END  
  
        SET @SID = @OldUserGroup_SID;  
    END  
  
    SET NOCOUNT OFF  
END;
GO
/****** Object:  StoredProcedure [mdm].[udpUserGroupUsersGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
Gets the users that are assigned to the given group.  
  
exec mdm.udpUserGroupUsersGet 8  
  
select * from mdm.tblUserGroupAssignment  
*/  
CREATE PROCEDURE [mdm].[udpUserGroupUsersGet]  
(  
    @UserGroup_ID   INT,  
    @CorrelationID  UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON  
  
    SELECT  
        U.ID,  
        U.MUID,  
        U.UserName + N' (' + U.DisplayName + N')' as Name,  
        U.UserName  
    FROM mdm.tblUser U  
    INNER JOIN mdm.tblUserGroupAssignment SGA   
    ON U.ID = SGA.User_ID  
    WHERE   SGA.UserGroup_ID = @UserGroup_ID  
        AND U.Status_ID = 1 -- Active  
    ORDER BY  
        U.UserName  
  
    SET NOCOUNT OFF  
END
GO
/****** Object:  StoredProcedure [mdm].[udpUserIsModelAdministrator]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
This stored procedure determines if a user is an administrator a model.  A model administrator must have update permission of  
the model and all underlying child objects.  This can be determined by passing in the Model Id itself or it can be determined  
by passing in child objects (if that is all that is available) and then based on the FK links it can be determined if the user  
is an administrator of the model.  
  
The object context is optional and need only be passed in if the object Muid is not passed in, which is the case in add mode.  
  
declare @ret as INT  
exec mdm.udpUserIsModelAdministrator  
    1,  
    7,  
    NULL,  
    'EE851F25-8919-460F-8485-99D319C70AF2',  
    NULL,  
    @ret OUTPUT  
select @ret  
  
declare @ret as INT  
exec mdm.udpUserIsModelAdministrator  
    1,  
    5,  
    NULL,  
    'Department',  
    NULL,  
    NULL,  
    @ret OUTPUT  
select @ret  
*/  
CREATE PROCEDURE [mdm].[udpUserIsModelAdministrator]  
(  
    @User_ID            INT,                        -- User id to check .  
    @ObjectType_ID      INT,                        -- The object type of the Muid being passed in.  
    @Object_MUID        UNIQUEIDENTIFIER = NULL,    -- The object's Muid.  Not passed in during add mode.  
    @Object_Name        NVARCHAR(MAX) = NULL,       -- The object's Name.  Not passed in during add mode.  
    @ObjectContext_MUID UNIQUEIDENTIFIER = NULL,    -- The object's context (or parent) Muid.  
    @ObjectContext_Name NVARCHAR(MAX) = NULL,       -- The object's context (or parent) name.  
    @Return_ID          INT = NULL OUTPUT,           -- The result: True if the user is a model admin.  False otherwise.  
    @CorrelationID      UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON  
  
    DECLARE  
         @EmptyMuid UNIQUEIDENTIFIER = CONVERT(UNIQUEIDENTIFIER, 0x0)  
        ,@ObjectType_Model                  INT = 1  
        ,@ObjectType_DerivedHierarchy       INT = 2  
        ,@ObjectType_DerivedHierarchyLevel  INT = 3  
        ,@ObjectType_Version                INT = 4  
        ,@ObjectType_Entity                 INT = 5  
        ,@ObjectType_Hierarchy              INT = 6  
        ,@ObjectType_Attribute              INT = 7  
        ,@ObjectType_AttributeGroup         INT = 8  
        ,@ObjectType_VersionFlag            INT = 10  
        ,@ObjectType_Index                  INT = 23  
        ;  
  
    -- In an add scenario the object Muid will not be supplied.  
    SET @Object_MUID = NULLIF(@Object_MUID, @EmptyMuid);  
    SET @Object_Name = NULLIF(@Object_Name, N'');  
  
    --Null out the context Muid and Name if it is not supplied.  
    SET @ObjectContext_MUID = NULLIF(@ObjectContext_MUID, @EmptyMuid);  
    SET @ObjectContext_Name = NULLIF(@ObjectContext_Name, N'');  
  
    IF @Object_MUID IS NULL AND @Object_Name IS NULL AND @ObjectContext_MUID IS NULL AND @ObjectContext_Name IS NULL  
    BEGIN  
        SET @Return_ID = 0;  
        RETURN;  
    END  
  
    IF (@Object_MUID IS NULL AND @Object_Name IS NOT NULL) AND (@ObjectContext_MUID IS NULL AND @ObjectContext_Name IS NULL) AND @ObjectType_ID <> @ObjectType_Model -- Model's don't need context  
    BEGIN  
        SET @Return_ID = 0;  
        RETURN;  
    END  
  
    -- Lookup the Model ID  
    IF @ObjectType_ID = @ObjectType_Model  
    BEGIN  
        SELECT  
            @Return_ID = CASE acl.Privilege_ID WHEN 5 /*Admin*/ THEN 1 ELSE 0 END  
        FROM  
            mdm.tblModel itm INNER JOIN  
            mdm.viw_SYSTEM_SECURITY_USER_MODEL AS acl  
                ON  acl.ID = itm.ID  
                AND acl.User_ID = @User_ID  
                AND acl.Privilege_ID <> 1 /*Deny*/  
                AND (itm.MUID = @Object_MUID OR itm.Name = @Object_Name)  
    END  
    ELSE IF @ObjectType_ID = @ObjectType_Entity  
    BEGIN  
        IF @Object_MUID IS NOT NULL  
            SELECT  
                @Return_ID = CASE acl.Privilege_ID WHEN 5 /*Admin*/ THEN 1 ELSE 0 END  
            FROM  
                mdm.viw_SYSTEM_SCHEMA_ENTITY itm INNER JOIN  
                mdm.viw_SYSTEM_SECURITY_USER_MODEL AS acl  
                    ON  ((itm.MUID = @Object_MUID)  
                    OR  (itm.Name = @Object_Name AND (((@ObjectContext_MUID IS NULL) OR (itm.Model_MUID = @ObjectContext_MUID)) AND ((@ObjectContext_Name IS NULL) OR (itm.Model_Name = @ObjectContext_Name))))  
                    )  
                    AND acl.ID = itm.Model_ID  
                    AND acl.User_ID = @User_ID  
                    AND acl.Privilege_ID <> 1 /*Deny*/  
        ELSE  
            SELECT  
                @Return_ID = CASE acl.Privilege_ID WHEN 5 /*Admin*/ THEN 1 ELSE 0 END  
            FROM  
                mdm.tblModel ctx INNER JOIN  
                mdm.viw_SYSTEM_SECURITY_USER_MODEL AS acl  
                    ON ((@ObjectContext_MUID IS NULL) OR (ctx.MUID = @ObjectContext_MUID))  
                    AND ((@ObjectContext_Name IS NULL) OR (ctx.Name = @ObjectContext_Name))  
                    AND acl.ID = ctx.ID  
                    AND acl.User_ID = @User_ID  
                    AND acl.Privilege_ID <> 1 /*Deny*/  
  
    END  
    ELSE IF @ObjectType_ID = @ObjectType_Attribute  
        BEGIN  
            IF @Object_MUID IS NOT NULL  
                SELECT  
                    @Return_ID = CASE acl.Privilege_ID WHEN 5 /*Admin*/ THEN 1 ELSE 0 END  
                FROM  
                    mdm.viw_SYSTEM_SCHEMA_ATTRIBUTES itm INNER JOIN  
                    mdm.viw_SYSTEM_SECURITY_USER_MODEL AS acl  
                        ON  ((itm.Attribute_MUID = @Object_MUID)  
                        OR  (itm.Attribute_Name = @Object_Name AND (((@ObjectContext_MUID IS NULL) OR (itm.Entity_MUID = @ObjectContext_MUID)) AND ((@ObjectContext_Name IS NULL) OR (itm.Entity_Name = @ObjectContext_Name))))  
                        )  
                        AND acl.ID = itm.Model_ID  
                        AND acl.User_ID = @User_ID  
                        AND acl.Privilege_ID <> 1 /*Deny*/  
            ELSE  
                SELECT  
                    @Return_ID = CASE acl.Privilege_ID WHEN 5 /*Admin*/ THEN 1 ELSE 0 END  
                FROM  
                    mdm.tblEntity ctx INNER JOIN  
                    mdm.viw_SYSTEM_SECURITY_USER_MODEL AS acl  
                        ON ((@ObjectContext_MUID IS NULL) OR (ctx.MUID = @ObjectContext_MUID))  
                        AND ((@ObjectContext_Name IS NULL ) OR (ctx.Name = @ObjectContext_Name))  
                        AND acl.ID = ctx.Model_ID  
                        AND acl.User_ID = @User_ID  
                        AND acl.Privilege_ID <> 1 /*Deny*/  
  
        END  
    ELSE IF @ObjectType_ID = @ObjectType_AttributeGroup  
        BEGIN  
            IF @Object_MUID IS NOT NULL  
                SELECT  
                    @Return_ID = CASE acl.Privilege_ID WHEN 5 /*Admin*/ THEN 1 ELSE 0 END  
                FROM  
                    mdm.viw_SYSTEM_SCHEMA_ATTRIBUTEGROUPS itm INNER JOIN  
                    mdm.viw_SYSTEM_SECURITY_USER_MODEL AS acl  
                        ON  ((itm.MUID = @Object_MUID)  
                        OR  (itm.Name = @Object_Name AND (((@ObjectContext_MUID IS NULL) OR (itm.Entity_MUID = @ObjectContext_MUID)) AND ((@ObjectContext_Name IS NULL) OR (itm.Entity_Name = @ObjectContext_Name))))  
                        )  
                        AND acl.ID = itm.Model_ID  
                        AND acl.User_ID = @User_ID  
                        AND acl.Privilege_ID <> 1 /*Deny*/  
            ELSE  
                SELECT  
                    @Return_ID = CASE acl.Privilege_ID WHEN 5 /*Admin*/ THEN 1 ELSE 0 END  
                FROM  
                    mdm.tblEntity ctx INNER JOIN  
                    mdm.viw_SYSTEM_SECURITY_USER_MODEL AS acl  
                        ON ((@ObjectContext_MUID IS NULL) OR (ctx.MUID = @ObjectContext_MUID))  
                        AND ((@ObjectContext_Name IS NULL) OR (ctx.Name = @ObjectContext_Name))  
                        AND acl.ID = ctx.Model_ID  
                        AND acl.User_ID = @User_ID  
                        AND acl.Privilege_ID <> 1 /*Deny*/  
  
        END  
    ELSE IF @ObjectType_ID = @ObjectType_Hierarchy  
        BEGIN  
            IF @Object_MUID IS NOT NULL  
            SELECT  
                @Return_ID = CASE acl.Privilege_ID WHEN 5 /*Admin*/ THEN 1 ELSE 0 END  
            FROM  
                mdm.viw_SYSTEM_SCHEMA_HIERARCHY_EXPLICIT itm INNER JOIN  
                mdm.viw_SYSTEM_SECURITY_USER_MODEL AS acl  
                    ON  ((itm.Hierarchy_MUID = @Object_MUID)  
                    OR  (itm.Hierarchy_Name = @Object_Name AND (((@ObjectContext_MUID IS NULL) OR (itm.Entity_MUID = @ObjectContext_MUID)) AND ((@ObjectContext_Name IS NULL) OR (itm.Entity_Name = @ObjectContext_Name))))  
                    )  
                    AND acl.ID = itm.Model_ID  
                    AND acl.User_ID = @User_ID  
                    AND acl.Privilege_ID <> 1 /*Deny*/  
            ELSE  
                SELECT  
                    @Return_ID = CASE acl.Privilege_ID WHEN 5 /*Admin*/ THEN 1 ELSE 0 END  
                FROM  
                    mdm.tblEntity ctx INNER JOIN  
                    mdm.viw_SYSTEM_SECURITY_USER_MODEL AS acl  
                        ON ((@ObjectContext_MUID IS NULL) OR (ctx.MUID = @ObjectContext_MUID))  
                        AND ((@ObjectContext_Name IS NULL) OR (ctx.Name = @ObjectContext_Name))  
                        AND acl.ID = ctx.Model_ID  
                        AND acl.User_ID = @User_ID  
                        AND acl.Privilege_ID <> 1 /*Deny*/  
  
        END  
    ELSE IF @ObjectType_ID = @ObjectType_DerivedHierarchy  
        BEGIN  
            IF @Object_MUID IS NOT NULL  
                SELECT  
                    @Return_ID = CASE acl.Privilege_ID WHEN 5 /*Admin*/ THEN 1 ELSE 0 END  
                FROM  
                    mdm.viw_SYSTEM_SCHEMA_HIERARCHY_DERIVED itm INNER JOIN  
                    mdm.viw_SYSTEM_SECURITY_USER_MODEL AS acl  
                        ON  ((itm.Hierarchy_MUID = @Object_MUID)  
                        OR  (itm.Hierarchy_Name = @Object_Name AND (((@ObjectContext_MUID IS NULL) OR (itm.Model_MUID = @ObjectContext_MUID)) AND ((@ObjectContext_Name IS NULL) OR (itm.Model_Name = @ObjectContext_Name))))  
                        )  
                        AND acl.ID = itm.Model_ID  
                        AND acl.User_ID = @User_ID  
                        AND acl.Privilege_ID <> 1 /*Deny*/  
            ELSE  
                SELECT  
                    @Return_ID = CASE acl.Privilege_ID WHEN 5 /*Admin*/ THEN 1 ELSE 0 END  
                FROM  
                    mdm.tblModel ctx INNER JOIN  
                    mdm.viw_SYSTEM_SECURITY_USER_MODEL AS acl  
                        ON ((@ObjectContext_MUID IS NULL) OR (ctx.MUID = @ObjectContext_MUID))  
                        AND ((@ObjectContext_Name IS NULL) OR (ctx.Name = @ObjectContext_Name))  
                        AND acl.ID = ctx.ID  
                        AND acl.User_ID = @User_ID  
                        AND acl.Privilege_ID <> 1 /*Deny*/  
        END  
    ELSE IF @ObjectType_ID = @ObjectType_DerivedHierarchyLevel  
        BEGIN  
            IF @Object_MUID IS NOT NULL  
                SELECT  
                    @Return_ID = CASE acl.Privilege_ID WHEN 5 /*Admin*/ THEN 1 ELSE 0 END  
                FROM  
                    mdm.viw_SYSTEM_SCHEMA_HIERARCHY_DERIVED_LEVELS itm INNER JOIN  
                    mdm.viw_SYSTEM_SECURITY_USER_MODEL AS acl  
                        ON  ((itm.MUID = @Object_MUID)  
                        OR  (itm.Name = @Object_Name AND (((@ObjectContext_MUID IS NULL) OR (itm.Hierarchy_MUID = @ObjectContext_MUID)) AND ((@ObjectContext_Name IS NULL) OR (itm.Hierarchy_Name = @ObjectContext_Name))))  
                        )  
                        AND acl.ID = itm.Model_ID  
                        AND acl.User_ID = @User_ID  
                        AND acl.Privilege_ID <> 1 /*Deny*/  
            ELSE  
                SELECT  
                    @Return_ID = CASE acl.Privilege_ID WHEN 5 /*Admin*/ THEN 1 ELSE 0 END  
                FROM  
                    mdm.tblDerivedHierarchy ctx INNER JOIN  
                    mdm.tblModel mdl  
                        ON ctx.Model_ID = mdl.ID  
                    INNER JOIN  
                    mdm.viw_SYSTEM_SECURITY_USER_MODEL AS acl  
                        ON ((@ObjectContext_MUID IS NULL) OR (ctx.MUID = @ObjectContext_MUID))  
                        AND ((@ObjectContext_Name IS NULL) OR (ctx.Name = @ObjectContext_Name))  
                        AND acl.ID = mdl.ID  
                        AND acl.User_ID = @User_ID  
                        AND acl.Privilege_ID <> 1 /*Deny*/  
        END  
    ELSE IF @ObjectType_ID = @ObjectType_VersionFlag  
        BEGIN  
            IF @Object_MUID IS NOT NULL  
                SELECT  
                    @Return_ID = CASE acl.Privilege_ID WHEN 5 /*Admin*/ THEN 1 ELSE 0 END  
                FROM  
                    mdm.viw_SYSTEM_SCHEMA_VERSION_FLAGS itm INNER JOIN  
                    mdm.viw_SYSTEM_SECURITY_USER_MODEL AS acl  
                        ON  ((itm.MUID = @Object_MUID)  
                        OR  (itm.Name = @Object_Name AND (((@ObjectContext_MUID IS NULL) OR (itm.Model_MUID = @ObjectContext_MUID)) AND ((@ObjectContext_Name IS NULL) OR (itm.Model_Name = @ObjectContext_Name))))  
                        )  
                        AND acl.ID = itm.Model_ID  
                        AND acl.User_ID = @User_ID  
                        AND acl.Privilege_ID <> 1 /*Deny*/  
            ELSE  
                SELECT  
                    @Return_ID = CASE acl.Privilege_ID WHEN 5 /*Admin*/ THEN 1 ELSE 0 END  
                FROM  
                    mdm.tblModel ctx INNER JOIN  
                    mdm.viw_SYSTEM_SECURITY_USER_MODEL AS acl  
                        ON ((@ObjectContext_MUID IS NULL) OR (ctx.MUID = @ObjectContext_MUID))  
                        AND ((@ObjectContext_Name IS NULL) OR (ctx.Name = @ObjectContext_Name))  
                        AND acl.ID = ctx.ID  
                        AND acl.User_ID = @User_ID  
                        AND acl.Privilege_ID <> 1 /*Deny*/  
  
        END  
    ELSE IF @ObjectType_ID = @ObjectType_Version  
        BEGIN  
            IF @Object_MUID IS NOT NULL  
                SELECT  
                    @Return_ID = CASE acl.Privilege_ID WHEN 5 /*Admin*/ THEN 1 ELSE 0 END  
                FROM  
                    mdm.viw_SYSTEM_SCHEMA_VERSION itm INNER JOIN  
                    mdm.viw_SYSTEM_SECURITY_USER_MODEL AS acl  
                        ON  ((itm.MUID = @Object_MUID)  
                        OR  (itm.Name = @Object_Name AND (((@ObjectContext_MUID IS NULL) OR (itm.Model_MUID = @ObjectContext_MUID)) AND ((@ObjectContext_Name IS NULL) OR (itm.Model_Name = @ObjectContext_Name))))  
                        )  
                        AND acl.ID = itm.Model_ID  
                        AND acl.User_ID = @User_ID  
                        AND acl.Privilege_ID <> 1 /*Deny*/  
            ELSE  
                SELECT  
                    @Return_ID = CASE acl.Privilege_ID WHEN 5 /*Admin*/ THEN 1 ELSE 0 END  
                FROM  
                    mdm.tblModel ctx INNER JOIN  
                    mdm.viw_SYSTEM_SECURITY_USER_MODEL AS acl  
                        ON ((@ObjectContext_MUID IS NULL) OR (ctx.MUID = @ObjectContext_MUID))  
                        AND ((@ObjectContext_Name IS NULL) OR (ctx.Name = @ObjectContext_Name))  
                        AND acl.ID = ctx.ID  
                        AND acl.User_ID = @User_ID  
                        AND acl.Privilege_ID <> 1 /*Deny*/  
  
        END  
  
    ELSE IF @ObjectType_ID = @ObjectType_Index  
    BEGIN  
        IF @Object_MUID IS NOT NULL  
            SELECT  
                @Return_ID = CASE acl.Privilege_ID WHEN 5 /*Admin*/ THEN 1 ELSE 0 END  
            FROM  
                mdm.viw_SYSTEM_SCHEMA_INDEXES itm INNER JOIN  
                mdm.viw_SYSTEM_SECURITY_USER_MODEL AS acl  
                    ON  ((itm.Index_MUID = @Object_MUID)  
                    OR  (itm.Index_Name = @Object_Name AND (((@ObjectContext_MUID IS NULL) OR (itm.Model_MUID = @ObjectContext_MUID)) AND ((@ObjectContext_Name IS NULL) OR (itm.Model_Name = @ObjectContext_Name))))  
                    )  
                    AND acl.ID = itm.Model_ID  
                    AND acl.User_ID = @User_ID  
                    AND acl.Privilege_ID <> 1 /*Deny*/  
        ELSE  
            SELECT  
                @Return_ID = CASE acl.Privilege_ID WHEN 5 /*Admin*/ THEN 1 ELSE 0 END  
            FROM  
                mdm.tblModel ctx INNER JOIN  
                mdm.viw_SYSTEM_SECURITY_USER_MODEL AS acl  
                    ON ((@ObjectContext_MUID IS NULL) OR (ctx.MUID = @ObjectContext_MUID))  
                    AND ((@ObjectContext_Name IS NULL) OR (ctx.Name = @ObjectContext_Name))  
                    AND acl.ID = ctx.ID  
                    AND acl.User_ID = @User_ID  
                    AND acl.Privilege_ID <> 1 /*Deny*/  
  
    END  
  
    SET @Return_ID = ISNULL(@Return_ID,0)  
  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpUserListGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
Gets all user info.  
  
EXEC mdm.udpUserListGet  
  
*/  
CREATE PROCEDURE [mdm].[udpUserListGet]  
(  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON  
    SELECT   
        u.ID,  
        u.MUID,  
        u.Status_ID,  
        u.SID,  
        u.UserName,  
        u.DisplayName,  
        u.Description,  
        u.EmailAddress,  
        u.LastLoginDTM,  
        COALESCE(u.EnterUserID,0) AS EnterUserID,  
        eu.MUID AS EnterUserMUID,  
        COALESCE(eu.UserName,N'') AS EnterUserName,  
        COALESCE(eu.DisplayName,N'') AS EnterUserDisplayName,  
        u.EnterDTM,  
        COALESCE(u.LastChgUserID,0) AS LastChgUserID,  
        lcu.MUID AS LastChgUserMUID,  
        COALESCE(lcu.UserName,N'') AS LastChgUserName,  
        COALESCE(lcu.DisplayName,N'') AS LastChgUserDisplayName,  
        u.LastChgDTM,  
        pref.PreferenceValue AS EmailType   
    FROM mdm.tblUser u  
    LEFT JOIN mdm.tblUser eu   
    ON u.EnterUserID = eu.ID   
    LEFT JOIN mdm.tblUser lcu   
    ON u.LastChgUserID = lcu.ID  
    LEFT JOIN mdm.tblUserPreference pref   
    ON      u.ID = pref.User_ID   
        AND PreferenceName=N'lstEmail'  
    WHERE u.Status_ID = 1  
    ORDER BY u.ID  
  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpUserListGetByItem]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
exec mdm.udpUserListGetByItem 1,6   -- Model  
exec mdm.udpUserListGetByItem 2,6   -- Should return an empty resultset  
exec mdm.udpUserListGetByItem 3,1   -- Entity  
exec mdm.udpUserListGetByItem 4,158 -- Attribute  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpUserListGetByItem]  
(  
	@Object_ID	INT,  
	@Securable_ID	INT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
	SET NOCOUNT ON  
  
	DECLARE @SQL            NVARCHAR(MAX)  
	DECLARE @ViewName		sysname;  
    DECLARE @ParamList		NVARCHAR(MAX)  
	SET @ParamList = N'@Securable_IDx	INT ';  
	  
	SELECT @ViewName = ViewName FROM mdm.tblSecurityObject WHERE ID = @Object_ID  
	IF @ViewName IS NULL BEGIN  
		SET  @Securable_ID = -11111  
		SELECT @ViewName = ViewName FROM mdm.tblSecurityObject WHERE ID = 1  
	END; --if  
	  
	SELECT @SQL =  
				N'  
				SELECT   
						u.ID,  
						u.UserName,  
						u.UserName + '' ('' + u.DisplayName + '')'' AS Name,  
						u.Description,  
						u.EmailAddress,  
						sec.Privilege_ID  AS Privilege_ID,  
                        sec.AccessPermission AS AccessPermission  
  
				FROM	mdm.' +  QUOTENAME(@ViewName) + N' sec  
						INNER JOIN mdm.tblUser u  
							ON sec.User_ID = u.ID AND sec.ID = @Securable_IDx AND u.Status_ID = 1  
				ORDER BY u.UserName;'  
	EXEC sp_executesql @SQL, @ParamList,@Securable_ID;  
  
	SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpUserLoginByIdentifier]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
EXEC mdm.udpUserLoginByIdentifier 'bbarnett',''  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpUserLoginByIdentifier]  
(  
	@SID				NVARCHAR(250) = NULL,	  
	@UserName			NVARCHAR(100) = NULL,  
	@Return_ID			INT = NULL OUTPUT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
	SET NOCOUNT ON  
  
	SET @SID = NULLIF(LTRIM(RTRIM(@SID)), N'');  
	  
	IF ((@SID IS NULL OR LEN(@SID) = 0) AND (@UserName IS NULL OR LEN(@UserName) = 0) )  
		SET @Return_ID = NULL;  
	ELSE BEGIN  
		  
		SELECT 	@Return_ID = ID   
		FROM 	mdm.tblUser  
		WHERE   
			(@SID IS NULL OR SID = @SID)  
			AND UserName = CASE WHEN @SID IS NULL OR @SID = N'' THEN @UserName ELSE UserName END  
		AND Status_ID = 1;  
			  
		UPDATE mdm.tblUser SET LastLoginDTM = GETUTCDATE() WHERE ID = @Return_ID;  
	END; --if  
	  
	EXEC mdm.udpUserGet @Return_ID;  
  
	SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpUserPreferenceDelete]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
exec mdm.udpUserPreferenceDelete 1, 'Model'  
*/  
CREATE PROCEDURE [mdm].[udpUserPreferenceDelete]  
(  
    @User_ID			INT,  
    @PreferenceName		NVARCHAR(100),  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    BEGIN TRY  
  
        DELETE FROM mdm.tblUserPreference  
        WHERE   
            [User_ID] = @User_ID AND  
            PreferenceName = @PreferenceName   
            ;  
        RETURN(0);  
  
    END TRY  
    --Compensate as necessary  
    BEGIN CATCH  
  
        -- Get error info.  
        DECLARE  
            @ErrorMessage NVARCHAR(4000),  
            @ErrorSeverity INT,  
            @ErrorState INT,  
            @ErrorNumber INT,  
            @ErrorLine INT,  
            @ErrorProcedure NVARCHAR(126);  
        EXEC mdm.udpGetErrorInfo  
            @ErrorMessage = @ErrorMessage OUTPUT,  
            @ErrorSeverity = @ErrorSeverity OUTPUT,  
            @ErrorState = @ErrorState OUTPUT,  
            @ErrorNumber = @ErrorNumber OUTPUT,  
            @ErrorLine = @ErrorLine OUTPUT,  
            @ErrorProcedure = @ErrorProcedure OUTPUT  
  
        SET @ErrorMessage = CONCAT(@ErrorMessage, N', @ErrorNumber = ', @ErrorNumber, N', @ErrorProcedure = "', @ErrorProcedure, N'", line ', @ErrorLine);  
  
        --IF @TranCounter = 0 ROLLBACK TRANSACTION;  
        --ELSE IF XACT_STATE() <> -1 ROLLBACK TRANSACTION TX;  
  
        RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);  
  
        --On error, return NULL results  
        --SELECT @Return_ID = NULL;  
        RETURN(1);  
  
    END CATCH;  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpUserPreferenceSave]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
exec mdm.udpUserPreferenceSave 1, 'Model', 7  
exec mdm.udpUserPreferenceSave 1, 'Entity', 32  
exec mdm.udpUserPreferenceSave 1, 'Version', 20  
exec mdm.udpUserPreferenceSave 1, 'MemberType', 1  
exec mdm.udpUserPreferenceSave 1, 'DBADisplayType', 1  
exec mdm.udpUserPreferenceSave 1, 'User-Defined 1', 'ABCDEFGH1234567890'  
*/  
CREATE PROCEDURE [mdm].[udpUserPreferenceSave]  
(  
    @User_ID			INT,  
    @PreferenceName		NVARCHAR(100),  
    @PreferenceValue	NVARCHAR(MAX),  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    BEGIN TRY  
  
        IF EXISTS(SELECT 1 FROM mdm.tblUserPreference WHERE PreferenceName = @PreferenceName AND User_ID = @User_ID) BEGIN  
  
            UPDATE mdm.tblUserPreference SET   
                PreferenceName = ISNULL(@PreferenceName,PreferenceName),  
                PreferenceValue = ISNULL(@PreferenceValue,PreferenceValue),  
                LastChgUserID = @User_ID,  
                LastChgDTM = GETUTCDATE()  
            WHERE   
                PreferenceName = @PreferenceName AND   
                [User_ID] = @User_ID;  
  
        END	ELSE BEGIN  
  
            INSERT INTO mdm.tblUserPreference(  
                [User_ID],  
                PreferenceName,  
                PreferenceValue,  
                EnterUserID,  
                EnterDTM,  
                LastChgUserID,  
                LastChgDTM  
            ) VALUES (  
                @User_ID,  
                @PreferenceName,  
                @PreferenceValue,  
                @User_ID,  
                GETUTCDATE(),  
                @User_ID,  
                GETUTCDATE()			  
            );  
        END; --if  
  
        RETURN(0);  
  
    END TRY  
    --Compensate as necessary  
    BEGIN CATCH  
  
        -- Get error info.  
        DECLARE  
            @ErrorMessage NVARCHAR(4000),  
            @ErrorSeverity INT,  
            @ErrorState INT,  
            @ErrorNumber INT,  
            @ErrorLine INT,  
            @ErrorProcedure NVARCHAR(126);  
        EXEC mdm.udpGetErrorInfo  
            @ErrorMessage = @ErrorMessage OUTPUT,  
            @ErrorSeverity = @ErrorSeverity OUTPUT,  
            @ErrorState = @ErrorState OUTPUT,  
            @ErrorNumber = @ErrorNumber OUTPUT,  
            @ErrorLine = @ErrorLine OUTPUT,  
            @ErrorProcedure = @ErrorProcedure OUTPUT  
  
        SET @ErrorMessage = CONCAT(@ErrorMessage, N', @ErrorNumber = ', @ErrorNumber, N', @ErrorProcedure = "', @ErrorProcedure, N'", line ', @ErrorLine);  
  
        --IF @TranCounter = 0 ROLLBACK TRANSACTION;  
        --ELSE IF XACT_STATE() <> -1 ROLLBACK TRANSACTION TX;  
  
        RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);  
  
        --On error, return NULL results  
        --SELECT @Return_ID = NULL;  
        RETURN(1);  
  
    END CATCH;  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpUserPreferencesDelete]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
exec mdm.udpUserPreferencesDelete 1, 'Model'  
*/  
CREATE PROCEDURE [mdm].[udpUserPreferencesDelete]  
(  
    @User_ID			INT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    BEGIN TRY  
  
        DELETE FROM mdm.tblUserPreference  
        WHERE   
            [User_ID] = @User_ID;  
        RETURN(0);  
  
    END TRY  
    --Compensate as necessary  
    BEGIN CATCH  
  
        -- Get error info.  
        DECLARE  
            @ErrorMessage NVARCHAR(4000),  
            @ErrorSeverity INT,  
            @ErrorState INT,  
            @ErrorNumber INT,  
            @ErrorLine INT,  
            @ErrorProcedure NVARCHAR(126);  
        EXEC mdm.udpGetErrorInfo  
            @ErrorMessage = @ErrorMessage OUTPUT,  
            @ErrorSeverity = @ErrorSeverity OUTPUT,  
            @ErrorState = @ErrorState OUTPUT,  
            @ErrorNumber = @ErrorNumber OUTPUT,  
            @ErrorLine = @ErrorLine OUTPUT,  
            @ErrorProcedure = @ErrorProcedure OUTPUT  
  
        SET @ErrorMessage = CONCAT(@ErrorMessage, N', @ErrorNumber = ', @ErrorNumber, N', @ErrorProcedure = "', @ErrorProcedure, N'", line ', @ErrorLine);  
  
        --IF @TranCounter = 0 ROLLBACK TRANSACTION;  
        --ELSE IF XACT_STATE() <> -1 ROLLBACK TRANSACTION TX;  
  
        RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);  
  
        --On error, return NULL results  
        --SELECT @Return_ID = NULL;  
        RETURN(1);  
  
    END CATCH;  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpUserPreferencesGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
exec mdm.udpUserPreferencesGet 1  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpUserPreferencesGet]  
(  
	@User_ID INT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
	SET NOCOUNT ON  
  
	SELECT  
		PreferenceName,  
		PreferenceValue  
	FROM  
		mdm.tblUserPreference  
	WHERE   
		[User_ID] = @User_ID  
  
	SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpUserSave]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpUserSave]  
(  
    @SystemUser_ID      INT,  
    @User_ID            INT = NULL OUTPUT,  
    @User_MUID          UNIQUEIDENTIFIER = NULL OUTPUT, -- \  
    @SID                NVARCHAR(250) = NULL OUTPUT,    -- - One of these is required  
    @Name               NVARCHAR(100) = NULL,           -- /  
    @Status_ID          TINYINT,  
    @DisplayName        NVARCHAR(256) = NULL,  
    @Description        NVARCHAR(500) = NULL,  
    @EmailAddress       NVARCHAR(100) = NULL,  
    @CorrelationID      UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS  
BEGIN  
    SET NOCOUNT ON  
  
    DECLARE @GuidEmpty              UNIQUEIDENTIFIER = CAST(0x0 AS UNIQUEIDENTIFIER),  
  
            @Status_Create          INT = 0,  
            @Status_Activate        INT = 1,  
            @Status_Deactive        INT = 2,  
            @Status_Clone           INT = 3,  
  
            @UserStatus_ID          TINYINT,  
            @UserStatus_Active      TINYINT = 1,  
            @UserStatus_Deactive    TINYINT = 2,  
              
            @OldUser_MUID           UNIQUEIDENTIFIER,  
            @OldUser_SID            NVARCHAR(250),  
            @ErrorMessage           NVARCHAR(4000);  
  
    SELECT   
        @User_MUID = NULLIF(@User_MUID, @GuidEmpty),  
        @SID = NULLIF(LTRIM(RTRIM(@SID)), N''),  
        @Name = NULLIF(LTRIM(RTRIM(@Name)), N''),  
        @DisplayName = NULLIF(LTRIM(RTRIM(@DisplayName)), N''),  
        @Description = NULLIF(LTRIM(RTRIM(@Description)), N''),  
        @EmailAddress = NULLIF(LTRIM(RTRIM(@EmailAddress)), N'');  
  
    SELECT @User_ID = ID, @OldUser_MUID = MUID, @OldUser_SID = [SID]  
    FROM mdm.tblUser  
    WHERE  
        (@User_MUID IS NOT NULL OR @SID IS NOT NULL OR @Name IS NOT NULL)  
        AND (@Status_ID = @Status_Clone OR @User_MUID  IS NULL OR MUID = @User_MUID)  
        AND (@SID IS NULL OR [SID] = @SID)  
  
    -- New user  
    IF @User_ID IS NULL  
    BEGIN  
  
        IF @Status_ID = @Status_Activate OR @Status_ID = @Status_Deactive  
        BEGIN  
            RAISERROR('MDSERR500004|The principal cannot be updated because the principal identifier is not valid. The identifier must have an existing GUID, name, or both.', 16, 1);  
            RETURN  
        END  
  
        -- For new user, the name and sid should be unique  
        IF EXISTS(  
            SELECT 1  
            FROM mdm.tblUser  
            WHERE  
                (@SID IS NOT NULL OR @Name IS NOT NULL)  
                AND ((@SID IS NOT NULL AND [SID] = @SID)  
                    OR (@Name IS NOT NULL AND UserName = @Name))  
        )  
        BEGIN  
            SELECT  @ErrorMessage = N'MDSERR500015|Name and Security Identifier (SID) combination must be unique for user update, create, and copy operations. Name: {0}, Security Identifier: {1}.|' + REPLACE(@Name, N'|', N'') + '|' + @SID;  
            SET @ErrorMessage = REPLACE(@ErrorMessage, '%', '%%')-- escape out format specifier  
            RAISERROR(@ErrorMessage, 16, 1, @Name, @SID);  
        END  
  
        IF @User_MUID IS NULL  
        BEGIN  
            IF @Status_ID = @Status_Clone  
            BEGIN  
                RAISERROR('MDSERR500004|The principal cannot be updated because the principal identifier is not valid. The identifier must have an existing GUID, name, or both.', 16, 1);  
                RETURN  
            END  
            ELSE  
            BEGIN  
                SET @User_MUID = NEWID();  
            END  
        END  
  
        INSERT INTO mdm.tblUser  
        (  
            [Status_ID],  
            [UserName],  
            [SID],  
            [DisplayName],  
            [Description],  
            [EmailAddress],  
            [EnterUserID],  
            [LastChgUserID],  
            [MUID]  
        )  
        SELECT  
            @UserStatus_Active,  
            @Name,  
            @SID,  
            COALESCE(@DisplayName,N''),  
            @Description,  
            @EmailAddress,  
            @SystemUser_ID,  
            @SystemUser_ID,  
            @User_MUID  
  
        SET @User_ID = SCOPE_IDENTITY();  
    END  
    ELSE  
    BEGIN  
        SET @UserStatus_ID = CASE @Status_ID WHEN @Status_Deactive THEN @UserStatus_Deactive ELSE @UserStatus_Active END;  
  
        IF @Status_ID != @Status_Clone OR @User_MUID IS NULL  
        BEGIN  
            UPDATE tblUser  
            SET Status_ID = @UserStatus_ID,  
                UserName = COALESCE(@Name, UserName),  
                DisplayName = COALESCE(@DisplayName, DisplayName),  
                [Description] = COALESCE(@Description, [Description]),  
                EmailAddress = COALESCE(@EmailAddress, EmailAddress),  
                LastChgUserID = @SystemUser_ID,  
                LastChgDTM = GETUTCDATE()  
            WHERE ID = @User_ID  
            SET @User_MUID = @OldUser_MUID;  
        END  
        ELSE  
        BEGIN  
            UPDATE tblUser  
            SET MUID = @User_MUID,  
                Status_ID = @UserStatus_ID,  
                UserName = COALESCE(@Name, UserName),  
                DisplayName = COALESCE(@DisplayName, DisplayName),  
                [Description] = COALESCE(@Description, [Description]),  
                EmailAddress = COALESCE(@EmailAddress, EmailAddress),  
                LastChgUserID = @SystemUser_ID,  
                LastChgDTM = GETUTCDATE()  
            WHERE ID = @User_ID  
        END  
  
        SET @SID = @OldUser_SID;  
    END  
  
    -- Send the message  
	EXEC mdm.udpPerformanceQueueSave;  
  
    SET NOCOUNT OFF  
END;
GO
/****** Object:  StoredProcedure [mdm].[udpUserScriptActionWrapper]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpUserScriptActionWrapper]  
(     
    @ScriptName SYSNAME,      
    @MemberIdList mdm.[MemberId] READONLY,  
    @ModelName NVARCHAR(50),  
    @VersionName NVARCHAR(50),  
    @EntityName NVARCHAR(50),  
    @BusinessRuleName NVARCHAR(50)  
)     
WITH EXECUTE AS 'mds_br_user'  
AS BEGIN      
    IF EXISTS (SELECT 1 FROM @MemberIdList)  
    BEGIN  
        DECLARE @Sql NVARCHAR(500) = 'EXEC usr.'+ @ScriptName +N' @MemberIdList, @BRP_ModelName ,@BRP_EntityName ,@BRP_VersionName, @BRP_BRName'  
           
        EXEC sp_executesql @Sql,N'@MemberIdList mdm.[MemberId] READONLY, @BRP_ModelName NVARCHAR(50), @BRP_EntityName NVARCHAR(50), @BRP_VersionName NVARCHAR(50),@BRP_BRName NVARCHAR(50)',     
                                   @MemberIdList,        @ModelName,        @EntityName,     @VersionName, @BusinessRuleName;    
    END  
END
GO
/****** Object:  StoredProcedure [mdm].[udpUsersGetByObjectPermission]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
-- Get all user with effective permissions of all models  
EXEC mdm.udpUsersGetByObjectPermission @User_ID = 1, @ObjectType = 1  
  
-- Get all user with effective permissions of entities under model product  
EXEC mdm.udpUsersGetByObjectPermission @User_ID = 1, @ObjectType = 5, @Model_Name = N'Product'  
  
-- Get all user with effective permissions of leaf membertpye of entity product/product  
EXEC mdm.udpUsersGetByObjectPermission @User_ID = 1, @ObjectType = 8, @Model_Name = N'Product', @Entity_Name = N'Product'  
  
-- Get all user with effective permissions of consolidated membertype of entity product/product  
EXEC mdm.udpUsersGetByObjectPermission @User_ID = 1, @ObjectType = 9, @Model_Name = N'Product', @Entity_Name = N'Product'  
  
-- Get all user with effective permissions of collection membertype of entity product/product  
EXEC mdm.udpUsersGetByObjectPermission @User_ID = 1, @ObjectType = 10, @Model_Name = N'Product', @Entity_Name = N'Product'  
  
-- Get all user with effective permissions of attributes of entity product/product/leaf  
EXEC mdm.udpUsersGetByObjectPermission @User_ID = 1, @ObjectType = 7, @Model_Name = N'Product', @Entity_Name = N'Product', @MemberType_ID = 1  
  
*/  
CREATE PROCEDURE [mdm].[udpUsersGetByObjectPermission]  
(  
    @User_ID                INT, -- Who is doing the look up  
    @ObjectType             TINYINT,  
    @Model_MUID             UNIQUEIDENTIFIER = NULL,  
    @Model_Name             NVARCHAR(50) = NULL,  
    @Entity_MUID            UNIQUEIDENTIFIER = NULL,  
    @Entity_Name            NVARCHAR(50) = NULL,  
    @MemberType_ID          TINYINT = NULL,  
    @Attribute_MUID         UNIQUEIDENTIFIER = NULL,  
    @Attribute_Name         NVARCHAR(100) = NULL,  
    @SecurityPermission     TINYINT = NULL,  
    @AccessPermission       TINYINT = NULL,  
    @CorrelationID          UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON  
  
    DECLARE @GuidEmpty                      UNIQUEIDENTIFIER = CAST(0x0 AS UNIQUEIDENTIFIER),  
              
            @Model_ID                       INT = NULL,  
            @Entity_ID                      INT = NULL,  
            @Model_Permission               TINYINT = NULL,  
  
            @Permission_Admin               INT = 5,  
  
            @MemberType_NotSpecified        TINYINT = 0,  
            @MemberType_Leaf                TINYINT = 1,  
            @MemberType_Consolidated        TINYINT = 2,  
            @MemberType_Collection          TINYINT = 3,  
  
            -- Check [mdm].[tblSecurityObject]  
            @ObjectType_Model               TINYINT = 1,  
            @ObjectType_Entity              TINYINT = 3,  
            @ObjectType_Attribute           TINYINT = 4,  
            @ObjectType_LeafType            TINYINT = 8,  
            @ObjectType_ConsolidatedType    TINYINT = 9,  
            @ObjectType_CollectionType      TINYINT = 10;  
  
    SELECT  
        @User_ID = NULLIF(@User_ID, 0),  
        @Model_MUID = NULLIF(@Model_MUID, @GuidEmpty),  
        @Model_Name = NULLIF(LTRIM(RTRIM(@Model_Name)), N''),  
        @Entity_MUID = NULLIF(@Entity_MUID, @GuidEmpty),  
        @Entity_Name = NULLIF(LTRIM(RTRIM(@Entity_Name)), N''),  
        @MemberType_ID = NULLIF(@MemberType_ID, 0),  
        @Attribute_MUID = NULLIF(@Attribute_MUID, @GuidEmpty),  
        @Attribute_Name = NULLIF(LTRIM(RTRIM(@Attribute_Name)), N''),  
        @ObjectType = NULLIF(@ObjectType, 0),  
        @SecurityPermission = NULLIF(@SecurityPermission, 0),  
        @AccessPermission = NULLIF(@AccessPermission, 0);  
  
    IF @ObjectType IS NULL OR @ObjectType NOT IN (@ObjectType_Model, @ObjectType_Entity, @ObjectType_Attribute, @ObjectType_LeafType, @ObjectType_ConsolidatedType, @ObjectType_CollectionType)  
    BEGIN  
        RAISERROR('MDSERR300005|The supplied object type is not valid.', 16, 1);  
        RETURN;  
    END  
  
    DECLARE @Permission TABLE  
    (  
        [User_ID]           INT,  
        ObjectType          TINYINT,  
        SecurityPermission  TINYINT NULL,  
        AccessPermission    TINYINT NULL,  
        Model_MUID          UNIQUEIDENTIFIER,  
        Model_Name          NVARCHAR(50),  
        Entity_MUID         UNIQUEIDENTIFIER NULL,  
        [Entity_Name]       NVARCHAR(50) NULL,  
        MemberType          TINYINT NULL,  
        Attribute_MUID      UNIQUEIDENTIFIER NULL,  
        Attribute_Name      NVARCHAR(100) NULL  
    );  
  
    IF @ObjectType = @ObjectType_Model  
    BEGIN  
        INSERT @Permission (  
            [User_ID],  
            ObjectType,  
            SecurityPermission,  
            AccessPermission,  
            Model_MUID,  
            Model_Name,  
            Entity_MUID,  
            [Entity_Name],  
            MemberType,  
            Attribute_MUID,  
            Attribute_Name  
        )  
        SELECT  
            ssum.[User_ID],  
            @ObjectType_Model,  
            ssum.Privilege_ID,  
            ssum.AccessPermission,  
            m.MUID,  
            m.Name,  
            NULL,  
            NULL,  
            NULL,  
            NULL,  
            NULL  
        FROM mdm.viw_SYSTEM_SECURITY_USER_MODEL ssum  
        INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_MODEL ownedssum  
        ON ssum.ID = ownedssum.ID AND ownedssum.[User_ID] = @User_ID AND ownedssum.Privilege_ID = @Permission_Admin  
        INNER JOIN mdm.tblModel m  
        ON ssum.ID = m.ID  
        WHERE (@Model_MUID IS NULL OR m.MUID = @Model_MUID)  
            AND (@Model_Name IS NULL OR m.Name = @Model_Name)  
            AND (@SecurityPermission IS NULL OR ssum.Privilege_ID = @SecurityPermission)  
            AND (@AccessPermission IS NULL OR ssum.AccessPermission = @AccessPermission)  
    END  
    ELSE  
    BEGIN  
        IF @Model_MUID IS NOT NULL OR @Model_Name IS NOT NULL  
        BEGIN  
            EXEC mdm.udpInformationLookupModel  
                @User_ID = @User_ID,  
                @Model_MUID = @Model_MUID,  
                @Model_Name = @Model_Name,  
                @ID = @Model_ID OUTPUT,  
                @Name = @Model_Name OUTPUT,  
                @MUID = @Model_MUID OUTPUT,  
                @Privilege_ID = @Model_Permission OUTPUT;  
        END  
  
        IF @Model_ID IS NULL OR @Model_Permission != @Permission_Admin  
        BEGIN  
            RAISERROR('MDSERR120003|The user does not have permission or the object ID is not valid.', 16, 1);  
            RETURN;  
        END  
  
        IF @ObjectType = @ObjectType_Entity  
        BEGIN  
            INSERT @Permission (  
                [User_ID],  
                ObjectType,  
                SecurityPermission,  
                AccessPermission,  
                Model_MUID,  
                Model_Name,  
                Entity_MUID,  
                [Entity_Name],  
                MemberType,  
                Attribute_MUID,  
                Attribute_Name  
            )  
            SELECT  
                ssue.[User_ID],  
                @ObjectType_Entity,  
                ssue.Privilege_ID,  
                ssue.AccessPermission,  
                @Model_MUID,  
                @Model_Name,  
                e.MUID,  
                e.Name,  
                NULL,  
                NULL,  
                NULL  
            FROM mdm.viw_SYSTEM_SECURITY_USER_ENTITY ssue  
            INNER JOIN mdm.tblEntity e  
            ON ssue.ID = e.ID AND e.Model_ID = @Model_ID  
            WHERE (@Entity_MUID IS NULL OR e.MUID = @Entity_MUID)  
                AND (@Entity_Name IS NULL OR e.Name = @Entity_Name)  
                AND (@SecurityPermission IS NULL OR ssue.Privilege_ID = @SecurityPermission)  
                AND (@AccessPermission IS NULL OR ssue.AccessPermission = @AccessPermission)  
        END  
        ELSE  
        BEGIN  
            IF @Entity_MUID IS NOT NULL OR @Entity_Name IS NOT NULL  
            BEGIN  
                EXEC mdm.udpInformationLookupEntity  
                    @User_ID = @User_ID,  
                    @Entity_MUID = @Entity_MUID,  
                    @Entity_Name = @Entity_Name,  
                    @ID = @Entity_ID OUTPUT,  
                    @Name = @Entity_Name OUTPUT,  
                    @MUID = @Entity_MUID OUTPUT;  
            END  
  
            IF @Entity_ID IS NULL  
            BEGIN  
                RAISERROR('MDSERR120003|The user does not have permission or the object ID is not valid.', 16, 1);  
                RETURN;  
            END;  
  
            IF @ObjectType IN (@ObjectType_LeafType, @ObjectType_ConsolidatedType, @ObjectType_CollectionType)  
            BEGIN  
                SET @MemberType_ID = @ObjectType - @ObjectType_LeafType + 1;  
                IF @MemberType_ID IS NULL OR @MemberType_ID NOT IN (@MemberType_Leaf, @MemberType_Consolidated, @MemberType_Collection)  
                BEGIN  
                    RAISERROR('MDSERR120003|The user does not have permission or the object ID is not valid.', 16, 1);  
                    RETURN;  
                END  
  
                INSERT @Permission (  
                    [User_ID],  
                    ObjectType,  
                    SecurityPermission,  
                    AccessPermission,  
                    Model_MUID,  
                    Model_Name,  
                    Entity_MUID,  
                    [Entity_Name],  
                    MemberType,  
                    Attribute_MUID,  
                    Attribute_Name  
                )  
                SELECT  
                    ssumt.[User_ID],  
                    @ObjectType,  
                    ssumt.Privilege_ID,  
                    ssumt.AccessPermission,  
                    @Model_MUID,  
                    @Model_Name,  
                    @Entity_MUID,  
                    @Entity_Name,  
                    @MemberType_ID,  
                    NULL,  
                    NULL  
                FROM mdm.viw_SYSTEM_SECURITY_USER_MEMBERTYPE ssumt  
                WHERE ssumt.[Entity_ID] = @Entity_ID  
                    AND ssumt.ID = @MemberType_ID  
                    AND (@SecurityPermission IS NULL OR ssumt.Privilege_ID = @SecurityPermission)  
                    AND (@AccessPermission IS NULL OR ssumt.AccessPermission = @AccessPermission)  
                END  
            ELSE IF @ObjectType = @ObjectType_Attribute  
            BEGIN  
                IF @MemberType_ID IS NULL OR @MemberType_ID NOT IN (@MemberType_Leaf, @MemberType_Consolidated, @MemberType_Collection)  
                BEGIN  
                    RAISERROR('MDSERR120003|The user does not have permission or the object ID is not valid.', 16, 1);  
                    RETURN;  
                END;  
  
                INSERT @Permission (  
                    [User_ID],  
                    ObjectType,  
                    SecurityPermission,  
                    AccessPermission,  
                    Model_MUID,  
                    Model_Name,  
                    Entity_MUID,  
                    [Entity_Name],  
                    MemberType,  
                    Attribute_MUID,  
                    Attribute_Name  
                )  
                SELECT  
                    ssua.[User_ID],  
                    @ObjectType_Attribute,  
                    ssua.Privilege_ID,  
                    ssua.AccessPermission,  
                    @Model_MUID,  
                    @Model_Name,  
                    @Entity_MUID,  
                    @Entity_Name,  
                    @MemberType_ID,  
                    a.MUID,  
                    a.Name  
                FROM mdm.viw_SYSTEM_SECURITY_USER_ATTRIBUTE ssua  
                INNER JOIN mdm.tblAttribute a  
                ON ssua.ID = a.ID AND a.[Entity_ID] = @Entity_ID AND a.MemberType_ID = @MemberType_ID  
                WHERE (@Attribute_MUID IS NULL OR a.MUID = @Attribute_MUID)  
                    AND (@Attribute_Name IS NULL OR a.Name = @Attribute_Name)  
                    AND (@SecurityPermission IS NULL OR ssua.Privilege_ID = @SecurityPermission)  
                    AND (@AccessPermission IS NULL OR ssua.AccessPermission = @AccessPermission)  
            END  
        END  
    END  
  
    SELECT  
        ID,  
        UserName,  
        MUID,  
        [SID]  
    FROM mdm.tblUser u  
    WHERE u.ID IN (SELECT [User_ID] FROM @Permission)  
  
    SELECT  
        [User_ID],  
        ObjectType,  
        SecurityPermission,  
        AccessPermission,  
        Model_Name,  
        Model_MUID,  
        [Entity_Name],  
        Entity_MUID,  
        MemberType,  
        Attribute_Name,  
        Attribute_MUID  
    FROM @Permission  
  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpUsersGroupGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
Gets information about the groups to which the given users belong.  
  
*/  
CREATE PROCEDURE [mdm].[udpUsersGroupGet]  
(  
     @UserIds        mdm.IdList READONLY  
    ,@CorrelationID  UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON  
  
    -- Load the user IDs into an indexed table var, for faster join perf.  
    DECLARE @UserIdTable TABLE(User_ID INT PRIMARY KEY);  
    INSERT INTO @UserIdTable(User_ID)  
    SELECT DISTINCT ID   
    FROM @UserIds;  
  
    -- Get info on the groups to which the user(s) belong.  
    SELECT   
         ug.User_ID  
        ,ug.UserGroup_ID  
        ,ug.UserGroup_MUID  
        ,ug.UserGroup_Name  
    FROM mdm.viw_SYSTEM_USERGROUP_USERS ug  
    INNER JOIN @UserIdTable u  
    ON ug.User_ID = u.User_ID  
    ORDER BY   
         ug.User_ID -- Sorting by user will make processing the results more efficient.  
        ,ug.UserGroup_Name -- Sorting the groups alphabetically will make the results cleaner.  
  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpValidateEntity]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
EXEC mdm.udpValidateEntity 1, 20, 32  
*/  
CREATE PROCEDURE [mdm].[udpValidateEntity]  
(  
   @User_ID        INT,      
   @Version_ID  INT,      
   @Entity_ID      INT,      
   @RunSingleBatch BIT = 0,      
   @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability      
)      
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN      
    SET NOCOUNT ON      
      
    DECLARE @entityTableName        sysname;      
    DECLARE @IsHierarchyEnabled     INT;      
    DECLARE @parentChildView        sysname;      
    DECLARE @sql                    NVARCHAR(MAX);      
      
    DECLARE @tblHierarchy           TABLE (HierarchyID INT);      
    DECLARE @Hierarchy_ID           INT;      
    DECLARE @BatchSize              NVARCHAR(10) = '200000';      
    DECLARE @Model_ID               INT;      
    DECLARE @EventStatus_Running    TINYINT = 1;      
    DECLARE @EventStatus_NotRunning TINYINT = 2;    
    
    BEGIN TRY      
        IF EXISTS (SELECT 1 FROM mdm.tblSyncRelationship WHERE TargetEntity_ID = @Entity_ID AND TargetVersion_ID = @Version_ID)  
        BEGIN  
            RAISERROR (N'MDSERR200226|The entity version cannot be validated. It is the target of a sync relationship.', 16, 1);  
            RETURN;  
        END  
  
        -- Store validation entity event      
        SELECT @Model_ID = Model_ID FROM [mdm].tblEntity WHERE ID = @Entity_ID;  
          
        EXEC [mdm].udpSystemEventSave @User_ID=@User_ID,@Version_ID=@Version_ID,@Entity_ID=@Entity_ID,@EventName=N'ValidateEntity',@EventStatus_ID=@EventStatus_Running      
      
        SET @RunSingleBatch = COALESCE(@RunSingleBatch, 0);      
      
        SELECT      
            @entityTableName = QUOTENAME(EntityTable),      
            @IsHierarchyEnabled = CASE WHEN HierarchyTable IS NULL THEN 0 ELSE 1 END      
        FROM mdm.tblEntity      
        WHERE ID = @Entity_ID;      
      
        --Calculate the level number for the corresponding hierarchies within the version and entities.      
        INSERT INTO @tblHierarchy SELECT ID FROM mdm.tblHierarchy WHERE Entity_ID = @Entity_ID;      
      
        WHILE EXISTS(SELECT 1 FROM @tblHierarchy)      
        BEGIN      
            SET @Hierarchy_ID = (SELECT TOP 1 HierarchyID FROM @tblHierarchy);      
      
            --Recalculate system hierarchy attributes (level number, sort order, and index code)      
            EXEC mdm.udpHierarchySystemAttributesSave @Version_ID, @Hierarchy_ID;      
      
            DELETE FROM @tblHierarchy WHERE HierarchyID = @Hierarchy_ID;      
        END      
      
        --Validate the Member Type 2s (HP), hierarchy parent, if needed.      
        --These must be validated before Type 1s because of possible hierarchy parent inheritance business rules.      
        IF @IsHierarchyEnabled = 1      
        BEGIN      
            SELECT @parentChildView = QUOTENAME(mdm.udfViewNameGetByID(@Entity_ID, 4, 0, 0));      
      
            SELECT @sql = N'      
                DECLARE @MemberIdList              AS mdm.IdList;      
                DECLARE @MemberType_Consolidated   TINYINT = 2;      
      
                WHILE (1 = 1)      
                BEGIN      
                    INSERT INTO @MemberIdList (ID)      
                        SELECT TOP ' + @BatchSize + N' Child_ID      
                        FROM mdm.' + @parentChildView + N'      
                        WHERE Version_ID = @Version_ID      
                            AND Child_ValidationStatus_ID IN (SELECT OptionID FROM mdm.tblList WHERE ListCode = N''lstValidationStatus'' AND Group_ID = 1)      
                            AND ChildType_ID = 2;      
      
                    IF (@@ROWCOUNT = 0)      
                    BEGIN      
                        BREAK;          
                    END;      
      
                    EXEC mdm.udpValidateMembers @User_ID=@User_ID, @Version_ID=@Version_ID, @Entity_ID=@Entity_ID, @MemberIdList=@MemberIdList, @MemberType_ID=@MemberType_Consolidated, @ProcessUIRulesOnly=0, @ReturnChangedIds=0;      
      
                    DELETE FROM @MemberIdList;      
      
                    IF @RunSingleBatch = 1      
                    BEGIN      
                        BREAK;      
                    END;      
                END;';      
            --print @sql;      
            EXEC sp_executesql @sql, N'@User_ID INT,    @Version_ID INT,    @Entity_ID INT, @RunSingleBatch BIT',       
                                       @User_ID,        @Version_ID,        @Entity_ID,     @RunSingleBatch;      
        END      
      
        --Validate the Member Type 1s (EN), leaf      
        SELECT @sql = N'      
                DECLARE @MemberIdList           AS mdm.IdList;      
                DECLARE @EventStatus_NotRunning TINYINT = 2;      
                DECLARE @MemberType_Leaf        TINYINT = 1;      
      
                WHILE (1 = 1)      
                BEGIN      
                    INSERT INTO @MemberIdList (ID)      
                        SELECT TOP ' + @BatchSize + N' ID      
                        FROM mdm.' + @entityTableName + N'      
                        WHERE Status_ID = 1      
                          AND Version_ID = @Version_ID      
                          AND ValidationStatus_ID IN (SELECT OptionID FROM mdm.tblList WHERE ListCode = N''lstValidationStatus'' AND Group_ID = 1);      
      
                    IF (@@ROWCOUNT = 0)      
                    BEGIN      
                        EXEC [mdm].udpSystemEventSave @User_ID=@User_ID,@Version_ID=@Version_ID,@Entity_ID=@Entity_ID,@EventName=N''ValidateEntity'',@EventStatus_ID=@EventStatus_NotRunning      
                        BREAK;      
                    END;      
      
                    EXEC mdm.udpValidateMembers @User_ID=@User_ID, @Version_ID=@Version_ID, @Entity_ID=@Entity_ID, @MemberIdList=@MemberIdList, @MemberType_ID=@MemberType_Leaf, @ProcessUIRulesOnly=0, @ReturnChangedIds=0;      
      
                    DELETE FROM @MemberIdList;      
      
                    IF @RunSingleBatch = 1      
                    BEGIN      
                        BREAK;      
                    END;      
                END;';      
        --print @sql;      
        EXEC sp_executesql @sql, N'@User_ID INT,    @Version_ID INT,    @Entity_ID INT, @RunSingleBatch BIT',       
                                   @User_ID,        @Version_ID,        @Entity_ID,     @RunSingleBatch;      
    END TRY      
    --Compensate as necessary      
    BEGIN CATCH      
      
        -- Get error info.      
        DECLARE      
            @ErrorMessage NVARCHAR(4000),      
            @ErrorSeverity INT,      
            @ErrorState INT,      
            @ErrorNumber INT,      
            @ErrorLine INT,      
            @ErrorProcedure NVARCHAR(126);      
        EXEC mdm.udpGetErrorInfo      
            @ErrorMessage = @ErrorMessage OUTPUT,      
            @ErrorSeverity = @ErrorSeverity OUTPUT,      
            @ErrorState = @ErrorState OUTPUT,      
            @ErrorNumber = @ErrorNumber OUTPUT,      
            @ErrorLine = @ErrorLine OUTPUT,      
            @ErrorProcedure = @ErrorProcedure OUTPUT      
            
        -- Save the error message and change the event status    
    
        EXEC [mdm].udpSystemEventSave     
            @User_ID=@User_ID,    
            @Version_ID=@Version_ID,    
            @Entity_ID=@Entity_ID,    
            @EventName=N'ValidateEntity',    
            @EventStatus_ID=@EventStatus_NotRunning,    
            @CorrelationID = @CorrelationID,    
            @ErrorMsg = @ErrorMessage    
          
        SET @ErrorMessage = CONCAT(@ErrorMessage, N', @ErrorNumber = ', @ErrorNumber, N', @ErrorProcedure = "', @ErrorProcedure, N'", line ', @ErrorLine);      
        RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);      
      
        
      
    END CATCH;     
    SET NOCOUNT OFF;      
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpValidateFunctionArguments]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [mdm].[udpValidateFunctionArguments]    
(    
    @ScriptName   SYSNAME,       
    @IsSproc    BIT,       
    @Arguments mdm.ScriptArgument READONLY,      
    @ThrowException BIT = 0,     
    @BRID INT = NULL,  -- This parameter is only used in error message    
    @IsValid BIT OUT,    
    @ScriptArguments NVARCHAR(MAX) = NULL OUT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability        
)        
/*WITH*/        
AS BEGIN        
    SET NOCOUNT ON        
    DECLARE @NvarcharTypeId INT = TYPE_ID('nvarchar')      
        ,@BitTypeId INT = TYPE_ID('bit')      
        ,@DecimalTypeId INT = TYPE_ID('decimal')      
        ,@DateTimeTypeId INT = TYPE_ID('datetime2')    
        ,@BRName NVARCHAR(50) = ''     
        ,@ErrorMsg NVARCHAR(MAX);    
      
    SET @ScriptArguments = ''  
    IF @ThrowException = 1 AND @BRID IS NOT NULL  
    BEGIN    
        SELECT @BRName = Name FROM mdm.tblBRBusinessRule WHERE ID = @BRID    
    END    
    
    SET @IsValid = 1      
    IF @IsSproc = 1       
    BEGIN      
        IF mdm.udfScriptExists(@ScriptName, 2 , 'usr') = 0          
        BEGIN              
            IF @ThrowException = 1      
            BEGIN      
                SET @ErrorMsg = 'MDSERR400068|Business Rule {0} is corrupted. Could not find SQL Stored Procedure {1} in usr schema. |' + @BRName +'|'+ @ScriptName    
                SET @ErrorMsg = REPLACE(@ErrorMsg, '%', '%%')-- escape out format specifier  
                RAISERROR(@ErrorMsg, 16, 1);                  
            END      
            ELSE      
            BEGIN      
                SET @IsValid = 0;      
            END      
            RETURN      
        END                 
    END      
    ELSE      
    BEGIN      
        IF mdm.udfScriptExists(@ScriptName, 1 , 'usr') = 0          
        BEGIN              
            IF @ThrowException = 1      
            BEGIN      
                SET @ErrorMsg = 'MDSERR400069|Business Rule {0} is corrupted. Could not find SQL Function {1} in usr schema. |' + @BRName+'|'+ @ScriptName;    
                SET @ErrorMsg = REPLACE(@ErrorMsg, '%', '%%')-- escape out format specifier  
                RAISERROR(@ErrorMsg, 16, 1);                  
            END      
            ELSE      
            BEGIN      
                SET @IsValid = 0;      
            END      
            RETURN      
        END                  
        CREATE TABLE #ParameterPair      
        (      
            Id INT IDENTITY(1,1),      
            ParaIndex INT NULL,      
            ParaName SYSNAME NULL,      
            ParaDataType INT NULL,      
            ParaDataTypeInformation INT NULL,      
            ArgumentType INT NULL, -- 1 VALUE 2 ATTRIBUTE 3 NULL      
            ArgumentValue NVARCHAR(999) NULL ,  
            ArgumentScript NVARCHAR(MAX) NULL    
        );      
      
       with cte      
       AS      
       (      
          SELECT       
          p.parameter_id AS ParaIndex,       
          p.name AS ParaName,      
          p.user_type_id AS ParaDataType,      
          CASE p.user_type_id      
              WHEN @NvarcharTypeId THEN p.max_length      
              WHEN @BitTypeId THEN p.scale      
              WHEN @DecimalTypeId THEN p.scale      
              WHEN @DateTimeTypeId THEN p.scale      
              ELSE NULL END as ParaDataTypeInformation                   
                
          FROM sys.objects o      
          INNER JOIN sys.parameters p ON p.object_id = o.object_id      
          WHERE o.schema_id = SCHEMA_ID('usr')       
          AND o.name = @ScriptName      
          AND o.type ='FN'      
       )      
        INSERT INTO #ParameterPair      
        SELECT p.ParaIndex, p.ParaName,p.ParaDataType, p.ParaDataTypeInformation,a.ArgumentType,a.ArgumentValue,a.ArgumentScript FROM cte p      
        FULL OUTER JOIN @Arguments a ON a.Name = p.ParaName      
          
       Declare @Id int      
            ,@ParaIndex INT      
            ,@ParaName SYSNAME      
            ,@ParaDataType INT -- 1 STRING 2 NUMBER 3 DATE 4 DBA 5 FILE      
            ,@ParaDataTypeInformation INT      
            ,@ArgumentType INT -- 1 VALUE 2 ATTRIBUTE 3 NULL/BLANK      
            ,@ArgumentValue NVARCHAR(999)    
            ,@ArgumentScript NVARCHAR(MAX)    
            ,@SQL NVARCHAR(MAX)      
            ,@ArgDataType_ID INT      
            ,@ArgDataTypeInformation INT      
              
         
          
        While (Select Count(*) From #ParameterPair) > 0 AND @IsValid = 1     
        Begin      
      
            Select Top 1 @Id = Id, @ParaIndex = ParaIndex, @ParaName = ParaName, @ParaDataType = ParaDataType, @ParaDataTypeInformation = ParaDataTypeInformation      
            , @ArgumentValue = ArgumentValue, @ArgumentType = ArgumentType , @ArgumentScript = ArgumentScript From #ParameterPair      
              
            IF @ParaIndex IS NULL -- HAVE AN EXTRA ARGUMENT      
            BEGIN                  
                IF @ThrowException = 1      
                BEGIN      
                    SET @ErrorMsg = 'MDSERR400066|Business Rule {0} is corrupted. There is an extra argument assigned to SQL Function {1}. |'+ @BRName+'|'+ @ScriptName;    
                    SET @ErrorMsg = REPLACE(@ErrorMsg, '%', '%%')-- escape out format specifier  
                    RAISERROR(@ErrorMsg, 16, 1);      
                END      
                ELSE      
                BEGIN      
                    SET @IsValid = 0;                      
                END      
                RETURN                  
            END      
            ELSE      
            BEGIN                  
                IF(@ParaIndex <> 0) -- IS NOT RETURN VALUE      
                BEGIN      
                    IF @ArgumentType = 1 -- VALUE      
                    BEGIN       
                        IF @ParaDataType = @NvarcharTypeId -- STRING      
                        BEGIN      
                            IF(@ParaDataTypeInformation <> -1 AND LEN(@ArgumentValue) > @ParaDataTypeInformation/2)      
                            BEGIN      
                                SET @IsValid = 0;       
                            END      
                        END      
                        ELSE IF @ParaDataType = @DecimalTypeId -- DECIMAL      
                        BEGIN      
                            SET @SQL  = N'        
                            IF TRY_CONVERT(DECIMAL(38,'+ CONVERT(NVARCHAR(2),@ParaDataTypeInformation)+') ,@ArgumentValue) IS NULL       
                                 OR ( CHARINDEX(''.'', @ArgumentValue,0) <>0 AND LEN(@ArgumentValue)- CHARINDEX(''.'', @ArgumentValue,0)>'+ CONVERT(NVARCHAR(2),@ParaDataTypeInformation) +')      
                            BEGIN      
                                SET @IsValid = 0      
                            END';               
                            EXEC sp_executesql @SQL,   N'@ArgumentValue NVARCHAR(999), @IsValid BIT OUTPUT', @ArgumentValue, @IsValid OUTPUT;                     
                        END      
                        ELSE IF @ParaDataType = @DateTimeTypeId --DateTime      
                        BEGIN      
                            IF mdq.IsDateTime2(@ArgumentValue) = 0     
                            BEGIN      
                                SET @IsValid = 0       
                            END      
                        END                         
                    END -- END FREE FORM ARGUMENT VALUE CHECK      
                    ELSE IF @ArgumentType = 2 -- ATTRIBUTE      
                    BEGIN      
                        -- GET CORRESPONDING ATTRIBUTE INFOMATION      
                        SELECT @ArgDataType_ID = [DataType_ID], @ArgDataTypeInformation = [DataTypeInformation] FROM mdm.tblAttribute WHERE ID = CAST(@ArgumentValue AS INT)      
                        IF @ArgDataType_ID IS NULL      
                        BEGIN      
                            SET @IsValid = 0      
                        END      
                        IF @ParaDataType = @NvarcharTypeId -- STRING      
                        BEGIN      
                            IF(@ArgDataType_ID <>1 OR ( @ParaDataTypeInformation <> -1 AND @ArgDataTypeInformation > @ParaDataTypeInformation/2))      
                            BEGIN      
                                SET @IsValid = 0;       
                            END      
                        END      
                        ELSE IF @ParaDataType = @DecimalTypeId -- DECIMAL      
                      BEGIN      
                            IF(@ArgDataType_ID <>2 OR (@ArgDataTypeInformation <> @ParaDataTypeInformation))         
                            BEGIN      
                                SET @IsValid = 0;      
                            END        
                        END      
                        ELSE IF @ParaDataType = @DateTimeTypeId --Datetime      
                        BEGIN      
                            IF @ArgDataType_ID <>3      
                            BEGIN      
                                SET @IsValid = 0       
                            END      
                        END        
                    END  -- END ATTRIBUTE ARGUMENT CHECK      
                    ELSE IF @ArgumentType IS NULL  
                    BEGIN  
                        SET @IsValid = 0  
                    END  
                     
                    -- SKIP BLANK ARGUMENT      
                    IF @ThrowException = 1 AND @IsValid = 0      
                    BEGIN      
                        SET @ErrorMsg = 'MDSERR400067|Business Rule {0} is corrupted.The parameter {1} in [usr].{2} either has not assigned or does not match the type of the argument. |'+@BRName+'|'+ @ParaName+'|'+@ScriptName;    
                        SET @ErrorMsg = REPLACE(@ErrorMsg, '%', '%%')-- escape out format specifier  
                        RAISERROR(@ErrorMsg, 16, 1);      
                        RETURN      
                    END   
                    IF @IsValid = 1  
                    BEGIN  
                        IF @ScriptArguments <> ''  
                        BEGIN  
                            SET @ScriptArguments = @ScriptArguments + ' , '  
                        END  
                        SET @ScriptArguments = @ScriptArguments + @ArgumentScript  
                    END  
                            
                END      
            END              
            Delete #ParameterPair Where Id = @Id      
      
        End      
    END      
    SET NOCOUNT OFF       
        
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpValidateMembers]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpValidateMembers]  
(  
    @User_ID INT,   
    @Version_ID INT,  
    @Entity_ID INT,  
    @MemberIdList mdm.IdList READONLY,   
    @MemberType_ID TINYINT,  
    @ProcessUIRulesOnly BIT = 0,  
    @ReturnChangedIds BIT = 0,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON  
  
    /*  
    Business Rule Process options.  Any combination can be present.  
    Bits              876543210  
    ===================================  
    Default          = 000000001 =  1  
    ChangeValue      = 000000010 =  2  
    Assignment       = 000000011 =  3  
    Validation       = 000000100 =  4  
    UI               = 000001000 =  8  
    ExternalAction   = 000010000 =  16  
    Logging          = 010000000 =  128  
    ReturnChangedIds = 100000000 =  256  
    */  
    DECLARE @ProcessOptions	               INT;  
    DECLARE @ProcessOptionDefault          INT = 1;  
    DECLARE @ProcessOptionChangeValue      INT = 2;  
    DECLARE @ProcessOptionAssignments      INT = @ProcessOptionDefault | @ProcessOptionChangeValue;  
    DECLARE @ProcessOptionValidation       INT = 4;  
    DECLARE @ProcessOptionUI               INT = 8;  
    DECLARE @ProcessOptionExternalAction   INT = 16;  
    DECLARE @ProcessOptionLogging          INT = 128;  
    DECLARE @ProcessOptionReturnChangedIds INT = 256;  
  
    IF @ProcessUIRulesOnly = 1  
    BEGIN  
        SET @ProcessOptions = @ProcessOptionUI;  
    END  
    ELSE  
    BEGIN  
        SET @ProcessOptions = @ProcessOptionAssignments | @ProcessOptionValidation | @ProcessOptionLogging | @ProcessOptionExternalAction;  
          
        IF @ReturnChangedIds = 1  
        BEGIN  
            SET @ProcessOptions |= @ProcessOptionReturnChangedIds;  
        END  
    END  
  
    --Call the Business Rules Controller to process rules for the member(s)  
    EXEC mdm.udpBusinessRule_AttributeMemberController @User_ID, @Version_ID, @Entity_ID, @MemberIdList, @MemberType_ID, @ProcessOptions  
  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpValidateModel]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
EXEC mdm.udpValidateModel 1, 9, 5, 0  
select * from mdm.tbl_7_VL  
truncate table mdm.tbl_7_VL  
select * from mdm.tblModelVersion  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpValidateModel]  
(  
    @User_ID		INT,  
    @Model_ID		INT,  
    @Version_ID		INT,  
    @Status_ID		INT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON  
  
  
    EXEC mdm.udpSystemEventSave @User_ID=@User_ID,@Version_ID=@Version_ID,@EventName='ValidateModel',@EventStatus_ID=1 -- EventStatus = 1 means NotRunning  
  
    DECLARE @MetaID		INT;  
    DECLARE @EntityID	INT;  
    DECLARE	@Entities   TABLE (EntityID int,ProcessSeq int);  
    DECLARE @ValidationLogViewName  sysname;  
    DECLARE @SQL NVARCHAR(MAX);  
    DECLARE @ValidationIssuesExist BIT;  
    DECLARE @EventStatus_NotRunning TINYINT = 2;  
  
    --Determine processing sequence of entities based on entity dependency or derived hierarchy processing priority.  
    INSERT INTO @Entities  
        SELECT   
              Entity_ID  
             ,[Level]  
        FROM mdm.udfEntityGetProcessingSequence(@Model_ID)  
        ORDER BY [Level]  
          
    DECLARE @CurrentStatus_ID TINYINT  
    DECLARE @Counter INT = 1;  
    DECLARE @MaxCounter INT = (SELECT MAX(ProcessSeq) FROM @Entities);  
  
    WHILE @Counter <= @MaxCounter  
    BEGIN  
        SELECT @EntityID = EntityID FROM @Entities WHERE ProcessSeq = @Counter;  
        EXEC mdm.udpValidateEntity @User_ID, @Version_ID, @EntityID  
          
        SELECT @CurrentStatus_ID = EventStatus_ID FROM mdm.tblEvent E WHERE E.LastChgUserID = @User_ID AND EventName = CAST(N'ValidateModel' AS NVARCHAR(100)) AND Version_ID = @Version_ID  
          
        IF @CurrentStatus_ID = 2 --Canceled  
            SET @Counter = @MaxCounter + 1;  
        ELSE  
            SET @Counter += 1;  
    END -- WHILE  
  
	EXEC mdm.udpSystemEventSave @User_ID=@User_ID,@Version_ID=@Version_ID,@EventName='ValidateModel',@EventStatus_ID=@EventStatus_NotRunning  
  
    IF @Status_ID = 3 --Commit  
       BEGIN  
          SET @ValidationLogViewName = mdm.udfGetValidationLogViewName(@Model_ID);  
          SET @SQL = N'  
          IF EXISTS(SELECT 1 FROM [mdm].' + QUOTENAME(@ValidationLogViewName) + N' WHERE Version_ID = @Version_ID)  
          BEGIN  
            SET @ValidationIssuesExist = 1;  
          END  
          ELSE  
          BEGIN  
            SET @ValidationIssuesExist = 0;  
          END  
          ';  
          EXEC sp_executesql @SQL, N'@Version_ID INT, @ValidationIssuesExist BIT OUTPUT',   
                                     @Version_ID,     @ValidationIssuesExist OUTPUT;  
  
          IF @ValidationIssuesExist = 0  
          BEGIN  
                -- Get current values (to prevent them from being overwritten with null)  
                DECLARE   
                     @VersionFlag_ID INT  
                SELECT   
                     @VersionFlag_ID = VersionFlag_ID  
                FROM mdm.tblModelVersion  
                WHERE ID = @Version_ID;  
  
                EXEC mdm.udpVersionSave   
                    @User_ID = @User_ID,   
                    @Model_ID = @Model_ID,  
                    @Version_ID = @Version_ID,  
                    @CurrentVersion_ID = NULL,   
                    @Status_ID = 3/*Committed*/,   
                    @VersionFlag_ID = @VersionFlag_ID,  
                    @AllowVersionCommit = 1;  
          END  
       END  
  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpValidationIsRunning]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
Determines whether the the specified model version (or versions) is being validated by the service broker.  
  
DECLARE @IsRunning BIT = 0;  
EXEC mdm.udpValidationIsRunning @Version_ID = 20, @IsRunning = @IsRunning OUTPUT -- checks one version  
SELECT @IsRunning;  
EXEC mdm.udpValidationIsRunning @Entity_ID = 31, @IsRunning = @IsRunning OUTPUT -- checks all versions that pertain to the specified entity's model.  
SELECT @IsRunning;  
EXEC mdm.udpValidationIsRunning @Model_ID = 7, @IsRunning = @IsRunning OUTPUT -- checks all versions that pertain to the specified model.  
SELECT @IsRunning;  
EXEC mdm.udpValidationIsRunning @IsRunning = @IsRunning OUTPUT -- checks all versions  
SELECT @IsRunning;  
  
*/  
CREATE PROCEDURE [mdm].[udpValidationIsRunning]  
(  
     @Model_ID      INT = NULL  
    ,@Version_ID    INT = NULL  
    ,@Entity_ID     INT = NULL  
    ,@IsRunning     BIT OUTPUT  
    ,@CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
-- The caller is the application pool user which should have VIEW SERVER STATE  
WITH EXECUTE AS CALLER  
AS BEGIN  
    SET NOCOUNT ON  
      
    DECLARE @IsTaskActive  BIT = 0;  
    SELECT @IsTaskActive = 1 FROM sys.dm_broker_activated_tasks WHERE procedure_name = N'[mdm].[udpValidationQueueActivate]';  
  
    EXEC mdm.udpValidationIsRunningInternal  
        @Model_ID = @Model_ID,  
        @Version_ID = @Version_ID,  
        @Entity_ID = @Entity_ID,  
        @IsTaskActive = @IsTaskActive,  
        @IsRunning = @IsRunning OUTPUT,  
        @CorrelationID = @CorrelationID;  
  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpValidationIsRunningInternal]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
Determines whether the the specified model version (or versions) is being validated by the service broker.  
*/  
CREATE PROCEDURE [mdm].[udpValidationIsRunningInternal]  
(  
     @Model_ID      INT = NULL  
    ,@Version_ID    INT = NULL  
    ,@Entity_ID     INT = NULL  
    ,@IsTaskActive  BIT  
    ,@IsRunning     BIT OUTPUT  
    ,@CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON  
      
    DECLARE   
         @EventStatus_Running       TINYINT = 1  
        ,@EventStatus_NotRunning    TINYINT = 2  
        ,@EventName_ValidateModel   NVARCHAR(MAX) = N'ValidateModel';  
      
    -- Sanitize inputs  
    SET @Model_ID = NULLIF(@Model_ID, 0);  
    SET @Version_ID = NULLIF(@Version_ID, 0);  
    SET @Entity_ID = NULLIF(@Entity_ID, 0);  
  
    -- Find all running validation event rows for the version(s) that match the given criteria  
    DECLARE @RunningEventIds TABLE (ID INT PRIMARY KEY)  
    INSERT INTO @RunningEventIds  
    SELECT DISTINCT  
        ev.ID  
    FROM mdm.tblEvent ev  
    INNER JOIN mdm.tblModelVersion mv  
        ON ev.Version_ID = mv.ID  
    INNER JOIN mdm.tblEntity en  
        ON mv.Model_ID = en.Model_ID  
    WHERE  
            (@Version_ID IS NULL OR mv.ID       = @Version_ID)  
        AND (@Model_ID   IS NULL OR mv.Model_ID = @Model_ID)  
        AND (@Entity_ID  IS NULL OR en.ID       = @Entity_ID)  
        AND ev.EventName                        = @EventName_ValidateModel  
        AND ev.EventStatus_ID                   = @EventStatus_Running;  
  
    SET @IsRunning = 0;  
    IF EXISTS (SELECT 1 FROM @RunningEventIds)  
    BEGIN  
        -- At least one 'ValidateModel' event row is marked "running", but this does not guarantee that it really is running. Another check is needed to make sure.  
        -- That is, if the service is interrupted (like from a power outage) while validation is in progress, when the db comes back online the event row will still   
        -- be marked "running", even though the validation process has stopped. So, check to make sure the service broker validation process is running.   
        IF @IsTaskActive = 1  
        BEGIN  
            -- The second check passed, but note that it is not foolproof. It detects whether the validation process is running, but it does not specify on which version.   
            -- If the version does not match the criteria passed in to this sproc, then the @IsRunning bit will be wrongly set. However, the probability of this happening   
            -- is very low, and the impact would be small and transitory (ends once the other version finishes validating).  
            SET @IsRunning = 1;  
        END ELSE  
        BEGIN  
            -- Validation isn't running, contrary to what the event table says, so correct the erroneous event table rows.  
            UPDATE ev  
            SET ev.EventStatus_ID = @EventStatus_NotRunning  
            FROM mdm.tblEvent ev  
            INNER JOIN @RunningEventIds re  
                ON ev.ID = re.ID;  
        END;  
    END;  
  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpValidationLogClear]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
exec mdm.udpValidationLogClear 7, 3  
  
select * from mdm.tbl_7_VL  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpValidationLogClear]  
(  
    @Model_ID   INT,  
	@Version_ID	INT,	  
	@ID			INT = NULL,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
	SET NOCOUNT ON  
  
    IF @Model_ID IS NULL OR NOT EXISTS(SELECT ID FROM mdm.tblModel WHERE ID = @Model_ID)  
    BEGIN  
        --A valid model must be supplied  
        RAISERROR('MDSERR300005|The supplied model is not valid.', 16, 1);   
        RETURN;  
    END;  
  
    DECLARE @ValidationLogTableName sysname,  
            @SQL                    NVARCHAR(MAX);  
  
    SET @ValidationLogTableName = mdm.udfGetValidationLogTableName(@Model_ID);  
  
	IF @ID IS NOT NULL  
		BEGIN  
			SET @SQL = N'  
            DELETE FROM [mdm].' + QUOTENAME(@ValidationLogTableName) + N' WHERE ID = @ID;  
            ';  
            EXEC sp_executesql @SQL, N'@ID INT', @ID;  
		END  
	ELSE  
		BEGIN  
			SET @SQL = N'  
            DELETE FROM mdm.' + QUOTENAME(@ValidationLogTableName) + N' WHERE Version_ID = @Version_ID;  
            ';  
            EXEC sp_executesql @SQL, N'@Version_ID INT', @Version_ID;  
		END  
  
	SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpValidationLogClearByMemberID]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
exec mdm.udpValidationLogClearByMemberID 7,5,191,1  
select * from mdm.tbl_7_VL  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpValidationLogClearByMemberID]  
(  
    @Version_ID	INT,  
    @Entity_ID	INT,  
    @Member_ID	INT,  
    @MemberType_ID	INT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON  
  
    DECLARE @Model_ID               INT,  
            @SQL                    NVARCHAR(MAX),  
            @ValidationLogTableName sysname,  
            @ValidationLogViewName  sysname;  
  
    --Figure out the model ID  
    SELECT @Model_ID = Model_ID  
    FROM mdm.tblModelVersion  
    WHERE ID = @Version_ID;  
  
    SET @ValidationLogTableName = mdm.udfGetValidationLogTableName(@Model_ID);  
    SET @ValidationLogViewName = mdm.udfGetValidationLogViewName(@Model_ID);  
  
    SET @SQL = N'  
    DELETE   
    FROM 	[mdm].' + QUOTENAME(@ValidationLogTableName) + N'  
    WHERE	ID IN  
        (SELECT	vl.ID  
        FROM 	[mdm].' + QUOTENAME(@ValidationLogViewName) + N' vl   
        WHERE	vl.Member_ID = @Member_ID AND  
            vl.MemberType_ID = @MemberType_ID AND  
            vl.Version_ID = @Version_ID AND  
            vl.Entity_ID = @Entity_ID);  
    ';  
    EXEC sp_executesql @SQL, N'@Member_ID INT, @MemberType_ID INT, @Version_ID INT, @Entity_ID INT',  
                               @Member_ID,     @MemberType_ID,     @Version_ID,     @Entity_ID;  
  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpValidationLogClearByMemberIDs]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
Deletes all validation issues for the specified set of member ids.  
  
DECLARE @MemberIdList       mdm.IdList;  
INSERT INTO @MemberIdList  
VALUES (1), (2), (3)  
  
EXEC mdm.udpValidationLogClearByMemberIDs 7, 5, 1, @MemberIdList  
SELECT * FROM mdm.tbl_7_VL  
*/  
CREATE PROCEDURE [mdm].[udpValidationLogClearByMemberIDs]  
(  
     @Version_ID     INT  
    ,@Entity_ID      INT  
    ,@MemberType_ID  TINYINT  
    ,@MemberIdList   mdm.IdList READONLY  
    ,@CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON  
  
    DECLARE @Model_ID               INT,  
            @SQL                    NVARCHAR(MAX),  
            @ValidationLogTableName sysname;  
  
    SELECT @Model_ID = Model_ID  
    FROM mdm.tblModelVersion  
    WHERE ID = @Version_ID;  
  
    SET @ValidationLogTableName = mdm.udfGetValidationLogTableName(@Model_ID);  
  
    SET @SQL = N'  
    DELETE lg  
    FROM [mdm].' + QUOTENAME(@ValidationLogTableName) + N' lg  
    INNER JOIN @MemberIdList m  
        ON  
            lg.Member_ID = m.ID  
    WHERE  
        lg.Version_ID = @Version_ID  
        AND lg.Entity_ID = @Entity_ID  
        AND lg.MemberType_ID = @MemberType_ID;  
    ';  
    EXEC sp_executesql @SQL, N'@MemberIdList mdm.IdList READONLY, @Version_ID INT, @Entity_ID INT, @MemberType_ID TINYINT',  
                               @MemberIdList,                     @Version_ID,     @Entity_ID,     @MemberType_ID;  
  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpValidationLogClearForBusinessRules]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
exec mdm.udpValidationLogClearForBusinessRules 1,1,1,0  
exec mdm.udpValidationLogClearForBusinessRules 1,1,1,1 -- delete validation log entries for excluded rules only  
*/  
CREATE PROCEDURE [mdm].[udpValidationLogClearForBusinessRules]  
(  
    @Entity_ID          INT,  
    @MemberType_ID      TINYINT,  
    @ExcludedRulesOnly  BIT = 0,  
    @CorrelationID      UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON  
  
    DECLARE @Model_ID               INT,  
            @SQL                    NVARCHAR(MAX),  
            @ValidationLogTableName sysname;  
  
    SELECT @Model_ID = Model_ID  
    FROM mdm.tblEntity  
    WHERE ID = @Entity_ID;  
  
    SET @ValidationLogTableName = mdm.udfGetValidationLogTableName(@Model_ID);  
      
    SET @SQL = N'  
    DELETE vl  
    FROM [mdm].' + QUOTENAME(@ValidationLogTableName) + N' vl  
    INNER JOIN mdm.tblBRBusinessRule br  
    ON vl.BRBusinessRule_ID = br.ID  
    WHERE   br.Entity_ID = @Entity_ID  
        AND br.MemberType_ID = @MemberType_ID';  
      
    IF COALESCE(@ExcludedRulesOnly, 0) = 1  
    BEGIN  
        SET @SQL += N'  
        AND br.Status_ID =  2 -- Excluded';  
    END;  
  
    EXEC sp_executesql @SQL, N'@Entity_ID INT, @MemberType_ID TINYINT',  
                               @Entity_ID,     @MemberType_ID;  
  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpValidationQueueActivate]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
--Create SSB items  
CREATE QUEUE [mdm].[microsoft/mdm/queue/validation] WITH STATUS = ON , RETENTION = OFF  ON [PRIMARY]   
CREATE SERVICE [microsoft/mdm/service/validation]  AUTHORIZATION [dbo]  ON QUEUE [mdm].[microsoft/mdm/queue/validation] ([microsoft/mdm/contract/validation])  
CREATE MESSAGE TYPE [microsoft/mdm/message/validation] AUTHORIZATION [dbo] VALIDATION = WELL_FORMED_XML  
CREATE CONTRACT [microsoft/mdm/contract/validation] AUTHORIZATION [dbo] ([microsoft/mdm/message/validation] SENT BY INITIATOR)  
  
  
--Alter the queue to use the SP we just created in an activated manner  
ALTER QUEUE mdm.[microsoft/mdm/queue/validation]  
WITH STATUS = ON , RETENTION = OFF , ACTIVATION (  STATUS = ON , PROCEDURE_NAME = [mdm].[udpValidationQueueActivate] , MAX_QUEUE_READERS = 1 , EXECUTE AS CALLER  )  
  
*/  
CREATE PROCEDURE [mdm].[udpValidationQueueActivate]  
/*WITH*/  
AS BEGIN  
	SET NOCOUNT ON;  
  
	DECLARE			  
		 @message_type_name	sysname  
		,@handle			UNIQUEIDENTIFIER  
		,@interval			INT  
		,@body				XML  
		,@need_new			BIT;  
	  
	--Initialize variables  
	SELECT @handle = NULL, @need_new = NULL;   
	  
	--Load interval setting from config, and check the defaults and ranges  
	SET @interval = 120; --Protect against NULL values  
	  
	BEGIN TRANSACTION   
  
	WAITFOR (  
		RECEIVE TOP(1)  
			@handle = [conversation_handle],  
			@message_type_name = message_type_name,  
			@body = CONVERT(XML,message_body)  
		FROM mdm.[microsoft/mdm/queue/validation]		  
	), TIMEOUT 5000; --Always wait a constant time for any new messages  
			  
	--Got a TIMER message  
	IF (@message_type_name = N'microsoft/mdm/message/validation') BEGIN  
  
		--Start a new TIMER and COMMIT the transaction before we do the real work, to avoid poisoning  
		BEGIN CONVERSATION TIMER (@handle) TIMEOUT = @interval;  
		COMMIT TRANSACTION;  
		PRINT 'ValidationQueue received message';	  
		--Do the real work here - run validation  
		DECLARE 				  
				@User_ID	INT,  
				@Model_ID	INT,  
				@Version_ID INT,  
				@Entity_ID	INT,  
				@CommitVersion TINYINT;  
		  
		SET @User_ID = @body.value('/ValidationCriteria[1]/User_ID[1]','int');  
		SET @Model_ID = @body.value('/ValidationCriteria[1]/Model_ID[1]','int');  
		SET @Version_ID = @body.value('/ValidationCriteria[1]/Version_ID[1]','int');  
		SET @Entity_ID = @body.value('/ValidationCriteria[1]/Entity_ID[1]','int');  
		SET @CommitVersion = @body.value('/ValidationCriteria[1]/CommitVersion[1]','TINYINT');  
  
		PRINT 'ValidationQueue processing model'	  
		IF @CommitVersion = 1  
			BEGIN  
				EXEC mdm.udpValidateModel @User_ID=@User_ID,@Model_ID=@Model_ID,@Version_ID=@Version_ID,@Status_ID=3 --Status of 3 is Committed  
			END  
		ELSE  
			BEGIN  
				EXEC mdm.udpValidateModel @User_ID=@User_ID,@Model_ID=@Model_ID,@Version_ID=@Version_ID,@Status_ID=0  
			END  
		PRINT 'ValidationQueue processed message';	  
  
	--Got an END DIALOG message  
	END ELSE IF (@message_type_name = N'http://schemas.microsoft.com/SQL/ServiceBroker/EndDialog') BEGIN  
  
		PRINT 'ValidationQueue EndDialog'  
  
	--Got ERROR message  
	END ELSE IF (@message_type_name = N'http://schemas.microsoft.com/SQL/ServiceBroker/Error') BEGIN  
  
		PRINT 'ValidationQueue Error'  
  
	--Timeout or unexpected message  
	END ELSE BEGIN   
		  
		COMMIT TRANSACTION;  
		  
	END; --if  
	  
	SET NOCOUNT OFF;  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpValidationQueueSave]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
--Entity -Errors on temp table  
Exec mdm.udpValidationQueueSave 1, 7,20, 33, null,null  
--MEmber - works fine  
Exec mdm.udpValidationQueueSave 1, 7,20, 33, 188,1  
  
*/  
CREATE PROCEDURE [mdm].[udpValidationQueueSave]  
(  
    @User_ID        INT,   
    @Model_ID       INT,  
    @Version_ID     INT,  
    @Entity_ID      INT = NULL,  
    @CommitVersion  BIT = 0, --1=Commit, otherwise do not commit the version  
    @CorrelationID  UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON  
    --Insert a Message into the Service Broker Queue  
    DECLARE @xml AS XML;  
    SET @xml = (  
        SELECT  
            @User_ID AS [User_ID],  
            @Model_ID AS [Model_ID],  
            @Version_ID AS [Version_ID],  
            @Entity_ID AS [Entity_ID],  
            @CommitVersion AS [CommitVersion]  
        FOR XML PATH('ValidationCriteria'), ELEMENTS  
    );  
  
    --try to get an existing conversation handle  
    DECLARE @conversationHandle UNIQUEIDENTIFIER = mdm.udfServiceGetConversationHandle(  
        N'microsoft/mdm/service/system',  
        N'microsoft/mdm/service/validation');  
  
    --Start a new conversation if necessary  
    IF @conversationHandle IS NULL  
        BEGIN DIALOG @conversationHandle  
            FROM SERVICE [microsoft/mdm/service/system]   
            TO SERVICE N'microsoft/mdm/service/validation'  
            ON CONTRACT [microsoft/mdm/contract/validation]   
            WITH ENCRYPTION = OFF;  
  
    --Send a sample message  
    SEND ON CONVERSATION @conversationHandle MESSAGE TYPE [microsoft/mdm/message/validation](@xml);  
  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpValidationsGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
DECLARE @memberIds mdm.IdList;  
--INSERT INTO @memberIds VALUES (1),(2)  
  
exec mdm.udpValidationsGet 1,16,23,@memberIds,1  
exec mdm.udpValidationsGet 2,16,23,@memberIds,1  
  
exec mdm.udpValidationsGet 1,20,31,@memberIds,1  
exec mdm.udpValidationsGet 4,20,31,@memberIds,1  
  
exec mdm.udpValidationsGet 1,16,NULL,@memberIds  
exec mdm.udpValidationsGet 2,16,NULL,@memberIds  
  
exec mdm.udpValidationsGet null,16  
  
-- use paging within a version  
DECLARE @TotalCount INT;  
exec mdm.udpValidationsGet 1,20,NULL,@memberIds,NULL,NULL,1,50,N'MemberCode',N'ASC',@TotalCount OUTPUT;  
SELECT @TotalCount  
  
select * from mdm.tbl_7_VL  
select * from mdm.viw_SYSTEM_7_ISSUE_VALIDATION  
select * from mdm.tblList  
  
  
Dependency: udpSecurityMembersResolverGet  
*/  
CREATE PROCEDURE [mdm].[udpValidationsGet]  
(  
    @User_ID                INT,  
    @Version_ID             INT,  
    @Entity_ID              INT = NULL,  
    @Member_IDs             mdm.IdList READONLY,  
    @MemberType_ID          TINYINT = NULL,  
    @NotificationUser_ID    INT = NULL,  
    @PageNumber             INT = NULL,  
    @PageSize               INT = NULL, -- Null: use system setting, <=0: return all records, X: return X records.  
    @SortColumn             sysname = NULL,  
    @SortDirection          NVARCHAR(4) = NULL,  
    @TotalIssueCount        INT OUTPUT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS N'mds_schema_user' -- Execute as a user that has permission to select on [tblUserGroupAssignment], [tblBRBusinessRule], [udfSecurityUserBusinessRuleList]  
AS BEGIN  
    SET NOCOUNT ON  
  
    DECLARE  
        @SQL                NVARCHAR(MAX),  
        @PagingSQL          NVARCHAR(MAX) = N'',  
        @SortSQL            NVARCHAR(MAX),  
        @FromAndWhereSQL    NVARCHAR(MAX),  
        @StartRow           INT,  
        @EndRow             INT,  
        @UseMemberSecurity      BIT,  
        @IsAdmin                BIT,  
        @MemberType_Permission  TINYINT,  
        @Permission_Deny        INT = 1,  
        @Model_ID               INT,  
        @ValidationLogViewName  SYSNAME;  
  
    --Get the @Model_ID that owns the specific @Version_ID  
    SELECT @Model_ID = Model_ID FROM mdm.tblModelVersion WHERE ID = @Version_ID;  
  
    --Check for invalid parameters  
    IF (@Version_ID IS NULL OR @Model_ID IS NULL) BEGIN  
        RAISERROR('MDSERR100010|The Parameters are not valid.', 16, 1);  
        RETURN(1);  
    END; --if  
  
    SET @ValidationLogViewName = mdm.udfGetValidationLogViewName(@Model_ID);  
  
    ----------------------------------------------------------------------------------------  
    --Check security  
    ----------------------------------------------------------------------------------------  
    --Check Object Permissions.  Mark any attributes the user doesn't have permission to.  
    -- When checking validation status for whole versions, the @Entity_ID is not sent in  
    IF @Entity_ID IS NOT NULL  
    BEGIN  
        SELECT @MemberType_Permission = Privilege_ID,  
            @IsAdmin = IsAdmin  
        FROM mdm.viw_SYSTEM_SECURITY_USER_MEMBERTYPE  
        WHERE [User_ID] = @User_ID  
            AND [Entity_ID] = @Entity_ID  
            AND (@MemberType_ID IS NULL OR ID = @MemberType_ID);  
  
        IF @IsAdmin != 1  
        BEGIN  
            SET @MemberType_Permission = COALESCE(@MemberType_Permission, @Permission_Deny);  
            SET @UseMemberSecurity = mdm.udfUseMemberSecurity(@User_ID, @Entity_ID, @Version_ID, @MemberType_ID);  
        END  
    END  
  
    -- Create a temp table to store the results  
    CREATE TABLE #ValidationIssueIDs (  
        [RowId]                 INT,  
        [ID]                    INT PRIMARY KEY CLUSTERED,  
        [Model_ID]              INT,  
        [Model_MUID]            UNIQUEIDENTIFIER,  
        [Model_Name]            NVARCHAR(50),  
        [Version_ID]            INT,  
        [Version_MUID]          UNIQUEIDENTIFIER,  
        [Version_Name]          NVARCHAR(50),  
        [Hierarchy_ID]          INT,  
        [Hierarchy_MUID]        UNIQUEIDENTIFIER,  
        [Hierarchy_Name]        NVARCHAR(50),  
        [Entity_ID]             INT,  
        [Entity_MUID]           UNIQUEIDENTIFIER,  
        [Entity_Name]           NVARCHAR(MAX),  
        [MemberType_ID]         TINYINT,  
        [Member_ID]             INT,  
        [Member_MUID]           UNIQUEIDENTIFIER,  
        [MemberCode]            NVARCHAR(250),  
        [Description]           NVARCHAR(MAX),  
        [BRBusinessRule_ID]     INT,  
        [BRBusinessRule_MUID]   UNIQUEIDENTIFIER,  
        [BRBusinessRule_Name]   NVARCHAR(50),        
        [BRItem_ID]             INT,  
        [BRItem_MUID]           UNIQUEIDENTIFIER,  
        [BRItem_Name]           NVARCHAR(MAX),  
        [BRItem_Category]       TINYINT,  
        [EnterDTM]              DATETIME2(3),  
        [EnterUserID]           INT,  
        [EnterUserMUID]         UNIQUEIDENTIFIER,  
        [EnterUserName]         NVARCHAR(100),  
        [LastChgDTM]            DATETIME2(3),  
        [LastChgUserID]         INT,  
        [LastChgUserMUID]       UNIQUEIDENTIFIER,  
        [LastChgUserName]       NVARCHAR(100),  
        [NotificationStatus_ID] INT  
        );  
  
    --Only check for security level if we had an @Entity_ID sent in  
    IF @Entity_ID IS NULL OR @MemberType_Permission <> @Permission_Deny   
    BEGIN  
        -- GET ERROR MESSAGE  
        SELECT  en.ID AS [Entity_ID], en.MUID AS Entity_MUID, en.Name AS [Entity_Name], ev.ErrorMsg  
        FROM mdm.tblEvent ev  
        INNER JOIN mdm.tblEntity en ON ev.[Entity_ID] = en.ID  
        WHERE ev.Version_ID = @Version_ID  
        AND ev.ErrorMsg IS NOT NULL  
        AND (@Entity_ID IS NULL OR ev.[Entity_ID] = @Entity_ID)  
  
        IF (@PageSize IS NULL)  
        BEGIN  
            SELECT @PageSize = CONVERT(INT, SettingValue) FROM mdm.tblSystemSetting WHERE SettingName = CAST(N'RowsPerBatch' AS NVARCHAR(100));  
            SET @PageSize = COALESCE(@PageSize, 0); -- If the system setting is null, return all records.  
        END;  
  
        -- Set sort column SQL.  
        SET @SortColumn = QUOTENAME(COALESCE(NULLIF(@SortColumn, N''), N'ID')); -- Sort by ID by default.  
        SET @SortDirection = CASE WHEN UPPER(@SortDirection) = N'DESC' THEN N'DESC' ELSE N'ASC' END; -- Sort ascending by default, and protect against SQL injection.  
        SET @SortSQL = @SortColumn + N' ' + @SortDirection;  
  
        -- Set paging SQL.  
  
        IF (@PageSize > 0)  
        BEGIN  
            -- Ensure page number is greater than zero.  
            IF (COALESCE(@PageNumber, 0) < 1)  
            BEGIN  
                SET @PageNumber = 1;  
            END  
  
            SET @StartRow = (COALESCE(@PageNumber, 1) - 1) * (@PageSize) + 1;  
            SET @EndRow = @StartRow + @PageSize - 1;  
            SET @PagingSQL = N'  
                    WHERE RowId BETWEEN @StartRow AND @EndRow';  
        END;  
  
  
        SET @FromAndWhereSQL = N'  
                    FROM [mdm].' + QUOTENAME(@ValidationLogViewName) + N' L';  
        IF (EXISTS(SELECT 1 FROM @Member_IDs))  
        BEGIN  
            SET @FromAndWhereSQL += N'  
                    INNER JOIN @Member_IDs m  
                        ON m.ID = L.Member_ID';  
        END  
  
        --Create a temp table to cache the list of business rules this user has access to  
        CREATE TABLE #BusinessRuleList  
        (  
            BusinessRule_ID INT PRIMARY KEY CLUSTERED  
        );  
  
        --Fill the temp table up with the list of business rule IDs  
        INSERT INTO #BusinessRuleList  
        SELECT BusinessRule_ID FROM mdm.udfSecurityUserBusinessRuleList(@User_ID, @Entity_ID, @MemberType_ID);  
  
        SET @FromAndWhereSQL += N'  
                    INNER JOIN #BusinessRuleList AS BRACL  
                        ON BRACL.BusinessRule_ID = L.BRBusinessRule_ID  
                    LEFT JOIN mdm.tblBRBusinessRule BR  
                        ON BR.ID = L.BRBusinessRule_ID  
                    WHERE  
                        L.Version_ID = @Version_ID  
                        AND (@NotificationUser_ID IS NULL OR  
                            BR.NotificationUserID = @NotificationUser_ID OR  
                            BR.NotificationGroupID IN (SELECT UserGroup_ID FROM mdm.tblUserGroupAssignment uga WHERE uga.[User_ID] = @NotificationUser_ID))';  
        SET @SQL = N'  
                -- Use a CTE to apply sorting and paging  
                WITH pageItems AS (  
                    SELECT  
                        ROW_NUMBER() OVER (ORDER BY L.' + @SortSQL + N') AS RowId,  
                        L.*' +  
                        @FromAndWhereSQL + N'  
                    )  
                -- Insert the specified page of results into the temp table  
                INSERT INTO #ValidationIssueIDs  
                SELECT *  
                FROM pageItems' +  
                @PagingSQL + N';  
  
                -- Get the total number of validaiton issues  
                SET @TotalIssueCount =  @@ROWCOUNT;  
                IF (@StartRow > 1 OR @PageSize = @TotalIssueCount)  
                BEGIN  
                    -- Paging is being used and the results set may only be a subset of the total number of  
                    -- results, so re-execute the query (without paging) to get the total row count.  
                    SET @TotalIssueCount = (  
                        SELECT COUNT(*) ' +  
                        @FromAndWhereSQL + N');  
                END;';  
        -- PRINT @SQL  
  
        -- Execute SQL  
        DECLARE @SqlParameters AS NVARCHAR(MAX) = N'@User_ID INT, @Version_ID INT, @Entity_ID INT, @Member_IDs mdm.IdList READONLY, @MemberType_ID INT, @NotificationUser_ID INT, @StartRow INT, @EndRow INT, @PageSize INT, @TotalIssueCount INT OUTPUT';  
        EXEC sp_executesql @SQL, @SqlParameters,  
            @User_ID, @Version_ID, @Entity_ID, @Member_IDs, @MemberType_ID, @NotificationUser_ID, @StartRow, @EndRow, @PageSize, @TotalIssueCount OUTPUT;  
  
        DECLARE  
            @emptyCriteria      mdm.MemberGetCriteria,  
            @memberCount        INT,  
            @memberId           INT,  
            @entityId           INT,  
            @memberTypeId       INT;  
  
        --If getting issues for a notification recipient user or a single member, determine if user has permission to view member  
        --Model admins have permission for entire model so no need to check member security.  
        IF (@NotificationUser_ID IS NOT NULL OR EXISTS(SELECT 1 FROM @Member_IDs)) AND @UseMemberSecurity = 1  
        BEGIN  
            DECLARE @MemberPermissions AS TABLE (ID INT, MemberType_ID INT, Privilege_ID INT, AccessPermission TINYINT);  
            DECLARE @MemberPermissionsInput mdm.MemberId;  
  
            --Select member IDs into the input parameter for security members resolver get  
            INSERT INTO @MemberPermissionsInput(ID, MemberType_ID)  
            SELECT  
                DISTINCT  
                 VI.Member_ID  
                ,VI.MemberType_ID  
            FROM  
                #ValidationIssueIDs VI;  
  
            --Select the output from security resolver into a table valued variable  
            INSERT INTO @MemberPermissions  
            EXEC mdm.udpSecurityMembersResolverGet @User_ID = @User_ID, @Version_ID = @Version_ID, @Entity_ID = @Entity_ID, @MemberIds = @MemberPermissionsInput;  
  
            --Delete all issues for members the the user does not have access to. We only want to eliminate  
            --the denies. The reads and updates can stay.  
            DELETE Issues  
            FROM #ValidationIssueIDs Issues  
            INNER JOIN @MemberPermissions Prm ON Prm.ID = Issues.Member_ID  
            WHERE  
                Prm.Privilege_ID = @Permission_Deny;  
        END  
    END  
  
    -- Return the results.  
    SET @SQL = N'SELECT * FROM #ValidationIssueIDs ORDER BY ' + @SortSQL + N';';  
    EXEC sp_executesql @SQL;  
    SET NOCOUNT OFF  
  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpValidationStatusEntitySummaryGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
 exec mdm.udpValidationStatusEntitySummaryGet @User_ID=1, @Version_Name=N'Product'  
 exec mdm.udpValidationStatusEntitySummaryGet @User_ID=1, @Version_Name=N'Product', @Entity_Name=N'Product'  
*/  
CREATE PROCEDURE [mdm].[udpValidationStatusEntitySummaryGet]  
(  
     @User_ID                   INT  
    ,@Entity_ID                 INT = NULL  
    ,@Entity_MUID               UNIQUEIDENTIFIER = NULL  
    ,@Entity_Name               NVARCHAR(200) = NULL  
    ,@Version_ID                INT = NULL  
    ,@Version_MUID              UNIQUEIDENTIFIER = NULL  
    ,@Version_Name              NVARCHAR(50) = NULL  
    ,@Model_ID                  INT = NULL OUTPUT  
    ,@Model_MUID                UNIQUEIDENTIFIER = NULL OUTPUT  
    ,@Model_Name                NVARCHAR(50) = NULL OUTPUT  
    ,@CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON  
  
    DECLARE @SQL                       NVARCHAR(MAX);  
    DECLARE @Table                     sysname;  
    DECLARE @MemberTypeID              INT;  
    DECLARE @MemberType_Leaf           INT = 1;  
    DECLARE @MemberType_Consolidated   INT = 2;  
    DECLARE @MemberType_Hierarchy      INT = 4;  
    DECLARE @EventStatus_NotRunning    TINYINT = 2;  
    DECLARE @Counter                   INT;  
    DECLARE @MaxCounter                INT;  
    DECLARE @CurrentEntity_ID          INT;  
    DECLARE @Permission_Deny		   INT = 1;  
    DECLARE @GuidEmpty                 UNIQUEIDENTIFIER = CAST(0x0 AS UNIQUEIDENTIFIER);  
  
    DECLARE @tblList TABLE   
    (  
        RowNumber       INT IDENTITY (1, 1) PRIMARY KEY CLUSTERED NOT NULL,   
        Entity_ID       INT,   
        MemberTypeID    INT,   
        ValidationTable sysname COLLATE database_default  
    )  
  
    CREATE TABLE #tblEntityValidationCounts   
    (  
       Entity_ID              INT,  
       ValidationStatus_ID    INT,   
       ValidationStatus_Count INT  
    )  
  
    -- Validate version and entity ids  
    SET @Version_Name  = NULLIF(@Version_Name, N'');  
    SET @Entity_Name = NULLIF(@Entity_Name, N'');  
    SET @Version_MUID = NULLIF(@Version_MUID, @GuidEmpty);  
    SET @Entity_MUID = NULLIF(@Entity_MUID, @GuidEmpty);  
    SET @Version_ID = NULLIF(@Version_ID, 0);  
    SET @Entity_ID = NULLIF(@Entity_ID, 0);  
  
    -- Validate version  
    DECLARE @Version_ID_Lookup INT = NULL;   
  
    SELECT   
         @Version_ID = v.ID  
        ,@Version_Name = v.Name  
        ,@Version_MUID = v.MUID  
        ,@Version_ID_Lookup = v.ID -- This column is used to determine in the version exists (or the user has permission to it) because it is not nullable.  
        ,@Model_ID = v.Model_ID  
        ,@Model_MUID = m.MUID  
        ,@Model_Name = m.Name  
    FROM mdm.tblModelVersion v  
    INNER JOIN mdm.tblModel m  
    ON v.Model_ID = m.ID  
    INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_MODEL s  
    ON      v.Model_ID = s.ID  
        AND COALESCE(s.Privilege_ID, @Permission_Deny) <> @Permission_Deny  
        AND s.User_ID = @User_ID  
    WHERE   
            (@Version_MUID IS NOT NULL OR @Version_Name IS NOT NULL OR @Version_ID IS NOT NULL) -- At least one Identifier param must be provided.  
        AND (@Version_MUID IS NULL OR @Version_MUID = v.MUID)  
        AND (@Version_Name IS NULL OR @Version_Name = v.Name)  
        AND (@Version_ID   IS NULL OR @Version_ID  = v.ID)  
  
    IF @Version_ID_Lookup IS NULL  
    BEGIN  
        RAISERROR('MDSERR300006|The supplied version is not valid.', 16, 1);   
        RETURN;  
    END;  
  
    -- If entity ids are provided then validate entity  
    IF @Entity_Name IS NOT NULL OR @Entity_ID IS NOT NULL OR @Entity_MUID IS NOT NULL  
    BEGIN  
        DECLARE @Entity_ID_Lookup INT = NULL;  
  
        SELECT   
             @Entity_ID = e.ID  
            ,@Entity_Name = e.Name  
            ,@Entity_MUID = e.MUID  
            ,@Entity_ID_Lookup = e.ID -- This column is used to determine in the model exists (or the user has permission to it) because it is not nullable.  
        FROM mdm.tblEntity e  
        INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_ENTITY s  
        ON      e.ID = s.ID  
            AND COALESCE(s.Privilege_ID, @Permission_Deny) <> @Permission_Deny  
            AND s.User_ID = @User_ID  
        WHERE  
            e.Model_ID = @Model_ID  
            AND (@Entity_MUID IS NULL OR @Entity_MUID = e.MUID)  
            AND (@Entity_Name IS NULL OR @Entity_Name = e.Name)  
            AND (@Entity_ID   IS NULL OR @Entity_ID  = e.ID)  
  
        IF @Entity_ID_Lookup IS NULL  
        BEGIN  
            RAISERROR('MDSERR300008|The supplied entity is not valid.', 16, 1);  
            RETURN;  
        END;  
  
    END  
  
    --Seed table with entities, each with validation statuses and counts of zero  
    INSERT INTO #tblEntityValidationCounts   
    SELECT   
        e.ID  
        ,CAST(list.OptionID AS INT)  
        ,0  -- initial count of zero  
    FROM mdm.tblEntity e  
    INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_ENTITY s   
    ON e.ID = s.ID  
    CROSS JOIN mdm.tblList list  
    WHERE   
            e.Model_ID = @Model_ID  
        AND (@Entity_ID IS NULL OR @Entity_ID = e.ID)  
        AND COALESCE(s.Privilege_ID, @Permission_Deny) <> @Permission_Deny   
        AND s.User_ID = @User_ID  
        AND list.ListCode = N'lstValidationStatus'  
        AND list.IsVisible = 1  
    ORDER BY   
        e.ID  
        ,list.Seq;  
  
    --Get the list of member tables  
    INSERT INTO @tblList  
        SELECT   
            e.ID AS Entity_ID  
            ,@MemberType_Leaf AS MemberTypeID  
            ,EntityTable AS ValidationTable  
        FROM   
            [mdm].tblEntity e  
        INNER JOIN [mdm].viw_SYSTEM_SECURITY_USER_ENTITY s ON e.ID = s.ID  
            AND COALESCE(s.Privilege_ID, @Permission_Deny) <> @Permission_Deny   
            AND s.User_ID = @User_ID  
        WHERE   
            e.Model_ID = @Model_ID   
            AND (@Entity_ID IS NULL OR e.ID = @Entity_ID)  
      UNION ALL  
        SELECT   
            e.ID AS Entity_ID  
            ,@MemberType_Consolidated  
            ,HierarchyParentTable   
        FROM   
            [mdm].tblEntity e  
        INNER JOIN [mdm].viw_SYSTEM_SECURITY_USER_ENTITY s ON e.ID = s.ID  
            AND COALESCE(s.Privilege_ID, @Permission_Deny) <> @Permission_Deny   
            AND s.User_ID = @User_ID  
        WHERE   
            e.Model_ID = @Model_ID   
            AND HierarchyParentTable IS NOT NULL   
            AND (@Entity_ID IS NULL OR e.ID = @Entity_ID)  
      UNION ALL  
        SELECT   
            e.ID AS Entity_ID  
            ,@MemberType_Hierarchy  
            ,HierarchyTable   
        FROM   
            [mdm].tblEntity e  
        INNER JOIN [mdm].viw_SYSTEM_SECURITY_USER_ENTITY s ON e.ID = s.ID  
            AND COALESCE(s.Privilege_ID, @Permission_Deny) <> @Permission_Deny   
            AND s.User_ID = @User_ID  
        WHERE   
            e.Model_ID = @Model_ID   
            AND HierarchyTable IS NOT NULL   
            AND @Entity_ID IS NULL  
  
  
    ----Loop through each member table getting the validation status counts  
    SET @Counter = 1;  
    SET @MaxCounter = (SELECT MAX(RowNumber) FROM @tblList);  
  
    WHILE @Counter <= @MaxCounter  
    BEGIN  
       SELECT   
            @MemberTypeID = MemberTypeID  
            ,@Table = ValidationTable  
            ,@CurrentEntity_ID = Entity_ID  
       FROM @tblList WHERE [RowNumber] = @Counter  
  
       IF (@MemberTypeID <> @MemberType_Hierarchy)  
       BEGIN  
           SET @SQL =   
           N'  
           WITH cteCounts AS  
           (  
               SELECT ValidationStatus_ID, COUNT(*) AS ValCnt  
               FROM  [mdm].' + QUOTENAME(@Table) + N'    
               WHERE Status_ID = 1   
               GROUP BY ValidationStatus_ID  
           )  
           UPDATE #tblEntityValidationCounts  
           SET   
               ValidationStatus_Count = ValidationStatus_Count + ValCnt  
           FROM #tblEntityValidationCounts vc  
           INNER JOIN cteCounts ON cteCounts.ValidationStatus_ID = vc.ValidationStatus_ID  
           WHERE Entity_ID = @CurrentEntity_ID  
           '  
       END  
       ELSE  
       BEGIN  
           --We are only concerned about LevelNumber = -1 from the HR table.  These records need their LevelNumber recalculated.  
           SET @SQL =   
           N'  
           WITH cteCounts AS  
           (  
               SELECT 4 ValidationStatus_ID, COUNT(*) AS ValCnt  
                  FROM  [mdm].' + QUOTENAME(@Table) + N'  
                  WHERE Status_ID = 1 AND LevelNumber = -1  
           )  
           UPDATE #tblEntityValidationCounts  
           SET   
              ValidationStatus_Count = ValidationStatus_Count + ValCnt  
           FROM #tblEntityValidationCounts vc  
           INNER JOIN cteCounts ON cteCounts.ValidationStatus_ID = vc.ValidationStatus_ID  
           WHERE Entity_ID = @CurrentEntity_ID  
           '  
       END			  
       EXEC sp_executesql @SQL, N'@CurrentEntity_ID INT', @CurrentEntity_ID;  
        SET @Counter += 1;  
    END  
  
    --Return validation results per entity  
    SELECT     
       ent.ID AS [Entity_ID],  
       ent.Name AS [Entity_Name],  
       ent.MUID AS [Entity_MUID],  
       ValidationStatus_ID  AS [ValidationID],  
       ValidationStatus_Count AS [Count]  
    FROM    
       #tblEntityValidationCounts vc  
    INNER JOIN [mdm].tblEntity ent ON vc.Entity_ID = ent.ID;  
  
    --Return last validated dtm for model  
    SELECT LastChgDTM AS [VersionLastValidated], Version_ID  
    FROM [mdm].tblEvent   
    WHERE  
        Version_ID = @Version_ID AND  
        EventName = N'ValidateVersion' AND  
        EventStatus_ID = @EventStatus_NotRunning;  
  
    --Return last validated dtm for entity  
    SELECT LastChgDTM AS [EntityLastValidated], Version_ID, Entity_ID  
    FROM [mdm].tblEvent   
    WHERE   
        Version_ID = @Version_ID AND  
        (@Entity_ID IS NULL OR Entity_ID = @Entity_ID) AND  
        EventName = N'ValidateEntity' AND  
        EventStatus_ID = @EventStatus_NotRunning;  
              
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpValidationStatusSummaryGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
EXEC mdm.udpValidationStatusSummaryGet  20  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpValidationStatusSummaryGet]  
(  
   @Version_ID INT,  
   @Entity_ID INT = NULL,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
	SET NOCOUNT ON  
  
	DECLARE @SQL     NVARCHAR(MAX)  
	DECLARE @Table   sysname     
	DECLARE @MemberTypeID INT  
	DECLARE @tblList TABLE (RowNumber INT IDENTITY (1, 1) PRIMARY KEY CLUSTERED NOT NULL, MemberTypeID INT, ValidationTable sysname COLLATE database_default) --Flag to track if the table is used for validation.  
	DECLARE @ModelID INT = (SELECT TOP 1 Model_ID FROM mdm.tblModelVersion WHERE ID = @Version_ID);  
    DECLARE @EntityMemberType INT = 1;  
    DECLARE @HierarchyParentMemberType INT = 2;  
    DECLARE @HierarchyMemberType INT = 4;  
  
	CREATE TABLE #tblValidationCounts   
	   (  
	   ValidationStatus_ID    INT,   
	   ValidationStatus_Count INT  
	   )  
  
	--Seed table with validation statuses, each with a count of zero  
	INSERT INTO #tblValidationCounts   
	SELECT CAST(OptionID AS INT), 0  
	FROM mdm.tblList  
	WHERE ListCode = N'lstValidationStatus' AND IsVisible = 1  
	ORDER BY Seq  
  
	--Get the list of member tables  
	INSERT INTO @tblList  
	  SELECT @EntityMemberType AS MemberTypeID, EntityTable AS ValidationTable FROM mdm.tblEntity WHERE Model_ID = @ModelID AND (@Entity_ID IS NULL OR ID = @Entity_ID)  
	  UNION ALL  
	  SELECT @HierarchyParentMemberType, HierarchyParentTable FROM mdm.tblEntity WHERE Model_ID = @ModelID AND HierarchyParentTable IS NOT NULL AND (@Entity_ID IS NULL OR ID = @Entity_ID)  
	  UNION ALL  
	  SELECT @HierarchyMemberType, HierarchyTable FROM mdm.tblEntity WHERE Model_ID = @ModelID AND HierarchyTable IS NOT NULL AND @Entity_ID IS NULL  
  
  
	----Loop through each member table getting the validation status counts  
	DECLARE @Counter INT = 1;  
	DECLARE @MaxCounter INT = (SELECT MAX(RowNumber) FROM @tblList);  
  
	WHILE @Counter <= @MaxCounter  
	BEGIN  
	   SELECT   
	        @MemberTypeID = MemberTypeID  
	        ,@Table = ValidationTable   
	   FROM @tblList WHERE [RowNumber] = @Counter  
  
	   IF (@MemberTypeID <> @HierarchyMemberType)  
	       SET @SQL =   
	       N'  
	       UPDATE #tblValidationCounts  
	       SET ValidationStatus_Count = ValidationStatus_Count + ValCnt  
	       FROM  
		      (SELECT ValidationStatus_ID, COUNT(*) AS ValCnt  
		      FROM  mdm.' + quotename(@Table) + N' a    
		      WHERE Version_ID = @Version_ID AND Status_ID = 1   
		      GROUP BY ValidationStatus_ID) b INNER JOIN #tblValidationCounts vc ON b.ValidationStatus_ID = vc.ValidationStatus_ID  
	       '  
	   ELSE  
    	   --We are only concerned about LevelNumber = -1 from the HR table.  These records need their LevelNumber recalculated.  
	       SET @SQL =   
	       N'  
	       UPDATE #tblValidationCounts  
	       SET ValidationStatus_Count = ValidationStatus_Count + ValCnt  
	       FROM  
		      (SELECT 4 ValidationStatus_ID, COUNT(*) AS ValCnt  
		      FROM  mdm.' + quotename(@Table) + N' a    
		      WHERE Version_ID = @Version_ID AND Status_ID = 1 AND LevelNumber = -1) b INNER JOIN #tblValidationCounts vc ON b.ValidationStatus_ID = vc.ValidationStatus_ID'  
			  
	   EXEC sp_executesql @SQL, N'@Version_ID INT', @Version_ID  
        SET @Counter += 1;  
	END  
  
	--Return results  
	SELECT     
	   ValidationStatus_ID  AS [ValidationID],  
	   ValidationStatus_Count AS [Count]  
	FROM    
	   #tblValidationCounts	  
  
	DROP TABLE #tblValidationCounts  
  
	SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpVersionCopy]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
--TEST SCRIPT  
    EXEC mdm.udpSystemSettingSave 1,'CopyOnlyCommittedVersion', '0'  --don't require committed versions to copy  
    DECLARE @P1 int, @P2 UNIQUEIDENTIFIER;  
    DECLARE @x NVARCHAR(50) = NEWID();  
  
  
    --Recursively copy versions N times. If you want to copy the same version  
    -- each time just replace the second @v OUTPUT param below with null.  
    DECLARE @v INT = 23;  
    DECLARE @i INT = 0;  
    WHILE (@i < 1) BEGIN  
        SELECT @x = NEWID();  
        EXEC mdm.udpVersionCopy 1, @v, @x, @x, @v OUTPUT,null,1;  
        PRINT @v;  
        SET @i += 1;  
    END; --while  
  
    SELECT * FROM mdm.tblModelVersion  
  
    EXEC mdm.udpSystemSettingSave 1,'CopyOnlyCommittedVersion', '1'  --reset required committed versions to copy  
*/  
CREATE PROCEDURE [mdm].[udpVersionCopy]  
(  
    @User_ID            INT,  
    @Version_ID         INT,  
    @VersionName        NVARCHAR(50),  
    @VersionDescription NVARCHAR(250),  
    @Return_ID          INT = NULL OUTPUT,  
    @Return_MUID        UNIQUEIDENTIFIER = NULL OUTPUT,  
    @Debug              BIT = 0,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE @Model_ID                   INT,  
            @NewVersion_ID              INT,  
            @NewVersion_MUID            UNIQUEIDENTIFIER,  
            @Entity_ID                  INT,  
            @MemberType_ID              INT,  
            @TableName                  SYSNAME,  
            @TableNameEN                SYSNAME,  
            @TableNameHP                SYSNAME,  
            @TableNameCN                SYSNAME,  
            @SQL                        NVARCHAR(MAX),  
            @From                       NVARCHAR(MAX),  
            @Insert                     NVARCHAR(MAX),  
            @StartTime                  DATETIME2(7),  
  
            @MemberType_Leaf                TINYINT = 1,  
            @MemberType_Consolidated        TINYINT = 2,  
            @MemberType_Collection          TINYINT = 3,  
            @MemberType_Hierarchy           TINYINT = 4,  
            @MemberType_CollectionMember    TINYINT = 5,  
  
            -- This pseudo-constant is for use in string concatenation operations to prevent string truncation. When concatenating two or more strings,  
            -- if none of the strings is an NVARCHAR(MAX) or an NVARCHAR constant that is longer than 4,000 characters, then the resulting string   
            -- will be silently truncated to 4,000 characters. Concatenating with this empty NVARCHAR(MAX), is sufficient to prevent truncation.  
            -- See http://connect.microsoft.com/SQLServer/feedback/details/283368/nvarchar-max-concatenation-yields-silent-truncation.  
            @TruncationGuard        NVARCHAR(MAX) = N'',  
  
            @CopyNbr                    INT,  
            @CopyOnlyCommittedVersion   NVARCHAR(250),  
            @SourceVersionStatusID      TINYINT,  
            @SourceVersionName          NVARCHAR(50),  
            @SourceVersionDesc          NVARCHAR(500),  
            @UpdateDbaValuesScript      NVARCHAR(MAX);  
  
    SELECT  
        @SourceVersionStatusID = Status_ID,  
        @SourceVersionName = [Name],  
        @SourceVersionDesc = [Description]  
    FROM mdm.tblModelVersion  
    WHERE ID = @Version_ID;  
  
    --If CopyOnlyCommittedVersion is turned on then verify that the version is committed.  
    EXEC mdm.udpSystemSettingGet N'CopyOnlyCommittedVersion', @CopyOnlyCommittedVersion OUTPUT;  
    IF CONVERT(INT, @CopyOnlyCommittedVersion) = 1 AND @SourceVersionStatusID <> 3   
    BEGIN  
        --On error, return NULL results  
        SELECT @Return_ID = NULL, @Return_MUID = NULL;  
        RAISERROR('MDSERR200062|The version cannot be copied. Only committed versions can be copied.', 16, 1);  
        RETURN;  
    END; --if  
  
    IF NULLIF(@VersionName, N'') IS NULL   
    BEGIN  
        SELECT @CopyNbr = ISNULL(Count(AsOfVersion_ID), 0) + 1 FROM mdm.tblModelVersion WHERE AsOfVersion_ID = @Version_ID;  
        SET @VersionName = CONCAT(N'Copy (', @CopyNbr, N') of ',  @SourceVersionName);  
    END; --if  
  
    SET @VersionDescription = ISNULL(NULLIF(@VersionDescription, N''), @SourceVersionDesc);  
  
    --Start transaction, being careful to check if we are nested  
    DECLARE @TranCounter INT;  
    SET @TranCounter = @@TRANCOUNT;  
    IF @TranCounter > 0 SAVE TRANSACTION TX;  
    ELSE BEGIN TRANSACTION;  
  
    BEGIN TRY  
  
        SELECT @Model_ID = Model_ID FROM mdm.tblModelVersion WHERE ID = @Version_ID;  
  
        --Create new version record and get new Version_ID  
        --Make the new version private  
        EXEC mdm.udpVersionSave   
            @User_ID = @User_ID,   
            @Model_ID = @Model_ID,  
            @Version_ID = NULL,  
            @CurrentVersion_ID = @Version_ID,   
            @Status_ID = 1/*Open*/,   
            @Name = @VersionName,   
            @Description = @VersionDescription,   
            @Return_ID = @NewVersion_ID OUTPUT,   
            @Return_MUID = @NewVersion_MUID OUTPUT;  
  
        --Initialize the return parameters  
        SELECT @Return_ID = @NewVersion_ID, @Return_MUID = @NewVersion_MUID;  
  
        --Temporary table to hold all the entity table names  
        DECLARE @EntityTable TABLE  
        (  
            Entity_ID INT,   
            MemberType_ID INT,   
            TableName SYSNAME,   
            [Level] INT,  
            EntityTable SYSNAME,  
            HierarchyParentTable SYSNAME NULL,  
            CollectionTable SYSNAME NULL  
        );  
  
        --Need to copy data in the right order so as to not violate FKs  
        INSERT INTO @EntityTable  
        SELECT edt.Entity_ID, edt.MemberType_ID, edt.TableName, edt.[Level], e.EntityTable, e.HierarchyParentTable, e.CollectionTable  
        FROM mdm.udfEntityDependencyTree(@Model_ID) edt  
        INNER JOIN mdm.tblEntity e  
        ON edt.Entity_ID = e.ID;  
  
        --Loop through the member tables  
        WHILE EXISTS(SELECT 1 FROM @EntityTable)   
        BEGIN  
  
            SET @SQL = N'';  
  
            SELECT TOP 1  
                @Entity_ID = Entity_ID,  
                @MemberType_ID = MemberType_ID,  
                @TableName = TableName,  
                @TableNameEN = EntityTable,             --EN (1)  
                @TableNameHP = HierarchyParentTable,    --HP (2)  
                @TableNameCN = CollectionTable          --CN (3)  
            FROM @EntityTable  
            ORDER BY [Level] ASC; --Copy tables in correct dependency order  
  
            --Mapping foreign keys seems faster via (stage + UPDATE + INSERT) than (JOIN + direct INSERT)  
            --This is likely due to the large number of constraints (especially FKs) in the member tables  
            --Note that SELECT INTO also uses the source collations in the destination temporary table  
            IF @MemberType_ID IN (@MemberType_Leaf, @MemberType_Consolidated, @MemberType_Collection)   
            BEGIN --EN, HP, CN  
                SELECT @Insert = N'', @From = N'';  
  
                --Get the list of Attributes in the current Entity  
                SELECT  
                     @Insert = CONCAT(@TruncationGuard, @Insert, CASE WHEN a.DomainEntity_ID IS NULL THEN CONCAT(CASE WHEN @Insert = N'' THEN N' ' ELSE N',' END, QUOTENAME(a.TableColumn), N' -- ', a.Name, N'  
    ') END)  
  
                    ,@From =   CONCAT(@TruncationGuard, @From,   CASE WHEN a.DomainEntity_ID IS NULL THEN CONCAT(CASE WHEN @From = N''   THEN N' ' ELSE N'  
    ,' END,       
                        CASE a.TableColumn  
                            WHEN N'ValidationStatus_ID' THEN N'CASE WHEN ValidationStatus_ID = 2 THEN 4 ELSE ValidationStatus_ID END AS '  
                            WHEN N'AsOf_ID' THEN N'ID AS ' --Copy old ID value into AsOf_ID column  
                            WHEN N'Version_ID' THEN N'@NewVersion_ID AS ' --Hard-code new version  
                            WHEN N'LastChgUserID' THEN N'@User_ID AS ' --Hard code user  
                            WHEN N'LastChgVersionID' THEN N'@NewVersion_ID AS ' --Hard code new version  
                            ELSE N'' --Use old value for all other columns  
                        END,  
                        QUOTENAME(a.TableColumn), N' -- ', a.Name) END)  
  
                    ,@UpdateDbaValuesScript = CONCAT(@TruncationGuard, @UpdateDbaValuesScript, CASE WHEN a.DomainEntity_ID IS NOT NULL THEN CONCAT(CASE WHEN @Debug = 1 THEN CONCAT(N'  
SET @StartTime = SYSDATETIME();  
PRINT CONCAT(@StartTime, N'': Copy DBA ', QUOTENAME(a.Name), N' Start'');') END, N'  
UPDATE new   
SET ', QUOTENAME(a.TableColumn), N' = dba.ID -- ', a.Name, N'  
FROM mdm.', QUOTENAME(@TableName), N' AS old  
INNER JOIN mdm.', QUOTENAME(@TableName), N' AS new   
ON      old.Version_ID = @Version_ID   
    AND old.ID = new.AsOf_ID  
INNER JOIN mdm.', QUOTENAME(d.EntityTable), N' AS dba   
ON      new.Version_ID = dba.Version_ID   
    AND old.', QUOTENAME(a.TableColumn), N' = dba.AsOf_ID  
WHERE   new.Version_ID = @NewVersion_ID   
    AND old.', QUOTENAME(a.TableColumn), N' IS NOT NULL   
    AND new.Status_ID = 1  
OPTION(OPTIMIZE FOR (@Version_ID UNKNOWN, @NewVersion_ID UNKNOWN)); -- Avoid parameter sniffing  
', CASE WHEN @Debug = 1 THEN CONCAT(N'PRINT CONCAT(SYSDATETIME(), N'': Copy DBA ', QUOTENAME(a.Name), N' end in '', DATEDIFF(MS, @StartTime, SYSDATETIME()), N'' ms'');  
') END) END)  
                FROM mdm.tblAttribute AS a  
                LEFT JOIN mdm.tblEntity AS d   
                ON a.DomainEntity_ID = d.ID  
                WHERE   a.Entity_ID = @Entity_ID   
                    AND a.MemberType_ID = @MemberType_ID  
                    --Cannot insert into system and/or computed columns  
                    AND (a.IsSystem = 0 OR a.TableColumn NOT IN (N'ID', N'Status_ID', N'EnterDTM', N'LastChgDTM', N'LastChgTS', N'MUID'));  
  
                SET @SQL = CONCAT(@TruncationGuard, N'  
--Copy mapped data into destination  
INSERT INTO mdm.', QUOTENAME(@TableName), N'  
(  
    ', @Insert, N'  
)  
SELECT  
    ', @From, N'  
FROM mdm.', QUOTENAME(@TableName), N'  
WHERE   Version_ID = @Version_ID  
    AND Status_ID = 1  
;');  
  
            --Since the HR table is much simpler, a direct insert still has good performance  
            END ELSE IF @MemberType_ID = @MemberType_Hierarchy   
            BEGIN --HR  
                SET @SQL = CONCAT(@TruncationGuard, CASE WHEN @Debug = 1 THEN N'  
PRINT CONCAT(SYSDATETIME(), '': Start copy HR table '')  
DECLARE @StartTime DATETIME2(7) = SYSDATETIME();  
' END, N'  
INSERT INTO mdm.', QUOTENAME(@TableName), N'  
(  
     Version_ID  
    ,Hierarchy_ID  
    ,Parent_HP_ID  
    ,ChildType_ID  
    ,Child_EN_ID  
    ,Child_HP_ID  
    ,SortOrder  
    ,LevelNumber  
    ,EnterUserID  
    ,EnterVersionID  
    ,LastChgUserID  
    ,LastChgVersionID  
    ,AsOf_ID  
)  
SELECT   
     @NewVersion_ID AS Version_ID  
    ,hr.Hierarchy_ID  
    ,hp.ID AS Parent_HP_ID  
    ,hr.ChildType_ID  
    ,leafChild.ID AS Child_EN_ID  
    ,conChild.ID AS Child_HP_ID  
    ,hr.SortOrder  
    ,hr.LevelNumber  
    ,hr.EnterUserID  
    ,hr.EnterVersionID  
    ,@User_ID AS LastChgUserID  
    ,@NewVersion_ID AS LastChgVersionID  
    ,hr.ID AS AsOf_ID  
FROM mdm.', QUOTENAME(@TableName), N' AS hr  
LEFT JOIN mdm.', QUOTENAME(@TableNameHP), N' AS hp -- new parents  
ON      hp.Version_ID = @NewVersion_ID  
    AND hr.Parent_HP_ID = hp.AsOf_ID  
LEFT JOIN mdm.', QUOTENAME(@TableNameHP), N' conChild -- new consolidated children  
ON      conChild.Version_ID = @NewVersion_ID  
    AND hr.Child_HP_ID = conChild.AsOf_ID  
LEFT JOIN mdm.', QUOTENAME(@TableNameEN), N' leafChild -- new leaf children  
ON      leafChild.Version_ID = @NewVersion_ID  
    AND hr.Child_EN_ID = leafChild.AsOf_ID  
WHERE   hr.Version_ID = @Version_ID  
    AND hr.Status_ID = 1;', CASE WHEN @Debug = 1 THEN N'  
  
PRINT CONCAT(SYSDATETIME(), '': Initial copy to HR table end in '', DATEDIFF(MS, @StartTime, SYSDATETIME()), '' ms'')  
SET @StartTime = SYSDATETIME();' END, N'  
  
--seed HR table with leaf entities on the root for hierarchies that did not exist in the original version  
WITH h AS  
(  
    SELECT h.ID   
    FROM mdm.tblHierarchy AS h  
    LEFT JOIN mdm.', QUOTENAME(@TableName), ' AS hr   
    ON      h.ID = hr.Hierarchy_ID  
        AND hr.Version_ID = @NewVersion_ID  
    WHERE   hr.ID IS NULL  
        AND h.Entity_ID = @Entity_ID  
        AND h.IsMandatory = 1  
)  
INSERT INTO mdm.', QUOTENAME(@TableName), N'  
(  
     Version_ID  
    ,Hierarchy_ID  
    ,Parent_HP_ID  
    ,ChildType_ID  
    ,Child_EN_ID  
    ,Child_HP_ID  
    ,SortOrder  
    ,LevelNumber  
    ,EnterUserID  
    ,EnterVersionID  
    ,LastChgUserID  
    ,LastChgVersionID  
    ,AsOf_ID  
)  
SELECT  
     @NewVersion_ID AS Version_ID  
    ,h.ID  
    ,NULL  
    ,1  
    ,e.ID  
    ,NULL  
    ,e.ID  
    ,-1  
    ,e.EnterUserID  
    ,e.EnterVersionID  
    ,e.LastChgUserID  
    ,e.LastChgVersionID  
    ,NULL  
FROM mdm.', QUOTENAME(@TableNameEN), N' AS e   
CROSS JOIN h  
WHERE e.Version_ID = @NewVersion_ID', CASE WHEN @Debug = 1 THEN N'  
  
PRINT CONCAT(SYSDATETIME(), '': Create ROOT rows for mandatory hierarchies end in '', DATEDIFF(MS, @StartTime, SYSDATETIME()), '' ms'')  
' END);  
  
            --Since the CM table is much simpler, a direct insert still has good performance  
            END ELSE IF @MemberType_ID = @MemberType_CollectionMember   
            BEGIN --CM  
  
                SET @SQL = CONCAT(@TruncationGuard, N'  
WITH cte AS  
(  
    SELECT  
         @NewVersion_ID AS Version_ID  
        ,pr.ID AS Parent_CN_ID  
        ,cm.ChildType_ID  
        ,en.ID AS Child_EN_ID', CASE WHEN @TableNameHP IS NOT NULL THEN N'  
        ,hp.ID AS Child_HP_ID' END, N'   
        ,cn.ID AS Child_CN_ID  
        ,cm.SortOrder  
        ,cm.Weight  
        ,cm.EnterUserID  
        ,cm.EnterVersionID  
        ,@User_ID AS LastChgUserID  
        ,@NewVersion_ID AS LastChgVersionID  
        ,cm.ID AS AsOf_ID  
    FROM mdm.', QUOTENAME(@TableName), N' AS cm  
    INNER JOIN mdm.', QUOTENAME(@TableNameCN), N' AS pr  
    ON      pr.Version_ID = @NewVersion_ID  
        AND cm.Parent_CN_ID = pr.AsOf_ID  
        AND pr.Status_ID = 1  
    LEFT JOIN mdm.', QUOTENAME(@TableNameEN), N' AS en  
    ON      en.Version_ID = pr.Version_ID  
        AND cm.ChildType_ID = 1  
        AND cm.Child_EN_ID = en.AsOf_ID  
        AND en.Status_ID = 1', CASE WHEN @TableNameHP IS NOT NULL THEN CONCAT(N'  
    LEFT JOIN mdm.', QUOTENAME(@TableNameHP), N' AS hp  
    ON      hp.Version_ID = pr.Version_ID  
        AND cm.ChildType_ID = 2  
        AND cm.Child_HP_ID = hp.AsOf_ID  
        AND hp.Status_ID = 1') END, N'  
    LEFT JOIN mdm.', QUOTENAME(@TableNameCN), N' AS cn  
    ON      cn.Version_ID = pr.Version_ID  
        AND cm.ChildType_ID = 3  
        AND cm.Child_CN_ID = cn.AsOf_ID  
        AND cn.Status_ID = 1  
    WHERE   cm.Version_ID = @Version_ID  
        AND cm.Status_ID = 1  
)  
INSERT INTO mdm.', QUOTENAME(@TableName), N'  
(  
     Version_ID  
    ,Parent_CN_ID  
    ,ChildType_ID  
    ,Child_EN_ID', CASE WHEN @TableNameHP IS NOT NULL THEN N'  
    ,Child_HP_ID' END, N'  
    ,Child_CN_ID  
    ,SortOrder  
    ,Weight  
    ,EnterUserID  
    ,EnterVersionID  
    ,LastChgUserID  
    ,LastChgVersionID  
    ,AsOf_ID  
)  
SELECT * FROM cte  
WHERE --FKs may be NULL if original row was soft-deleted  
        Parent_CN_ID IS NOT NULL  
    AND ISNULL(Child_EN_ID, ', CASE WHEN @TableNameHP IS NOT NULL THEN N'ISNULL(Child_HP_ID, Child_CN_ID)' ELSE N'Child_CN_ID' END, N') IS NOT NULL  
;');  
  
            END; --if  
            IF @Debug = 1   
            BEGIN  
                SET @StartTime = SYSDATETIME();  
                PRINT CONCAT(@StartTime, N': ', @TableName, N' start ');  
                --PRINT @SQL;  
            END --if debug  
  
            EXEC sp_executesql @SQL,  
                N'@User_ID INT, @Version_ID INT, @NewVersion_ID INT, @Entity_ID INT',  
                @User_ID, @Version_ID, @NewVersion_ID, @Entity_ID;  
  
            IF @Debug = 1   
            BEGIN  
                PRINT CONCAT(SYSDATETIME(), N': ', @TableName, N' end in ', DATEDIFF(MS, @StartTime, SYSDATETIME()), N' ms');  
            END --if debug  
  
  
            DELETE FROM @EntityTable WHERE Entity_ID = @Entity_ID AND MemberType_ID = @MemberType_ID;  
  
        END; --while  
  
        --Finally, map all the DBAs only after all new PK values are populated  
        --We need to do this at the very end to cater for recursive derived hierarchies (self-referencing DBAs)  
        IF NULLIF(@UpdateDbaValuesScript, N'') IS NOT NULL  
        BEGIN  
            If @Debug = 1   
            BEGIN  
                SET @UpdateDbaValuesScript = N'DECLARE @StartTime DATETIME2(7);  
'  
                    + @UpdateDbaValuesScript;  
                --PRINT @UpdateDbaValuesScript;  
            END  
  
            EXEC sp_executesql @UpdateDbaValuesScript,  
                N'@User_ID INT, @Version_ID INT, @NewVersion_ID INT, @Entity_ID INT',  
                @User_ID, @Version_ID, @NewVersion_ID, @Entity_ID;  
  
        END  
  
        --Copy the security records across  
        EXEC mdm.udpSecurityRoleAccessMemberCopy @User_ID = @User_ID, @SourceVersion_ID = @Version_ID, @TargetVersion_ID = @NewVersion_ID, @MapMembersByID = 1;  
  
        --(Re)build the member security (MS) records for the new versions via the queue  
        EXEC mdm.udpSecurityMemberProcessRebuildModelVersion @Version_ID = @NewVersion_ID, @ProcessNow = 1;  
  
  
        -- Copy sync relationships for which the copied version is a target. The copied sync relationship will instead target the new version.  
        -- Any failure in the sync process should not cause version copy to fail, but instead sync errors should be logged in the sync table.  
        DECLARE @TargetEntity TABLE  
        (  
             TargetEntity_ID    INT PRIMARY KEY  
            ,TargetEntity_MUID  UNIQUEIDENTIFIER  
            ,TargetModel_MUID   UNIQUEIDENTIFIER  
            ,User_ID            INT  
        );  
        INSERT INTO tblSyncRelationship  
        (  
             SourceVersion_ID  
            ,SourceEntity_ID  
            ,TargetVersion_ID  
            ,TargetEntity_ID  
            ,TargetEntityNameIsAliased  
            ,RefreshFrequencyInHours  
            ,EnterUserID  
            ,LastChgUserID  
        )  
        OUTPUT inserted.TargetEntity_ID, inserted.LastChgUserID INTO @TargetEntity(TargetEntity_ID, User_ID)  
        SELECT  
             sr.SourceVersion_ID  
            ,sr.SourceEntity_ID  
            ,@NewVersion_ID  
            ,sr.TargetEntity_ID  
            ,sr.TargetEntityNameIsAliased  
            ,sr.RefreshFrequencyInHours  
            ,sr.EnterUserID  
            ,sr.LastChgUserID  
        FROM mdm.tblSyncRelationship sr  
        WHERE sr.TargetVersion_ID = @Version_ID;  
  
        -- Get MUIDs  
        UPDATE tgt  
        SET  
             TargetEntity_MUID =  e.MUID  
            ,TargetModel_MUID = m.MUID  
        FROM @TargetEntity tgt  
        INNER JOIN mdm.tblEntity e  
        ON tgt.TargetEntity_ID = e.ID  
        INNER JOIN mdm.tblModel m  
        ON e.Model_ID = m.ID  
  
        DECLARE   
             @TargetEntity_ID   INT = 0  
            ,@TargetEntity_MUID UNIQUEIDENTIFIER  
            ,@TargetModel_MUID  UNIQUEIDENTIFIER  
            ,@SyncUser_ID       INT;  
        WHILE EXISTS(SELECT 1 FROM @TargetEntity WHERE TargetEntity_ID > @TargetEntity_ID)  
        BEGIN  
            SELECT TOP 1   
                 @TargetEntity_ID   = TargetEntity_ID   
                ,@TargetEntity_MUID = TargetEntity_MUID  
                ,@TargetModel_MUID  = TargetModel_MUID  
                ,@SyncUser_ID       = User_ID  
            FROM @TargetEntity   
            WHERE TargetEntity_ID > @TargetEntity_ID  
            ORDER BY TargetEntity_ID;  
  
            BEGIN TRY  
                EXEC mdm.udpSyncRefresh   
                     @User_ID = @SyncUser_ID  
                    ,@TargetModel_MUID = @TargetModel_MUID  
                    ,@TargetVersion_MUID = @NewVersion_MUID  
                    ,@TargetEntity_MUID = @TargetEntity_MUID  
            END TRY  
            BEGIN CATCH  
                -- Add the error message to the sync table  
                DECLARE @ErrorMsg NVARCHAR(4000)  
                EXEC mdm.udpGetErrorInfo @ErrorMessage = @ErrorMsg OUTPUT  
  
                DECLARE @SyncStatus_Failed TINYINT = 3;  
                UPDATE mdm.tblSyncRelationship  
                SET  
                     LastSyncAttemptDTM         = GETUTCDATE()  
                    ,LastSyncAttemptStatus      = @SyncStatus_Failed  
                    ,LastSyncAttemptErrorInfo   = @ErrorMsg  
                WHERE   TargetVersion_ID = @NewVersion_ID  
                    AND TargetEntity_ID = @TargetEntity_ID  
            END CATCH  
        END  
  
        --Commit only if we are not nested  
        IF @TranCounter = 0 COMMIT TRANSACTION;  
        RETURN(0);  
  
    END TRY  
    --Compensate as necessary  
    BEGIN CATCH  
  
        -- Get error info.  
        DECLARE  
            @ErrorMessage NVARCHAR(4000),  
            @ErrorSeverity INT,  
            @ErrorState INT,  
            @ErrorNumber INT,  
            @ErrorLine INT,  
            @ErrorProcedure NVARCHAR(126);  
        EXEC mdm.udpGetErrorInfo  
            @ErrorMessage = @ErrorMessage OUTPUT,  
            @ErrorSeverity = @ErrorSeverity OUTPUT,  
            @ErrorState = @ErrorState OUTPUT,  
            @ErrorNumber = @ErrorNumber OUTPUT,  
            @ErrorLine = @ErrorLine OUTPUT,  
            @ErrorProcedure = @ErrorProcedure OUTPUT  
  
        SET @ErrorMessage = CONCAT(@ErrorMessage, N', @ErrorNumber = ', @ErrorNumber, N', @ErrorProcedure = "', @ErrorProcedure, N'", line ', @ErrorLine);  
  
        IF @TranCounter = 0 ROLLBACK TRANSACTION;  
        ELSE IF XACT_STATE() <> -1 ROLLBACK TRANSACTION TX;  
  
        RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);  
  
        --On error, return NULL results  
        --SELECT @Return_ID = NULL;  
        RETURN(1);  
  
    END CATCH;  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpVersionCopyByMUID]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    DECLARE @Return_ID              int,  
            @Return_MUID            uniqueidentifier,  
            @VersionName            NVARCHAR(50),  
            @VersionDescription     NVARCHAR(250);  
  
    SELECT  
            @VersionName            = 'New Product Version',  
            @VersionDescription     = 'Product Model - Proposed next quarter model';  
  
    EXEC mdm.udpVersionCopyByMUID 1, 'DC011B93-5599-4278-8101-B3D254A09B81', @VersionName, @VersionDescription, @Return_ID OUTPUT, @Return_MUID OUTPUT;  
    SELECT @Return_ID, @Return_MUID;  
  
    SELECT * FROM mdm.tblModelVersion;  
*/  
CREATE PROCEDURE [mdm].[udpVersionCopyByMUID]  
(  
    @User_ID                INT,  
    @Version_MUID           UNIQUEIDENTIFIER,  
    @VersionName            NVARCHAR(50),  
    @VersionDescription     NVARCHAR(250),  
    @Return_ID              INT = NULL OUTPUT,  
    @Return_MUID            UNIQUEIDENTIFIER = NULL OUTPUT,  
    @CorrelationID          UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE @FunctionalPrivilege_Versions  TINYINT = 2  
    IF mdm.udfSecurityUserFunctionIsAllowed(@User_ID, @FunctionalPrivilege_Versions) = 0  
    BEGIN  
        RAISERROR('MDSERR120002|The user does not have permission to perform this operation.', 16, 1);  
        RETURN;  
    END  
  
    DECLARE   
         @Version_ID        INT  
        ,@ModelPrivilege    INT;  
  
    SELECT   
         @Version_ID = mv.ID   
        ,@ModelPrivilege = m.Privilege_ID  
    FROM mdm.tblModelVersion mv  
    INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_MODEL m  
    ON mv.Model_ID = m.ID  
    WHERE   mv.MUID = @Version_MUID  
        AND m.User_ID = @User_ID  
        AND m.Privilege_ID > 1/*Deny*/;  
  
    --Test for invalid parameters  
    IF (@Version_ID IS NULL) --Invalid @Version_MUID  
    BEGIN  
        --On error, return NULL results  
        SELECT @Return_ID = NULL, @Return_MUID = NULL;  
        RAISERROR('MDSERR200036|The version cannot be copied. The version MUID is not valid.', 16, 1);  
        RETURN;  
    END;  
  
    IF @ModelPrivilege != 5 /*Admin*/  
    BEGIN  
        --On error, return NULL results  
        SELECT @Return_ID = NULL, @Return_MUID = NULL;  
        RAISERROR(N'MDSERR120003|The user does not have permission or the object ID is not valid.', 16, 1);  
        RETURN;  
    END;  
  
    EXEC mdm.udpVersionCopy @User_ID, @Version_ID, @VersionName, @VersionDescription, @Return_ID OUTPUT, @Return_MUID OUTPUT;  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpVersionDelete]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    EXEC mdm.udpVersionDelete 7;  
    SELECT * FROM mdm.tblModelVersion;  
*/  
CREATE PROCEDURE [mdm].[udpVersionDelete]  
(  
    @Version_ID    INT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE  
        @ID                     INT,  
        @Model_ID               INT,  
        @Entity_ID              INT,  
        @MemberType_ID          TINYINT,  
        @MemberType_Leaf        TINYINT = 1,  
        @TableName              SYSNAME,  
        @SQL                    NVARCHAR(MAX),  
        @DbaUpdateSeqment       NVARCHAR(MAX),  
        @DbaRowCount            INT,  
        @ValidationLogTableName SYSNAME,  
        @TransactionTableName   SYSNAME,  
        @ChangeSetTableName     SYSNAME;  
  
    --Get the @Model_ID that owns the specific @Version_ID  
    SELECT @Model_ID = Model_ID FROM mdm.tblModelVersion WHERE ID = @Version_ID;  
  
    --Check for invalid parameters  
    IF (@Version_ID IS NULL OR @Model_ID IS NULL) BEGIN  
        RAISERROR('MDSERR100010|The Parameters are not valid.', 16, 1);  
        RETURN(1);  
    END; --if  
  
    --Get the validation log table name  
    SET @ValidationLogTableName = mdm.udfGetValidationLogTableName(@Model_ID);  
    SET @TransactionTableName = CONCAT(N'tbl_', @Model_ID, N'_TR');  
    SET @ChangeSetTableName = CONCAT(N'tbl_', @Model_ID, N'_CS');;  
  
    --Start transaction, being careful to check if we are nested  
    DECLARE @TranCounter INT;  
    SET @TranCounter = @@TRANCOUNT;  
    IF @TranCounter > 0 SAVE TRANSACTION TX;  
    ELSE BEGIN TRANSACTION;  
  
    BEGIN TRY  
  
        -- Remove any sync relationships for which the deleted version is source or target.  
        DECLARE  
             @TargetVersion_ID  INT  
            ,@TargetEntity_ID   INT  
        CREATE TABLE #SyncRelationshipsToDelete  
        (  
             TargetVersion_ID   INT  
            ,TargetEntity_ID    INT  
        );  
        CREATE UNIQUE CLUSTERED INDEX #pk_SyncRelationshipsToDelete ON #SyncRelationshipsToDelete(TargetVersion_ID, TargetEntity_ID);  
        INSERT INTO #SyncRelationshipsToDelete  
        SELECT  
              sr.TargetVersion_ID  
             ,sr.TargetEntity_ID  
        FROM mdm.tblSyncRelationship sr  
        WHERE  SourceVersion_ID = @Version_ID  
            OR TargetVersion_ID = @Version_ID;  
  
        WHILE EXISTS(SELECT 1 FROM #SyncRelationshipsToDelete)  
        BEGIN  
            SELECT TOP 1  
                 @TargetVersion_ID  = TargetVersion_ID  
                ,@TargetEntity_ID   = TargetEntity_ID  
            FROM #SyncRelationshipsToDelete  
  
            EXEC mdm.udpSyncRelationshipDelete  
                 @User_ID = 0 -- Unused when @IsVersionOrEntityDelete = 1  
                ,@TargetVersion_ID = @TargetVersion_ID  
                ,@TargetEntity_ID = @TargetEntity_ID  
                ,@IsVersionOrEntityDelete = 1  
                ,@CorrelationID = @CorrelationID  
  
            DELETE FROM #SyncRelationshipsToDelete  
            WHERE   TargetVersion_ID  = @TargetVersion_ID  
                AND TargetEntity_ID = @TargetEntity_ID  
        END;  
  
        --Temporary table to hold all the entity table names  
        DECLARE @EntityTable TABLE  
        (  
             RowNumber INT IDENTITY(1, 1) NOT NULL PRIMARY KEY  
            ,TableName SYSNAME NOT NULL  
            ,MemberType_ID TINYINT NOT NULL  
        );  
  
        --Temporary table to hold all the DBA column names  
        DECLARE @DbaTable TABLE  
        (  
             RowNumber INT IDENTITY(1, 1) NOT NULL PRIMARY KEY  
            ,Entity_ID INT NOT NULL  
            ,MemberType_ID TINYINT NOT NULL  
            ,TableName SYSNAME NOT NULL  
            ,DbaColumnName SYSNAME NOT NULL  
        );  
  
        --Pre-deletion step  
  
        --Delete the subscription views associated with the version  
        EXEC mdm.udpSubscriptionViewsDelete  
            @Model_ID               = NULL,  
            @Version_ID             = @Version_ID,  
            @Entity_ID                = NULL,  
            @DerivedHierarchy_ID    = NULL;  
  
        --Update all DBA values to NULL for this version.  This ensures there will be no FK violations when deleting member data below.  
        INSERT INTO @DbaTable  
        SELECT  
             att.Entity_ID  
            ,att.Attribute_MemberType_ID  
            ,seq.TableName  
            ,att.Attribute_Column AS DbaColumnName  
        FROM mdm.viw_SYSTEM_SCHEMA_ATTRIBUTES att  
        INNER JOIN mdm.udfEntityDependencyTree(@Model_ID) seq  
        ON seq.Entity_ID = att.Entity_ID  
        AND att.Attribute_MemberType_ID = seq.MemberType_ID  
        AND att.Attribute_DBAEntity_ID <> 0  
        AND att.Model_ID = @Model_ID  
        ORDER BY att.Entity_ID, att.Attribute_MemberType_ID;  
  
        DECLARE @Counter INT    = 1,  
                @MaxCounter INT = (SELECT MAX(RowNumber) FROM @DbaTable);  
  
        WHILE @Counter <= @MaxCounter  
        BEGIN  
  
            SELECT  
                 @Entity_ID = Entity_ID  
                ,@MemberType_ID = MemberType_ID  
                ,@TableName = TableName  
            FROM @DbaTable  
            WHERE RowNumber = @Counter;  
  
            SELECT @DbaUpdateSeqment=N'';  
            --Generate the portion of the UPDATE statment that sets the DBA columns to NULL  
            --This sets and appends to the variable all in one statement.  
            SELECT  
                @DbaUpdateSeqment = @DbaUpdateSeqment + DbaColumnName + N'=NULL,'  
            FROM @DbaTable  
            WHERE Entity_ID = @Entity_ID  
            AND   MemberType_ID = @MemberType_ID;  
  
            --Get the rowcount of the number of DBAs.  
            SELECT @DbaRowCount = @@ROWCOUNT;  
  
            --Drop the comma on the end.  
            SELECT @DbaUpdateSeqment = SUBSTRING(@DbaUpdateSeqment,1,LEN(@DbaUpdateSeqment)-1)  
  
            SET @SQL = N'  
                UPDATE mdm.' + QUOTENAME(@TableName) + N' SET ' + @DbaUpdateSeqment + N'  
                WHERE Version_ID = ' + CONVERT(NVARCHAR(30), @Version_ID) + N';';  
  
            --PRINT @SQL  
            EXEC sp_executesql @SQL;  
  
            --Increment by the number of DBAs to get to the next Entity or MemberType.  
            SET @Counter += @DbaRowCount;  
  
        END; --while  
  
        --Delete Member data for this version.  Order of deletion doesn't matter since all DBA values have been set to NULL above.  
        INSERT INTO @EntityTable  
            SELECT  TableName, MemberType_ID  
            FROM mdm.udfEntityDependencyTree(@Model_ID)  
            ORDER BY [Level] DESC;  
  
        SELECT @Counter = 1,  
                @MaxCounter = (SELECT MAX(RowNumber) FROM @EntityTable);  
  
        --Entity level  
        --EN/HP/HR/CN/CM and their HS/AN/PD tables will be deleted explicitly  
        --MS table will be deleted by foreign key cascade delete  
        WHILE @Counter <= @MaxCounter  
        BEGIN  
            SELECT  
                @TableName = TableName,  
                @MemberType_ID = MemberType_ID  
            FROM @EntityTable  
            WHERE RowNumber = @Counter;  
  
            SET @SQL = CONCAT(N'  
                DELETE FROM mdm.', QUOTENAME(@TableName), N'  
                WHERE Version_ID = @Version_ID;  
  
                DELETE FROM mdm.', QUOTENAME(@TableName + N'_HS'), N'  
                WHERE Version_ID = @Version_ID;  
  
                DELETE FROM mdm.', QUOTENAME(@TableName + N'_AN'), N'  
                WHERE Version_ID = @Version_ID;');  
  
            IF @MemberType_ID = @MemberType_Leaf  
            BEGIN  
                SET @SQL = CONCAT(@SQL, N'  
                    DELETE FROM mdm.', QUOTENAME(@TableName + N'_PD'), N'  
                    WHERE Version_ID = @Version_ID;');  
            END  
  
            --PRINT @SQL  
            EXEC sp_executesql @SQL, N'@Version_ID INT', @Version_ID;  
  
            SET @Counter += 1;  
        END; --while  
  
        --Delete all notification queue related items  
        DELETE FROM mdm.tblNotificationUsers WHERE Notification_ID IN (select ID from mdm.tblNotificationQueue WHERE Version_ID = @Version_ID);  
        DELETE FROM mdm.tblNotificationQueue WHERE Version_ID = @Version_ID;  
  
        --Model level  
        --TR/VL/CS tables will be deleted explicitly  
        --AN table will be deleted by forign key cascade delete  
        SET @SQL = CONCAT(N'  
            DELETE FROM [mdm].', QUOTENAME(@ValidationLogTableName), N'  
            WHERE Version_ID = @Version_ID;  
  
            DELETE FROM [mdm].', QUOTENAME(@TransactionTableName), N'  
            WHERE Version_ID = @Version_ID;  
  
            DELETE FROM [mdm].', QUOTENAME(@ChangeSetTableName), N'  
            WHERE Version_ID = @Version_ID;');  
        EXEC sp_executesql @SQL, N'@Version_ID INT', @Version_ID;  
  
        --Delete all security role access member items  
        DELETE FROM mdm.tblSecurityRoleAccessMember WHERE Version_ID = @Version_ID;  
  
        -- Delete the Version out of ModelVersion table  
        DELETE FROM mdm.tblModelVersion WHERE ID = @Version_ID;  
  
        --Commit only if we are not nested  
        IF @TranCounter = 0 COMMIT TRANSACTION;  
        RETURN(0);  
  
    END TRY  
    --Compensate as necessary  
    BEGIN CATCH  
  
        -- Get error info.  
        DECLARE  
            @ErrorMessage NVARCHAR(4000),  
            @ErrorSeverity INT,  
            @ErrorState INT,  
            @ErrorNumber INT,  
            @ErrorLine INT,  
            @ErrorProcedure NVARCHAR(126);  
        EXEC mdm.udpGetErrorInfo  
            @ErrorMessage = @ErrorMessage OUTPUT,  
            @ErrorSeverity = @ErrorSeverity OUTPUT,  
            @ErrorState = @ErrorState OUTPUT,  
            @ErrorNumber = @ErrorNumber OUTPUT,  
            @ErrorLine = @ErrorLine OUTPUT,  
            @ErrorProcedure = @ErrorProcedure OUTPUT  
  
        SET @ErrorMessage = CONCAT(@ErrorMessage, N', @ErrorNumber = ', @ErrorNumber, N', @ErrorProcedure = "', @ErrorProcedure, N'", line ', @ErrorLine);  
  
        IF @TranCounter = 0 ROLLBACK TRANSACTION;  
        ELSE IF XACT_STATE() <> -1 ROLLBACK TRANSACTION TX;  
  
        RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);  
  
        --On error, return NULL results  
        --SELECT @Return_ID = NULL;  
        RETURN(1);  
  
    END CATCH;  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpVersionFlagGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpVersionFlagGet]  
(  
     @User_ID       INT  
  
    ,@Model_MUID    UNIQUEIDENTIFIER = NULL  
    ,@Model_Name    NVARCHAR(50) = NULL  
    ,@Model_ID      INT = NULL -- set internally only  
  
    ,@VersionFlag_MUID  UNIQUEIDENTIFIER = NULL  
    ,@VersionFlag_Name  NVARCHAR(50) = NULL  
  
    ,@IncludeParentIdentifiers  BIT = 1 -- Return results sets for parent Model and Entity identifiers. Set to 0 when getting attributes as part of a parent object (because the parent identifiers will already have been looked up).  
    ,@Debug                     BIT = 0  
    ,@CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
  
    SET NOCOUNT ON  
  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), ': begin udpVersionFlagGet')  
  
    -- Get model ID  
    IF @Model_ID IS NULL -- If the ID was already provided, don't bother looking it up again  
        AND (@Model_Name IS NOT NULL OR @Model_MUID IS NOT NULL)  
    BEGIN  
        SELECT   
             @Model_ID = ID  
            ,@Model_MUID = MUID  
            ,@Model_Name = Name  
        FROM mdm.tblModel  
        WHERE   MUID = ISNULL(@Model_MUID, MUID)  
            AND Name = ISNULL(@Model_Name, Name)  
  
        SET @Model_ID = COALESCE(@Model_ID, 0)  
    END  
  
    -- Get version flag ID  
    DECLARE @VersionFlag_ID INT = NULL;  
    IF @VersionFlag_Name IS NOT NULL OR @VersionFlag_MUID IS NOT NULL  
    BEGIN  
        SELECT   
             @VersionFlag_ID = ID  
            ,@VersionFlag_MUID = MUID  
            ,@VersionFlag_Name = Name  
        FROM mdm.tblModelVersionFlag  
        WHERE   MUID = ISNULL(@VersionFlag_MUID, MUID)  
            AND Name = ISNULL(@VersionFlag_Name, Name)  
            AND Model_ID = ISNULL(@Model_ID, Model_ID) -- If a model filter is specified, use it  
  
        SET @VersionFlag_ID = COALESCE(@VersionFlag_ID, 0)  
    END  
  
    DECLARE @SelectedVersionFlag TABLE   
    (  
         ID                 INT PRIMARY KEY  
        ,Model_ID           INT  
        ,Privilege_ID       TINYINT  
        ,AccessPermission   TINYINT  
    )  
  
    INSERT INTO @SelectedVersionFlag  
    SELECT  
         vf.ID  
        ,vf.Model_ID  
        ,acl.Privilege_ID  
        ,acl.AccessPermission  
    FROM mdm.tblModelVersionFlag vf  
    INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_MODEL acl  
    ON vf.Model_ID = acl.ID  
    WHERE   acl.User_ID = @User_ID  
        AND vf.Model_ID = ISNULL(@Model_ID, vf.Model_ID)  
        AND vf.ID = ISNULL(@VersionFlag_ID, vf.ID)  
        AND vf.Status_ID = 1  
        AND acl.Privilege_ID <> 1 /*Deny*/  
  
    IF @IncludeParentIdentifiers = 1  
    BEGIN  
        -- Return model Identifier(s)  
        IF @Model_ID IS NOT NULL  
        BEGIN  
            IF @Model_Name IS NULL OR @Model_MUID IS NULL  
            BEGIN  
                SELECT   
                     @Model_MUID = MUID  
                    ,@Model_Name = Name  
                FROM mdm.tblModel  
                WHERE ID = @Model_ID  
            END  
  
            -- A single model was specified, and its info has already been looked up, so simply return it  
            SELECT   
                 @Model_MUID    AS Model_MUID  
                ,@Model_Name    AS Model_Name  
                ,@Model_ID      AS Model_ID  
        END ELSE  
        BEGIN  
            SELECT DISTINCT  
                 m.MUID AS Model_MUID  
                ,m.Name AS Model_Name  
                ,m.ID   AS Model_ID  
            FROM @SelectedVersionFlag vf  
            INNER JOIN mdm.tblModel m  
            ON vf.Model_ID = m.ID  
        END  
    END  
  
    SELECT  
         vf.MUID    AS VersionFlag_MUID  
        ,vf.Name    AS VersionFlag_Name  
        ,vf.ID      AS VersionFlag_ID  
        ,svf.Privilege_ID  
        ,svf.AccessPermission  
  
        ,svf.Model_ID  
  
        ,vf.Description  
        ,vf.IsCommittedOnly  
  
        ,NULLIF(vf.AssignedVersion_MUID, 0x0)   AS AssignedVersion_MUID  
        ,NULLIF(vf.AssignedVersion_Name, N'')   AS AssignedVersion_Name  
        ,NULLIF(vf.AssignedVersion_ID, 0)       AS AssignedVersion_ID  
  
        ,vf.EnteredUser_DTM  
        ,vf.EnteredUser_MUID  
        ,vf.EnteredUser_UserName  
        ,vf.EnteredUser_ID  
        ,vf.LastChgUser_DTM  
        ,vf.LastChgUser_MUID  
        ,vf.LastChgUser_UserName  
        ,vf.LastChgUser_ID  
    FROM @SelectedVersionFlag svf  
    INNER JOIN mdm.viw_SYSTEM_SCHEMA_VERSION_FLAGS vf  
    ON svf.ID = vf.ID  
    ORDER BY   
         vf.Model_MUID  
        ,vf.Name  
  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), ': end udpVersionFlagGet')  
  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpVersionGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpVersionGet]  
(  
     @User_ID       INT  
  
    ,@Model_MUID    UNIQUEIDENTIFIER = NULL  
    ,@Model_Name    NVARCHAR(50) = NULL  
    ,@Model_ID      INT = NULL -- set internally only  
  
    ,@Version_MUID    UNIQUEIDENTIFIER = NULL  
    ,@Version_Name    NVARCHAR(50) = NULL  
  
    ,@IncludeParentIdentifiers  BIT = 1 -- Return results sets for parent Model identifiers. Set to 0 when getting versions as part of a parent object (because the parent identifiers will already have been looked up).  
    ,@Debug                     BIT = 0  
    ,@CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
  
    SET NOCOUNT ON  
  
    DECLARE   
         @ValidationStatus_NotSpecified TINYINT = 0  
        ,@ValidationStatus_NotValidated TINYINT = 1  
        ,@ValidationStatus_Validated    TINYINT = 2  
  
        ,@VersionStatus_Open        TINYINT = 1  
        ,@VersionStatus_Locked      TINYINT = 2  
        ,@VersionStatus_Committed   TINYINT = 3  
        ;  
  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), ': start udpVersionGet')  
  
    -- Get model ID  
    IF @Model_ID IS NULL -- If the ID was already provided, don't bother looking it up again  
        AND (@Model_Name IS NOT NULL OR @Model_MUID IS NOT NULL)  
    BEGIN  
        SELECT   
             @Model_ID = ID  
            ,@Model_MUID = MUID  
            ,@Model_Name = Name  
        FROM mdm.tblModel  
        WHERE   MUID = ISNULL(@Model_MUID, MUID)  
            AND Name = ISNULL(@Model_Name, Name)  
  
        SET @Model_ID = COALESCE(@Model_ID, 0)  
    END  
  
    -- Get version ID  
    DECLARE @Version_ID INT = NULL;  
    IF @Version_Name IS NOT NULL OR @Version_MUID IS NOT NULL  
    BEGIN  
        SELECT   
             @Version_ID = ID  
            ,@Version_MUID = MUID  
            ,@Version_Name = Name  
        FROM mdm.tblModelVersion  
        WHERE   MUID = ISNULL(@Version_MUID, MUID)  
            AND Name = ISNULL(@Version_Name, Name)  
            AND Model_ID = ISNULL(@Model_ID, Model_ID) -- If a model filter is specified, use it  
  
        SET @Version_ID = COALESCE(@Version_ID, 0)  
    END  
  
    DECLARE @SelectedVersion TABLE   
    (  
         ID                     INT PRIMARY KEY  
        ,Model_ID               INT  
        ,ValidationStatus_ID    TINYINT  
        ,Privilege_ID           TINYINT  
        ,AccessPermission       TINYINT  
    )  
  
    INSERT INTO @SelectedVersion  
    SELECT  
         v.ID  
        ,v.Model_ID  
        ,CASE v.Status_ID   
            WHEN @VersionStatus_Committed THEN @ValidationStatus_Validated -- Committed versions are always validated  
            ELSE @ValidationStatus_NotSpecified END  
        ,4/*Access*/  
        ,CASE  
            -- If the status is Committed (3) then the version has been approved and cannot be updated by anyone  
            WHEN v.Status_ID = 3 THEN 0 -- ReadOnly  
            -- If the status is Locked (2) then the version is locked for review and can only be updated by a Model administrator  
            WHEN v.Status_ID = 2 THEN  
                CASE  
                    WHEN acl.Privilege_ID = 5 /*Admin*/ THEN 7 -- All  
                    ELSE 0 -- ReadOnly  
                END  
            -- If the status is Open (1) then return update.  
            ELSE 7 -- All  
        END AS AccessPermission  
    FROM mdm.tblModelVersion v  
    INNER JOIN mdm.viw_SYSTEM_SECURITY_USER_MODEL acl  
    ON v.Model_ID = acl.ID  
    WHERE   acl.User_ID = @User_ID  
        AND v.Model_ID = ISNULL(@Model_ID, v.Model_ID)  
        AND v.ID = ISNULL(@Version_ID, v.ID)  
        AND acl.Privilege_ID <> 1 /*Deny*/  
  
    IF @IncludeParentIdentifiers = 1  
    BEGIN  
        -- Return model Identifier(s)  
        IF @Model_ID IS NOT NULL  
        BEGIN  
            IF @Model_Name IS NULL OR @Model_MUID IS NULL  
            BEGIN  
                SELECT   
                     @Model_MUID = MUID  
                    ,@Model_Name = Name  
                FROM mdm.tblModel  
                WHERE ID = @Model_ID  
            END  
  
            -- A single model was specified, and its info has already been looked up, so simply return it  
            SELECT   
                 @Model_MUID    AS Model_MUID  
                ,@Model_Name    AS Model_Name  
                ,@Model_ID      AS Model_ID  
        END ELSE  
        BEGIN  
            SELECT DISTINCT  
                 m.MUID AS Model_MUID  
                ,m.Name AS Model_Name  
                ,m.ID   AS Model_ID  
            FROM @SelectedVersion v  
            INNER JOIN mdm.tblModel m  
            ON v.Model_ID = m.ID  
        END  
    END  
  
    -- Get version validation status  
    DECLARE   
         @IsValidated           BIT  
        ,@ValidationStatus_ID   TINYINT;  
    SET @Version_ID = -1  
  
    WHILE (1 = 1)  
    BEGIN  
        SET @Model_ID = NULL  
  
        SELECT TOP 1   
             @Model_ID = Model_ID  
            ,@Version_ID = ID   
            ,@ValidationStatus_ID = ValidationStatus_ID  
        FROM @SelectedVersion   
        WHERE ID > @Version_ID  
        ORDER BY ID ASC  
  
        IF @Model_ID IS NULL  
        BEGIN  
            BREAK;  
        END  
        ELSE IF @ValidationStatus_ID = @ValidationStatus_NotSpecified -- Skip versions whose validation status has already been determined   
        BEGIN  
  
            EXEC mdm.udpVersionValidationStatusGet @Model_ID = @Model_ID, @Version_ID = @Version_ID, @IsValidated = @IsValidated OUTPUT  
  
            UPDATE @SelectedVersion   
            SET ValidationStatus_ID = CASE @IsValidated WHEN 0 THEN @ValidationStatus_NotValidated ELSE @ValidationStatus_Validated END  
            WHERE ID = @Version_ID  
        END   
    END  
  
    SELECT  
         v.MUID AS Version_MUID  
        ,v.Name AS Version_Name  
        ,v.ID   AS Version_ID  
        ,sv.Privilege_ID  
        ,sv.AccessPermission  
  
        ,sv.Model_ID  
  
        ,v.Description  
        ,v.Status_ID  
        ,sv.ValidationStatus_ID  
        ,v.VersionNbr AS VersionNumber  
  
        ,NULLIF(v.Flag_MUID, 0x0)       AS VersionFlag_MUID  
        ,NULLIF(v.Flag, N'')            AS VersionFlag_Name  
        ,NULLIF(v.VersionFlag_ID, 0)    AS VersionFlag_ID  
  
        ,NULLIF(v.CopiedFrom_MUID, 0x0) AS CopiedFrom_MUID  
        ,NULLIF(v.CopiedFrom, N'')      AS CopiedFrom_Name  
        ,NULLIF(v.CopiedFrom_ID, 0)     AS CopiedFrom_ID  
  
        ,v.EnteredUser_DTM  
        ,v.EnteredUser_MUID  
        ,v.EnteredUser_UserName  
        ,v.EnteredUser_ID  
        ,v.LastChgUser_DTM  
        ,v.LastChgUser_MUID  
        ,v.LastChgUser_UserName  
        ,v.LastChgUser_ID  
    FROM @SelectedVersion sv  
    INNER JOIN mdm.viw_SYSTEM_SCHEMA_VERSION v  
    ON sv.ID = v.ID  
    ORDER BY   
         v.Model_MUID  
        ,v.VersionNbr  
  
    IF @Debug = 1 PRINT CONCAT(SYSDATETIME(), ': end udpVersionGet')  
  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpVersionGetByID]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
exec mdm.udpVersionGetByID 1  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpVersionGetByID]  
(  
    @Version_ID	INT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON  
  
    SELECT  
        vVer.ID,  
        vVer.MUID,  
        vVer.Name,  
        vVer.Model_ID,  
        vVer.Model_MUID,  
        vVer.Model_Name,  
        vVer.[Description],  
        vVer.Status_ID,  
        vVer.[Status],  
        vVer.VersionNbr Display_ID,  
        vVer.Flag_MUID,  
        vVer.Flag VersionFlag,  
        vVer.CopiedFrom_ID AS AsOfVersionID,  
        vVer.CopiedFrom_MUID AS AsOfVersionMUID,  
        vVer.CopiedFrom AS AsOfVersionName,  
        4 AS Privilege_ID, /*Access*/  
        0 AS AccessPermission, /*ReadOnly*/  
        vVer.EnteredUser_MUID,  
        vVer.EnteredUser_UserName,  
        vVer.EnteredUser_DTM,  
        vVer.LastChgUser_MUID,  
        vVer.LastChgUser_UserName,  
        vVer.LastChgUser_DTM  
    FROM  
        mdm.viw_SYSTEM_SCHEMA_VERSION AS vVer   
    WHERE  
        vVer.ID = @Version_ID;  
  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpVersionGetByMUID]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
exec mdm.udpVersionGetByMUID '9EC759AA-459D-4807-8774-AAE02B9F04F8'  
*/  
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
*/  
CREATE PROCEDURE [mdm].[udpVersionGetByMUID]  
(  
	@MUID		UNIQUEIDENTIFIER,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
	SET NOCOUNT ON  
  
	DECLARE @ID INT  
	SELECT @ID = ID FROM mdm.tblModelVersion WHERE MUID = @MUID  
  
	EXEC mdm.udpVersionGetByID @ID  
  
	SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpVersionSave]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    --Create Version  
    DECLARE @Return_ID INT, @Return_MUID UNIQUEIDENTIFIER;  
    --SET @Return_MUID = NEWID(); SELECT @Return_MUID; --Uncomment to test clone operation  
    EXEC mdm.udpVersionSave 1, 7, NULL, 0, 1, N'VERSION_1', N'blah', 14, @Return_ID OUTPUT, @Return_MUID OUTPUT;  
    SELECT @Return_ID, @Return_MUID;  
    SELECT * FROM mdm.tblModelVersion WHERE ID = @Return_ID;  
  
    --Update existing Version  
    DECLARE @Return_ID INT, @Return_MUID UNIQUEIDENTIFIER;  
    --SET @Return_MUID = NEWID(); SELECT @Return_MUID; --Uncomment to test clone operation  
    EXEC mdm.udpVersionSave 1, 7, 20, NULL, NULL, 'Version 3 [TEST]', 'Product Model - scenario 2 [TEST]', 14, @Return_ID OUTPUT, @Return_MUID OUTPUT;  
    SELECT @Return_ID, @Return_MUID;  
    SELECT * FROM mdm.tblModelVersion WHERE ID = @Return_ID;  
  
    --Update existing Version, change status  
    DECLARE @Return_ID INT, @Return_MUID UNIQUEIDENTIFIER;  
    --SET @Return_MUID = NEWID(); SELECT @Return_MUID; --Uncomment to test clone operation  
    EXEC mdm.udpVersionSave 1, 7, 20, NULL, 1, NULL, NULL, 14, @Return_ID OUTPUT, @Return_MUID OUTPUT;  
    SELECT @Return_ID, @Return_MUID;  
    SELECT * FROM mdm.tblModelVersion WHERE ID = @Return_ID;  
  
    --Update existing Version, clear VersionFlag  
    DECLARE @Return_ID INT, @Return_MUID UNIQUEIDENTIFIER;  
    --SET @Return_MUID = NEWID(); SELECT @Return_MUID; --Uncomment to test clone operation  
    EXEC mdm.udpVersionSave 1, 7, 20, NULL, NULL, 'Version 3 [TEST]', 'Product Model - scenario 2 [TEST]', 0, @Return_ID OUTPUT, @Return_MUID OUTPUT;  
    SELECT @Return_ID, @Return_MUID;  
    SELECT * FROM mdm.tblModelVersion WHERE ID = @Return_ID;  
*/  
CREATE PROCEDURE [mdm].[udpVersionSave]  
(  
    @User_ID            INT,  
    @Model_ID           INT,  
    @Version_ID         INT = NULL,  
    @CurrentVersion_ID  INT = NULL, -- used to set AsOfVersion_ID  
    @Status_ID          TINYINT = NULL,  
    @Name               NVARCHAR(50) = NULL,  
    @Description        NVARCHAR(500) = NULL,  
    @VersionFlag_ID     INT = NULL,  
    @AllowVersionCommit BIT = 0, -- Whether the version status can be changed to committed. Only model validation should set this flag.  
    @Return_ID          INT = NULL OUTPUT,  
    @Return_MUID        UNIQUEIDENTIFIER = NULL OUTPUT, --Also an input parameter for clone operations  
    @CorrelationID      UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE  
            @CurrentVersionID INT,  
            @CurrentDTM    DATETIME2(3),  
            @IsValidated BIT,  
            @ValidationLogTableName SYSNAME,  
            @SQL NVARCHAR(MAX),  
  
            @VersionStatus_Open         TINYINT = 1,  
            @VersionStatus_Locked       TINYINT = 2,  
            @VersionStatus_Committed    TINYINT = 3  
            ;  
  
    --Initialize output parameters and local variables  
    SELECT  
        @Name = LTRIM(RTRIM(@Name)),  
        @Description = LTRIM(RTRIM(@Description)),  
        @Return_ID = NULL,  
        @CurrentDTM = GETUTCDATE()--,  
        --@VersionFlag_ID = NULLIF(@VersionFlag_ID, 0); --0 is a magic number  
  
    --Test for invalid parameters  
    IF     @Status_ID NOT IN (@VersionStatus_Open, @VersionStatus_Locked, @VersionStatus_Committed)  
        OR COALESCE(@Model_ID, 0) <= 0 --Invalid Model_ID  
    BEGIN  
        --On error, return NULL results  
        SELECT @Return_ID = NULL, @Return_MUID = NULL;  
        RAISERROR('MDSERR100010|The Parameters are not valid.', 16, 1);  
        RETURN(1);  
    END; --if  
  
  
    DECLARE @PriorStatus_ID TINYINT = 0;  
    IF @Version_ID IS NOT NULL  
    BEGIN  
        SELECT  
             @PriorStatus_ID = Status_ID  
            ,@Return_MUID = MUID  
        FROM mdm.tblModelVersion  
        WHERE ID = @Version_ID  
    END  
  
    IF COALESCE(@PriorStatus_ID, 0) <> @VersionStatus_Committed AND @Status_ID = @VersionStatus_Committed AND COALESCE(@AllowVersionCommit, 0) = 0  
    BEGIN  
        --On error, return NULL results  
        SELECT @Return_ID = NULL, @Return_MUID = NULL;  
        RAISERROR('MDSERR500049|Cannot set version status to Commit.  Use the ValidationProcessRequest to commit a version.', 16, 1);  
        RETURN;  
    END  
  
    --Determine if the current version status is committed.  
    IF @PriorStatus_ID = @VersionStatus_Committed  
    BEGIN  
        -- The current status is committed.  Cannot change status.  
        IF @Status_ID IS NOT NULL AND ISNULL(@Status_ID, 0) <> @VersionStatus_Committed  
            BEGIN  
                --On error, return NULL results  
                SELECT @Return_ID = NULL, @Return_MUID = NULL;  
                RAISERROR('MDSERR200064|The version cannot be saved. The status of committed versions cannot be changed.', 16, 1);  
                RETURN;  
            END  
    END  
    ELSE  
    BEGIN  
        IF ISNULL(@VersionFlag_ID, 0) <> 0  
        BEGIN  
            -- Current status is not committed.  
            --Verify VersionFlag is valid  
            IF EXISTS(SELECT 1 FROM mdm.tblModelVersionFlag WHERE ID = @VersionFlag_ID AND CommittedOnly_ID = 1) AND (@Status_ID <> @VersionStatus_Committed)  
            BEGIN  
                --On error, return NULL results  
                SELECT @Return_ID = NULL, @Return_MUID = NULL;  
                RAISERROR('MDSERR200065|The version cannot be saved. The version is not committed and the version flag can be used for committed versions only.', 16, 1);  
                RETURN;  
            END  
  
            --If trying to commit the version, make sure the version has been validated  
            IF ISNULL(@Status_ID, 0) = @VersionStatus_Committed  
            BEGIN  
                EXECUTE mdm.udpVersionValidationStatusGet @Model_ID = @Model_ID, @Version_ID = @Version_ID, @IsValidated = @IsValidated OUTPUT  
                IF @IsValidated <> 1  
                BEGIN  
                    --On error, return NULL results  
                    SELECT @Return_ID = NULL, @Return_MUID = NULL;  
                    RAISERROR('MDSERR200071|The version cannot be saved because it has not been validated.', 16, 1);  
                    RETURN;  
                END  
            END  
        END  
    END  
  
    DECLARE @NameHasReservedCharacters BIT;  
    EXEC mdm.udpMetadataItemReservedCharactersCheck @Name, @NameHasReservedCharacters OUTPUT;  
    IF @NameHasReservedCharacters = 1  
    BEGIN  
        RAISERROR('MDSERR100055|The version cannot be created because it contains characters that are not valid.', 16, 1);  
        RETURN;  
    END; --if  
  
    -- Ensure the name isn't already being used  
    IF EXISTS(SELECT 1  
              FROM mdm.tblModelVersion  
              WHERE Model_ID = @Model_ID  
                AND Name = @Name  
                AND (@Version_ID IS NULL OR @Version_ID <> ID))  
    BEGIN  
        RAISERROR('MDSERR110003|The name already exists. Type a different name.', 16, 1);  
        RETURN;  
    END  
  
    DECLARE @DescriptionHasReservedCharacters BIT;  
    EXEC mdm.udpMetadataItemReservedCharactersCheck @Description, @DescriptionHasReservedCharacters OUTPUT;  
    IF @DescriptionHasReservedCharacters = 1  
    BEGIN  
        RAISERROR('MDSERR100055|The version cannot be created because it contains characters that are not valid.', 16, 1);  
        RETURN;  
    END; --if  
  
    --Start transaction, being careful to check if we are nested  
    DECLARE @TranCounter INT;  
    SET @TranCounter = @@TRANCOUNT;  
    IF @TranCounter > 0 SAVE TRANSACTION TX;  
    ELSE BEGIN TRANSACTION;  
  
    BEGIN TRY  
        -- If VersionFlag is associated with another version, remove it from that version.  
        UPDATE mdm.tblModelVersion  
        SET VersionFlag_ID = NULL  
        WHERE   VersionFlag_ID = @VersionFlag_ID  
            AND (@Version_ID IS NULL OR ID <> @Version_ID)  
  
        IF (@Version_ID IS NOT NULL)  
        BEGIN  
            ----------------------------------------  
            ------      Update Version         -----  
            ----------------------------------------  
            --Update details in the Version table  
            UPDATE mdm.tblModelVersion  
            SET  
                 Status_ID = ISNULL(@Status_ID, Status_ID)  
                ,[Name] = ISNULL(@Name, [Name])  
                ,[Description] = ISNULL(@Description, [Description])  
                ,VersionFlag_ID = @VersionFlag_ID  
                ,LastChgDTM = @CurrentDTM  
                ,LastChgUserID = @User_ID  
            WHERE  
                ID = @Version_ID;  
  
            IF (@Status_ID IS NOT NULL)  
            BEGIN  
                IF (@Status_ID <> @PriorStatus_ID)  
                BEGIN  
                    -- Create a version status change notification  
                    EXEC mdm.udpNotificationCreateVersionStatusChange @User_ID=@User_ID, @Version_ID=@Version_ID, @PriorStatus_ID=@PriorStatus_ID;  
                END  
            END  
  
            --Get the validation log table names  
            SET @ValidationLogTableName = mdm.udfGetValidationLogTableName(@Model_ID);  
  
            --Archive validation log issues  
            IF @Status_ID = @VersionStatus_Committed  
            BEGIN  
  
                EXEC mdm.udpValidationLogClear @Model_ID = @Model_ID, @Version_ID = @Version_ID;  
  
            END; --if  
  
        END ELSE  
        BEGIN  
            ----------------------------------------  
            ------         New Version         -----  
            ----------------------------------------  
            --Accept an explicit MUID (for clone operations) or generate a new one  
            SET @Return_MUID = ISNULL(@Return_MUID, NEWID());  
            --Insert details into Version table  
            INSERT INTO mdm.tblModelVersion  
            (  
                [Model_ID],  
                [Status_ID] ,  
                [Display_ID],  
                [Name],  
                [Description],  
                [VersionFlag_ID],  
                [AsOfVersion_ID],  
                [MUID],  
                [EnterDTM],  
                [EnterUserID],  
                [LastChgDTM],  
                [LastChgUserID]  
            )  
            SELECT  
                @Model_ID,  
                @Status_ID,  
                ISNULL(MAX(Display_ID), 0) + 1,  
                @Name,  
                @Description,  
                @VersionFlag_ID,  
                NULLIF(@CurrentVersion_ID, 0),  
                @Return_MUID,  
                @CurrentDTM,  
                @User_ID,  
                @CurrentDTM,  
                @User_ID  
            FROM  
                mdm.tblModelVersion  
            WHERE  
                Model_ID = @Model_ID;  
  
            --Save the identity value  
            SET @Version_ID = SCOPE_IDENTITY();  
  
            EXEC mdm.udpTablePartitionQueueSave @Model_ID = @Model_ID, @Version_ID = @Version_ID;  
  
        END --if  
  
        --Return values  
        SET @Return_ID = @Version_ID;  
  
        --Commit only if we are not nested  
        IF @TranCounter = 0 COMMIT TRANSACTION;  
  
    END TRY  
    --Compensate as necessary  
    BEGIN CATCH  
  
        -- Get error info.  
        DECLARE  
            @ErrorMessage NVARCHAR(4000),  
            @ErrorSeverity INT,  
            @ErrorState INT,  
            @ErrorNumber INT,  
            @ErrorLine INT,  
            @ErrorProcedure NVARCHAR(126);  
        EXEC mdm.udpGetErrorInfo  
            @ErrorMessage = @ErrorMessage OUTPUT,  
            @ErrorSeverity = @ErrorSeverity OUTPUT,  
            @ErrorState = @ErrorState OUTPUT,  
            @ErrorNumber = @ErrorNumber OUTPUT,  
            @ErrorLine = @ErrorLine OUTPUT,  
            @ErrorProcedure = @ErrorProcedure OUTPUT  
  
        SET @ErrorMessage = CONCAT(@ErrorMessage, N', @ErrorNumber = ', @ErrorNumber, N', @ErrorProcedure = "', @ErrorProcedure, N'", line ', @ErrorLine);  
  
        IF @TranCounter = 0 ROLLBACK TRANSACTION;  
        ELSE IF XACT_STATE() <> -1 ROLLBACK TRANSACTION TX;  
  
        RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);  
  
        SELECT @Return_ID = NULL, @Return_MUID = NULL;  
        RETURN(1);  
  
    END CATCH;  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpVersionSaveByMUID]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
 Wrapper for udpVersionSave sproc.  
*/  
CREATE PROCEDURE [mdm].[udpVersionSaveByMUID]  
(  
    @User_ID                INT,  
    @Model_MUID             UNIQUEIDENTIFIER,  
    @Version_MUID           UNIQUEIDENTIFIER = NULL,  
    @Status_ID              TINYINT = NULL,  
    @Name                   NVARCHAR(50) = NULL,  
    @Description            NVARCHAR(250) = NULL,  
    @VersionFlag_MUID       UNIQUEIDENTIFIER = NULL,  
    @Return_ID              INT = NULL OUTPUT,  
    @Return_MUID            UNIQUEIDENTIFIER = NULL OUTPUT, --Also an input parameter for clone operations  
    @CorrelationID          UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
WITH EXECUTE AS 'mds_schema_user'  
AS BEGIN  
    SET NOCOUNT ON;  
  
    DECLARE @FunctionalPrivilege_Versions  TINYINT = 2  
    IF mdm.udfSecurityUserFunctionIsAllowed(@User_ID, @FunctionalPrivilege_Versions) = 0  
    BEGIN  
        RAISERROR('MDSERR120002|The user does not have permission to perform this operation.', 16, 1);  
        RETURN;  
    END  
  
    DECLARE  
        @Model_ID           INT,  
        @Model_Privilege    INT,  
        @Version_ID         INT,  
        @VersionFlag_ID     INT;  
  
    DECLARE @EmptyMuid UNIQUEIDENTIFIER SET @EmptyMuid = CONVERT(UNIQUEIDENTIFIER, 0x0);  
  
    SELECT   
         @Model_ID = m.ID   
        ,@Model_Privilege = um.Privilege_ID  
    FROM mdm.viw_SYSTEM_SECURITY_USER_MODEL um  
    INNER JOIN mdm.tblModel m  
    ON um.ID = m.ID  
    WHERE   m.MUID = @Model_MUID  
        AND um.User_ID = @User_ID;  
  
    --Test for invalid parameters  
    IF (@Model_ID IS NULL) --Invalid Model_MUID  
    BEGIN  
        --On error, return NULL results  
        SELECT @Return_ID = NULL, @Return_MUID = NULL;  
        RAISERROR('MDSERR200004|The version cannot be saved. The model ID is not valid.', 16, 1);  
        RETURN;  
    END; --if        
  
    IF @Model_Privilege != 5 /*Admin*/  
    BEGIN  
        --On error, return NULL results  
        SELECT @Return_ID = NULL, @Return_MUID = NULL;  
        RAISERROR(N'MDSERR120003|The user does not have permission or the object ID is not valid.', 16, 1);  
        RETURN;  
    END;  
  
    SELECT @Version_ID = ID  
    FROM mdm.tblModelVersion  
    WHERE   Model_ID = @Model_ID  
        AND MUID = @Version_MUID;  
  
    IF (@Version_MUID IS NOT NULL AND @Version_MUID <> @EmptyMuid AND @Version_ID IS NULL) --Invalid Version_MUID  
    BEGIN  
        --On error, return NULL results  
        SELECT @Return_ID = NULL, @Return_MUID = NULL;  
        RAISERROR('MDSERR200005|The version cannot be saved. The version ID is not valid.', 16, 1);  
        RETURN;  
    END; --if        
  
    IF @VersionFlag_MUID IS NOT NULL AND @VersionFlag_MUID <> @EmptyMuid  
    BEGIN  
        SELECT @VersionFlag_ID = ID FROM mdm.tblModelVersionFlag WHERE MUID = @VersionFlag_MUID;  
        IF (@VersionFlag_ID IS NULL) --Invalid Version_MUID  
        BEGIN  
            --On error, return NULL results  
            SELECT @Return_ID = NULL, @Return_MUID = NULL;  
            RAISERROR('MDSERR200070|The version cannot be saved. The version flag ID is not valid.', 16, 1);  
            RETURN;  
        END  
    END; --if        
      
    EXEC mdm.udpVersionSave  
            @User_ID = @User_ID,   
            @Model_ID = @Model_ID,  
            @Version_ID = @Version_ID,  
            @CurrentVersion_ID = NULL,   
            @Status_ID = @Status_ID,   
            @Name = @Name,   
            @Description = @Description,   
            @VersionFlag_ID = @VersionFlag_ID,  
            @Return_ID = @Return_ID OUTPUT,   
            @Return_MUID = @Return_MUID OUTPUT;  
  
    SET NOCOUNT OFF;  
END; --proc
GO
/****** Object:  StoredProcedure [mdm].[udpVersionValidationStatusGet]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
DECLARE @IsValidated BIT  
EXEC mdm.udpVersionValidationStatusGet 20, @IsValidated OUTPUT  
SELECT @IsValidated  
*/  
CREATE PROCEDURE [mdm].[udpVersionValidationStatusGet]  
(  
    @Model_ID   INT,  
    @Version_ID  INT,  
    @IsValidated BIT = NULL OUTPUT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON  
  
    SET @IsValidated = 1  
  
  
    DECLARE @tblList TABLE   
    (  
         RowNumber          INT IDENTITY (1, 1) PRIMARY KEY CLUSTERED NOT NULL  
        ,ValidationTable    sysname COLLATE database_default --Flag to track if the table is used for validation.  
    )   
    DECLARE @SQL     NVARCHAR(MAX)  
    DECLARE @Table   sysname  
      
    --Get the list of entity table names for the model  
    INSERT INTO @tblList  
      SELECT EntityTable AS ValidationTable   
      FROM mdm.tblEntity   
      WHERE Model_ID = @Model_ID  
      UNION ALL  
      SELECT HierarchyParentTable   
      FROM mdm.tblEntity   
      WHERE Model_ID = @Model_ID   
        AND HierarchyParentTable IS NOT NULL  
  
    DECLARE @Counter INT = 1;  
    DECLARE @MaxCounter INT = (SELECT MAX(RowNumber) FROM @tblList);  
  
    WHILE @Counter <= @MaxCounter  
    BEGIN  
       SELECT @Table = ValidationTable   
       FROM @tblList   
       WHERE [RowNumber] = @Counter  
  
        SET @SQL = N'SELECT @IsValidated = CASE WHEN EXISTS(SELECT ID FROM mdm.' + quotename(@Table) + N' WHERE Version_ID = @Version_ID AND ValidationStatus_ID <> 3 AND Status_ID = 1) THEN 0 ELSE 1 END';  
         
       EXEC sp_executesql @SQL, N'@Version_ID INT, @IsValidated INT OUTPUT', @Version_ID, @IsValidated OUTPUT;  
         
       -- Return as soon as we find a member table that is not validated.  No need to check any further.  
        IF @IsValidated = 0  
        BEGIN  
            RETURN @IsValidated;  
        END  
  
        SET @Counter += 1;  
    END  
  
    SET NOCOUNT OFF  
      
    RETURN @IsValidated;  
END --proc
GO
/****** Object:  StoredProcedure [mdm].[udpViewNamesGetByID]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
    EXEC mdm.udpViewNamesGetByID 2,1  
*/  
CREATE PROCEDURE [mdm].[udpViewNamesGetByID]  
(  
    @Model_ID               INT,  
    @Entity_ID              INT,  
    @DerivedHierarchy_ID    INT,  
    @ItemType_ID            TINYINT = 1, --1=ALL; 2=Collection views; 3=Hierarchy views  
    @CorrelationID          UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
/*WITH*/  
AS BEGIN  
    SET NOCOUNT ON  
  
    DECLARE  
         @SQL                   NVARCHAR(MAX)  
        ,@ItemType_All          TINYINT = 1  
        ,@ItemType_Collections  TINYINT = 2  
        ,@ItemType_Hierarchies  TINYINT = 3;  
  
    WITH allviews AS (  
        SELECT [Model_ID], [Entity_ID], [DerivedHierarchy_ID], ViewName  
        FROM  
        (  
            SELECT  
                tMod.ID [Model_ID],  
                tEnt.ID [Entity_ID],  
                NULL [DerivedHierarchy_ID],  
  
                --System views  
                CAST(CONCAT(N'viw_SYSTEM_', tMod.ID, N'_', tEnt.ID, N'_CHILDATTRIBUTES') AS SYSNAME)                                                                [ViewSystem_ChildAttributes],  
                CAST(CONCAT(N'viw_SYSTEM_', tMod.ID, N'_', tEnt.ID, N'_CHILDATTRIBUTES_EXP') AS SYSNAME)                                                            [ViewSystem_ChildAttributes_EXP],  
                CAST(CONCAT(N'viw_SYSTEM_', tMod.ID, N'_', tEnt.ID, N'_CHILDATTRIBUTES_HISTORY') AS SYSNAME)                                                        [ViewSystem_ChildAttributes_History],  
                CAST(CONCAT(N'viw_SYSTEM_', tMod.ID, N'_', tEnt.ID, N'_CHILDATTRIBUTES_PENDING') AS SYSNAME)                                                        [ViewSystem_ChildAttributes_Pending],  
                CAST(CASE WHEN tEnt.CollectionTable IS NOT NULL THEN CONCAT(N'viw_SYSTEM_', tMod.ID, N'_', tEnt.ID, N'_COLLECTIONATTRIBUTES') END AS SYSNAME)       [ViewSystem_CollectionAttributes],  
                CAST(CASE WHEN tEnt.CollectionTable IS NOT NULL THEN CONCAT(N'viw_SYSTEM_', tMod.ID, N'_', tEnt.ID, N'_COLLECTIONATTRIBUTES_EXP') END AS SYSNAME)   [ViewSystem_CollectionAttributes_EXP],  
                CAST(CASE WHEN tHir.ID IS NOT NULL THEN CONCAT(N'viw_SYSTEM_', tMod.ID, N'_', tEnt.ID, N'_LEVELS') END AS SYSNAME)                                  [ViewSystem_Levels],  
                CAST(CASE WHEN tHir.ID IS NOT NULL THEN CONCAT(N'viw_SYSTEM_', tMod.ID, N'_', tEnt.ID, N'_PARENTATTRIBUTES') END AS SYSNAME)                        [ViewSystem_ParentAttributes],  
                CAST(CASE WHEN tHir.ID IS NOT NULL THEN CONCAT(N'viw_SYSTEM_', tMod.ID, N'_', tEnt.ID, N'_PARENTATTRIBUTES_EXP') END AS SYSNAME)                    [ViewSystem_ParentAttributes_EXP],  
                CAST(CASE WHEN tHir.ID IS NOT NULL THEN CONCAT(N'viw_SYSTEM_', tMod.ID, N'_', tEnt.ID, N'_PARENTCHILD') END AS SYSNAME)                             [ViewSystem_ParentChild],  
                CAST(CASE WHEN tEnt.CollectionTable IS NOT NULL THEN CONCAT(N'viw_SYSTEM_', tMod.ID, N'_', tEnt.ID, N'_COLLECTIONPARENTCHILD') END AS SYSNAME)      [ViewSystem_CollectionParentChild]  
            FROM mdm.tblModel tMod  
            INNER JOIN mdm.tblEntity tEnt  
            ON tMod.ID = tEnt.Model_ID  
            LEFT JOIN mdm.tblHierarchy tHir  
            ON tEnt.ID = tHir.Entity_ID  
            LEFT JOIN mdm.tblDerivedHierarchy tDHir  
            ON tMod.ID = tDHir.Model_ID  
         ) AS p  
         UNPIVOT (  
                ViewName FOR ViewType IN ([ViewSystem_ChildAttributes], [ViewSystem_ChildAttributes_EXP], [ViewSystem_ChildAttributes_History], [ViewSystem_ChildAttributes_Pending],  
                [ViewSystem_CollectionAttributes], [ViewSystem_CollectionAttributes_EXP], [ViewSystem_Levels], [ViewSystem_ParentAttributes], [ViewSystem_ParentAttributes_EXP],  
                [ViewSystem_ParentChild], [ViewSystem_CollectionParentChild])  
        ) AS unpvt  
        UNION ALL  
        SELECT [Model_ID], [Entity_ID], [DerivedHierarchy_ID], ViewName  
        FROM  
        (  
            SELECT  
                tMod.ID [Model_ID],  
                NULL [Entity_ID],  
                tDHir.ID [DerivedHierarchy_ID],  
  
                --System views  
                CAST(CASE WHEN tDHir.ID IS NOT NULL THEN CONCAT(N'viw_SYSTEM_', tMod.ID, N'_', tDHir.ID, N'_PARENTCHILD_DERIVED') END AS SYSNAME)                   [ViewSystem_DerivedParentChild]  
            FROM mdm.tblModel tMod  
            INNER JOIN mdm.tblDerivedHierarchy tDHir  
            ON tMod.ID = tDHir.Model_ID  
         ) AS p  
         UNPIVOT (  
                ViewName FOR ViewType IN ([ViewSystem_DerivedParentChild])  
        ) AS unpvt  
        UNION ALL  
        SELECT [Model_ID], [Entity_ID], [DerivedHierarchy_ID], ViewName  
        FROM  
        (  
            SELECT  
                ID [Model_ID] ,  
                NULL [Entity_ID],  
                NULL [DerivedHierarchy_ID],  
                CAST(CONCAT(N'viw_SYSTEM_', ID, N'_ISSUE_VALIDATION') AS SYSNAME) [ISSUE_VALIDATION],  
                CAST(CONCAT(N'viw_SYSTEM_', ID, N'_TRANSACTIONS') AS SYSNAME) [TRANSACTIONS],  
                CAST(CONCAT(N'viw_SYSTEM_', ID, N'_TRANSACTIONS_ANNOTATIONS') AS SYSNAME) [TRANSACTIONS_ANNOTATIONS],  
                CAST(CONCAT(N'viw_SYSTEM_', ID, N'_USER_VALIDATION') AS SYSNAME) [USER_VALIDATION]  
            FROM mdm.tblModel  
        ) AS p  
        UNPIVOT (  
                ViewName FOR ViewType IN ([ISSUE_VALIDATION], [TRANSACTIONS], [TRANSACTIONS_ANNOTATIONS], [USER_VALIDATION])  
        ) AS unpvt  
    )  
    SELECT DISTINCT ViewName  
    FROM allviews  
    WHERE ((Model_ID IS NULL AND @Model_ID IS NULL) OR Model_ID = @Model_ID)  
        AND (([Entity_ID] IS NULL AND @Entity_ID IS NULL) OR [Entity_ID] = @Entity_ID)  
        AND (([DerivedHierarchy_ID] IS NULL AND @DerivedHierarchy_ID IS NULL) OR [DerivedHierarchy_ID] = @DerivedHierarchy_ID)  
        AND ((@ItemType_ID = @ItemType_All)  
            OR (@ItemType_ID = @ItemType_Hierarchies AND ViewName NOT LIKE N'%CHILDATTRIBUTES%')  
            OR (@ItemType_ID = @ItemType_Collections AND ViewName LIKE N'%COLLECTION%'))  
  
    SET NOCOUNT OFF  
END --proc
GO
/****** Object:  StoredProcedure [mdq].[udpIsDateTime2]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
This method is a temporary substitute for the SQL CLR function. It should be removed when SQL Azure adds support for SQL CLR.  
  
DECLARE @IsDateTime2 BIT = NULL;  
  
EXEC mdq.udpIsDateTime2 NULL, @IsDateTime2 OUTPUT; -- 0  
  
*/  
CREATE PROCEDURE [mdq].[udpIsDateTime2]  
(  
    @Input NVARCHAR(MAX) = NULL,  
    @IsDateTime2 BIT OUTPUT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
AS  
BEGIN  
    IF @Input IS NULL  
    BEGIN  
        SET @IsDateTime2 = 0;  
    END ELSE  
    BEGIN   
        BEGIN TRY  
            DECLARE @DateTime2 DATETIME2 = CONVERT(DATETIME2, @Input);  
            SET @IsDateTime2 = 1;  
        END TRY  
        BEGIN CATCH  
            SET @IsDateTime2 = 0;  
        END CATCH;  
    END;  
END;
GO
/****** Object:  StoredProcedure [mdq].[udpIsNumber]    Script Date: 12/10/2019 8:55:06 AM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*  
==============================================================================  
 Copyright (c) Microsoft Corporation. All Rights Reserved.  
==============================================================================  
  
This method is a temporary substitute for the SQL CLR function. It should be removed when SQL Azure adds support for SQL CLR.  
  
DECLARE @IsNumeric BIT = NULL;  
  
EXEC mdq.udpIsNumber NULL, @IsNumeric OUTPUT; -- 0  
EXEC mdq.udpIsNumber N'123.45', @IsNumeric OUTPUT; -- 1  
EXEC mdq.udpIsNumber N'123', @IsNumeric OUTPUT; -- 1  
EXEC mdq.udpIsNumber N'foo', @IsNumeric OUTPUT; -- 0  
  
*/  
CREATE PROCEDURE [mdq].[udpIsNumber]  
(  
    @Input NVARCHAR(MAX) = NULL,  
    @IsNumeric BIT OUTPUT,  
    @CorrelationID UNIQUEIDENTIFIER = NULL  -- This parameter is populated from the c# layer and provides end to end traceability  
)  
AS  
BEGIN  
    IF @Input IS NULL  
    BEGIN  
        SET @IsNumeric = 0;  
    END ELSE  
    BEGIN   
        BEGIN TRY  
            DECLARE @Numeric DECIMAL = CONVERT(DECIMAL, @Input);  
            SET @IsNumeric = 1;  
        END TRY  
        BEGIN CATCH  
            SET @IsNumeric = 0;  
        END CATCH;  
    END;  
END;
GO
USE [master]
GO
ALTER DATABASE [QuanLySinhVien] SET  READ_WRITE 
GO
